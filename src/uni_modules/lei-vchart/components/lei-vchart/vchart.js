var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// http-url:https://unpkg.com/eventemitter3@4.0.7/index.js
var require_eventemitter3_4_0 = __commonJS({
  "http-url:https://unpkg.com/eventemitter3@4.0.7/index.js"(exports, module) {
    "use strict";
    var has2 = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has2.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a22, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a22), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a22, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a22, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a22, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length2 = listeners.length, j;
        for (i = 0; i < length2; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a22);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a22, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length2 = listeners.length; i < length2; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/data/parser/array
var arrayParser = (array3) => array3;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/typings/spec/common
var RenderModeEnum;
!function(RenderModeEnum2) {
  RenderModeEnum2["desktop-browser"] = "desktop-browser", RenderModeEnum2["mobile-browser"] = "mobile-browser", RenderModeEnum2.node = "node", RenderModeEnum2.worker = "worker", RenderModeEnum2.miniApp = "miniApp", RenderModeEnum2.wx = "wx", RenderModeEnum2.tt = "tt", RenderModeEnum2.harmony = "harmony", RenderModeEnum2["desktop-miniApp"] = "desktop-miniApp", RenderModeEnum2.lynx = "lynx";
}(RenderModeEnum || (RenderModeEnum = {}));

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/interface/type
var ComponentTypeEnum;
!function(ComponentTypeEnum2) {
  ComponentTypeEnum2.cartesianAxis = "cartesianAxis", ComponentTypeEnum2.cartesianBandAxis = "cartesianAxis-band", ComponentTypeEnum2.cartesianLinearAxis = "cartesianAxis-linear", ComponentTypeEnum2.cartesianTimeAxis = "cartesianAxis-time", ComponentTypeEnum2.cartesianLogAxis = "cartesianAxis-log", ComponentTypeEnum2.cartesianSymlogAxis = "cartesianAxis-symlog", ComponentTypeEnum2.polarAxis = "polarAxis", ComponentTypeEnum2.polarBandAxis = "polarAxis-band", ComponentTypeEnum2.polarLinearAxis = "polarAxis-linear", ComponentTypeEnum2.crosshair = "crosshair", ComponentTypeEnum2.cartesianCrosshair = "cartesianCrosshair", ComponentTypeEnum2.polarCrosshair = "polarCrosshair", ComponentTypeEnum2.dataZoom = "dataZoom", ComponentTypeEnum2.geoCoordinate = "geoCoordinate", ComponentTypeEnum2.indicator = "indicator", ComponentTypeEnum2.discreteLegend = "discreteLegend", ComponentTypeEnum2.continuousLegend = "continuousLegend", ComponentTypeEnum2.colorLegend = "colorLegend", ComponentTypeEnum2.sizeLegend = "sizeLegend", ComponentTypeEnum2.mapLabel = "mapLabel", ComponentTypeEnum2.markLine = "markLine", ComponentTypeEnum2.markArea = "markArea", ComponentTypeEnum2.markPoint = "markPoint", ComponentTypeEnum2.polarMarkLine = "polarMarkLine", ComponentTypeEnum2.polarMarkArea = "polarMarkArea", ComponentTypeEnum2.polarMarkPoint = "polarMarkPoint", ComponentTypeEnum2.geoMarkPoint = "geoMarkPoint", ComponentTypeEnum2.tooltip = "tooltip", ComponentTypeEnum2.title = "title", ComponentTypeEnum2.player = "player", ComponentTypeEnum2.scrollBar = "scrollBar", ComponentTypeEnum2.label = "label", ComponentTypeEnum2.totalLabel = "totalLabel", ComponentTypeEnum2.brush = "brush", ComponentTypeEnum2.poptip = "poptip", ComponentTypeEnum2.customMark = "customMark";
}(ComponentTypeEnum || (ComponentTypeEnum = {}));

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/index.js
var import_eventemitter3 = __toESM(require_eventemitter3_4_0());

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/isType
var isType = (value, type) => Object.prototype.toString.call(value) === `[object ${type}]`;
var isType_default = isType;

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/isBoolean
var isBoolean = (value, fuzzy = false) => fuzzy ? "boolean" == typeof value : true === value || false === value || isType_default(value, "Boolean");
var isBoolean_default = isBoolean;

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/isFunction
var isFunction = (value) => "function" == typeof value;
var isFunction_default = isFunction;

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/isNil
var isNil = (value) => null == value;
var isNil_default = isNil;

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/isValid
var isValid = (value) => null != value;
var isValid_default = isValid;

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/isObject
var isObject = (value) => {
  const type = typeof value;
  return null !== value && "object" === type || "function" === type;
};
var isObject_default = isObject;

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/isObjectLike
var isObjectLike = (value) => "object" == typeof value && null !== value;
var isObjectLike_default = isObjectLike;

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/isPlainObject
var isPlainObject = function(value) {
  if (!isObjectLike_default(value) || !isType_default(value, "Object"))
    return false;
  if (null === Object.getPrototypeOf(value))
    return true;
  let proto = value;
  for (; null !== Object.getPrototypeOf(proto); )
    proto = Object.getPrototypeOf(proto);
  return Object.getPrototypeOf(value) === proto;
};
var isPlainObject_default = isPlainObject;

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/isUndefined
var isUndefined = (value) => void 0 === value;
var isUndefined_default = isUndefined;

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/isString
var isString = (value, fuzzy = false) => {
  const type = typeof value;
  return fuzzy ? "string" === type : "string" === type || isType_default(value, "String");
};
var isString_default = isString;

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/isArray
var isArray = (value) => Array.isArray ? Array.isArray(value) : isType_default(value, "Array");
var isArray_default = isArray;

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/isArrayLike
var isArrayLike = function(value) {
  return null !== value && "function" != typeof value && Number.isFinite(value.length);
};
var isArrayLike_default = isArrayLike;

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/isDate
var isDate = (value) => isType_default(value, "Date");
var isDate_default = isDate;

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/isNumber
var isNumber = (value, fuzzy = false) => {
  const type = typeof value;
  return fuzzy ? "number" === type : "number" === type || isType_default(value, "Number");
};
var isNumber_default = isNumber;

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/isNumeric
var isNumeric = (value) => "string" == typeof value && (!isNaN(Number(value)) && !isNaN(parseFloat(value)));
var isNumeric_default = isNumeric;

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/isValidNumber
var isValidNumber = (value) => isNumber_default(value) && Number.isFinite(value);
var isValidNumber_default = isValidNumber;

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/isValidUrl
var isValidUrl = (value) => new RegExp(/^(http(s)?:\/\/)\w+[^\s]+(\.[^\s]+){1,}$/).test(value);
var isValidUrl_default = isValidUrl;

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/isBase64
var isBase64 = (value) => new RegExp(/^data:image\/(?:gif|png|jpeg|bmp|webp|svg\+xml)(?:;charset=utf-8)?;base64,(?:[A-Za-z0-9]|[+/])+={0,2}/g).test(value);
var isBase64_default = isBase64;

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/getType
var getType = (value) => ({}).toString.call(value).replace(/^\[object /, "").replace(/]$/, "");
var getType_default = getType;

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/isPrototype
var objectProto = Object.prototype;
var isPrototype = function(value) {
  const Ctor = value && value.constructor;
  return value === ("function" == typeof Ctor && Ctor.prototype || objectProto);
};
var isPrototype_default = isPrototype;

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/isEmpty
var hasOwnProperty = Object.prototype.hasOwnProperty;
function isEmpty(value) {
  if (isNil_default(value))
    return true;
  if (isArrayLike_default(value))
    return !value.length;
  const type = getType_default(value);
  if ("Map" === type || "Set" === type)
    return !value.size;
  if (isPrototype_default(value))
    return !Object.keys(value).length;
  for (const key in value)
    if (hasOwnProperty.call(value, key))
      return false;
  return true;
}
var isEmpty_default = isEmpty;

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/get
var get = (obj, path, defaultValue) => {
  const paths = isString_default(path) ? path.split(".") : path;
  for (let p = 0; p < paths.length; p++)
    obj = obj ? obj[paths[p]] : void 0;
  return void 0 === obj ? defaultValue : obj;
};
var get_default = get;

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/has
var hasOwnProperty2 = Object.prototype.hasOwnProperty;
var has = (object, key) => null != object && hasOwnProperty2.call(object, key);
var has_default = has;

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/cloneDeep
function cloneDeep(value) {
  let result2;
  if (!isValid_default(value) || "object" != typeof value)
    return value;
  const isArr = isArray_default(value), length2 = value.length;
  result2 = isArr ? new Array(length2) : "object" == typeof value ? {} : isBoolean_default(value) || isNumber_default(value) || isString_default(value) ? value : isDate_default(value) ? /* @__PURE__ */ new Date(+value) : void 0;
  const props = isArr ? void 0 : Object.keys(Object(value));
  let index = -1;
  if (result2)
    for (; ++index < (props || value).length; ) {
      const key = props ? props[index] : index, subValue = value[key];
      result2[key] = cloneDeep(subValue);
    }
  return result2;
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/merge
function baseMerge(target, source, shallowArray = false) {
  if (source) {
    if (target === source)
      return;
    if (isValid_default(source) && "object" == typeof source) {
      const iterable = Object(source), props = [];
      for (const key in iterable)
        props.push(key);
      let { length: length2 } = props, propIndex = -1;
      for (; length2--; ) {
        const key = props[++propIndex];
        isValid_default(iterable[key]) && "object" == typeof iterable[key] ? baseMergeDeep(target, source, key, shallowArray) : assignMergeValue(target, key, iterable[key]);
      }
    }
  }
}
function baseMergeDeep(target, source, key, shallowArray = false) {
  const objValue = target[key], srcValue = source[key];
  let newValue = source[key], isCommon = true;
  if (isArray_default(srcValue)) {
    if (shallowArray)
      newValue = [];
    else if (isArray_default(objValue))
      newValue = objValue;
    else if (isArrayLike_default(objValue)) {
      newValue = new Array(objValue.length);
      let index = -1;
      const length2 = objValue.length;
      for (; ++index < length2; )
        newValue[index] = objValue[index];
    }
  } else
    isPlainObject_default(srcValue) ? (newValue = objValue, "function" != typeof objValue && "object" == typeof objValue || (newValue = {})) : isCommon = false;
  isCommon && baseMerge(newValue, srcValue, shallowArray), assignMergeValue(target, key, newValue);
}
function assignMergeValue(target, key, value) {
  (void 0 !== value && !eq(target[key], value) || void 0 === value && !(key in target)) && (target[key] = value);
}
function eq(value, other) {
  return value === other || Number.isNaN(value) && Number.isNaN(other);
}
function merge(target, ...sources) {
  let sourceIndex = -1;
  const length2 = sources.length;
  for (; ++sourceIndex < length2; ) {
    baseMerge(target, sources[sourceIndex], true);
  }
  return target;
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/pickWithout
function pickWithout(obj, keys2) {
  if (!obj || !isPlainObject_default(obj))
    return obj;
  const result2 = {};
  return Object.keys(obj).forEach((k2) => {
    const v = obj[k2];
    let match = false;
    keys2.forEach((itKey) => {
      (isString_default(itKey) && itKey === k2 || itKey instanceof RegExp && k2.match(itKey)) && (match = true);
    }), match || (result2[k2] = v);
  }), result2;
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/isEqual
function objToString(obj) {
  return Object.prototype.toString.call(obj);
}
function objectKeys(obj) {
  return Object.keys(obj);
}
function isEqual(a3, b, options) {
  if (a3 === b)
    return true;
  if (typeof a3 != typeof b)
    return false;
  if (null == a3 || null == b)
    return false;
  if (Number.isNaN(a3) && Number.isNaN(b))
    return true;
  if (objToString(a3) !== objToString(b))
    return false;
  if (isFunction_default(a3))
    return !!(null == options ? void 0 : options.skipFunction);
  if ("object" != typeof a3)
    return false;
  if (isArray_default(a3)) {
    if (a3.length !== b.length)
      return false;
    for (let i = a3.length - 1; i >= 0; i--)
      if (!isEqual(a3[i], b[i], options))
        return false;
    return true;
  }
  if (!isPlainObject_default(a3))
    return false;
  const ka = objectKeys(a3), kb = objectKeys(b);
  if (ka.length !== kb.length)
    return false;
  ka.sort(), kb.sort();
  for (let i = ka.length - 1; i >= 0; i--)
    if (ka[i] != kb[i])
      return false;
  for (let i = ka.length - 1; i >= 0; i--) {
    const key = ka[i];
    if (!isEqual(a3[key], b[key], options))
      return false;
  }
  return true;
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/mixin
function keys(obj) {
  if (!obj)
    return [];
  if (Object.keys)
    return Object.keys(obj);
  const keyList = [];
  for (const key in obj)
    obj.hasOwnProperty(key) && keyList.push(key);
  return keyList;
}
function defaults(target, source, overlay) {
  const keysArr = keys(source);
  for (let i = 0; i < keysArr.length; i++) {
    const key = keysArr[i];
    (overlay ? null != source[key] : null == target[key]) && (target[key] = source[key]);
  }
  return target;
}
function mixin(target, source, override = true) {
  if (target = "prototype" in target ? target.prototype : target, source = "prototype" in source ? source.prototype : source, Object.getOwnPropertyNames) {
    const keyList = Object.getOwnPropertyNames(source);
    for (let i = 0; i < keyList.length; i++) {
      const key = keyList[i];
      "constructor" !== key && (override ? null != source[key] : null == target[key]) && (target[key] = source[key]);
    }
  } else
    defaults(target, source, override);
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/array
function array(arr) {
  return isValid_default(arr) ? isArray_default(arr) ? arr : [arr] : [];
}
function last(val) {
  if (isArrayLike_default(val)) {
    return val[val.length - 1];
  }
}
var maxInArray = (arr, compareFn) => {
  var _a;
  if (0 === arr.length)
    return;
  let max3 = arr[0];
  for (let i = 1; i < arr.length; i++) {
    const value = arr[i];
    (null !== (_a = null == compareFn ? void 0 : compareFn(value, max3)) && void 0 !== _a ? _a : value - max3 > 0) && (max3 = value);
  }
  return max3;
};
var minInArray = (arr, compareFn) => {
  var _a;
  if (0 === arr.length)
    return;
  let min3 = arr[0];
  for (let i = 1; i < arr.length; i++) {
    const value = arr[i];
    (null !== (_a = null == compareFn ? void 0 : compareFn(value, min3)) && void 0 !== _a ? _a : value - min3 < 0) && (min3 = value);
  }
  return min3;
};
function arrayEqual(a3, b) {
  if (!isArray_default(a3) || !isArray_default(b))
    return false;
  if (a3.length !== b.length)
    return false;
  for (let i = 0; i < a3.length; i++)
    if (a3[i] !== b[i])
      return false;
  return true;
}
function uniqArray(arr) {
  return arr && isArray_default(arr) ? Array.from(new Set(array(arr))) : arr;
}
function shuffleArray(arr, random = Math.random) {
  let j, x, i = arr.length;
  for (; i; )
    j = Math.floor(random() * i), x = arr[--i], arr[i] = arr[j], arr[j] = x;
  return arr;
}
function flattenArray(arr) {
  if (!isArray_default(arr))
    return [arr];
  const result2 = [];
  for (const value of arr)
    result2.push(...flattenArray(value));
  return result2;
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/range
function range(start, stop, step) {
  isValid_default(stop) || (stop = start, start = 0), isValid_default(step) || (step = 1);
  let i = -1;
  const n = 0 | Math.max(0, Math.ceil((stop - start) / step)), range2 = new Array(n);
  for (; ++i < n; )
    range2[i] = start + i * step;
  return range2;
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/ascending
function ascending(a3, b) {
  return a3 < b ? -1 : a3 > b ? 1 : a3 >= b ? 0 : NaN;
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/toNumber
function toNumber(a3) {
  return Number(a3);
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/quantileSorted
function quantileSorted(values, percent, valueof = toNumber) {
  const n = values.length;
  if (!n)
    return;
  if (percent <= 0 || n < 2)
    return valueof(values[0], 0, values);
  if (percent >= 1)
    return valueof(values[n - 1], n - 1, values);
  const i = (n - 1) * percent, i0 = Math.floor(i), value0 = valueof(values[i0], i0, values);
  return value0 + (valueof(values[i0 + 1], i0 + 1, values) - value0) * (i - i0);
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/logger
var hasConsole = "undefined" != typeof console;
function log(method, level, input) {
  const args = [level].concat([].slice.call(input));
  hasConsole && console[method].apply(console, args);
}
var LoggerLevel;
!function(LoggerLevel2) {
  LoggerLevel2[LoggerLevel2.None = 0] = "None", LoggerLevel2[LoggerLevel2.Error = 1] = "Error", LoggerLevel2[LoggerLevel2.Warn = 2] = "Warn", LoggerLevel2[LoggerLevel2.Info = 3] = "Info", LoggerLevel2[LoggerLevel2.Debug = 4] = "Debug";
}(LoggerLevel || (LoggerLevel = {}));
var Logger = class _Logger {
  static getInstance(level, method) {
    return _Logger._instance && isNumber_default(level) ? _Logger._instance.level(level) : _Logger._instance || (_Logger._instance = new _Logger(level, method)), _Logger._instance;
  }
  static setInstance(logger) {
    return _Logger._instance = logger;
  }
  static setInstanceLevel(level) {
    _Logger._instance ? _Logger._instance.level(level) : _Logger._instance = new _Logger(level);
  }
  static clearInstance() {
    _Logger._instance = null;
  }
  constructor(level = LoggerLevel.None, method) {
    this._onErrorHandler = [], this._level = level, this._method = method;
  }
  addErrorHandler(handler) {
    this._onErrorHandler.find((h) => h === handler) || this._onErrorHandler.push(handler);
  }
  removeErrorHandler(handler) {
    const index = this._onErrorHandler.findIndex((h) => h === handler);
    index < 0 || this._onErrorHandler.splice(index, 1);
  }
  callErrorHandler(...args) {
    this._onErrorHandler.forEach((h) => h(...args));
  }
  canLogInfo() {
    return this._level >= LoggerLevel.Info;
  }
  canLogDebug() {
    return this._level >= LoggerLevel.Debug;
  }
  canLogError() {
    return this._level >= LoggerLevel.Error;
  }
  canLogWarn() {
    return this._level >= LoggerLevel.Warn;
  }
  level(levelValue) {
    return arguments.length ? (this._level = +levelValue, this) : this._level;
  }
  error(...args) {
    var _a;
    return this._level >= LoggerLevel.Error && (this._onErrorHandler.length ? this.callErrorHandler(...args) : log(null !== (_a = this._method) && void 0 !== _a ? _a : "error", "ERROR", args)), this;
  }
  warn(...args) {
    return this._level >= LoggerLevel.Warn && log(this._method || "warn", "WARN", args), this;
  }
  info(...args) {
    return this._level >= LoggerLevel.Info && log(this._method || "log", "INFO", args), this;
  }
  debug(...args) {
    return this._level >= LoggerLevel.Debug && log(this._method || "log", "DEBUG", args), this;
  }
};
Logger._instance = null;

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/bisect
function bisect(a3, x, lo = 0, hi) {
  for (isNil_default(hi) && (hi = a3.length); lo < hi; ) {
    const mid = lo + hi >>> 1;
    ascending(a3[mid], x) > 0 ? hi = mid : lo = mid + 1;
  }
  return lo;
}
var binaryFuzzySearch = (arr, compareFn) => binaryFuzzySearchInNumberRange(0, arr.length, (value) => compareFn(arr[value]));
var binaryFuzzySearchInNumberRange = (x14, x23, compareFn) => {
  let left2 = x14, right2 = x23;
  for (; left2 < right2; ) {
    const mid = Math.floor((left2 + right2) / 2);
    compareFn(mid) >= 0 ? right2 = mid : left2 = mid + 1;
  }
  return left2;
};

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/median
var median = (values, isSorted) => {
  let sorted = values;
  return true !== isSorted && (sorted = values.sort(ascending)), quantileSorted(sorted, 0.5);
};

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/number
var DEFAULT_ABSOLUTE_TOLERATE = 1e-10;
var DEFAULT_RELATIVE_TOLERATE = 1e-10;
function isNumberClose(a3, b, relTol = DEFAULT_RELATIVE_TOLERATE, absTol = DEFAULT_ABSOLUTE_TOLERATE) {
  const abs3 = absTol, rel = relTol * Math.max(a3, b);
  return Math.abs(a3 - b) <= Math.max(abs3, rel);
}
function isGreater(a3, b, relTol, absTol) {
  return a3 > b && !isNumberClose(a3, b, relTol, absTol);
}
function isLess(a3, b, relTol, absTol) {
  return a3 < b && !isNumberClose(a3, b, relTol, absTol);
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/memoize
var memoize = (func) => {
  let lastArgs = null, lastResult = null;
  return (...args) => (lastArgs && args.every((val, i) => val === lastArgs[i]) || (lastArgs = args, lastResult = func(...args)), lastResult);
};

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/clamp
var clamp = function(input, min3, max3) {
  return input < min3 ? min3 : input > max3 ? max3 : input;
};
var clamp_default = clamp;

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/clampRange
var clampRange = (range2, min3, max3) => {
  let [lowValue, highValue] = range2;
  highValue < lowValue && (lowValue = range2[1], highValue = range2[0]);
  const span = highValue - lowValue;
  return span >= max3 - min3 ? [min3, max3] : (lowValue = Math.min(Math.max(lowValue, min3), max3 - span), [lowValue, lowValue + span]);
};
var clampRange_default = clampRange;

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/clamper
function clamper(a3, b) {
  let t;
  return a3 > b && (t = a3, a3 = b, b = t), (x) => Math.max(a3, Math.min(b, x));
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/debounce
var hasRaf = false;
try {
  hasRaf = "function" == typeof requestAnimationFrame && "function" == typeof cancelAnimationFrame;
} catch (err) {
  hasRaf = false;
}
function debounce(func, wait, options) {
  let lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  const useRAF = !wait && 0 !== wait && hasRaf;
  if ("function" != typeof func)
    throw new TypeError("Expected a function");
  function invokeFunc(time) {
    const args = lastArgs, thisArg = lastThis;
    return lastArgs = lastThis = void 0, lastInvokeTime = time, result2 = func.apply(thisArg, args), result2;
  }
  function startTimer(pendingFunc, wait2) {
    return useRAF ? (cancelAnimationFrame(timerId), requestAnimationFrame(pendingFunc)) : setTimeout(pendingFunc, wait2);
  }
  function shouldInvoke(time) {
    const timeSinceLastCall = time - lastCallTime;
    return void 0 === lastCallTime || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && time - lastInvokeTime >= maxWait;
  }
  function timerExpired() {
    const time = Date.now();
    if (shouldInvoke(time))
      return trailingEdge(time);
    timerId = startTimer(timerExpired, function(time2) {
      const timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - (time2 - lastCallTime);
      return maxing ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }(time));
  }
  function trailingEdge(time) {
    return timerId = void 0, trailing && lastArgs ? invokeFunc(time) : (lastArgs = lastThis = void 0, result2);
  }
  function debounced(...args) {
    const time = Date.now(), isInvoking = shouldInvoke(time);
    if (lastArgs = args, lastThis = this, lastCallTime = time, isInvoking) {
      if (void 0 === timerId)
        return function(time2) {
          return lastInvokeTime = time2, timerId = startTimer(timerExpired, wait), leading ? invokeFunc(time2) : result2;
        }(lastCallTime);
      if (maxing)
        return timerId = startTimer(timerExpired, wait), invokeFunc(lastCallTime);
    }
    return void 0 === timerId && (timerId = startTimer(timerExpired, wait)), result2;
  }
  return wait = +wait || 0, isObject_default(options) && (leading = !!options.leading, maxing = "maxWait" in options, maxing && (maxWait = Math.max(isValidNumber_default(options.maxWait) ? options.maxWait : 0, wait)), trailing = "trailing" in options ? !!options.trailing : trailing), debounced.cancel = function() {
    void 0 !== timerId && function(id2) {
      if (useRAF)
        return cancelAnimationFrame(id2);
      clearTimeout(id2);
    }(timerId), lastInvokeTime = 0, lastArgs = lastCallTime = lastThis = timerId = void 0;
  }, debounced.flush = function() {
    return void 0 === timerId ? result2 : trailingEdge(Date.now());
  }, debounced.pending = function() {
    return void 0 !== timerId;
  }, debounced;
}
hasRaf = false;
var debounce_default = debounce;

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/throttle
function throttle(func, wait, options) {
  let leading = true, trailing = true;
  if ("function" != typeof func)
    throw new TypeError("Expected a function");
  return isObject_default(options) && (leading = "leading" in options ? !!options.leading : leading, trailing = "trailing" in options ? !!options.trailing : trailing), debounce_default(func, wait, {
    leading,
    trailing,
    maxWait: wait
  });
}
var throttle_default = throttle;

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/interpolate
function interpolateNumber(a3, b) {
  return (t) => a3 * (1 - t) + b * t;
}
function interpolateNumberRound(a3, b) {
  return function(t) {
    return Math.round(a3 * (1 - t) + b * t);
  };
}
function interpolateDate(a3, b) {
  const aVal = a3.valueOf(), bVal = b.valueOf(), d = /* @__PURE__ */ new Date();
  return (t) => (d.setTime(aVal * (1 - t) + bVal * t), d);
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function interpolateString(a3, b) {
  let am, bm, bs, bi = reA.lastIndex = reB.lastIndex = 0, i = -1;
  const s2 = [], q = [];
  for (a3 += "", b += ""; (am = reA.exec(a3)) && (bm = reB.exec(b)); )
    (bs = bm.index) > bi && (bs = b.slice(bi, bs), s2[i] ? s2[i] += bs : s2[++i] = bs), (am = am[0]) === (bm = bm[0]) ? s2[i] ? s2[i] += bm : s2[++i] = bm : (s2[++i] = null, q.push({
      i,
      x: interpolateNumber(am, bm)
    })), bi = reB.lastIndex;
  return bi < b.length && (bs = b.slice(bi), s2[i] ? s2[i] += bs : s2[++i] = bs), s2.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
    for (let o, i2 = 0; i2 < b; ++i2)
      s2[(o = q[i2]).i] = o.x(t);
    return s2.join("");
  });
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/common/toValidNumber
function toValidNumber(v) {
  if (isValidNumber_default(v))
    return v;
  const value = +v;
  return isValidNumber_default(value) ? value : 0;
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/math
var epsilon = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;
var pi2 = 2 * Math.PI;
var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max = Math.max;
var min = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;
var pow = Math.pow;
function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}
function asin(x) {
  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
}
function pointAt(x14, y14, x23, y23, t) {
  let x, y;
  return "number" == typeof x14 && "number" == typeof x23 && (x = (1 - t) * x14 + t * x23), "number" == typeof y14 && "number" == typeof y23 && (y = (1 - t) * y14 + t * y23), {
    x,
    y
  };
}
function crossProduct(dir1, dir2) {
  return dir1[0] * dir2[1] - dir1[1] * dir2[0];
}
function fuzzyEqualVec(a3, b) {
  return abs(a3[0] - b[0]) + abs(a3[1] - b[1]) < 1e-12;
}
function fixPrecision(num, precision = 10) {
  return Math.round(num * precision) / precision;
}
function getDecimalPlaces(n) {
  const dStr = n.toString().split(/[eE]/), s2 = (dStr[0].split(".")[1] || "").length - (+dStr[1] || 0);
  return s2 > 0 ? s2 : 0;
}
function precisionAdd(a3, b) {
  return fixPrecision(a3 + b, 10 ** Math.max(getDecimalPlaces(a3), getDecimalPlaces(b)));
}
function precisionSub(a3, b) {
  return fixPrecision(a3 - b, 10 ** Math.max(getDecimalPlaces(a3), getDecimalPlaces(b)));
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/data-structure/point
var Point = class _Point {
  constructor(x = 0, y = 0, x14, y14) {
    this.x = 0, this.y = 0, this.x = x, this.y = y, this.x1 = x14, this.y1 = y14;
  }
  clone() {
    return new _Point(this.x, this.y);
  }
  copyFrom(p) {
    return this.x = p.x, this.y = p.y, this.x1 = p.x1, this.y1 = p.y1, this.defined = p.defined, this.context = p.context, this;
  }
  set(x, y) {
    return this.x = x, this.y = y, this;
  }
  add(point5) {
    return isNumber_default(point5) ? (this.x += point5, void (this.y += point5)) : (this.x += point5.x, this.y += point5.y, this);
  }
  sub(point5) {
    return isNumber_default(point5) ? (this.x -= point5, void (this.y -= point5)) : (this.x -= point5.x, this.y -= point5.y, this);
  }
  multi(point5) {
    throw new Error("\u6682\u4E0D\u652F\u6301");
  }
  div(point5) {
    throw new Error("\u6682\u4E0D\u652F\u6301");
  }
};
var PointService = class {
  static distancePP(p1, p2) {
    return sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));
  }
  static distanceNN(x, y, x14, y14) {
    return sqrt(pow(x - x14, 2) + pow(y - y14, 2));
  }
  static distancePN(point5, x, y) {
    return sqrt(pow(x - point5.x, 2) + pow(y - point5.y, 2));
  }
  static pointAtPP(p1, p2, t) {
    return new Point((p2.x - p1.x) * t + p1.x, (p2.y - p1.y) * t + p1.y);
  }
};

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/data-structure/bounds
function transformBoundsWithMatrix(out, bounds, matrix) {
  const { x1: x14, y1: y14, x2: x23, y2: y23 } = bounds;
  return matrix.onlyTranslate() ? (out !== bounds && out.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), out.translate(matrix.e, matrix.f), bounds) : (out.clear(), out.add(matrix.a * x14 + matrix.c * y14 + matrix.e, matrix.b * x14 + matrix.d * y14 + matrix.f), out.add(matrix.a * x23 + matrix.c * y14 + matrix.e, matrix.b * x23 + matrix.d * y14 + matrix.f), out.add(matrix.a * x23 + matrix.c * y23 + matrix.e, matrix.b * x23 + matrix.d * y23 + matrix.f), out.add(matrix.a * x14 + matrix.c * y23 + matrix.e, matrix.b * x14 + matrix.d * y23 + matrix.f), bounds);
}
var Bounds = class _Bounds {
  constructor(bounds) {
    bounds ? this.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2) : this.clear();
  }
  clone() {
    return new _Bounds(this);
  }
  clear() {
    return this.x1 = +Number.MAX_VALUE, this.y1 = +Number.MAX_VALUE, this.x2 = -Number.MAX_VALUE, this.y2 = -Number.MAX_VALUE, this;
  }
  empty() {
    return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
  }
  equals(b) {
    return this.x1 === b.x1 && this.y1 === b.y1 && this.x2 === b.x2 && this.y2 === b.y2;
  }
  setValue(x14 = 0, y14 = 0, x23 = 0, y23 = 0) {
    return this.x1 = x14, this.y1 = y14, this.x2 = x23, this.y2 = y23, this;
  }
  set(x14 = 0, y14 = 0, x23 = 0, y23 = 0) {
    return x23 < x14 ? (this.x2 = x14, this.x1 = x23) : (this.x1 = x14, this.x2 = x23), y23 < y14 ? (this.y2 = y14, this.y1 = y23) : (this.y1 = y14, this.y2 = y23), this;
  }
  add(x = 0, y = 0) {
    return x < this.x1 && (this.x1 = x), y < this.y1 && (this.y1 = y), x > this.x2 && (this.x2 = x), y > this.y2 && (this.y2 = y), this;
  }
  expand(d = 0) {
    return isArray_default(d) ? (this.y1 -= d[0], this.x2 += d[1], this.y2 += d[2], this.x1 -= d[3]) : (this.x1 -= d, this.y1 -= d, this.x2 += d, this.y2 += d), this;
  }
  round() {
    return this.x1 = Math.floor(this.x1), this.y1 = Math.floor(this.y1), this.x2 = Math.ceil(this.x2), this.y2 = Math.ceil(this.y2), this;
  }
  translate(dx = 0, dy = 0) {
    return this.x1 += dx, this.x2 += dx, this.y1 += dy, this.y2 += dy, this;
  }
  rotate(angle2 = 0, x = 0, y = 0) {
    const p = this.rotatedPoints(angle2, x, y);
    return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);
  }
  scale(sx = 0, sy = 0, x = 0, y = 0) {
    const p = this.scalePoints(sx, sy, x, y);
    return this.clear().add(p[0], p[1]).add(p[2], p[3]);
  }
  union(b) {
    return b.x1 < this.x1 && (this.x1 = b.x1), b.y1 < this.y1 && (this.y1 = b.y1), b.x2 > this.x2 && (this.x2 = b.x2), b.y2 > this.y2 && (this.y2 = b.y2), this;
  }
  intersect(b) {
    return b.x1 > this.x1 && (this.x1 = b.x1), b.y1 > this.y1 && (this.y1 = b.y1), b.x2 < this.x2 && (this.x2 = b.x2), b.y2 < this.y2 && (this.y2 = b.y2), this;
  }
  encloses(b) {
    return b && this.x1 <= b.x1 && this.x2 >= b.x2 && this.y1 <= b.y1 && this.y2 >= b.y2;
  }
  alignsWith(b) {
    return b && (this.x1 === b.x1 || this.x2 === b.x2 || this.y1 === b.y1 || this.y2 === b.y2);
  }
  intersects(b) {
    return b && !(this.x2 < b.x1 || this.x1 > b.x2 || this.y2 < b.y1 || this.y1 > b.y2);
  }
  contains(x = 0, y = 0) {
    return !(x < this.x1 || x > this.x2 || y < this.y1 || y > this.y2);
  }
  containsPoint(p) {
    return !(p.x < this.x1 || p.x > this.x2 || p.y < this.y1 || p.y > this.y2);
  }
  width() {
    return this.empty() ? 0 : this.x2 - this.x1;
  }
  height() {
    return this.empty() ? 0 : this.y2 - this.y1;
  }
  scaleX(s2 = 0) {
    return this.x1 *= s2, this.x2 *= s2, this;
  }
  scaleY(s2 = 0) {
    return this.y1 *= s2, this.y2 *= s2, this;
  }
  transformWithMatrix(matrix) {
    return transformBoundsWithMatrix(this, this, matrix), this;
  }
  copy(b) {
    return this.x1 = b.x1, this.y1 = b.y1, this.x2 = b.x2, this.y2 = b.y2, this;
  }
  rotatedPoints(angle2, x, y) {
    const { x1: x14, y1: y14, x2: x23, y2: y23 } = this, cos3 = Math.cos(angle2), sin3 = Math.sin(angle2), cx = x - x * cos3 + y * sin3, cy = y - x * sin3 - y * cos3;
    return [cos3 * x14 - sin3 * y14 + cx, sin3 * x14 + cos3 * y14 + cy, cos3 * x14 - sin3 * y23 + cx, sin3 * x14 + cos3 * y23 + cy, cos3 * x23 - sin3 * y14 + cx, sin3 * x23 + cos3 * y14 + cy, cos3 * x23 - sin3 * y23 + cx, sin3 * x23 + cos3 * y23 + cy];
  }
  scalePoints(sx, sy, x, y) {
    const { x1: x14, y1: y14, x2: x23, y2: y23 } = this;
    return [sx * x14 + (1 - sx) * x, sy * y14 + (1 - sy) * y, sx * x23 + (1 - sx) * x, sy * y23 + (1 - sy) * y];
  }
};
var AABBBounds = class extends Bounds {
};

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/angle
function degreeToRadian(degree) {
  return degree * (Math.PI / 180);
}
function radianToDegree(radian) {
  return 180 * radian / Math.PI;
}
var clampRadian = (angle2 = 0) => {
  if (angle2 < 0)
    for (; angle2 < -tau; )
      angle2 += tau;
  else if (angle2 > 0)
    for (; angle2 > tau; )
      angle2 -= tau;
  return angle2;
};
var clampAngleByRadian = clampRadian;
function polarToCartesian(center2, radius, angleInRadian) {
  return radius ? {
    x: center2.x + radius * Math.cos(angleInRadian),
    y: center2.y + radius * Math.sin(angleInRadian)
  } : {
    x: center2.x,
    y: center2.y
  };
}
function getAngleByPoint(center2, point5) {
  return Math.atan2(point5.y - center2.y, point5.x - center2.x);
}
function normalizeAngle(angle2) {
  for (; angle2 < 0; )
    angle2 += 2 * Math.PI;
  for (; angle2 >= 2 * Math.PI; )
    angle2 -= 2 * Math.PI;
  return angle2;
}
function findBoundaryAngles(startAngle, endAngle) {
  const deltaAngle = Math.abs(endAngle - startAngle);
  if (deltaAngle >= 2 * Math.PI || 2 * Math.PI - deltaAngle < 1e-6)
    return [0, Math.PI / 2, Math.PI, 1.5 * Math.PI];
  const normalMin = normalizeAngle(Math.min(startAngle, endAngle)), normalMax = normalMin + deltaAngle, steps = [normalMin, normalMax];
  let directionAngle = Math.floor(normalMin / Math.PI) * Math.PI / 2;
  for (; directionAngle < normalMax; )
    directionAngle > normalMin && steps.push(directionAngle), directionAngle += Math.PI / 2;
  return steps;
}
function calculateMaxRadius(rect, center2, startAngle, endAngle) {
  const { x, y } = center2, steps = findBoundaryAngles(startAngle, endAngle), { width, height } = rect, radiusList = [];
  return steps.forEach((step) => {
    const sin3 = Math.sin(step), cos3 = Math.cos(step);
    1 === sin3 ? radiusList.push(height - y) : -1 === sin3 ? radiusList.push(y) : 1 === cos3 ? radiusList.push(width - x) : -1 === cos3 ? radiusList.push(x) : (sin3 > 0 ? radiusList.push(Math.abs((height - y) / cos3)) : radiusList.push(Math.abs(y / cos3)), cos3 > 0 ? radiusList.push(Math.abs((width - x) / sin3)) : radiusList.push(Math.abs(x / sin3)));
  }), Math.min.apply(null, radiusList);
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/data-structure/matrix
var Matrix = class _Matrix {
  constructor(a3 = 1, b = 0, c3 = 0, d = 1, e = 0, f = 0) {
    this.a = a3, this.b = b, this.c = c3, this.d = d, this.e = e, this.f = f;
  }
  equalToMatrix(m22) {
    return !(this.e !== m22.e || this.f !== m22.f || this.a !== m22.a || this.d !== m22.d || this.b !== m22.b || this.c !== m22.c);
  }
  equalTo(a3, b, c3, d, e, f) {
    return !(this.e !== e || this.f !== f || this.a !== a3 || this.d !== d || this.b !== b || this.c !== c3);
  }
  setValue(a3, b, c3, d, e, f) {
    return this.a = a3, this.b = b, this.c = c3, this.d = d, this.e = e, this.f = f, this;
  }
  reset() {
    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.e = 0, this.f = 0, this;
  }
  getInverse() {
    const a3 = this.a, b = this.b, c3 = this.c, d = this.d, e = this.e, f = this.f, m4 = new _Matrix(), dt = a3 * d - b * c3;
    return m4.a = d / dt, m4.b = -b / dt, m4.c = -c3 / dt, m4.d = a3 / dt, m4.e = (c3 * f - d * e) / dt, m4.f = -(a3 * f - b * e) / dt, m4;
  }
  rotate(rad) {
    const c3 = Math.cos(rad), s2 = Math.sin(rad), m11 = this.a * c3 + this.c * s2, m12 = this.b * c3 + this.d * s2, m21 = this.a * -s2 + this.c * c3, m22 = this.b * -s2 + this.d * c3;
    return this.a = m11, this.b = m12, this.c = m21, this.d = m22, this;
  }
  rotateByCenter(rad, cx, cy) {
    const cos3 = Math.cos(rad), sin3 = Math.sin(rad), rotateM13 = (1 - cos3) * cx + sin3 * cy, rotateM23 = (1 - cos3) * cy - sin3 * cx, m11 = cos3 * this.a - sin3 * this.b, m21 = sin3 * this.a + cos3 * this.b, m12 = cos3 * this.c - sin3 * this.d, m22 = sin3 * this.c + cos3 * this.d, m13 = cos3 * this.e - sin3 * this.f + rotateM13, m23 = sin3 * this.e + cos3 * this.f + rotateM23;
    return this.a = m11, this.b = m21, this.c = m12, this.d = m22, this.e = m13, this.f = m23, this;
  }
  scale(sx, sy) {
    return this.a *= sx, this.b *= sx, this.c *= sy, this.d *= sy, this;
  }
  setScale(sx, sy) {
    return this.b = this.b / this.a * sx, this.c = this.c / this.d * sy, this.a = sx, this.d = sy, this;
  }
  transform(a3, b, c3, d, e, f) {
    return this.multiply(a3, b, c3, d, e, f), this;
  }
  translate(x, y) {
    return this.e += this.a * x + this.c * y, this.f += this.b * x + this.d * y, this;
  }
  transpose() {
    const { a: a3, b, c: c3, d, e, f } = this;
    return this.a = b, this.b = a3, this.c = d, this.d = c3, this.e = f, this.f = e, this;
  }
  multiply(a22, b2, c22, d2, e24, f2) {
    const a1 = this.a, b1 = this.b, c1 = this.c, d1 = this.d, m11 = a1 * a22 + c1 * b2, m12 = b1 * a22 + d1 * b2, m21 = a1 * c22 + c1 * d2, m22 = b1 * c22 + d1 * d2, dx = a1 * e24 + c1 * f2 + this.e, dy = b1 * e24 + d1 * f2 + this.f;
    return this.a = m11, this.b = m12, this.c = m21, this.d = m22, this.e = dx, this.f = dy, this;
  }
  interpolate(m22, t) {
    const m4 = new _Matrix();
    return m4.a = this.a + (m22.a - this.a) * t, m4.b = this.b + (m22.b - this.b) * t, m4.c = this.c + (m22.c - this.c) * t, m4.d = this.d + (m22.d - this.d) * t, m4.e = this.e + (m22.e - this.e) * t, m4.f = this.f + (m22.f - this.f) * t, m4;
  }
  transformPoint(source, target) {
    const { a: a3, b, c: c3, d, e, f } = this, dt = a3 * d - b * c3, nextA = d / dt, nextB = -b / dt, nextC = -c3 / dt, nextD = a3 / dt, nextE = (c3 * f - d * e) / dt, nextF = -(a3 * f - b * e) / dt, { x, y } = source;
    target.x = x * nextA + y * nextC + nextE, target.y = x * nextB + y * nextD + nextF;
  }
  onlyTranslate(scale4 = 1) {
    return this.a === scale4 && 0 === this.b && 0 === this.c && this.d === scale4;
  }
  clone() {
    return new _Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
  }
  toTransformAttrs() {
    const a3 = this.a, b = this.b, c3 = this.c, d = this.d, delta = a3 * d - b * c3, result2 = {
      x: this.e,
      y: this.f,
      rotateDeg: 0,
      scaleX: 0,
      scaleY: 0,
      skewX: 0,
      skewY: 0
    };
    if (0 !== a3 || 0 !== b) {
      const r = Math.sqrt(a3 * a3 + b * b);
      result2.rotateDeg = b > 0 ? Math.acos(a3 / r) : -Math.acos(a3 / r), result2.scaleX = r, result2.scaleY = delta / r, result2.skewX = (a3 * c3 + b * d) / delta, result2.skewY = 0;
    } else if (0 !== c3 || 0 !== d) {
      const s2 = Math.sqrt(c3 * c3 + d * d);
      result2.rotateDeg = Math.PI / 2 - (d > 0 ? Math.acos(-c3 / s2) : -Math.acos(c3 / s2)), result2.scaleX = delta / s2, result2.scaleY = s2, result2.skewX = 0, result2.skewY = (a3 * c3 + b * d) / delta;
    }
    return result2.rotateDeg = radianToDegree(result2.rotateDeg), result2;
  }
};
function normalTransform(out, origin, x, y, scaleX, scaleY, angle2, rotateCenter) {
  const oa = origin.a, ob = origin.b, oc = origin.c, od = origin.d, oe = origin.e, of = origin.f, cosTheta = cos(angle2), sinTheta = sin(angle2);
  let rotateCenterX, rotateCenterY;
  rotateCenter ? (rotateCenterX = rotateCenter[0], rotateCenterY = rotateCenter[1]) : (rotateCenterX = x, rotateCenterY = y);
  const offsetX = rotateCenterX - x, offsetY = rotateCenterY - y, a1 = oa * cosTheta + oc * sinTheta, b1 = ob * cosTheta + od * sinTheta, c1 = oc * cosTheta - oa * sinTheta, d1 = od * cosTheta - ob * sinTheta;
  out.a = scaleX * a1, out.b = scaleX * b1, out.c = scaleY * c1, out.d = scaleY * d1, out.e = oe + oa * rotateCenterX + oc * rotateCenterY - a1 * offsetX - c1 * offsetY, out.f = of + ob * rotateCenterX + od * rotateCenterY - b1 * offsetX - d1 * offsetY;
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/lru
var LRU = class {
  constructor() {
    this.CLEAN_THRESHOLD = 1e3, this.L_TIME = 1e3, this.R_COUNT = 1, this.R_TIMESTAMP_MAX_SIZE = 20;
  }
  clearCache(cache, params2) {
    const { CLEAN_THRESHOLD = this.CLEAN_THRESHOLD, L_TIME = this.L_TIME, R_COUNT = this.R_COUNT } = params2;
    if (cache.size < CLEAN_THRESHOLD)
      return 0;
    let clearNum = 0;
    const clear = (key) => {
      clearNum++, cache.delete(key);
    }, now = Date.now();
    return cache.forEach((item, key) => {
      if (item.timestamp.length < R_COUNT)
        return clear(key);
      let useCount = 0;
      for (; now - item.timestamp[item.timestamp.length - 1 - useCount] < L_TIME && (useCount++, !(useCount >= R_COUNT)); )
        ;
      if (useCount < R_COUNT)
        return clear(key);
      for (; now - item.timestamp[0] > L_TIME; )
        item.timestamp.shift();
    }), clearNum;
  }
  addLimitedTimestamp(cacheItem, t, params2) {
    const { R_TIMESTAMP_MAX_SIZE = this.R_TIMESTAMP_MAX_SIZE } = params2;
    cacheItem.timestamp.length > R_TIMESTAMP_MAX_SIZE && cacheItem.timestamp.shift(), cacheItem.timestamp.push(t);
  }
  clearTimeStamp(cache, params2) {
    const { L_TIME = this.L_TIME } = params2, now = Date.now();
    cache.forEach((item) => {
      for (; now - item.timestamp[0] > L_TIME; )
        item.timestamp.shift();
    });
  }
  clearItemTimestamp(cacheItem, params2) {
    const { L_TIME = this.L_TIME } = params2, now = Date.now();
    for (; now - cacheItem.timestamp[0] > L_TIME; )
      cacheItem.timestamp.shift();
  }
};

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/color
var color_exports = {};
__export(color_exports, {
  Color: () => Color,
  DEFAULT_COLORS: () => DEFAULT_COLORS,
  RGB: () => RGB,
  hexToRgb: () => hexToRgb,
  hslToRgb: () => hslToRgb,
  interpolateRgb: () => interpolateRgb,
  rgbToHex: () => rgbToHex,
  rgbToHsl: () => rgbToHsl
});

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/color/hslToRgb
function hslToRgb(h, s2, l) {
  s2 /= 100, l /= 100;
  const c3 = (1 - Math.abs(2 * l - 1)) * s2, x = c3 * (1 - Math.abs(h / 60 % 2 - 1)), m4 = l - c3 / 2;
  let r = 0, g = 0, b = 0;
  return 0 <= h && h < 60 ? (r = c3, g = x, b = 0) : 60 <= h && h < 120 ? (r = x, g = c3, b = 0) : 120 <= h && h < 180 ? (r = 0, g = c3, b = x) : 180 <= h && h < 240 ? (r = 0, g = x, b = c3) : 240 <= h && h < 300 ? (r = x, g = 0, b = c3) : 300 <= h && h < 360 && (r = c3, g = 0, b = x), r = Math.round(255 * (r + m4)), g = Math.round(255 * (g + m4)), b = Math.round(255 * (b + m4)), {
    r,
    g,
    b
  };
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/color/rgbToHsl
function rgbToHsl(r, g, b) {
  r /= 255, g /= 255, b /= 255;
  const cMin = Math.min(r, g, b), cMax = Math.max(r, g, b), delta = cMax - cMin;
  let h = 0, s2 = 0, l = 0;
  return h = 0 === delta ? 0 : cMax === r ? (g - b) / delta % 6 : cMax === g ? (b - r) / delta + 2 : (r - g) / delta + 4, h = Math.round(60 * h), h < 0 && (h += 360), l = (cMax + cMin) / 2, s2 = 0 === delta ? 0 : delta / (1 - Math.abs(2 * l - 1)), s2 = +(100 * s2).toFixed(1), l = +(100 * l).toFixed(1), {
    h,
    s: s2,
    l
  };
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/color/Color
var REG_HEX = /^#([0-9a-f]{3,8})$/;
var DEFAULT_COLORS_OPACITY = {
  transparent: 4294967040
};
var DEFAULT_COLORS = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
function hex(value) {
  return ((value = Math.max(0, Math.min(255, Math.round(value) || 0))) < 16 ? "0" : "") + value.toString(16);
}
function rgb(value) {
  return isNumber_default(value) ? new RGB(value >> 16, value >> 8 & 255, 255 & value, 1) : isArray_default(value) ? new RGB(value[0], value[1], value[2]) : new RGB(255, 255, 255);
}
function rgba(value) {
  return isNumber_default(value) ? new RGB(value >>> 24, value >>> 16 & 255, value >>> 8 & 255, 255 & value) : isArray_default(value) ? new RGB(value[0], value[1], value[2], value[3]) : new RGB(255, 255, 255, 1);
}
function SRGBToLinear(c3) {
  return c3 < 0.04045 ? 0.0773993808 * c3 : Math.pow(0.9478672986 * c3 + 0.0521327014, 2.4);
}
function LinearToSRGB(c3) {
  return c3 < 31308e-7 ? 12.92 * c3 : 1.055 * Math.pow(c3, 0.41666) - 0.055;
}
var Color = class _Color {
  static Brighter(source, b = 1) {
    return 1 === b ? source : new _Color(source).brighter(b).toRGBA();
  }
  static SetOpacity(source, o = 1) {
    return 1 === o ? source : new _Color(source).setOpacity(o).toRGBA();
  }
  static getColorBrightness(source, model = "hsl") {
    const color = source instanceof _Color ? source : new _Color(source);
    switch (model) {
      case "hsv":
      default:
        return color.getHSVBrightness();
      case "hsl":
        return color.getHSLBrightness();
      case "lum":
        return color.getLuminance();
      case "lum2":
        return color.getLuminance2();
      case "lum3":
        return color.getLuminance3();
    }
  }
  static parseColorString(value) {
    if (isValid_default(DEFAULT_COLORS_OPACITY[value]))
      return rgba(DEFAULT_COLORS_OPACITY[value]);
    if (isValid_default(DEFAULT_COLORS[value]))
      return rgb(DEFAULT_COLORS[value]);
    const formatValue = `${value}`.trim().toLowerCase(), isHex = REG_HEX.exec(formatValue);
    if (isHex) {
      const hex2 = parseInt(isHex[1], 16), hexLength = isHex[1].length;
      return 3 === hexLength ? new RGB((hex2 >> 8 & 15) + ((hex2 >> 8 & 15) << 4), (hex2 >> 4 & 15) + ((hex2 >> 4 & 15) << 4), (15 & hex2) + ((15 & hex2) << 4), 1) : 6 === hexLength ? rgb(hex2) : 8 === hexLength ? new RGB(hex2 >> 24 & 255, hex2 >> 16 & 255, hex2 >> 8 & 255, (255 & hex2) / 255) : void 0;
    }
    if (/^(rgb|RGB|rgba|RGBA)/.test(formatValue)) {
      const aColor = formatValue.replace(/(?:\(|\)|rgba|RGBA|rgb|RGB)*/g, "").split(",");
      return new RGB(parseInt(aColor[0], 10), parseInt(aColor[1], 10), parseInt(aColor[2], 10), parseFloat(aColor[3]));
    }
    if (/^(hsl|HSL|hsla|HSLA)/.test(formatValue)) {
      const aColor = formatValue.replace(/(?:\(|\)|hsla|HSLA|hsl|HSL)*/g, "").split(","), rgb2 = hslToRgb(parseInt(aColor[0], 10), parseInt(aColor[1], 10), parseInt(aColor[2], 10));
      return new RGB(rgb2.r, rgb2.g, rgb2.b, parseFloat(aColor[3]));
    }
  }
  constructor(value) {
    const color = _Color.parseColorString(value);
    color ? this.color = color : (console.warn(`Warn: \u4F20\u5165${value}\u65E0\u6CD5\u89E3\u6790\u4E3AColor`), this.color = new RGB(255, 255, 255));
  }
  toRGBA() {
    return this.color.formatRgb();
  }
  toString() {
    return this.color.formatRgb();
  }
  toHex() {
    return this.color.formatHex();
  }
  toHsl() {
    return this.color.formatHsl();
  }
  brighter(k2) {
    const { r, g, b } = this.color;
    return this.color.r = Math.max(0, Math.min(255, Math.floor(r * k2))), this.color.g = Math.max(0, Math.min(255, Math.floor(g * k2))), this.color.b = Math.max(0, Math.min(255, Math.floor(b * k2))), this;
  }
  add(color) {
    const { r, g, b } = this.color;
    return this.color.r += Math.min(255, r + color.color.r), this.color.g += Math.min(255, g + color.color.g), this.color.b += Math.min(255, b + color.color.b), this;
  }
  sub(color) {
    return this.color.r = Math.max(0, this.color.r - color.color.r), this.color.g = Math.max(0, this.color.g - color.color.g), this.color.b = Math.max(0, this.color.b - color.color.b), this;
  }
  multiply(color) {
    const { r, g, b } = this.color;
    return this.color.r = Math.max(0, Math.min(255, Math.floor(r * color.color.r))), this.color.g = Math.max(0, Math.min(255, Math.floor(g * color.color.g))), this.color.b = Math.max(0, Math.min(255, Math.floor(b * color.color.b))), this;
  }
  getHSVBrightness() {
    return Math.max(this.color.r, this.color.g, this.color.b) / 255;
  }
  getHSLBrightness() {
    return 0.5 * (Math.max(this.color.r, this.color.g, this.color.b) / 255 + Math.min(this.color.r, this.color.g, this.color.b) / 255);
  }
  setHsl(h, s2, l) {
    const opacity = this.color.opacity, hsl = rgbToHsl(this.color.r, this.color.g, this.color.b), rgb2 = hslToRgb(isNil_default(h) ? hsl.h : clamp_default(h, 0, 360), isNil_default(s2) ? hsl.s : s2 >= 0 && s2 <= 1 ? 100 * s2 : s2, isNil_default(l) ? hsl.l : l <= 1 && l >= 0 ? 100 * l : l);
    return this.color = new RGB(rgb2.r, rgb2.g, rgb2.b, opacity), this;
  }
  setRGB(r, g, b) {
    return !isNil_default(r) && (this.color.r = r), !isNil_default(g) && (this.color.g = g), !isNil_default(b) && (this.color.b = b), this;
  }
  setHex(value) {
    const formatValue = `${value}`.trim().toLowerCase(), isHex = REG_HEX.exec(formatValue), hex2 = parseInt(isHex[1], 16), hexLength = isHex[1].length;
    return 3 === hexLength ? new RGB((hex2 >> 8 & 15) + ((hex2 >> 8 & 15) << 4), (hex2 >> 4 & 15) + ((hex2 >> 4 & 15) << 4), (15 & hex2) + ((15 & hex2) << 4), 1) : 6 === hexLength ? rgb(hex2) : 8 === hexLength ? new RGB(hex2 >> 24 & 255, hex2 >> 16 & 255, hex2 >> 8 & 255, (255 & hex2) / 255) : this;
  }
  setColorName(name) {
    const hex2 = DEFAULT_COLORS[name.toLowerCase()];
    return void 0 !== hex2 ? this.setHex(hex2) : console.warn("THREE.Color: Unknown color " + name), this;
  }
  setScalar(scalar) {
    return this.color.r = scalar, this.color.g = scalar, this.color.b = scalar, this;
  }
  setOpacity(o = 1) {
    return this.color.opacity = o, this;
  }
  getLuminance() {
    return (0.2126 * this.color.r + 0.7152 * this.color.g + 0.0722 * this.color.b) / 255;
  }
  getLuminance2() {
    return (0.2627 * this.color.r + 0.678 * this.color.g + 0.0593 * this.color.b) / 255;
  }
  getLuminance3() {
    return (0.299 * this.color.r + 0.587 * this.color.g + 0.114 * this.color.b) / 255;
  }
  clone() {
    return new _Color(this.color.toString());
  }
  copyGammaToLinear(color, gammaFactor = 2) {
    return this.color.r = Math.pow(color.color.r, gammaFactor), this.color.g = Math.pow(color.color.g, gammaFactor), this.color.b = Math.pow(color.color.b, gammaFactor), this;
  }
  copyLinearToGamma(color, gammaFactor = 2) {
    const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
    return this.color.r = Math.pow(color.color.r, safeInverse), this.color.g = Math.pow(color.color.g, safeInverse), this.color.b = Math.pow(color.color.b, safeInverse), this;
  }
  convertGammaToLinear(gammaFactor) {
    return this.copyGammaToLinear(this, gammaFactor), this;
  }
  convertLinearToGamma(gammaFactor) {
    return this.copyLinearToGamma(this, gammaFactor), this;
  }
  copySRGBToLinear(color) {
    return this.color.r = SRGBToLinear(color.color.r), this.color.g = SRGBToLinear(color.color.g), this.color.b = SRGBToLinear(color.color.b), this;
  }
  copyLinearToSRGB(color) {
    return this.color.r = LinearToSRGB(color.color.r), this.color.g = LinearToSRGB(color.color.g), this.color.b = LinearToSRGB(color.color.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
};
var RGB = class {
  constructor(r, g, b, opacity) {
    this.r = isNaN(+r) ? 255 : Math.max(0, Math.min(255, +r)), this.g = isNaN(+g) ? 255 : Math.max(0, Math.min(255, +g)), this.b = isNaN(+b) ? 255 : Math.max(0, Math.min(255, +b)), isValid_default(opacity) ? this.opacity = isNaN(+opacity) ? 1 : Math.max(0, Math.min(1, +opacity)) : this.opacity = 1;
  }
  formatHex() {
    return `#${hex(this.r) + hex(this.g) + hex(this.b) + (1 === this.opacity ? "" : hex(255 * this.opacity))}`;
  }
  formatRgb() {
    const opacity = this.opacity;
    return `${1 === opacity ? "rgb(" : "rgba("}${this.r},${this.g},${this.b}${1 === opacity ? ")" : `,${opacity})`}`;
  }
  formatHsl() {
    const opacity = this.opacity, { h, s: s2, l } = rgbToHsl(this.r, this.g, this.b);
    return `${1 === opacity ? "hsl(" : "hsla("}${h},${s2}%,${l}%${1 === opacity ? ")" : `,${opacity})`}`;
  }
  toString() {
    return this.formatHex();
  }
};

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/color/hexToRgb
function hexToRgb(str) {
  let r = "", g = "", b = "";
  const strtIndex = "#" === str[0] ? 1 : 0;
  for (let i = strtIndex; i < str.length; i++)
    "#" !== str[i] && (i < strtIndex + 2 ? r += str[i] : i < strtIndex + 4 ? g += str[i] : i < strtIndex + 6 && (b += str[i]));
  return [parseInt(r, 16), parseInt(g, 16), parseInt(b, 16)];
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/color/rgbToHex
function rgbToHex(r, g, b) {
  return Number((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/color/interpolate
function interpolateRgb(colorA, colorB) {
  const redA = colorA.r, redB = colorB.r, greenA = colorA.g, greenB = colorB.g, blueA = colorA.b, blueB = colorB.b, opacityA = colorA.opacity, opacityB = colorB.opacity;
  return (t) => {
    const r = Math.round(redA * (1 - t) + redB * t), g = Math.round(greenA * (1 - t) + greenB * t), b = Math.round(blueA * (1 - t) + blueB * t);
    return new RGB(r, g, b, opacityA * (1 - t) + opacityB * t);
  };
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/graphics/algorithm/intersect
function sub(out, v1, v2) {
  out[0] = v1[0] - v2[0], out[1] = v1[1] - v2[1];
}
var x11;
var x12;
var y11;
var y12;
var x21;
var x22;
var y21;
var y22;
function isIntersect(left1, right1, left2, right2) {
  let _temp, min1 = left1[0], max1 = right1[0], min22 = left2[0], max22 = right2[0];
  return max1 < min1 && (_temp = max1, max1 = min1, min1 = _temp), max22 < min22 && (_temp = max22, max22 = min22, min22 = _temp), !(max1 < min22 || max22 < min1) && (min1 = left1[1], max1 = right1[1], min22 = left2[1], max22 = right2[1], max1 < min1 && (_temp = max1, max1 = min1, min1 = _temp), max22 < min22 && (_temp = max22, max22 = min22, min22 = _temp), !(max1 < min22 || max22 < min1));
}
function getIntersectPoint(left1, right1, left2, right2) {
  if (!isIntersect(left1, right1, left2, right2))
    return false;
  const dir1 = [0, 0], dir2 = [0, 0], tempVec = [0, 0];
  if (sub(dir1, right1, left1), sub(dir2, right2, left2), fuzzyEqualVec(dir1, dir2))
    return true;
  sub(tempVec, left2, left1);
  const t = crossProduct(tempVec, dir2) / crossProduct(dir1, dir2);
  return t >= 0 && t <= 1 && [left1[0] + dir1[0] * t, left1[1] + dir1[1] * t];
}
function getRectIntersect(bbox1, bbox2, format) {
  return null === bbox1 ? bbox2 : null === bbox2 ? bbox1 : (x11 = bbox1.x1, x12 = bbox1.x2, y11 = bbox1.y1, y12 = bbox1.y2, x21 = bbox2.x1, x22 = bbox2.x2, y21 = bbox2.y1, y22 = bbox2.y2, format && (x11 > x12 && ([x11, x12] = [x12, x11]), y11 > y12 && ([y11, y12] = [y12, y11]), x21 > x22 && ([x21, x22] = [x22, x21]), y21 > y22 && ([y21, y22] = [y22, y21])), x11 >= x22 || x12 <= x21 || y11 >= y22 || y12 <= y21 ? {
    x1: 0,
    y1: 0,
    x2: 0,
    y2: 0
  } : {
    x1: Math.max(x11, x21),
    y1: Math.max(y11, y21),
    x2: Math.min(x12, x22),
    y2: Math.min(y12, y22)
  });
}
var InnerBBox;
!function(InnerBBox2) {
  InnerBBox2[InnerBBox2.NONE = 0] = "NONE", InnerBBox2[InnerBBox2.BBOX1 = 1] = "BBOX1", InnerBBox2[InnerBBox2.BBOX2 = 2] = "BBOX2";
}(InnerBBox || (InnerBBox = {}));
function isRectIntersect(bbox1, bbox2, format) {
  return !bbox1 || !bbox2 || (format ? (x11 = bbox1.x1, x12 = bbox1.x2, y11 = bbox1.y1, y12 = bbox1.y2, x21 = bbox2.x1, x22 = bbox2.x2, y21 = bbox2.y1, y22 = bbox2.y2, x11 > x12 && ([x11, x12] = [x12, x11]), y11 > y12 && ([y11, y12] = [y12, y11]), x21 > x22 && ([x21, x22] = [x22, x21]), y21 > y22 && ([y21, y22] = [y22, y21]), !(x11 > x22 || x12 < x21 || y11 > y22 || y12 < y21)) : !(bbox1.x1 > bbox2.x2 || bbox1.x2 < bbox2.x1 || bbox1.y1 > bbox2.y2 || bbox1.y2 < bbox2.y1));
}
function pointInRect(point5, bbox, format) {
  return !bbox || (format ? (x11 = bbox.x1, x12 = bbox.x2, y11 = bbox.y1, y12 = bbox.y2, x11 > x12 && ([x11, x12] = [x12, x11]), y11 > y12 && ([y11, y12] = [y12, y11]), point5.x >= x11 && point5.x <= x12 && point5.y >= y11 && point5.y <= y12) : point5.x >= bbox.x1 && point5.x <= bbox.x2 && point5.y >= bbox.y1 && point5.y <= bbox.y2);
}
function getProjectionRadius(checkAxis, axis2) {
  return Math.abs(axis2[0] * checkAxis[0] + axis2[1] * checkAxis[1]);
}
function rotate({ x, y }, deg, origin = {
  x: 0,
  y: 0
}) {
  return {
    x: (x - origin.x) * Math.cos(deg) + (y - origin.y) * Math.sin(deg) + origin.x,
    y: (x - origin.x) * Math.sin(deg) + (origin.y - y) * Math.cos(deg) + origin.y
  };
}
function getCenterPoint(box) {
  return {
    x: (box.x1 + box.x2) / 2,
    y: (box.y1 + box.y2) / 2
  };
}
function toRect(box, isDeg) {
  const deg = isDeg ? box.angle : degreeToRadian(box.angle), cp = getCenterPoint(box);
  return [rotate({
    x: box.x1,
    y: box.y1
  }, deg, cp), rotate({
    x: box.x2,
    y: box.y1
  }, deg, cp), rotate({
    x: box.x2,
    y: box.y2
  }, deg, cp), rotate({
    x: box.x1,
    y: box.y2
  }, deg, cp)];
}
function isRotateAABBIntersect(box1, box2, isDeg = false, ctx) {
  const rect1 = toRect(box1, isDeg), rect2 = toRect(box2, isDeg), vector = (start, end) => [end.x - start.x, end.y - start.y];
  ctx && (ctx.save(), ctx.fillStyle = "red", ctx.globalAlpha = 0.6, rect1.forEach((item, index) => {
    0 === index ? ctx.moveTo(item.x, item.y) : ctx.lineTo(item.x, item.y);
  }), ctx.fill(), ctx.restore(), ctx.save(), ctx.fillStyle = "green", ctx.globalAlpha = 0.6, rect2.forEach((item, index) => {
    0 === index ? ctx.moveTo(item.x, item.y) : ctx.lineTo(item.x, item.y);
  }), ctx.fill(), ctx.restore());
  const p1 = getCenterPoint(box1), p2 = getCenterPoint(box2);
  ctx && ctx.fillRect(p1.x, p1.y, 2, 2), ctx && ctx.fillRect(p2.x, p2.y, 2, 2);
  const vp1p2 = vector(p1, p2), AB = vector(rect1[0], rect1[1]), BC = vector(rect1[1], rect1[2]), A1B1 = vector(rect2[0], rect2[1]), B1C1 = vector(rect2[1], rect2[2]), deg11 = isDeg ? box1.angle : degreeToRadian(box1.angle);
  let deg12 = isDeg ? box1.angle + halfPi : degreeToRadian(90 - box1.angle);
  const deg21 = isDeg ? box2.angle : degreeToRadian(box2.angle);
  let deg22 = isDeg ? box2.angle + halfPi : degreeToRadian(90 - box2.angle);
  deg12 > pi2 && (deg12 -= pi2), deg22 > pi2 && (deg22 -= pi2);
  const isCover = (checkAxisRadius, deg, targetAxis1, targetAxis2) => {
    const checkAxis = [Math.cos(deg), Math.sin(deg)];
    return checkAxisRadius + (getProjectionRadius(checkAxis, targetAxis1) + getProjectionRadius(checkAxis, targetAxis2)) / 2 > getProjectionRadius(checkAxis, vp1p2);
  };
  return isCover((box1.x2 - box1.x1) / 2, deg11, A1B1, B1C1) && isCover((box1.y2 - box1.y1) / 2, deg12, A1B1, B1C1) && isCover((box2.x2 - box2.x1) / 2, deg21, AB, BC) && isCover((box2.y2 - box2.y1) / 2, deg22, AB, BC);
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/graphics/algorithm/aabb
var x1;
var y1;
var x2;
var y2;
function getAABBFromPoints(points) {
  return x1 = 1 / 0, y1 = 1 / 0, x2 = -1 / 0, y2 = -1 / 0, points.forEach((point5) => {
    x1 > point5.x && (x1 = point5.x), x2 < point5.x && (x2 = point5.x), y1 > point5.y && (y1 = point5.y), y2 < point5.y && (y2 = point5.y);
  }), {
    x1,
    y1,
    x2,
    y2
  };
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/graphics/polygon
var EPSILON = 1e-8;
function lineIntersectPolygon(a1x, a1y, a2x, a2y, points) {
  for (let i = 0, p2 = points[points.length - 1]; i < points.length; i++) {
    const p = points[i];
    if (isIntersect([a1x, a1y], [a2x, a2y], [p.x, p.y], [p2.x, p2.y]))
      return true;
    p2 = p;
  }
  return false;
}
function polygonContainPoint(points, x, y) {
  let w = 0, p = points[0];
  if (!p)
    return false;
  for (let i = 1; i < points.length; i++) {
    const p2 = points[i];
    w += isPointInLine(p.x, p.y, p2.x, p2.y, x, y), p = p2;
  }
  const p0 = points[0];
  return isAroundEqual(p.x, p0.x) && isAroundEqual(p.y, p0.y) || (w += isPointInLine(p.x, p.y, p0.x, p0.y, x, y)), 0 !== w;
}
function isPointInLine(x05, y05, x14, y14, x, y) {
  if (y > y05 && y > y14 || y < y05 && y < y14)
    return 0;
  if (y14 === y05)
    return 0;
  const t = (y - y05) / (y14 - y05);
  let dir = y14 < y05 ? 1 : -1;
  1 !== t && 0 !== t || (dir = y14 < y05 ? 0.5 : -0.5);
  const x_ = t * (x14 - x05) + x05;
  return x_ === x ? 1 / 0 : x_ > x ? dir : 0;
}
function isAroundEqual(a3, b) {
  return Math.abs(a3 - b) < EPSILON;
}
function polygonIntersectPolygon(pointsA, pointsB) {
  for (let i = 0; i < pointsB.length; i++) {
    if (polygonContainPoint(pointsA, pointsB[i].x, pointsB[i].y))
      return true;
    if (i > 0 && lineIntersectPolygon(pointsB[i - 1].x, pointsB[i - 1].y, pointsB[i].x, pointsB[i].y, pointsA))
      return true;
  }
  return false;
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/graphics/text/stringWidth
var eastAsianCharacterInfo = (character) => {
  let x = character.charCodeAt(0), y = 2 === character.length ? character.charCodeAt(1) : 0, codePoint = x;
  return 55296 <= x && x <= 56319 && 56320 <= y && y <= 57343 && (x &= 1023, y &= 1023, codePoint = x << 10 | y, codePoint += 65536), 12288 === codePoint || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 ? "F" : 8361 === codePoint || 65377 <= codePoint && codePoint <= 65470 || 65474 <= codePoint && codePoint <= 65479 || 65482 <= codePoint && codePoint <= 65487 || 65490 <= codePoint && codePoint <= 65495 || 65498 <= codePoint && codePoint <= 65500 || 65512 <= codePoint && codePoint <= 65518 ? "H" : 4352 <= codePoint && codePoint <= 4447 || 4515 <= codePoint && codePoint <= 4519 || 4602 <= codePoint && codePoint <= 4607 || 9001 <= codePoint && codePoint <= 9002 || 11904 <= codePoint && codePoint <= 11929 || 11931 <= codePoint && codePoint <= 12019 || 12032 <= codePoint && codePoint <= 12245 || 12272 <= codePoint && codePoint <= 12283 || 12289 <= codePoint && codePoint <= 12350 || 12353 <= codePoint && codePoint <= 12438 || 12441 <= codePoint && codePoint <= 12543 || 12549 <= codePoint && codePoint <= 12589 || 12593 <= codePoint && codePoint <= 12686 || 12688 <= codePoint && codePoint <= 12730 || 12736 <= codePoint && codePoint <= 12771 || 12784 <= codePoint && codePoint <= 12830 || 12832 <= codePoint && codePoint <= 12871 || 12880 <= codePoint && codePoint <= 13054 || 13056 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42124 || 42128 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 55216 <= codePoint && codePoint <= 55238 || 55243 <= codePoint && codePoint <= 55291 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65106 || 65108 <= codePoint && codePoint <= 65126 || 65128 <= codePoint && codePoint <= 65131 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127490 || 127504 <= codePoint && codePoint <= 127546 || 127552 <= codePoint && codePoint <= 127560 || 127568 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 194367 || 177984 <= codePoint && codePoint <= 196605 || 196608 <= codePoint && codePoint <= 262141 ? "W" : 32 <= codePoint && codePoint <= 126 || 162 <= codePoint && codePoint <= 163 || 165 <= codePoint && codePoint <= 166 || 172 === codePoint || 175 === codePoint || 10214 <= codePoint && codePoint <= 10221 || 10629 <= codePoint && codePoint <= 10630 ? "Na" : 161 === codePoint || 164 === codePoint || 167 <= codePoint && codePoint <= 168 || 170 === codePoint || 173 <= codePoint && codePoint <= 174 || 176 <= codePoint && codePoint <= 180 || 182 <= codePoint && codePoint <= 186 || 188 <= codePoint && codePoint <= 191 || 198 === codePoint || 208 === codePoint || 215 <= codePoint && codePoint <= 216 || 222 <= codePoint && codePoint <= 225 || 230 === codePoint || 232 <= codePoint && codePoint <= 234 || 236 <= codePoint && codePoint <= 237 || 240 === codePoint || 242 <= codePoint && codePoint <= 243 || 247 <= codePoint && codePoint <= 250 || 252 === codePoint || 254 === codePoint || 257 === codePoint || 273 === codePoint || 275 === codePoint || 283 === codePoint || 294 <= codePoint && codePoint <= 295 || 299 === codePoint || 305 <= codePoint && codePoint <= 307 || 312 === codePoint || 319 <= codePoint && codePoint <= 322 || 324 === codePoint || 328 <= codePoint && codePoint <= 331 || 333 === codePoint || 338 <= codePoint && codePoint <= 339 || 358 <= codePoint && codePoint <= 359 || 363 === codePoint || 462 === codePoint || 464 === codePoint || 466 === codePoint || 468 === codePoint || 470 === codePoint || 472 === codePoint || 474 === codePoint || 476 === codePoint || 593 === codePoint || 609 === codePoint || 708 === codePoint || 711 === codePoint || 713 <= codePoint && codePoint <= 715 || 717 === codePoint || 720 === codePoint || 728 <= codePoint && codePoint <= 731 || 733 === codePoint || 735 === codePoint || 768 <= codePoint && codePoint <= 879 || 913 <= codePoint && codePoint <= 929 || 931 <= codePoint && codePoint <= 937 || 945 <= codePoint && codePoint <= 961 || 963 <= codePoint && codePoint <= 969 || 1025 === codePoint || 1040 <= codePoint && codePoint <= 1103 || 1105 === codePoint || 8208 === codePoint || 8211 <= codePoint && codePoint <= 8214 || 8216 <= codePoint && codePoint <= 8217 || 8220 <= codePoint && codePoint <= 8221 || 8224 <= codePoint && codePoint <= 8226 || 8228 <= codePoint && codePoint <= 8231 || 8240 === codePoint || 8242 <= codePoint && codePoint <= 8243 || 8245 === codePoint || 8251 === codePoint || 8254 === codePoint || 8308 === codePoint || 8319 === codePoint || 8321 <= codePoint && codePoint <= 8324 || 8364 === codePoint || 8451 === codePoint || 8453 === codePoint || 8457 === codePoint || 8467 === codePoint || 8470 === codePoint || 8481 <= codePoint && codePoint <= 8482 || 8486 === codePoint || 8491 === codePoint || 8531 <= codePoint && codePoint <= 8532 || 8539 <= codePoint && codePoint <= 8542 || 8544 <= codePoint && codePoint <= 8555 || 8560 <= codePoint && codePoint <= 8569 || 8585 === codePoint || 8592 <= codePoint && codePoint <= 8601 || 8632 <= codePoint && codePoint <= 8633 || 8658 === codePoint || 8660 === codePoint || 8679 === codePoint || 8704 === codePoint || 8706 <= codePoint && codePoint <= 8707 || 8711 <= codePoint && codePoint <= 8712 || 8715 === codePoint || 8719 === codePoint || 8721 === codePoint || 8725 === codePoint || 8730 === codePoint || 8733 <= codePoint && codePoint <= 8736 || 8739 === codePoint || 8741 === codePoint || 8743 <= codePoint && codePoint <= 8748 || 8750 === codePoint || 8756 <= codePoint && codePoint <= 8759 || 8764 <= codePoint && codePoint <= 8765 || 8776 === codePoint || 8780 === codePoint || 8786 === codePoint || 8800 <= codePoint && codePoint <= 8801 || 8804 <= codePoint && codePoint <= 8807 || 8810 <= codePoint && codePoint <= 8811 || 8814 <= codePoint && codePoint <= 8815 || 8834 <= codePoint && codePoint <= 8835 || 8838 <= codePoint && codePoint <= 8839 || 8853 === codePoint || 8857 === codePoint || 8869 === codePoint || 8895 === codePoint || 8978 === codePoint || 9312 <= codePoint && codePoint <= 9449 || 9451 <= codePoint && codePoint <= 9547 || 9552 <= codePoint && codePoint <= 9587 || 9600 <= codePoint && codePoint <= 9615 || 9618 <= codePoint && codePoint <= 9621 || 9632 <= codePoint && codePoint <= 9633 || 9635 <= codePoint && codePoint <= 9641 || 9650 <= codePoint && codePoint <= 9651 || 9654 <= codePoint && codePoint <= 9655 || 9660 <= codePoint && codePoint <= 9661 || 9664 <= codePoint && codePoint <= 9665 || 9670 <= codePoint && codePoint <= 9672 || 9675 === codePoint || 9678 <= codePoint && codePoint <= 9681 || 9698 <= codePoint && codePoint <= 9701 || 9711 === codePoint || 9733 <= codePoint && codePoint <= 9734 || 9737 === codePoint || 9742 <= codePoint && codePoint <= 9743 || 9748 <= codePoint && codePoint <= 9749 || 9756 === codePoint || 9758 === codePoint || 9792 === codePoint || 9794 === codePoint || 9824 <= codePoint && codePoint <= 9825 || 9827 <= codePoint && codePoint <= 9829 || 9831 <= codePoint && codePoint <= 9834 || 9836 <= codePoint && codePoint <= 9837 || 9839 === codePoint || 9886 <= codePoint && codePoint <= 9887 || 9918 <= codePoint && codePoint <= 9919 || 9924 <= codePoint && codePoint <= 9933 || 9935 <= codePoint && codePoint <= 9953 || 9955 === codePoint || 9960 <= codePoint && codePoint <= 9983 || 10045 === codePoint || 10071 === codePoint || 10102 <= codePoint && codePoint <= 10111 || 11093 <= codePoint && codePoint <= 11097 || 12872 <= codePoint && codePoint <= 12879 || 57344 <= codePoint && codePoint <= 63743 || 65024 <= codePoint && codePoint <= 65039 || 65533 === codePoint || 127232 <= codePoint && codePoint <= 127242 || 127248 <= codePoint && codePoint <= 127277 || 127280 <= codePoint && codePoint <= 127337 || 127344 <= codePoint && codePoint <= 127386 || 917760 <= codePoint && codePoint <= 917999 || 983040 <= codePoint && codePoint <= 1048573 || 1048576 <= codePoint && codePoint <= 1114109 ? "A" : "N";
};

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/graphics/text/measure/util
function getContextFont(text2, defaultAttr = {}) {
  const { fontStyle = defaultAttr.fontStyle, fontVariant = defaultAttr.fontVariant, fontWeight = defaultAttr.fontWeight, fontSize = defaultAttr.fontSize, fontFamily = defaultAttr.fontFamily } = text2;
  return (fontStyle ? fontStyle + " " : "") + (fontVariant ? fontVariant + " " : "") + (fontWeight ? fontWeight + " " : "") + fontSize + "px " + (fontFamily || "sans-serif");
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/graphics/text/measure/textMeasure
var TextMeasure = class _TextMeasure {
  constructor(option, textSpec) {
    this._numberCharSize = null, this._fullCharSize = null, this._letterCharSize = null, this._specialCharSizeMap = {}, this._canvas = null, this._context = null, this._contextSaved = false, this._notSupportCanvas = false, this._notSupportVRender = false, this._userSpec = {}, this.specialCharSet = `-/: .,@%'"~`, this._option = option, this._userSpec = null != textSpec ? textSpec : {}, this.textSpec = this._initSpec(), isValid_default(option.specialCharSet) && (this.specialCharSet = option.specialCharSet), this._standardMethod = isValid_default(option.getTextBounds) ? this.fullMeasure.bind(this) : this.measureWithNaiveCanvas.bind(this);
  }
  initContext() {
    if (this._notSupportCanvas)
      return false;
    if (isNil_default(this._canvas) && (isValid_default(this._option.getCanvasForMeasure) && (this._canvas = this._option.getCanvasForMeasure()), isNil_default(this._canvas) && "undefined" != typeof window && void 0 !== window.document && globalThis && isValid_default(globalThis.document) && (this._canvas = globalThis.document.createElement("canvas"))), isNil_default(this._context) && isValid_default(this._canvas)) {
      const context = this._canvas.getContext("2d");
      isValid_default(context) && (context.save(), context.font = getContextFont(this.textSpec), this._contextSaved = true, this._context = context);
    }
    return !isNil_default(this._context) || (this._notSupportCanvas = true, false);
  }
  _initSpec() {
    var _a, _b, _c;
    const { defaultFontParams = {} } = this._option, { fontStyle = defaultFontParams.fontStyle, fontVariant = defaultFontParams.fontVariant, fontWeight = null !== (_a = defaultFontParams.fontWeight) && void 0 !== _a ? _a : "normal", fontSize = null !== (_b = defaultFontParams.fontSize) && void 0 !== _b ? _b : 12, fontFamily = null !== (_c = defaultFontParams.fontFamily) && void 0 !== _c ? _c : "sans-serif", align, textAlign = null != align ? align : "center", baseline, textBaseline = null != baseline ? baseline : "middle", ellipsis, limit } = this._userSpec;
    let { lineHeight = fontSize } = this._userSpec;
    if (isString_default(lineHeight) && "%" === lineHeight[lineHeight.length - 1]) {
      const scale4 = Number.parseFloat(lineHeight.substring(0, lineHeight.length - 1)) / 100;
      lineHeight = fontSize * scale4;
    }
    return {
      fontStyle,
      fontVariant,
      fontFamily,
      fontSize,
      fontWeight,
      textAlign,
      textBaseline,
      ellipsis,
      limit,
      lineHeight
    };
  }
  measure(text2, method) {
    switch (method) {
      case "vrender":
      case "canopus":
        return this.fullMeasure(text2);
      case "canvas":
        return this.measureWithNaiveCanvas(text2);
      case "simple":
        return this.quickMeasureWithoutCanvas(text2);
      default:
        return this.quickMeasure(text2);
    }
  }
  fullMeasure(text2) {
    if (isNil_default(text2))
      return {
        width: 0,
        height: 0
      };
    if (isNil_default(this._option.getTextBounds) || !this._notSupportVRender)
      return this.measureWithNaiveCanvas(text2);
    const { fontFamily, fontSize, fontWeight, textAlign, textBaseline, ellipsis, limit, lineHeight } = this.textSpec;
    let size;
    try {
      const bounds = this._option.getTextBounds({
        text: text2,
        fontFamily,
        fontSize,
        fontWeight,
        textAlign,
        textBaseline,
        ellipsis: !!ellipsis,
        maxLineWidth: limit || 1 / 0,
        lineHeight
      });
      size = {
        width: bounds.width(),
        height: bounds.height()
      };
    } catch (e) {
      this._notSupportVRender = true, size = this.measureWithNaiveCanvas(text2);
    }
    return size;
  }
  measureWithNaiveCanvas(text2) {
    return this._measureReduce(text2, this._measureWithNaiveCanvas.bind(this));
  }
  _measureWithNaiveCanvas(text2) {
    var _a;
    if (!this.initContext())
      return this._quickMeasureWithoutCanvas(text2);
    const metrics = this._context.measureText(text2), { fontSize, lineHeight } = this.textSpec;
    return {
      width: metrics.width,
      height: null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize
    };
  }
  quickMeasure(text2) {
    return this._measureReduce(text2, this._quickMeasure.bind(this));
  }
  _quickMeasure(text2) {
    const totalSize = {
      width: 0,
      height: 0
    };
    for (let i = 0; i < text2.length; i++) {
      const char = text2[i];
      let size = this._measureSpecialChar(char);
      isNil_default(size) && _TextMeasure.NUMBERS_CHAR_SET.includes(char) && (size = this._measureNumberChar()), isNil_default(size) && ["F", "W"].includes(eastAsianCharacterInfo(char)) && (size = this._measureFullSizeChar()), isNil_default(size) && (size = this._measureLetterChar()), totalSize.width += size.width, totalSize.height = Math.max(totalSize.height, size.height);
    }
    return totalSize;
  }
  quickMeasureWithoutCanvas(text2) {
    return this._measureReduce(text2, this._quickMeasureWithoutCanvas.bind(this));
  }
  _quickMeasureWithoutCanvas(text2) {
    var _a;
    const totalSize = {
      width: 0,
      height: 0
    }, { fontSize, lineHeight } = this.textSpec;
    for (let i = 0; i < text2.length; i++) {
      const char = text2[i], size = ["F", "W"].includes(eastAsianCharacterInfo(char)) ? 1 : 0.53;
      totalSize.width += size * fontSize;
    }
    return totalSize.height = null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize, totalSize;
  }
  _measureReduce(text2, processor) {
    var _a;
    const { fontSize, lineHeight } = this.textSpec, defaultResult = {
      width: 0,
      height: 0
    };
    if (isNil_default(text2))
      return defaultResult;
    if (isArray_default(text2)) {
      const textArr = text2.filter(isValid_default).map((s2) => s2.toString());
      return 0 === textArr.length ? defaultResult : 1 === textArr.length ? processor(textArr[0]) : {
        width: textArr.reduce((maxWidth, cur) => Math.max(maxWidth, processor(cur).width), 0),
        height: textArr.length * ((null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize) + 1) + 1
      };
    }
    return processor(text2.toString());
  }
  _measureNumberChar() {
    if (isNil_default(this._numberCharSize)) {
      const numberBounds = this._standardMethod(_TextMeasure.NUMBERS_CHAR_SET);
      this._numberCharSize = {
        width: numberBounds.width / _TextMeasure.NUMBERS_CHAR_SET.length,
        height: numberBounds.height
      };
    }
    return this._numberCharSize;
  }
  _measureFullSizeChar() {
    return isNil_default(this._fullCharSize) && (this._fullCharSize = this._standardMethod(_TextMeasure.FULL_SIZE_CHAR)), this._fullCharSize;
  }
  _measureLetterChar() {
    if (isNil_default(this._letterCharSize)) {
      const alphabetBounds = this._standardMethod(_TextMeasure.ALPHABET_CHAR_SET);
      this._letterCharSize = {
        width: alphabetBounds.width / _TextMeasure.ALPHABET_CHAR_SET.length,
        height: alphabetBounds.height
      };
    }
    return this._letterCharSize;
  }
  _measureSpecialChar(char) {
    return isValid_default(this._specialCharSizeMap[char]) ? this._specialCharSizeMap[char] : this.specialCharSet.includes(char) ? (this._specialCharSizeMap[char] = this._standardMethod(char), this._specialCharSizeMap[char]) : null;
  }
  release() {
    isValid_default(this._canvas) && (this._canvas = null), isValid_default(this._context) && (this._contextSaved && (this._context.restore(), this._contextSaved = false), this._context = null);
  }
};
TextMeasure.ALPHABET_CHAR_SET = "abcdefghijklmnopqrstuvwxyz", TextMeasure.NUMBERS_CHAR_SET = "0123456789", TextMeasure.FULL_SIZE_CHAR = "\u5B57";

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/graphics/bounds-util
var calculateAnchorOfBounds = (bounds, anchorType) => {
  const { x1: x14, x2: x23, y1: y14, y2: y23 } = bounds, rectWidth = Math.abs(x23 - x14), rectHeight = Math.abs(y23 - y14);
  let anchorX = (x14 + x23) / 2, anchorY = (y14 + y23) / 2, sx = 0, sy = 0;
  switch (anchorType) {
    case "top":
    case "inside-top":
      sy = -0.5;
      break;
    case "bottom":
    case "inside-bottom":
      sy = 0.5;
      break;
    case "left":
    case "inside-left":
      sx = -0.5;
      break;
    case "right":
    case "inside-right":
      sx = 0.5;
      break;
    case "top-right":
      sx = 0.5, sy = -0.5;
      break;
    case "top-left":
      sx = -0.5, sy = -0.5;
      break;
    case "bottom-right":
      sx = 0.5, sy = 0.5;
      break;
    case "bottom-left":
      sx = -0.5, sy = 0.5;
  }
  return anchorX += sx * rectWidth, anchorY += sy * rectHeight, {
    x: anchorX,
    y: anchorY
  };
};

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/padding
function normalizePadding(padding) {
  if (isValidNumber_default(padding))
    return [padding, padding, padding, padding];
  if (isArray_default(padding)) {
    const length2 = padding.length;
    if (1 === length2) {
      const paddingValue = padding[0];
      return [paddingValue, paddingValue, paddingValue, paddingValue];
    }
    if (2 === length2) {
      const [vertical, horizontal] = padding;
      return [vertical, horizontal, vertical, horizontal];
    }
    if (3 === length2) {
      const [top, horizontal, bottom] = padding;
      return [top, horizontal, bottom, horizontal];
    }
    if (4 === length2)
      return padding;
  }
  if (isObject_default(padding)) {
    const { top = 0, right: right2 = 0, bottom = 0, left: left2 = 0 } = padding;
    return [top, right2, bottom, left2];
  }
  return [0, 0, 0, 0];
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/dom
function getContainerSize(el, defaultWidth = 0, defaultHeight = 0) {
  if (!el)
    return {
      width: defaultWidth,
      height: defaultHeight
    };
  let getComputedStyle;
  try {
    getComputedStyle = null === window || void 0 === window ? void 0 : window.getComputedStyle;
  } catch (e) {
    getComputedStyle = () => ({});
  }
  const style = getComputedStyle(el);
  if (/^(\d*\.?\d+)(px)$/.exec(style.width)) {
    const computedWidth = parseFloat(style.width) - parseFloat(style.paddingLeft) - parseFloat(style.paddingRight) || el.clientWidth - 1, computedHeight = parseFloat(style.height) - parseFloat(style.paddingTop) - parseFloat(style.paddingBottom) || el.clientHeight - 1;
    return {
      width: computedWidth <= 0 ? defaultWidth : computedWidth,
      height: computedHeight <= 0 ? defaultHeight : computedHeight
    };
  }
  return {
    width: defaultWidth,
    height: defaultHeight
  };
}
function getElementAbsolutePosition(element) {
  const { x, y } = element.getBoundingClientRect();
  return {
    x,
    y
  };
}
function hasParentElement(element, target) {
  let parent = element.parentNode;
  for (; null !== parent; ) {
    if (parent === target)
      return true;
    parent = parent.parentNode;
  }
  return false;
}
var styleStringToObject = (styleStr = "") => {
  const res = {};
  return styleStr.split(";").forEach((item) => {
    if (item) {
      const arr = item.split(":");
      if (2 === arr.length) {
        const key = arr[0].trim(), value = arr[1].trim();
        key && value && (res[key] = value);
      }
    }
  }), res;
};
var lowerCamelCaseToMiddle = (str) => str.replace(/([A-Z])/g, "-$1").toLowerCase();
function isHTMLElement(obj) {
  try {
    return obj instanceof Element;
  } catch (_a) {
    const htmlElementKeys = ["children", "innerHTML", "classList", "setAttribute", "tagName", "getBoundingClientRect"], keys2 = Object.keys(obj);
    return htmlElementKeys.every((key) => keys2.includes(key));
  }
}

// http-url:https://unpkg.com/@turf/helpers@6.5.0/dist/es/index.js
var earthRadius = 63710088e-1;
var factors = {
  centimeters: earthRadius * 100,
  centimetres: earthRadius * 100,
  degrees: earthRadius / 111325,
  feet: earthRadius * 3.28084,
  inches: earthRadius * 39.37,
  kilometers: earthRadius / 1e3,
  kilometres: earthRadius / 1e3,
  meters: earthRadius,
  metres: earthRadius,
  miles: earthRadius / 1609.344,
  millimeters: earthRadius * 1e3,
  millimetres: earthRadius * 1e3,
  nauticalmiles: earthRadius / 1852,
  radians: 1,
  yards: earthRadius * 1.0936
};
var unitsFactors = {
  centimeters: 100,
  centimetres: 100,
  degrees: 1 / 111325,
  feet: 3.28084,
  inches: 39.37,
  kilometers: 1 / 1e3,
  kilometres: 1 / 1e3,
  meters: 1,
  metres: 1,
  miles: 1 / 1609.344,
  millimeters: 1e3,
  millimetres: 1e3,
  nauticalmiles: 1 / 1852,
  radians: 1 / earthRadius,
  yards: 1.0936133
};
function lengthToRadians(distance2, units) {
  if (units === void 0) {
    units = "kilometers";
  }
  var factor = factors[units];
  if (!factor) {
    throw new Error(units + " units is invalid");
  }
  return distance2 / factor;
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/geo/invariant
function getGeom(geojson) {
  return "Feature" === geojson.type ? geojson.geometry : geojson;
}
function isPointInPolygon(point5, polygon) {
  if (!point5)
    return false;
  if (!polygon)
    return false;
  const geom = getGeom(polygon), type = geom.type, bbox = polygon.bbox;
  let polys = geom.coordinates;
  if (bbox && true === pointInRect(point5, {
    x1: bbox[0],
    x2: bbox[1],
    y1: bbox[1],
    y2: bbox[3]
  }, true))
    return false;
  "Polygon" === type && (polys = [polys]);
  let result2 = false;
  for (let i = 0; i < polys.length; ++i)
    for (let j = 0; j < polys[i].length; ++j) {
      if (polygonContainPoint(polys[i][j].map((p) => ({
        x: p[0],
        y: p[1]
      })), point5.x, point5.y))
        return result2 = true, result2;
    }
  return result2;
}
function destination(point5, distance2, bearing, options = {}) {
  const longitude1 = degreeToRadian(point5[0]), latitude1 = degreeToRadian(point5[1]), bearingRad = degreeToRadian(bearing), radians2 = lengthToRadians(distance2, options.units), latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians2) + Math.cos(latitude1) * Math.sin(radians2) * Math.cos(bearingRad)), longitude2 = longitude1 + Math.atan2(Math.sin(bearingRad) * Math.sin(radians2) * Math.cos(latitude1), Math.cos(radians2) - Math.sin(latitude1) * Math.sin(latitude2));
  return {
    x: radianToDegree(longitude2),
    y: radianToDegree(latitude2)
  };
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/format/time
var TimeUtil = class _TimeUtil {
  static getInstance() {
    return _TimeUtil.instance || (_TimeUtil.instance = new _TimeUtil()), _TimeUtil.instance;
  }
  constructor() {
    this.locale_shortWeekdays = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], this.locale_periods = ["AM", "PM"], this.locale_weekdays = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], this.locale_shortMonths = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], this.numberRe = /^\s*\d+/, this.pads = {
      "-": "",
      _: " ",
      0: "0"
    }, this.requoteRe = /[\\^$*+?|[\]().{}]/g, this.locale_months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], this.formatShortWeekday = (d) => this.locale_shortWeekdays[d.getDay()], this.formatWeekday = (d) => this.locale_weekdays[d.getDay()], this.formatShortMonth = (d) => this.locale_shortMonths[d.getMonth()], this.formatMonth = (d) => this.locale_months[d.getMonth()], this.formatDayOfMonth = (d, p) => this.pad(d.getDate(), p, 2), this.formatHour24 = (d, p) => this.pad(d.getHours(), p, 2), this.formatHour12 = (d, p) => this.pad(d.getHours() % 12 || 12, p, 2), this.formatMilliseconds = (d, p) => this.pad(d.getMilliseconds(), p, 3), this.formatMonthNumber = (d, p) => this.pad(d.getMonth() + 1, p, 2), this.formatMinutes = (d, p) => this.pad(d.getMinutes(), p, 2), this.formatPeriod = (d) => this.locale_periods[+(d.getHours() >= 12)], this.formatSeconds = (d, p) => this.pad(d.getSeconds(), p, 2), this.formatFullYear = (d, p) => this.pad(d.getFullYear() % 1e4, p, 4), this.formatUTCShortWeekday = (d) => this.locale_shortWeekdays[d.getUTCDay()], this.formatUTCWeekday = (d) => this.locale_weekdays[d.getUTCDay()], this.formatUTCShortMonth = (d) => this.locale_shortMonths[d.getUTCMonth()], this.formatUTCMonth = (d) => this.locale_months[d.getUTCMonth()], this.formatUTCDayOfMonth = (d, p) => this.pad(d.getUTCDate(), p, 2), this.formatUTCHour24 = (d, p) => this.pad(d.getUTCHours(), p, 2), this.formatUTCHour12 = (d, p) => this.pad(d.getUTCHours() % 12 || 12, p, 2), this.formatUTCMilliseconds = (d, p) => this.pad(d.getUTCMilliseconds(), p, 3), this.formatUTCMonthNumber = (d, p) => this.pad(d.getUTCMonth() + 1, p, 2), this.formatUTCMinutes = (d, p) => this.pad(d.getUTCMinutes(), p, 2), this.formatUTCPeriod = (d) => this.locale_periods[+(d.getUTCHours() >= 12)], this.formatUTCSeconds = (d, p) => this.pad(d.getUTCSeconds(), p, 2), this.formatUTCFullYear = (d, p) => this.pad(d.getUTCFullYear() % 1e4, p, 4), this.formats = {
      a: this.formatShortWeekday,
      A: this.formatWeekday,
      b: this.formatShortMonth,
      B: this.formatMonth,
      d: this.formatDayOfMonth,
      e: this.formatDayOfMonth,
      H: this.formatHour24,
      I: this.formatHour12,
      L: this.formatMilliseconds,
      m: this.formatMonthNumber,
      M: this.formatMinutes,
      p: this.formatPeriod,
      S: this.formatSeconds,
      Y: this.formatFullYear
    }, this.utcFormats = {
      a: this.formatUTCShortWeekday,
      A: this.formatUTCWeekday,
      b: this.formatUTCShortMonth,
      B: this.formatUTCMonth,
      d: this.formatUTCDayOfMonth,
      e: this.formatUTCDayOfMonth,
      H: this.formatUTCHour24,
      I: this.formatUTCHour12,
      L: this.formatUTCMilliseconds,
      m: this.formatUTCMonthNumber,
      M: this.formatUTCMinutes,
      p: this.formatUTCPeriod,
      S: this.formatUTCSeconds,
      Y: this.formatUTCFullYear
    }, this.parseShortWeekday = (d, string, i) => {
      const n = this.shortWeekdayRe.exec(string.slice(i));
      return n ? (d.w = this.shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }, this.parseWeekday = (d, string, i) => {
      const n = this.weekdayRe.exec(string.slice(i));
      return n ? (d.w = this.weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }, this.parseShortMonth = (d, string, i) => {
      const n = this.shortMonthRe.exec(string.slice(i));
      return n ? (d.m = this.shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }, this.parseMonth = (d, string, i) => {
      const n = this.monthRe.exec(string.slice(i));
      return n ? (d.m = this.monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }, this.parseDayOfMonth = (d, string, i) => {
      const n = this.numberRe.exec(string.slice(i, i + 2));
      return n ? (d.d = +n[0], i + n[0].length) : -1;
    }, this.parseHour24 = (d, string, i) => {
      const n = this.numberRe.exec(string.slice(i, i + 2));
      return n ? (d.H = +n[0], i + n[0].length) : -1;
    }, this.parseMilliseconds = (d, string, i) => {
      const n = this.numberRe.exec(string.slice(i, i + 3));
      return n ? (d.L = +n[0], i + n[0].length) : -1;
    }, this.parseMonthNumber = (d, string, i) => {
      const n = this.numberRe.exec(string.slice(i, i + 2));
      return n ? (d.m = n - 1, i + n[0].length) : -1;
    }, this.parseMinutes = (d, string, i) => {
      const n = this.numberRe.exec(string.slice(i, i + 2));
      return n ? (d.M = +n[0], i + n[0].length) : -1;
    }, this.parsePeriod = (d, string, i) => {
      const n = this.periodRe.exec(string.slice(i));
      return n ? (d.p = this.periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }, this.parseSeconds = (d, string, i) => {
      const n = this.numberRe.exec(string.slice(i, i + 2));
      return n ? (d.S = +n[0], i + n[0].length) : -1;
    }, this.parseFullYear = (d, string, i) => {
      const n = this.numberRe.exec(string.slice(i, i + 4));
      return n ? (d.y = +n[0], i + n[0].length) : -1;
    }, this.parses = {
      a: this.parseShortWeekday,
      A: this.parseWeekday,
      b: this.parseShortMonth,
      B: this.parseMonth,
      d: this.parseDayOfMonth,
      e: this.parseDayOfMonth,
      H: this.parseHour24,
      I: this.parseHour24,
      L: this.parseMilliseconds,
      m: this.parseMonthNumber,
      M: this.parseMinutes,
      p: this.parsePeriod,
      S: this.parseSeconds,
      Y: this.parseFullYear
    }, this.timeFormat = (specifier, timeText) => this.newFormat(specifier, this.formats)(new Date(this.getFullTimeStamp(timeText))), this.timeUTCFormat = (specifier, timeText) => this.newFormat(specifier, this.utcFormats)(new Date(this.getFullTimeStamp(timeText))), this.timeParse = (specifier, timeText) => this.newParse(specifier, false)(timeText + ""), this.requoteF = this.requote.bind(this), this.periodRe = this.formatRe(this.locale_periods), this.periodLookup = this.formatLookup(this.locale_periods), this.weekdayRe = this.formatRe(this.locale_weekdays), this.weekdayLookup = this.formatLookup(this.locale_weekdays), this.shortWeekdayRe = this.formatRe(this.locale_shortWeekdays), this.shortWeekdayLookup = this.formatLookup(this.locale_shortWeekdays), this.monthRe = this.formatRe(this.locale_months), this.monthLookup = this.formatLookup(this.locale_months), this.shortMonthRe = this.formatRe(this.locale_shortMonths), this.shortMonthLookup = this.formatLookup(this.locale_shortMonths);
  }
  requote(s2) {
    return s2.replace(this.requoteRe, "\\$&");
  }
  localDate(d) {
    if (0 <= d.y && d.y < 100) {
      const date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
      return date.setFullYear(d.y), date;
    }
    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
  }
  utcDate(d) {
    if (0 <= d.y && d.y < 100) {
      const date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
      return date.setUTCFullYear(d.y), date;
    }
    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
  }
  newDate(y, m4, d) {
    return {
      y,
      m: m4,
      d,
      H: 0,
      M: 0,
      S: 0,
      L: 0
    };
  }
  formatRe(names) {
    return new RegExp("^(?:" + names.map(this.requoteF).join("|") + ")", "i");
  }
  formatLookup(names) {
    return new Map(names.map((name, i) => [name.toLowerCase(), i]));
  }
  pad(value, fill, width) {
    const sign3 = value < 0 ? "-" : "", string = (sign3 ? -value : value) + "", length2 = string.length;
    return sign3 + (length2 < width ? new Array(width - length2 + 1).join(fill) + string : string);
  }
  parseSpecifier(d, specifier, string, j) {
    let i = 0;
    const n = specifier.length, m4 = string.length;
    let c3, parse2;
    for (; i < n; ) {
      if (j >= m4)
        return -1;
      if (c3 = specifier.charCodeAt(i++), 37 === c3) {
        if (c3 = specifier.charAt(i++), parse2 = this.parses[c3 in this.pads ? specifier.charAt(i++) : c3], !parse2 || (j = parse2(d, string, j)) < 0)
          return -1;
      } else if (c3 !== string.charCodeAt(j++))
        return -1;
    }
    return j;
  }
  newParse(specifier, Z) {
    const that = this;
    return function(string) {
      const d = that.newDate(1900, void 0, 1);
      return that.parseSpecifier(d, specifier, string += "", 0) !== string.length ? null : "Q" in d ? new Date(d.Q) : "s" in d ? new Date(1e3 * d.s + ("L" in d ? d.L : 0)) : (Z && !("Z" in d) && (d.Z = 0), "p" in d && (d.H = d.H % 12 + 12 * d.p), void 0 === d.m && (d.m = "q" in d ? d.q : 0), "Z" in d ? (d.H += d.Z / 100 | 0, d.M += d.Z % 100, that.utcDate(d)) : that.localDate(d));
    };
  }
  newFormat(specifier, formats) {
    const that = this;
    return function(date) {
      const string = [];
      let i = -1, j = 0;
      const n = specifier.length;
      let c3, pad2, format;
      for (date instanceof Date || (date = /* @__PURE__ */ new Date(+date)); ++i < n; )
        37 === specifier.charCodeAt(i) && (string.push(specifier.slice(j, i)), (pad2 = that.pads[c3 = specifier.charAt(++i)]) ? c3 = specifier.charAt(++i) : pad2 = "e" === c3 ? " " : "0", format = formats[c3], c3 = format(date, pad2), string.push(c3), j = i + 1);
      return string.push(specifier.slice(j, i)), string.join("");
    };
  }
  getFullTimeStamp(timeText) {
    const timeOriStamp = parseInt(timeText + "", 10);
    return 10 === String(timeOriStamp).length ? 1e3 * timeOriStamp : timeOriStamp;
  }
};

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/format/number/formatDecimal
function formatDecimal(x) {
  return Math.abs(x = Math.round(x)) >= 1e21 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
}
function formatDecimalParts(x, p) {
  const _x = p ? x.toExponential(p - 1) : x.toExponential(), i = _x.indexOf("e");
  if (i < 0)
    return null;
  const coefficient = _x.slice(0, i);
  return [coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient, +_x.slice(i + 1)];
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/format/number/formatGroup
function formatGroup(grouping, thousands) {
  return function(value, width) {
    let i = value.length;
    const t = [];
    let j = 0, g = grouping[0], length2 = 0;
    for (; i > 0 && g > 0 && (length2 + g + 1 > width && (g = Math.max(1, width - length2)), t.push(value.substring(i -= g, i + g)), !((length2 += g + 1) > width)); )
      g = grouping[j = (j + 1) % grouping.length];
    return t.reverse().join(thousands);
  };
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/format/number/formatPrefixAuto
var prefixExponent;
function formatPrefixAuto(x, p) {
  const d = formatDecimalParts(x, p);
  if (!d)
    return x + "";
  const coefficient = d[0], exponent2 = d[1], i = exponent2 - (prefixExponent = 3 * Math.max(-8, Math.min(8, Math.floor(exponent2 / 3)))) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0];
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/format/number/formatRounded
function formatRounded(x, p) {
  const d = formatDecimalParts(x, p);
  if (!d)
    return x + "";
  const coefficient = d[0], exponent2 = d[1];
  return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/format/number/formatTrim
function formatTrim(s2) {
  const n = s2.length;
  let i1, i0 = -1;
  out:
    for (let i = 1; i < n; ++i)
      switch (s2[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          0 === i0 && (i0 = i), i1 = i;
          break;
        default:
          if (!+s2[i])
            break out;
          i0 > 0 && (i0 = 0);
      }
  return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/format/number/specifier
var FormatSpecifier = class {
  constructor(specifier = {}) {
    this.fill = void 0 === specifier.fill ? " " : specifier.fill + "", this.align = void 0 === specifier.align ? ">" : specifier.align + "", this.sign = void 0 === specifier.sign ? "-" : specifier.sign + "", this.symbol = void 0 === specifier.symbol ? "" : specifier.symbol + "", this.zero = !!specifier.zero, this.width = void 0 === specifier.width ? void 0 : +specifier.width, this.comma = !!specifier.comma, this.precision = void 0 === specifier.precision ? void 0 : +specifier.precision, this.trim = !!specifier.trim, this.type = void 0 === specifier.type ? "" : specifier.type + "";
  }
  toString() {
    return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (void 0 === this.width ? "" : Math.max(1, 0 | this.width)) + (this.comma ? "," : "") + (void 0 === this.precision ? "" : "." + Math.max(0, 0 | this.precision)) + (this.trim ? "~" : "") + this.type;
  }
};
var numberSpecifierReg = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  let match;
  if (match = numberSpecifierReg.exec(specifier))
    return new FormatSpecifier({
      fill: match[1],
      align: match[2],
      sign: match[3],
      symbol: match[4],
      zero: match[5],
      width: match[6],
      comma: match[7],
      precision: match[8] && match[8].slice(1),
      trim: match[9],
      type: match[10]
    });
  Logger.getInstance().error("invalid format: " + specifier);
}

// http-url:https://unpkg.com/@visactor/vutils@0.18.9/es/format/number/number
var prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
var NumberUtil = class _NumberUtil {
  constructor() {
    this.locale = {
      thousands: ",",
      grouping: [3],
      currency: ["$", ""]
    }, this.group = void 0 === this.locale.grouping || void 0 === this.locale.thousands ? (group) => group : formatGroup([...this.locale.grouping].map(Number), `${this.locale.thousands}`), this.currencyPrefix = void 0 === this.locale.currency ? "" : this.locale.currency[0] + "", this.currencySuffix = void 0 === this.locale.currency ? "" : this.locale.currency[1] + "", this.decimal = void 0 === this.locale.decimal ? "." : this.locale.decimal + "", this.numerals = void 0 === this.locale.numerals ? (numerals) => numerals : formatNumerals([...this.locale.numerals].map(String)), this.percent = void 0 === this.locale.percent ? "%" : this.locale.percent + "", this.minus = void 0 === this.locale.minus ? "\u2212" : this.locale.minus + "", this.nan = void 0 === this.locale.nan ? "NaN" : this.locale.nan + "", this.formatter = (specifier) => this.newFormat(specifier), this.format = (specifier, value) => this.formatter(specifier)(value), this.formatPrefix = (specifier, value) => this._formatPrefix(specifier, value);
  }
  static getInstance() {
    return _NumberUtil.instance || (_NumberUtil.instance = new _NumberUtil()), _NumberUtil.instance;
  }
  newFormat(specifier) {
    const specifierIns = formatSpecifier(specifier);
    let fill = specifierIns.fill, align = specifierIns.align;
    const sign3 = specifierIns.sign, symbol = specifierIns.symbol;
    let zero3 = specifierIns.zero;
    const width = specifierIns.width;
    let comma = specifierIns.comma, precision = specifierIns.precision, trim = specifierIns.trim, type = specifierIns.type;
    "n" === type ? (comma = true, type = "g") : formatTypes[type] || (void 0 === precision && (precision = 12), trim = true, type = "g"), (zero3 || "0" === fill && "=" === align) && (zero3 = true, fill = "0", align = "=");
    const prefix = "$" === symbol ? this.currencyPrefix : "#" === symbol && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = "$" === symbol ? this.currencySuffix : /[%p]/.test(type) ? this.percent : "", formatType = formatTypes[type], maybeSuffix = /[defgprstz%]/.test(type);
    precision = void 0 === precision ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    const { nan, minus, decimal, group, numerals } = this;
    function format(value) {
      let i, n, c3, valuePrefix = prefix, valueSuffix = suffix, _value = value;
      if ("c" === type)
        valueSuffix = formatType(_value) + valueSuffix, _value = "";
      else {
        _value = +_value;
        let valueNegative = _value < 0 || 1 / _value < 0;
        if (_value = isNaN(_value) ? nan : formatType(Math.abs(_value), precision), trim && (_value = formatTrim(_value)), valueNegative && 0 == +_value && "+" !== sign3 && (valueNegative = false), valuePrefix = (valueNegative ? "(" === sign3 ? sign3 : minus : "-" === sign3 || "(" === sign3 ? "" : sign3) + valuePrefix, valueSuffix = ("s" === type ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && "(" === sign3 ? ")" : ""), maybeSuffix) {
          for (i = -1, n = _value.length; ++i < n; )
            if (c3 = _value.charCodeAt(i), 48 > c3 || c3 > 57) {
              valueSuffix = (46 === c3 ? decimal + _value.slice(i + 1) : _value.slice(i)) + valueSuffix, _value = _value.slice(0, i);
              break;
            }
        }
      }
      comma && !zero3 && (_value = group(_value, 1 / 0));
      let length2 = valuePrefix.length + _value.length + valueSuffix.length, padding = length2 < width ? new Array(width - length2 + 1).join(fill) : "";
      switch (comma && zero3 && (_value = group(padding + _value, padding.length ? width - valueSuffix.length : 1 / 0), padding = ""), align) {
        case "<":
          _value = valuePrefix + _value + valueSuffix + padding;
          break;
        case "=":
          _value = valuePrefix + padding + _value + valueSuffix;
          break;
        case "^":
          _value = padding.slice(0, length2 = padding.length >> 1) + valuePrefix + _value + valueSuffix + padding.slice(length2);
          break;
        default:
          _value = padding + valuePrefix + _value + valueSuffix;
      }
      return numerals(_value);
    }
    return format.toString = function() {
      return specifier + "";
    }, format;
  }
  _formatPrefix(specifier, value) {
    const _specifier = formatSpecifier(specifier);
    _specifier.type = "f";
    const f = this.newFormat(_specifier.toString()), e = 3 * Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))), k2 = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
    return function(value2) {
      return f(k2 * value2) + prefix;
    };
  }
};
var formatTypes = {
  "%": (x, p) => (100 * x).toFixed(p),
  b: (x) => Math.round(x).toString(2),
  c: (x) => x + "",
  d: formatDecimal,
  f: (x, p) => x.toFixed(p),
  e: (x, p) => x.toExponential(p),
  g: (x, p) => x.toPrecision(p),
  o: (x) => Math.round(x).toString(8),
  p: (x, p) => formatRounded(100 * x, p),
  r: formatRounded,
  s: formatPrefixAuto,
  X: (x) => Math.round(x).toString(16).toUpperCase(),
  x: (x) => Math.round(x).toString(16),
  t: (x, p) => Number.isInteger(x) ? x.toFixed(2) : Math.floor(x * Math.pow(10, p)) / Math.pow(10, p) + "",
  z: (x, p) => x % 1 == 0 ? x + "" : x.toFixed(p)
};
function exponent(x) {
  const _x = formatDecimalParts(Math.abs(x));
  return _x ? _x[1] : NaN;
}
function formatNumerals(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, (i) => numerals[+i]);
  };
}

// http-url:https://unpkg.com/@visactor/vdataset@0.18.9/es/transform/filter
var filter = (data, options) => {
  const { callback } = options;
  return callback && (data = data.filter(callback)), data;
};

// http-url:https://unpkg.com/d3-geo@1.12.1/src/adder.js
function adder_default() {
  return new Adder();
}
function Adder() {
  this.reset();
}
Adder.prototype = {
  constructor: Adder,
  reset: function() {
    this.s = // rounded value
    this.t = 0;
  },
  add: function(y) {
    add(temp, y, this.t);
    add(this, temp.s, this.s);
    if (this.s)
      this.t += temp.t;
    else
      this.s = temp.t;
  },
  valueOf: function() {
    return this.s;
  }
};
var temp = new Adder();
function add(adder, a3, b) {
  var x = adder.s = a3 + b, bv = x - a3, av = x - bv;
  adder.t = a3 - av + (b - bv);
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/math.js
var epsilon2 = 1e-6;
var epsilon22 = 1e-12;
var pi3 = Math.PI;
var halfPi2 = pi3 / 2;
var quarterPi = pi3 / 4;
var tau2 = pi3 * 2;
var degrees = 180 / pi3;
var radians = pi3 / 180;
var abs2 = Math.abs;
var atan = Math.atan;
var atan22 = Math.atan2;
var cos2 = Math.cos;
var exp = Math.exp;
var log2 = Math.log;
var pow2 = Math.pow;
var sin2 = Math.sin;
var sign = Math.sign || function(x) {
  return x > 0 ? 1 : x < 0 ? -1 : 0;
};
var sqrt2 = Math.sqrt;
var tan = Math.tan;
function acos2(x) {
  return x > 1 ? 0 : x < -1 ? pi3 : Math.acos(x);
}
function asin2(x) {
  return x > 1 ? halfPi2 : x < -1 ? -halfPi2 : Math.asin(x);
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/noop.js
function noop() {
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/stream.js
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}
var streamObjectType = {
  Feature: function(object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function(object, stream) {
    var features = object.features, i = -1, n = features.length;
    while (++i < n)
      streamGeometry(features[i].geometry, stream);
  }
};
var streamGeometryType = {
  Sphere: function(object, stream) {
    stream.sphere();
  },
  Point: function(object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n)
      object = coordinates[i], stream.point(object[0], object[1], object[2]);
  },
  LineString: function(object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n)
      streamLine(coordinates[i], stream, 0);
  },
  Polygon: function(object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function(object, stream) {
    var coordinates = object.coordinates, i = -1, n = coordinates.length;
    while (++i < n)
      streamPolygon(coordinates[i], stream);
  },
  GeometryCollection: function(object, stream) {
    var geometries = object.geometries, i = -1, n = geometries.length;
    while (++i < n)
      streamGeometry(geometries[i], stream);
  }
};
function streamLine(coordinates, stream, closed) {
  var i = -1, n = coordinates.length - closed, coordinate;
  stream.lineStart();
  while (++i < n)
    coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}
function streamPolygon(coordinates, stream) {
  var i = -1, n = coordinates.length;
  stream.polygonStart();
  while (++i < n)
    streamLine(coordinates[i], stream, 1);
  stream.polygonEnd();
}
function stream_default(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/cartesian.js
function spherical(cartesian2) {
  return [atan22(cartesian2[1], cartesian2[0]), asin2(cartesian2[2])];
}
function cartesian(spherical2) {
  var lambda = spherical2[0], phi = spherical2[1], cosPhi = cos2(phi);
  return [cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi)];
}
function cartesianDot(a3, b) {
  return a3[0] * b[0] + a3[1] * b[1] + a3[2] * b[2];
}
function cartesianCross(a3, b) {
  return [a3[1] * b[2] - a3[2] * b[1], a3[2] * b[0] - a3[0] * b[2], a3[0] * b[1] - a3[1] * b[0]];
}
function cartesianAddInPlace(a3, b) {
  a3[0] += b[0], a3[1] += b[1], a3[2] += b[2];
}
function cartesianScale(vector, k2) {
  return [vector[0] * k2, vector[1] * k2, vector[2] * k2];
}
function cartesianNormalizeInPlace(d) {
  var l = sqrt2(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/compose.js
function compose_default(a3, b) {
  function compose(x, y) {
    return x = a3(x, y), b(x[0], x[1]);
  }
  if (a3.invert && b.invert)
    compose.invert = function(x, y) {
      return x = b.invert(x, y), x && a3.invert(x[0], x[1]);
    };
  return compose;
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/rotation.js
function rotationIdentity(lambda, phi) {
  return [abs2(lambda) > pi3 ? lambda + Math.round(-lambda / tau2) * tau2 : lambda, phi];
}
rotationIdentity.invert = rotationIdentity;
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau2) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}
function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi) {
    return lambda += deltaLambda, [lambda > pi3 ? lambda - tau2 : lambda < -pi3 ? lambda + tau2 : lambda, phi];
  };
}
function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}
function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos2(deltaPhi), sinDeltaPhi = sin2(deltaPhi), cosDeltaGamma = cos2(deltaGamma), sinDeltaGamma = sin2(deltaGamma);
  function rotation(lambda, phi) {
    var cosPhi = cos2(phi), x = cos2(lambda) * cosPhi, y = sin2(lambda) * cosPhi, z = sin2(phi), k2 = z * cosDeltaPhi + x * sinDeltaPhi;
    return [
      atan22(y * cosDeltaGamma - k2 * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi),
      asin2(k2 * cosDeltaGamma + y * sinDeltaGamma)
    ];
  }
  rotation.invert = function(lambda, phi) {
    var cosPhi = cos2(phi), x = cos2(lambda) * cosPhi, y = sin2(lambda) * cosPhi, z = sin2(phi), k2 = z * cosDeltaGamma - y * sinDeltaGamma;
    return [
      atan22(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k2 * sinDeltaPhi),
      asin2(k2 * cosDeltaPhi - x * sinDeltaPhi)
    ];
  };
  return rotation;
}
function rotation_default(rotate3) {
  rotate3 = rotateRadians(rotate3[0] * radians, rotate3[1] * radians, rotate3.length > 2 ? rotate3[2] * radians : 0);
  function forward(coordinates) {
    coordinates = rotate3(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
  }
  forward.invert = function(coordinates) {
    coordinates = rotate3.invert(coordinates[0] * radians, coordinates[1] * radians);
    return coordinates[0] *= degrees, coordinates[1] *= degrees, coordinates;
  };
  return forward;
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/circle.js
function circleStream(stream, radius, delta, direction2, t0, t1) {
  if (!delta)
    return;
  var cosRadius = cos2(radius), sinRadius = sin2(radius), step = direction2 * delta;
  if (t0 == null) {
    t0 = radius + direction2 * tau2;
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius(cosRadius, t0);
    t1 = circleRadius(cosRadius, t1);
    if (direction2 > 0 ? t0 < t1 : t0 > t1)
      t0 += direction2 * tau2;
  }
  for (var point5, t = t0; direction2 > 0 ? t > t1 : t < t1; t -= step) {
    point5 = spherical([cosRadius, -sinRadius * cos2(t), -sinRadius * sin2(t)]);
    stream.point(point5[0], point5[1]);
  }
}
function circleRadius(cosRadius, point5) {
  point5 = cartesian(point5), point5[0] -= cosRadius;
  cartesianNormalizeInPlace(point5);
  var radius = acos2(-point5[1]);
  return ((-point5[2] < 0 ? -radius : radius) + tau2 - epsilon2) % tau2;
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/clip/buffer.js
function buffer_default() {
  var lines = [], line2;
  return {
    point: function(x, y, m4) {
      line2.push([x, y, m4]);
    },
    lineStart: function() {
      lines.push(line2 = []);
    },
    lineEnd: noop,
    rejoin: function() {
      if (lines.length > 1)
        lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result2 = lines;
      lines = [];
      line2 = null;
      return result2;
    }
  };
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/pointEqual.js
function pointEqual_default(a3, b) {
  return abs2(a3[0] - b[0]) < epsilon2 && abs2(a3[1] - b[1]) < epsilon2;
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/clip/rejoin.js
function Intersection(point5, points, other, entry) {
  this.x = point5;
  this.z = points;
  this.o = other;
  this.e = entry;
  this.v = false;
  this.n = this.p = null;
}
function rejoin_default(segments2, compareIntersection2, startInside, interpolate2, stream) {
  var subject = [], clip = [], i, n;
  segments2.forEach(function(segment) {
    if ((n2 = segment.length - 1) <= 0)
      return;
    var n2, p0 = segment[0], p1 = segment[n2], x;
    if (pointEqual_default(p0, p1)) {
      if (!p0[2] && !p1[2]) {
        stream.lineStart();
        for (i = 0; i < n2; ++i)
          stream.point((p0 = segment[i])[0], p0[1]);
        stream.lineEnd();
        return;
      }
      p1[0] += 2 * epsilon2;
    }
    subject.push(x = new Intersection(p0, segment, null, true));
    clip.push(x.o = new Intersection(p0, null, x, false));
    subject.push(x = new Intersection(p1, segment, null, false));
    clip.push(x.o = new Intersection(p1, null, x, true));
  });
  if (!subject.length)
    return;
  clip.sort(compareIntersection2);
  link(subject);
  link(clip);
  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }
  var start = subject[0], points, point5;
  while (1) {
    var current = start, isSubject = true;
    while (current.v)
      if ((current = current.n) === start)
        return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i)
            stream.point((point5 = points[i])[0], point5[1]);
        } else {
          interpolate2(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i = points.length - 1; i >= 0; --i)
            stream.point((point5 = points[i])[0], point5[1]);
        } else {
          interpolate2(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}
function link(array3) {
  if (!(n = array3.length))
    return;
  var n, i = 0, a3 = array3[0], b;
  while (++i < n) {
    a3.n = b = array3[i];
    b.p = a3;
    a3 = b;
  }
  a3.n = b = array3[0];
  b.p = a3;
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/polygonContains.js
var sum = adder_default();
function longitude(point5) {
  if (abs2(point5[0]) <= pi3)
    return point5[0];
  else
    return sign(point5[0]) * ((abs2(point5[0]) + pi3) % tau2 - pi3);
}
function polygonContains_default(polygon, point5) {
  var lambda = longitude(point5), phi = point5[1], sinPhi = sin2(phi), normal = [sin2(lambda), -cos2(lambda), 0], angle2 = 0, winding = 0;
  sum.reset();
  if (sinPhi === 1)
    phi = halfPi2 + epsilon2;
  else if (sinPhi === -1)
    phi = -halfPi2 - epsilon2;
  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m4 = (ring = polygon[i]).length))
      continue;
    var ring, m4, point0 = ring[m4 - 1], lambda0 = longitude(point0), phi0 = point0[1] / 2 + quarterPi, sinPhi0 = sin2(phi0), cosPhi0 = cos2(phi0);
    for (var j = 0; j < m4; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j], lambda1 = longitude(point1), phi1 = point1[1] / 2 + quarterPi, sinPhi1 = sin2(phi1), cosPhi1 = cos2(phi1), delta = lambda1 - lambda0, sign3 = delta >= 0 ? 1 : -1, absDelta = sign3 * delta, antimeridian = absDelta > pi3, k2 = sinPhi0 * sinPhi1;
      sum.add(atan22(k2 * sign3 * sin2(absDelta), cosPhi0 * cosPhi1 + k2 * cos2(absDelta)));
      angle2 += antimeridian ? delta + sign3 * tau2 : delta;
      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc);
        var intersection = cartesianCross(normal, arc);
        cartesianNormalizeInPlace(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin2(intersection[2]);
        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }
  return (angle2 < -epsilon2 || angle2 < epsilon2 && sum < -epsilon2) ^ winding & 1;
}

// http-url:https://unpkg.com/d3-array@1.2.4/src/ascending
function ascending_default(a3, b) {
  return a3 < b ? -1 : a3 > b ? 1 : a3 >= b ? 0 : NaN;
}

// http-url:https://unpkg.com/d3-array@1.2.4/src/bisector
function bisector_default(compare) {
  if (compare.length === 1)
    compare = ascendingComparator(compare);
  return {
    left: function(a3, x, lo, hi) {
      if (lo == null)
        lo = 0;
      if (hi == null)
        hi = a3.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a3[mid], x) < 0)
          lo = mid + 1;
        else
          hi = mid;
      }
      return lo;
    },
    right: function(a3, x, lo, hi) {
      if (lo == null)
        lo = 0;
      if (hi == null)
        hi = a3.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a3[mid], x) > 0)
          hi = mid;
        else
          lo = mid + 1;
      }
      return lo;
    }
  };
}
function ascendingComparator(f) {
  return function(d, x) {
    return ascending_default(f(d), x);
  };
}

// http-url:https://unpkg.com/d3-array@1.2.4/src/bisect
var ascendingBisect = bisector_default(ascending_default);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;

// http-url:https://unpkg.com/d3-array@1.2.4/src/array
var array2 = Array.prototype;
var slice = array2.slice;
var map = array2.map;

// http-url:https://unpkg.com/d3-array@1.2.4/src/ticks
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);

// http-url:https://unpkg.com/d3-array@1.2.4/src/merge
function merge_default(arrays) {
  var n = arrays.length, m4, i = -1, j = 0, merged, array3;
  while (++i < n)
    j += arrays[i].length;
  merged = new Array(j);
  while (--n >= 0) {
    array3 = arrays[n];
    m4 = array3.length;
    while (--m4 >= 0) {
      merged[--j] = array3[m4];
    }
  }
  return merged;
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/clip/index.js
function clip_default(pointVisible, clipLine, interpolate2, start) {
  return function(sink) {
    var line2 = clipLine(sink), ringBuffer = buffer_default(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments2, ring;
    var clip = {
      point: point5,
      lineStart,
      lineEnd,
      polygonStart: function() {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments2 = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip.point = point5;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments2 = merge_default(segments2);
        var startInside = polygonContains_default(polygon, start);
        if (segments2.length) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          rejoin_default(segments2, compareIntersection, startInside, interpolate2, sink);
        } else if (startInside) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate2(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted)
          sink.polygonEnd(), polygonStarted = false;
        segments2 = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate2(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };
    function point5(lambda, phi) {
      if (pointVisible(lambda, phi))
        sink.point(lambda, phi);
    }
    function pointLine(lambda, phi) {
      line2.point(lambda, phi);
    }
    function lineStart() {
      clip.point = pointLine;
      line2.lineStart();
    }
    function lineEnd() {
      clip.point = point5;
      line2.lineEnd();
    }
    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      ringSink.point(lambda, phi);
    }
    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }
    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m4, segment, point6;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n)
        return;
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m4 = segment.length - 1) > 0) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m4; ++i)
            sink.point((point6 = segment[i])[0], point6[1]);
          sink.lineEnd();
        }
        return;
      }
      if (n > 1 && clean & 2)
        ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments2.push(ringSegments.filter(validSegment));
    }
    return clip;
  };
}
function validSegment(segment) {
  return segment.length > 1;
}
function compareIntersection(a3, b) {
  return ((a3 = a3.x)[0] < 0 ? a3[1] - halfPi2 - epsilon2 : halfPi2 - a3[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi2 - epsilon2 : halfPi2 - b[1]);
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/clip/antimeridian.js
var antimeridian_default = clip_default(
  function() {
    return true;
  },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-pi3, -halfPi2]
);
function clipAntimeridianLine(stream) {
  var lambda0 = NaN, phi0 = NaN, sign0 = NaN, clean;
  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda1, phi1) {
      var sign1 = lambda1 > 0 ? pi3 : -pi3, delta = abs2(lambda1 - lambda0);
      if (abs2(delta - pi3) < epsilon2) {
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi2 : -halfPi2);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi3) {
        if (abs2(lambda0 - sign0) < epsilon2)
          lambda0 -= sign0 * epsilon2;
        if (abs2(lambda1 - sign1) < epsilon2)
          lambda1 -= sign1 * epsilon2;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }
      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function() {
      return 2 - clean;
    }
  };
}
function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0, cosPhi1, sinLambda0Lambda1 = sin2(lambda0 - lambda1);
  return abs2(sinLambda0Lambda1) > epsilon2 ? atan((sin2(phi0) * (cosPhi1 = cos2(phi1)) * sin2(lambda1) - sin2(phi1) * (cosPhi0 = cos2(phi0)) * sin2(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
}
function clipAntimeridianInterpolate(from, to, direction2, stream) {
  var phi;
  if (from == null) {
    phi = direction2 * halfPi2;
    stream.point(-pi3, phi);
    stream.point(0, phi);
    stream.point(pi3, phi);
    stream.point(pi3, 0);
    stream.point(pi3, -phi);
    stream.point(0, -phi);
    stream.point(-pi3, -phi);
    stream.point(-pi3, 0);
    stream.point(-pi3, phi);
  } else if (abs2(from[0] - to[0]) > epsilon2) {
    var lambda = from[0] < to[0] ? pi3 : -pi3;
    phi = direction2 * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/clip/circle.js
function circle_default(radius) {
  var cr = cos2(radius), delta = 6 * radians, smallRadius = cr > 0, notHemisphere = abs2(cr) > epsilon2;
  function interpolate2(from, to, direction2, stream) {
    circleStream(stream, radius, delta, direction2, from, to);
  }
  function visible(lambda, phi) {
    return cos2(lambda) * cos2(phi) > cr;
  }
  function clipLine(stream) {
    var point0, c0, v0, v00, clean;
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi) {
        var point1 = [lambda, phi], point22, v = visible(lambda, phi), c3 = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? pi3 : -pi3), phi) : 0;
        if (!point0 && (v00 = v0 = v))
          stream.lineStart();
        if (v !== v0) {
          point22 = intersect4(point0, point1);
          if (!point22 || pointEqual_default(point0, point22) || pointEqual_default(point1, point22))
            point1[2] = 1;
        }
        if (v !== v0) {
          clean = 0;
          if (v) {
            stream.lineStart();
            point22 = intersect4(point1, point0);
            stream.point(point22[0], point22[1]);
          } else {
            point22 = intersect4(point0, point1);
            stream.point(point22[0], point22[1], 2);
            stream.lineEnd();
          }
          point0 = point22;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t;
          if (!(c3 & c0) && (t = intersect4(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1], 3);
            }
          }
        }
        if (v && (!point0 || !pointEqual_default(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v, c0 = c3;
      },
      lineEnd: function() {
        if (v0)
          stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return clean | (v00 && v0) << 1;
      }
    };
  }
  function intersect4(a3, b, two) {
    var pa = cartesian(a3), pb = cartesian(b);
    var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
    if (!determinant)
      return !two && a3;
    var c1 = cr * n2n2 / determinant, c22 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A = cartesianScale(n1, c1), B = cartesianScale(n2, c22);
    cartesianAddInPlace(A, B);
    var u = n1xn2, w = cartesianDot(A, u), uu = cartesianDot(u, u), t2 = w * w - uu * (cartesianDot(A, A) - 1);
    if (t2 < 0)
      return;
    var t = sqrt2(t2), q = cartesianScale(u, (-w - t) / uu);
    cartesianAddInPlace(q, A);
    q = spherical(q);
    if (!two)
      return q;
    var lambda0 = a3[0], lambda1 = b[0], phi0 = a3[1], phi1 = b[1], z;
    if (lambda1 < lambda0)
      z = lambda0, lambda0 = lambda1, lambda1 = z;
    var delta2 = lambda1 - lambda0, polar = abs2(delta2 - pi3) < epsilon2, meridian = polar || delta2 < epsilon2;
    if (!polar && phi1 < phi0)
      z = phi0, phi0 = phi1, phi1 = z;
    if (meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < (abs2(q[0] - lambda0) < epsilon2 ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta2 > pi3 ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q1 = cartesianScale(u, (-w + t) / uu);
      cartesianAddInPlace(q1, A);
      return [q, spherical(q1)];
    }
  }
  function code(lambda, phi) {
    var r = smallRadius ? radius : pi3 - radius, code2 = 0;
    if (lambda < -r)
      code2 |= 1;
    else if (lambda > r)
      code2 |= 2;
    if (phi < -r)
      code2 |= 4;
    else if (phi > r)
      code2 |= 8;
    return code2;
  }
  return clip_default(visible, clipLine, interpolate2, smallRadius ? [0, -radius] : [-pi3, radius - pi3]);
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/clip/line.js
function line_default(a3, b, x05, y05, x14, y14) {
  var ax = a3[0], ay = a3[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
  r = x05 - ax;
  if (!dx && r > 0)
    return;
  r /= dx;
  if (dx < 0) {
    if (r < t0)
      return;
    if (r < t1)
      t1 = r;
  } else if (dx > 0) {
    if (r > t1)
      return;
    if (r > t0)
      t0 = r;
  }
  r = x14 - ax;
  if (!dx && r < 0)
    return;
  r /= dx;
  if (dx < 0) {
    if (r > t1)
      return;
    if (r > t0)
      t0 = r;
  } else if (dx > 0) {
    if (r < t0)
      return;
    if (r < t1)
      t1 = r;
  }
  r = y05 - ay;
  if (!dy && r > 0)
    return;
  r /= dy;
  if (dy < 0) {
    if (r < t0)
      return;
    if (r < t1)
      t1 = r;
  } else if (dy > 0) {
    if (r > t1)
      return;
    if (r > t0)
      t0 = r;
  }
  r = y14 - ay;
  if (!dy && r < 0)
    return;
  r /= dy;
  if (dy < 0) {
    if (r > t1)
      return;
    if (r > t0)
      t0 = r;
  } else if (dy > 0) {
    if (r < t0)
      return;
    if (r < t1)
      t1 = r;
  }
  if (t0 > 0)
    a3[0] = ax + t0 * dx, a3[1] = ay + t0 * dy;
  if (t1 < 1)
    b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
  return true;
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/clip/rectangle.js
var clipMax = 1e9;
var clipMin = -clipMax;
function clipRectangle(x05, y05, x14, y14) {
  function visible(x, y) {
    return x05 <= x && x <= x14 && y05 <= y && y <= y14;
  }
  function interpolate2(from, to, direction2, stream) {
    var a3 = 0, a1 = 0;
    if (from == null || (a3 = corner(from, direction2)) !== (a1 = corner(to, direction2)) || comparePoint(from, to) < 0 ^ direction2 > 0) {
      do
        stream.point(a3 === 0 || a3 === 3 ? x05 : x14, a3 > 1 ? y14 : y05);
      while ((a3 = (a3 + direction2 + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }
  function corner(p, direction2) {
    return abs2(p[0] - x05) < epsilon2 ? direction2 > 0 ? 0 : 3 : abs2(p[0] - x14) < epsilon2 ? direction2 > 0 ? 2 : 1 : abs2(p[1] - y05) < epsilon2 ? direction2 > 0 ? 1 : 0 : direction2 > 0 ? 3 : 2;
  }
  function compareIntersection2(a3, b) {
    return comparePoint(a3.x, b.x);
  }
  function comparePoint(a3, b) {
    var ca = corner(a3, 1), cb = corner(b, 1);
    return ca !== cb ? ca - cb : ca === 0 ? b[1] - a3[1] : ca === 1 ? a3[0] - b[0] : ca === 2 ? a3[1] - b[1] : b[0] - a3[0];
  }
  return function(stream) {
    var activeStream = stream, bufferStream = buffer_default(), segments2, polygon, ring, x__, y__, v__, x_, y_, v_, first, clean;
    var clipStream = {
      point: point5,
      lineStart,
      lineEnd,
      polygonStart,
      polygonEnd
    };
    function point5(x, y) {
      if (visible(x, y))
        activeStream.point(x, y);
    }
    function polygonInside() {
      var winding = 0;
      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring2 = polygon[i], j = 1, m4 = ring2.length, point6 = ring2[0], a0, a1, b0 = point6[0], b1 = point6[1]; j < m4; ++j) {
          a0 = b0, a1 = b1, point6 = ring2[j], b0 = point6[0], b1 = point6[1];
          if (a1 <= y14) {
            if (b1 > y14 && (b0 - a0) * (y14 - a1) > (b1 - a1) * (x05 - a0))
              ++winding;
          } else {
            if (b1 <= y14 && (b0 - a0) * (y14 - a1) < (b1 - a1) * (x05 - a0))
              --winding;
          }
        }
      }
      return winding;
    }
    function polygonStart() {
      activeStream = bufferStream, segments2 = [], polygon = [], clean = true;
    }
    function polygonEnd() {
      var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments2 = merge_default(segments2)).length;
      if (cleanInside || visible2) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate2(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible2) {
          rejoin_default(segments2, compareIntersection2, startInside, interpolate2, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments2 = polygon = ring = null;
    }
    function lineStart() {
      clipStream.point = linePoint;
      if (polygon)
        polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }
    function lineEnd() {
      if (segments2) {
        linePoint(x__, y__);
        if (v__ && v_)
          bufferStream.rejoin();
        segments2.push(bufferStream.result());
      }
      clipStream.point = point5;
      if (v_)
        activeStream.lineEnd();
    }
    function linePoint(x, y) {
      var v = visible(x, y);
      if (polygon)
        ring.push([x, y]);
      if (first) {
        x__ = x, y__ = y, v__ = v;
        first = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x, y);
        }
      } else {
        if (v && v_)
          activeStream.point(x, y);
        else {
          var a3 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];
          if (line_default(a3, b, x05, y05, x14, y14)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a3[0], a3[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v)
              activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x, y);
            clean = false;
          }
        }
      }
      x_ = x, y_ = y, v_ = v;
    }
    return clipStream;
  };
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/identity.js
function identity_default2(x) {
  return x;
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/path/area.js
var areaSum = adder_default();
var areaRingSum = adder_default();
var x00;
var y00;
var x0;
var y0;
var areaStream = {
  point: noop,
  lineStart: noop,
  lineEnd: noop,
  polygonStart: function() {
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop;
    areaSum.add(abs2(areaRingSum));
    areaRingSum.reset();
  },
  result: function() {
    var area2 = areaSum / 2;
    areaSum.reset();
    return area2;
  }
};
function areaRingStart() {
  areaStream.point = areaPointFirst;
}
function areaPointFirst(x, y) {
  areaStream.point = areaPoint;
  x00 = x0 = x, y00 = y0 = y;
}
function areaPoint(x, y) {
  areaRingSum.add(y0 * x - x0 * y);
  x0 = x, y0 = y;
}
function areaRingEnd() {
  areaPoint(x00, y00);
}
var area_default = areaStream;

// http-url:https://unpkg.com/d3-geo@1.12.1/src/path/bounds.js
var x02 = Infinity;
var y02 = x02;
var x13 = -x02;
var y13 = x13;
var boundsStream = {
  point: boundsPoint,
  lineStart: noop,
  lineEnd: noop,
  polygonStart: noop,
  polygonEnd: noop,
  result: function() {
    var bounds = [[x02, y02], [x13, y13]];
    x13 = y13 = -(y02 = x02 = Infinity);
    return bounds;
  }
};
function boundsPoint(x, y) {
  if (x < x02)
    x02 = x;
  if (x > x13)
    x13 = x;
  if (y < y02)
    y02 = y;
  if (y > y13)
    y13 = y;
}
var bounds_default = boundsStream;

// http-url:https://unpkg.com/d3-geo@1.12.1/src/path/centroid.js
var X0 = 0;
var Y0 = 0;
var Z0 = 0;
var X1 = 0;
var Y1 = 0;
var Z1 = 0;
var X2 = 0;
var Y2 = 0;
var Z2 = 0;
var x002;
var y002;
var x03;
var y03;
var centroidStream = {
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.point = centroidPoint;
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  },
  result: function() {
    var centroid = Z2 ? [X2 / Z2, Y2 / Z2] : Z1 ? [X1 / Z1, Y1 / Z1] : Z0 ? [X0 / Z0, Y0 / Z0] : [NaN, NaN];
    X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
    return centroid;
  }
};
function centroidPoint(x, y) {
  X0 += x;
  Y0 += y;
  ++Z0;
}
function centroidLineStart() {
  centroidStream.point = centroidPointFirstLine;
}
function centroidPointFirstLine(x, y) {
  centroidStream.point = centroidPointLine;
  centroidPoint(x03 = x, y03 = y);
}
function centroidPointLine(x, y) {
  var dx = x - x03, dy = y - y03, z = sqrt2(dx * dx + dy * dy);
  X1 += z * (x03 + x) / 2;
  Y1 += z * (y03 + y) / 2;
  Z1 += z;
  centroidPoint(x03 = x, y03 = y);
}
function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}
function centroidRingStart() {
  centroidStream.point = centroidPointFirstRing;
}
function centroidRingEnd() {
  centroidPointRing(x002, y002);
}
function centroidPointFirstRing(x, y) {
  centroidStream.point = centroidPointRing;
  centroidPoint(x002 = x03 = x, y002 = y03 = y);
}
function centroidPointRing(x, y) {
  var dx = x - x03, dy = y - y03, z = sqrt2(dx * dx + dy * dy);
  X1 += z * (x03 + x) / 2;
  Y1 += z * (y03 + y) / 2;
  Z1 += z;
  z = y03 * x - x03 * y;
  X2 += z * (x03 + x);
  Y2 += z * (y03 + y);
  Z2 += z * 3;
  centroidPoint(x03 = x, y03 = y);
}
var centroid_default = centroidStream;

// http-url:https://unpkg.com/d3-geo@1.12.1/src/path/context.js
function PathContext(context) {
  this._context = context;
}
PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_) {
    return this._radius = _, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0)
      this._context.closePath();
    this._point = NaN;
  },
  point: function(x, y) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x, y);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x, y);
        break;
      }
      default: {
        this._context.moveTo(x + this._radius, y);
        this._context.arc(x, y, this._radius, 0, tau2);
        break;
      }
    }
  },
  result: noop
};

// http-url:https://unpkg.com/d3-geo@1.12.1/src/path/measure.js
var lengthSum = adder_default();
var lengthRing;
var x003;
var y003;
var x04;
var y04;
var lengthStream = {
  point: noop,
  lineStart: function() {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function() {
    if (lengthRing)
      lengthPoint(x003, y003);
    lengthStream.point = noop;
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length2 = +lengthSum;
    lengthSum.reset();
    return length2;
  }
};
function lengthPointFirst(x, y) {
  lengthStream.point = lengthPoint;
  x003 = x04 = x, y003 = y04 = y;
}
function lengthPoint(x, y) {
  x04 -= x, y04 -= y;
  lengthSum.add(sqrt2(x04 * x04 + y04 * y04));
  x04 = x, y04 = y;
}
var measure_default = lengthStream;

// http-url:https://unpkg.com/d3-geo@1.12.1/src/path/string.js
function PathString() {
  this._string = [];
}
PathString.prototype = {
  _radius: 4.5,
  _circle: circle(4.5),
  pointRadius: function(_) {
    if ((_ = +_) !== this._radius)
      this._radius = _, this._circle = null;
    return this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0)
      this._string.push("Z");
    this._point = NaN;
  },
  point: function(x, y) {
    switch (this._point) {
      case 0: {
        this._string.push("M", x, ",", y);
        this._point = 1;
        break;
      }
      case 1: {
        this._string.push("L", x, ",", y);
        break;
      }
      default: {
        if (this._circle == null)
          this._circle = circle(this._radius);
        this._string.push("M", x, ",", y, this._circle);
        break;
      }
    }
  },
  result: function() {
    if (this._string.length) {
      var result2 = this._string.join("");
      this._string = [];
      return result2;
    } else {
      return null;
    }
  }
};
function circle(radius) {
  return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/path/index.js
function path_default(projection3, context) {
  var pointRadius = 4.5, projectionStream, contextStream;
  function path(object) {
    if (object) {
      if (typeof pointRadius === "function")
        contextStream.pointRadius(+pointRadius.apply(this, arguments));
      stream_default(object, projectionStream(contextStream));
    }
    return contextStream.result();
  }
  path.area = function(object) {
    stream_default(object, projectionStream(area_default));
    return area_default.result();
  };
  path.measure = function(object) {
    stream_default(object, projectionStream(measure_default));
    return measure_default.result();
  };
  path.bounds = function(object) {
    stream_default(object, projectionStream(bounds_default));
    return bounds_default.result();
  };
  path.centroid = function(object) {
    stream_default(object, projectionStream(centroid_default));
    return centroid_default.result();
  };
  path.projection = function(_) {
    return arguments.length ? (projectionStream = _ == null ? (projection3 = null, identity_default2) : (projection3 = _).stream, path) : projection3;
  };
  path.context = function(_) {
    if (!arguments.length)
      return context;
    contextStream = _ == null ? (context = null, new PathString()) : new PathContext(context = _);
    if (typeof pointRadius !== "function")
      contextStream.pointRadius(pointRadius);
    return path;
  };
  path.pointRadius = function(_) {
    if (!arguments.length)
      return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path;
  };
  return path.projection(projection3).context(context);
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/transform.js
function transformer(methods4) {
  return function(stream) {
    var s2 = new TransformStream();
    for (var key in methods4)
      s2[key] = methods4[key];
    s2.stream = stream;
    return s2;
  };
}
function TransformStream() {
}
TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x, y) {
    this.stream.point(x, y);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};

// http-url:https://unpkg.com/d3-geo@1.12.1/src/projection/fit.js
function fit(projection3, fitBounds, object) {
  var clip = projection3.clipExtent && projection3.clipExtent();
  projection3.scale(150).translate([0, 0]);
  if (clip != null)
    projection3.clipExtent(null);
  stream_default(object, projection3.stream(bounds_default));
  fitBounds(bounds_default.result());
  if (clip != null)
    projection3.clipExtent(clip);
  return projection3;
}
function fitExtent(projection3, extent2, object) {
  return fit(projection3, function(b) {
    var w = extent2[1][0] - extent2[0][0], h = extent2[1][1] - extent2[0][1], k2 = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x = +extent2[0][0] + (w - k2 * (b[1][0] + b[0][0])) / 2, y = +extent2[0][1] + (h - k2 * (b[1][1] + b[0][1])) / 2;
    projection3.scale(150 * k2).translate([x, y]);
  }, object);
}
function fitSize(projection3, size, object) {
  return fitExtent(projection3, [[0, 0], size], object);
}
function fitWidth(projection3, width, object) {
  return fit(projection3, function(b) {
    var w = +width, k2 = w / (b[1][0] - b[0][0]), x = (w - k2 * (b[1][0] + b[0][0])) / 2, y = -k2 * b[0][1];
    projection3.scale(150 * k2).translate([x, y]);
  }, object);
}
function fitHeight(projection3, height, object) {
  return fit(projection3, function(b) {
    var h = +height, k2 = h / (b[1][1] - b[0][1]), x = -k2 * b[0][0], y = (h - k2 * (b[1][1] + b[0][1])) / 2;
    projection3.scale(150 * k2).translate([x, y]);
  }, object);
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/projection/resample.js
var maxDepth = 16;
var cosMinDistance = cos2(30 * radians);
function resample_default(project, delta2) {
  return +delta2 ? resample(project, delta2) : resampleNone(project);
}
function resampleNone(project) {
  return transformer({
    point: function(x, y) {
      x = project(x, y);
      this.stream.point(x[0], x[1]);
    }
  });
}
function resample(project, delta2) {
  function resampleLineTo(x05, y05, lambda0, a0, b0, c0, x14, y14, lambda1, a1, b1, c1, depth, stream) {
    var dx = x14 - x05, dy = y14 - y05, d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a3 = a0 + a1, b = b0 + b1, c3 = c0 + c1, m4 = sqrt2(a3 * a3 + b * b + c3 * c3), phi2 = asin2(c3 /= m4), lambda2 = abs2(abs2(c3) - 1) < epsilon2 || abs2(lambda0 - lambda1) < epsilon2 ? (lambda0 + lambda1) / 2 : atan22(b, a3), p = project(lambda2, phi2), x23 = p[0], y23 = p[1], dx2 = x23 - x05, dy2 = y23 - y05, dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 || abs2((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
        resampleLineTo(x05, y05, lambda0, a0, b0, c0, x23, y23, lambda2, a3 /= m4, b /= m4, c3, depth, stream);
        stream.point(x23, y23);
        resampleLineTo(x23, y23, lambda2, a3, b, c3, x14, y14, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda00, x004, y004, a00, b00, c00, lambda0, x05, y05, a0, b0, c0;
    var resampleStream = {
      point: point5,
      lineStart,
      lineEnd,
      polygonStart: function() {
        stream.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function() {
        stream.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };
    function point5(x, y) {
      x = project(x, y);
      stream.point(x[0], x[1]);
    }
    function lineStart() {
      x05 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }
    function linePoint(lambda, phi) {
      var c3 = cartesian([lambda, phi]), p = project(lambda, phi);
      resampleLineTo(x05, y05, lambda0, a0, b0, c0, x05 = p[0], y05 = p[1], lambda0 = lambda, a0 = c3[0], b0 = c3[1], c0 = c3[2], maxDepth, stream);
      stream.point(x05, y05);
    }
    function lineEnd() {
      resampleStream.point = point5;
      stream.lineEnd();
    }
    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }
    function ringPoint(lambda, phi) {
      linePoint(lambda00 = lambda, phi), x004 = x05, y004 = y05, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }
    function ringEnd() {
      resampleLineTo(x05, y05, lambda0, a0, b0, c0, x004, y004, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }
    return resampleStream;
  };
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/projection/index.js
var transformRadians = transformer({
  point: function(x, y) {
    this.stream.point(x * radians, y * radians);
  }
});
function transformRotate(rotate3) {
  return transformer({
    point: function(x, y) {
      var r = rotate3(x, y);
      return this.stream.point(r[0], r[1]);
    }
  });
}
function scaleTranslate(k2, dx, dy, sx, sy) {
  function transform5(x, y) {
    x *= sx;
    y *= sy;
    return [dx + k2 * x, dy - k2 * y];
  }
  transform5.invert = function(x, y) {
    return [(x - dx) / k2 * sx, (dy - y) / k2 * sy];
  };
  return transform5;
}
function scaleTranslateRotate(k2, dx, dy, sx, sy, alpha) {
  var cosAlpha = cos2(alpha), sinAlpha = sin2(alpha), a3 = cosAlpha * k2, b = sinAlpha * k2, ai = cosAlpha / k2, bi = sinAlpha / k2, ci = (sinAlpha * dy - cosAlpha * dx) / k2, fi = (sinAlpha * dx + cosAlpha * dy) / k2;
  function transform5(x, y) {
    x *= sx;
    y *= sy;
    return [a3 * x - b * y + dx, dy - b * x - a3 * y];
  }
  transform5.invert = function(x, y) {
    return [sx * (ai * x - bi * y + ci), sy * (fi - bi * x - ai * y)];
  };
  return transform5;
}
function projection(project) {
  return projectionMutator(function() {
    return project;
  })();
}
function projectionMutator(projectAt) {
  var project, k2 = 150, x = 480, y = 250, lambda = 0, phi = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate3, alpha = 0, sx = 1, sy = 1, theta = null, preclip = antimeridian_default, x05 = null, y05, x14, y14, postclip = identity_default2, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache, cacheStream;
  function projection3(point5) {
    return projectRotateTransform(point5[0] * radians, point5[1] * radians);
  }
  function invert(point5) {
    point5 = projectRotateTransform.invert(point5[0], point5[1]);
    return point5 && [point5[0] * degrees, point5[1] * degrees];
  }
  projection3.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate3)(preclip(projectResample(postclip(cacheStream = stream)))));
  };
  projection3.preclip = function(_) {
    return arguments.length ? (preclip = _, theta = void 0, reset3()) : preclip;
  };
  projection3.postclip = function(_) {
    return arguments.length ? (postclip = _, x05 = y05 = x14 = y14 = null, reset3()) : postclip;
  };
  projection3.clipAngle = function(_) {
    return arguments.length ? (preclip = +_ ? circle_default(theta = _ * radians) : (theta = null, antimeridian_default), reset3()) : theta * degrees;
  };
  projection3.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x05 = y05 = x14 = y14 = null, identity_default2) : clipRectangle(x05 = +_[0][0], y05 = +_[0][1], x14 = +_[1][0], y14 = +_[1][1]), reset3()) : x05 == null ? null : [[x05, y05], [x14, y14]];
  };
  projection3.scale = function(_) {
    return arguments.length ? (k2 = +_, recenter()) : k2;
  };
  projection3.translate = function(_) {
    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
  };
  projection3.center = function(_) {
    return arguments.length ? (lambda = _[0] % 360 * radians, phi = _[1] % 360 * radians, recenter()) : [lambda * degrees, phi * degrees];
  };
  projection3.rotate = function(_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * radians, deltaPhi = _[1] % 360 * radians, deltaGamma = _.length > 2 ? _[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
  };
  projection3.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * radians, recenter()) : alpha * degrees;
  };
  projection3.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, recenter()) : sx < 0;
  };
  projection3.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, recenter()) : sy < 0;
  };
  projection3.precision = function(_) {
    return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _ * _), reset3()) : sqrt2(delta2);
  };
  projection3.fitExtent = function(extent2, object) {
    return fitExtent(projection3, extent2, object);
  };
  projection3.fitSize = function(size, object) {
    return fitSize(projection3, size, object);
  };
  projection3.fitWidth = function(width, object) {
    return fitWidth(projection3, width, object);
  };
  projection3.fitHeight = function(height, object) {
    return fitHeight(projection3, height, object);
  };
  function recenter() {
    var center2 = scaleTranslateRotate(k2, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi)), transform5 = (alpha ? scaleTranslateRotate : scaleTranslate)(k2, x - center2[0], y - center2[1], sx, sy, alpha);
    rotate3 = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = compose_default(project, transform5);
    projectRotateTransform = compose_default(rotate3, projectTransform);
    projectResample = resample_default(projectTransform, delta2);
    return reset3();
  }
  function reset3() {
    cache = cacheStream = null;
    return projection3;
  }
  return function() {
    project = projectAt.apply(this, arguments);
    projection3.invert = project.invert && invert;
    return recenter();
  };
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/projection/conic.js
function conicProjection(projectAt) {
  var phi0 = 0, phi1 = pi3 / 3, m4 = projectionMutator(projectAt), p = m4(phi0, phi1);
  p.parallels = function(_) {
    return arguments.length ? m4(phi0 = _[0] * radians, phi1 = _[1] * radians) : [phi0 * degrees, phi1 * degrees];
  };
  return p;
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/projection/cylindricalEqualArea.js
function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = cos2(phi0);
  function forward(lambda, phi) {
    return [lambda * cosPhi0, sin2(phi) / cosPhi0];
  }
  forward.invert = function(x, y) {
    return [x / cosPhi0, asin2(y * cosPhi0)];
  };
  return forward;
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/projection/conicEqualArea.js
function conicEqualAreaRaw(y05, y14) {
  var sy0 = sin2(y05), n = (sy0 + sin2(y14)) / 2;
  if (abs2(n) < epsilon2)
    return cylindricalEqualAreaRaw(y05);
  var c3 = 1 + sy0 * (2 * n - sy0), r0 = sqrt2(c3) / n;
  function project(x, y) {
    var r = sqrt2(c3 - 2 * n * sin2(y)) / n;
    return [r * sin2(x *= n), r0 - r * cos2(x)];
  }
  project.invert = function(x, y) {
    var r0y = r0 - y, l = atan22(x, abs2(r0y)) * sign(r0y);
    if (r0y * n < 0)
      l -= pi3 * sign(x) * sign(r0y);
    return [l / n, asin2((c3 - (x * x + r0y * r0y) * n * n) / (2 * n))];
  };
  return project;
}
function conicEqualArea_default() {
  return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/projection/albers.js
function albers_default() {
  return conicEqualArea_default().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/projection/albersUsa.js
function multiplex(streams) {
  var n = streams.length;
  return {
    point: function(x, y) {
      var i = -1;
      while (++i < n)
        streams[i].point(x, y);
    },
    sphere: function() {
      var i = -1;
      while (++i < n)
        streams[i].sphere();
    },
    lineStart: function() {
      var i = -1;
      while (++i < n)
        streams[i].lineStart();
    },
    lineEnd: function() {
      var i = -1;
      while (++i < n)
        streams[i].lineEnd();
    },
    polygonStart: function() {
      var i = -1;
      while (++i < n)
        streams[i].polygonStart();
    },
    polygonEnd: function() {
      var i = -1;
      while (++i < n)
        streams[i].polygonEnd();
    }
  };
}
function albersUsa_default() {
  var cache, cacheStream, lower48 = albers_default(), lower48Point, alaska = conicEqualArea_default().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea_default().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point5, pointStream = { point: function(x, y) {
    point5 = [x, y];
  } };
  function albersUsa(coordinates) {
    var x = coordinates[0], y = coordinates[1];
    return point5 = null, (lower48Point.point(x, y), point5) || (alaskaPoint.point(x, y), point5) || (hawaiiPoint.point(x, y), point5);
  }
  albersUsa.invert = function(coordinates) {
    var k2 = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k2, y = (coordinates[1] - t[1]) / k2;
    return (y >= 0.12 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii : lower48).invert(coordinates);
  };
  albersUsa.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };
  albersUsa.precision = function(_) {
    if (!arguments.length)
      return lower48.precision();
    lower48.precision(_), alaska.precision(_), hawaii.precision(_);
    return reset3();
  };
  albersUsa.scale = function(_) {
    if (!arguments.length)
      return lower48.scale();
    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
    return albersUsa.translate(lower48.translate());
  };
  albersUsa.translate = function(_) {
    if (!arguments.length)
      return lower48.translate();
    var k2 = lower48.scale(), x = +_[0], y = +_[1];
    lower48Point = lower48.translate(_).clipExtent([[x - 0.455 * k2, y - 0.238 * k2], [x + 0.455 * k2, y + 0.238 * k2]]).stream(pointStream);
    alaskaPoint = alaska.translate([x - 0.307 * k2, y + 0.201 * k2]).clipExtent([[x - 0.425 * k2 + epsilon2, y + 0.12 * k2 + epsilon2], [x - 0.214 * k2 - epsilon2, y + 0.234 * k2 - epsilon2]]).stream(pointStream);
    hawaiiPoint = hawaii.translate([x - 0.205 * k2, y + 0.212 * k2]).clipExtent([[x - 0.214 * k2 + epsilon2, y + 0.166 * k2 + epsilon2], [x - 0.115 * k2 - epsilon2, y + 0.234 * k2 - epsilon2]]).stream(pointStream);
    return reset3();
  };
  albersUsa.fitExtent = function(extent2, object) {
    return fitExtent(albersUsa, extent2, object);
  };
  albersUsa.fitSize = function(size, object) {
    return fitSize(albersUsa, size, object);
  };
  albersUsa.fitWidth = function(width, object) {
    return fitWidth(albersUsa, width, object);
  };
  albersUsa.fitHeight = function(height, object) {
    return fitHeight(albersUsa, height, object);
  };
  function reset3() {
    cache = cacheStream = null;
    return albersUsa;
  }
  return albersUsa.scale(1070);
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/projection/azimuthal.js
function azimuthalRaw(scale4) {
  return function(x, y) {
    var cx = cos2(x), cy = cos2(y), k2 = scale4(cx * cy);
    return [
      k2 * cy * sin2(x),
      k2 * sin2(y)
    ];
  };
}
function azimuthalInvert(angle2) {
  return function(x, y) {
    var z = sqrt2(x * x + y * y), c3 = angle2(z), sc = sin2(c3), cc = cos2(c3);
    return [
      atan22(x * sc, z * cc),
      asin2(z && y * sc / z)
    ];
  };
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/projection/azimuthalEqualArea.js
var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt2(2 / (1 + cxcy));
});
azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
  return 2 * asin2(z / 2);
});
function azimuthalEqualArea_default() {
  return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/projection/azimuthalEquidistant.js
var azimuthalEquidistantRaw = azimuthalRaw(function(c3) {
  return (c3 = acos2(c3)) && c3 / sin2(c3);
});
azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
  return z;
});
function azimuthalEquidistant_default() {
  return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/projection/mercator.js
function mercatorRaw(lambda, phi) {
  return [lambda, log2(tan((halfPi2 + phi) / 2))];
}
mercatorRaw.invert = function(x, y) {
  return [x, 2 * atan(exp(y)) - halfPi2];
};
function mercator_default() {
  return mercatorProjection(mercatorRaw).scale(961 / tau2);
}
function mercatorProjection(project) {
  var m4 = projection(project), center2 = m4.center, scale4 = m4.scale, translate2 = m4.translate, clipExtent = m4.clipExtent, x05 = null, y05, x14, y14;
  m4.scale = function(_) {
    return arguments.length ? (scale4(_), reclip()) : scale4();
  };
  m4.translate = function(_) {
    return arguments.length ? (translate2(_), reclip()) : translate2();
  };
  m4.center = function(_) {
    return arguments.length ? (center2(_), reclip()) : center2();
  };
  m4.clipExtent = function(_) {
    return arguments.length ? (_ == null ? x05 = y05 = x14 = y14 = null : (x05 = +_[0][0], y05 = +_[0][1], x14 = +_[1][0], y14 = +_[1][1]), reclip()) : x05 == null ? null : [[x05, y05], [x14, y14]];
  };
  function reclip() {
    var k2 = pi3 * scale4(), t = m4(rotation_default(m4.rotate()).invert([0, 0]));
    return clipExtent(x05 == null ? [[t[0] - k2, t[1] - k2], [t[0] + k2, t[1] + k2]] : project === mercatorRaw ? [[Math.max(t[0] - k2, x05), y05], [Math.min(t[0] + k2, x14), y14]] : [[x05, Math.max(t[1] - k2, y05)], [x14, Math.min(t[1] + k2, y14)]]);
  }
  return reclip();
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/projection/conicConformal.js
function tany(y) {
  return tan((halfPi2 + y) / 2);
}
function conicConformalRaw(y05, y14) {
  var cy0 = cos2(y05), n = y05 === y14 ? sin2(y05) : log2(cy0 / cos2(y14)) / log2(tany(y14) / tany(y05)), f = cy0 * pow2(tany(y05), n) / n;
  if (!n)
    return mercatorRaw;
  function project(x, y) {
    if (f > 0) {
      if (y < -halfPi2 + epsilon2)
        y = -halfPi2 + epsilon2;
    } else {
      if (y > halfPi2 - epsilon2)
        y = halfPi2 - epsilon2;
    }
    var r = f / pow2(tany(y), n);
    return [r * sin2(n * x), f - r * cos2(n * x)];
  }
  project.invert = function(x, y) {
    var fy = f - y, r = sign(n) * sqrt2(x * x + fy * fy), l = atan22(x, abs2(fy)) * sign(fy);
    if (fy * n < 0)
      l -= pi3 * sign(x) * sign(fy);
    return [l / n, 2 * atan(pow2(f / r, 1 / n)) - halfPi2];
  };
  return project;
}
function conicConformal_default() {
  return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/projection/equirectangular.js
function equirectangularRaw(lambda, phi) {
  return [lambda, phi];
}
equirectangularRaw.invert = equirectangularRaw;
function equirectangular_default() {
  return projection(equirectangularRaw).scale(152.63);
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/projection/conicEquidistant.js
function conicEquidistantRaw(y05, y14) {
  var cy0 = cos2(y05), n = y05 === y14 ? sin2(y05) : (cy0 - cos2(y14)) / (y14 - y05), g = cy0 / n + y05;
  if (abs2(n) < epsilon2)
    return equirectangularRaw;
  function project(x, y) {
    var gy = g - y, nx = n * x;
    return [gy * sin2(nx), g - gy * cos2(nx)];
  }
  project.invert = function(x, y) {
    var gy = g - y, l = atan22(x, abs2(gy)) * sign(gy);
    if (gy * n < 0)
      l -= pi3 * sign(x) * sign(gy);
    return [l / n, g - sign(n) * sqrt2(x * x + gy * gy)];
  };
  return project;
}
function conicEquidistant_default() {
  return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/projection/equalEarth.js
var A1 = 1.340264;
var A2 = -0.081106;
var A3 = 893e-6;
var A4 = 3796e-6;
var M = sqrt2(3) / 2;
var iterations = 12;
function equalEarthRaw(lambda, phi) {
  var l = asin2(M * sin2(phi)), l2 = l * l, l6 = l2 * l2 * l2;
  return [
    lambda * cos2(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
    l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
  ];
}
equalEarthRaw.invert = function(x, y) {
  var l = y, l2 = l * l, l6 = l2 * l2 * l2;
  for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
    fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y;
    fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
    l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
    if (abs2(delta) < epsilon22)
      break;
  }
  return [
    M * x * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos2(l),
    asin2(sin2(l) / M)
  ];
};
function equalEarth_default() {
  return projection(equalEarthRaw).scale(177.158);
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/projection/gnomonic.js
function gnomonicRaw(x, y) {
  var cy = cos2(y), k2 = cos2(x) * cy;
  return [cy * sin2(x) / k2, sin2(y) / k2];
}
gnomonicRaw.invert = azimuthalInvert(atan);
function gnomonic_default() {
  return projection(gnomonicRaw).scale(144.049).clipAngle(60);
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/projection/identity.js
function identity_default3() {
  var k2 = 1, tx = 0, ty = 0, sx = 1, sy = 1, alpha = 0, ca, sa, x05 = null, y05, x14, y14, kx2 = 1, ky2 = 1, transform5 = transformer({
    point: function(x, y) {
      var p = projection3([x, y]);
      this.stream.point(p[0], p[1]);
    }
  }), postclip = identity_default2, cache, cacheStream;
  function reset3() {
    kx2 = k2 * sx;
    ky2 = k2 * sy;
    cache = cacheStream = null;
    return projection3;
  }
  function projection3(p) {
    var x = p[0] * kx2, y = p[1] * ky2;
    if (alpha) {
      var t = y * ca - x * sa;
      x = x * ca + y * sa;
      y = t;
    }
    return [x + tx, y + ty];
  }
  projection3.invert = function(p) {
    var x = p[0] - tx, y = p[1] - ty;
    if (alpha) {
      var t = y * ca + x * sa;
      x = x * ca - y * sa;
      y = t;
    }
    return [x / kx2, y / ky2];
  };
  projection3.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transform5(postclip(cacheStream = stream));
  };
  projection3.postclip = function(_) {
    return arguments.length ? (postclip = _, x05 = y05 = x14 = y14 = null, reset3()) : postclip;
  };
  projection3.clipExtent = function(_) {
    return arguments.length ? (postclip = _ == null ? (x05 = y05 = x14 = y14 = null, identity_default2) : clipRectangle(x05 = +_[0][0], y05 = +_[0][1], x14 = +_[1][0], y14 = +_[1][1]), reset3()) : x05 == null ? null : [[x05, y05], [x14, y14]];
  };
  projection3.scale = function(_) {
    return arguments.length ? (k2 = +_, reset3()) : k2;
  };
  projection3.translate = function(_) {
    return arguments.length ? (tx = +_[0], ty = +_[1], reset3()) : [tx, ty];
  };
  projection3.angle = function(_) {
    return arguments.length ? (alpha = _ % 360 * radians, sa = sin2(alpha), ca = cos2(alpha), reset3()) : alpha * degrees;
  };
  projection3.reflectX = function(_) {
    return arguments.length ? (sx = _ ? -1 : 1, reset3()) : sx < 0;
  };
  projection3.reflectY = function(_) {
    return arguments.length ? (sy = _ ? -1 : 1, reset3()) : sy < 0;
  };
  projection3.fitExtent = function(extent2, object) {
    return fitExtent(projection3, extent2, object);
  };
  projection3.fitSize = function(size, object) {
    return fitSize(projection3, size, object);
  };
  projection3.fitWidth = function(width, object) {
    return fitWidth(projection3, width, object);
  };
  projection3.fitHeight = function(height, object) {
    return fitHeight(projection3, height, object);
  };
  return projection3;
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/projection/naturalEarth1.js
function naturalEarth1Raw(lambda, phi) {
  var phi2 = phi * phi, phi4 = phi2 * phi2;
  return [
    lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi2 - 1529e-6 * phi4))),
    phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 5916e-6 * phi4)))
  ];
}
naturalEarth1Raw.invert = function(x, y) {
  var phi = y, i = 25, delta;
  do {
    var phi2 = phi * phi, phi4 = phi2 * phi2;
    phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 5916e-6 * phi4))) - y) / (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 5916e-6 * 11 * phi4)));
  } while (abs2(delta) > epsilon2 && --i > 0);
  return [
    x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (3971e-6 - 1529e-6 * phi2)))),
    phi
  ];
};
function naturalEarth1_default() {
  return projection(naturalEarth1Raw).scale(175.295);
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/projection/orthographic.js
function orthographicRaw(x, y) {
  return [cos2(y) * sin2(x), sin2(y)];
}
orthographicRaw.invert = azimuthalInvert(asin2);
function orthographic_default() {
  return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon2);
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/projection/stereographic.js
function stereographicRaw(x, y) {
  var cy = cos2(y), k2 = 1 + cos2(x) * cy;
  return [cy * sin2(x) / k2, sin2(y) / k2];
}
stereographicRaw.invert = azimuthalInvert(function(z) {
  return 2 * atan(z);
});
function stereographic_default() {
  return projection(stereographicRaw).scale(250).clipAngle(142);
}

// http-url:https://unpkg.com/d3-geo@1.12.1/src/projection/transverseMercator.js
function transverseMercatorRaw(lambda, phi) {
  return [log2(tan((halfPi2 + phi) / 2)), -lambda];
}
transverseMercatorRaw.invert = function(x, y) {
  return [-y, 2 * atan(exp(x)) - halfPi2];
};
function transverseMercator_default() {
  var m4 = mercatorProjection(transverseMercatorRaw), center2 = m4.center, rotate3 = m4.rotate;
  m4.center = function(_) {
    return arguments.length ? center2([-_[1], _[0]]) : (_ = center2(), [_[1], -_[0]]);
  };
  m4.rotate = function(_) {
    return arguments.length ? rotate3([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate3(), [_[0], _[1], _[2] - 90]);
  };
  return rotate3([0, 0, 90]).scale(159.155);
}

// http-url:https://unpkg.com/@visactor/vdataset@0.18.9/es/utils/js
var mergeDeepImmer = function(target, ...sources) {
  return mergeOption(cloneDeep(target), ...sources);
};
function _mergeOptionDeep(target, source, key) {
  const sourceValue = source[key];
  if (void 0 === sourceValue)
    target[key] = null;
  else if (isObject_default(sourceValue)) {
    isObject_default(target[key]) || (target[key] = {});
    for (const _key in sourceValue)
      _mergeOptionDeep(target[key], sourceValue, _key);
  } else
    target[key] = sourceValue;
}
function _mergeOptionBase(target, source) {
  if (isObject_default(source) && target !== source)
    for (const key in source)
      _mergeOptionDeep(target, source, key);
}
function mergeOption(target, ...sources) {
  target || (target = {});
  let sourceIndex = -1;
  const length2 = sources.length;
  for (; ++sourceIndex < length2; ) {
    _mergeOptionBase(target, sources[sourceIndex]);
  }
  return target;
}

// http-url:https://unpkg.com/@visactor/vdataset@0.18.9/es/constants
var DATAVIEW_TYPE;
!function(DATAVIEW_TYPE2) {
  DATAVIEW_TYPE2.DSV = "dsv", DATAVIEW_TYPE2.TREE = "tree", DATAVIEW_TYPE2.GEO = "geo", DATAVIEW_TYPE2.BYTE = "bytejson", DATAVIEW_TYPE2.HEX = "hex", DATAVIEW_TYPE2.GRAPH = "graph", DATAVIEW_TYPE2.TABLE = "table", DATAVIEW_TYPE2.GEO_GRATICULE = "geo-graticule";
}(DATAVIEW_TYPE || (DATAVIEW_TYPE = {}));

// http-url:https://unpkg.com/@visactor/vdataset@0.18.9/es/transform/fold
var fold = (data, options) => {
  const { fields: fields2, key, value, retains } = options, results = [];
  for (let i = 0; i < data.length; i++)
    fields2.forEach((field3) => {
      const item = {};
      if (item[key] = field3, item[value] = data[i][field3], retains)
        retains.forEach((retain) => {
          item[retain] = data[i][retain];
        });
      else
        for (const prop in data[i])
          -1 === fields2.indexOf(prop) && (item[prop] = data[i][prop]);
      results.push(item);
    });
  return results;
};

// http-url:https://unpkg.com/@visactor/vdataset@0.18.9/es/transform/fields
var fields = (data, options) => {
  var _a, _b;
  if (!(null == options ? void 0 : options.fields))
    return data;
  if (0 === data.length)
    return data;
  const fields2 = options.fields, dataTemp = data[0], filterFields = {}, sortFields = [];
  for (const key in fields2)
    if (Object.prototype.hasOwnProperty.call(fields2, key)) {
      const fieldInfo = fields2[key];
      if (!fieldInfo.type) {
        let dataCheck = dataTemp;
        key in dataTemp || (dataCheck = null !== (_a = data.find((d) => key in d)) && void 0 !== _a ? _a : dataTemp), fieldInfo.type = "number" == typeof dataCheck[key] ? "linear" : "ordinal";
      }
      let sortInfo;
      if ("number" == typeof fieldInfo.sortIndex && (sortInfo = {
        key,
        type: fieldInfo.type,
        index: fieldInfo.sortIndex,
        sortIndex: {},
        sortIndexCount: 0,
        sortReverse: true === fieldInfo.sortReverse
      }, sortFields.push(sortInfo)), (null === (_b = fieldInfo.domain) || void 0 === _b ? void 0 : _b.length) > 0)
        if ("ordinal" === fieldInfo.type) {
          fieldInfo._domainCache = {}, filterFields[key] = fieldInfo;
          const _domainCache = {};
          fieldInfo.domain.forEach((d, i) => {
            _domainCache[d] = i, fieldInfo._domainCache[d] = i;
          }), sortInfo && (sortInfo.sortIndex = _domainCache, sortInfo.sortIndexCount = fieldInfo.domain.length);
        } else
          fieldInfo.domain.length >= 2 && (filterFields[key] = fieldInfo);
    }
  return Object.keys(filterFields).length > 0 && (data = data.filter((d) => {
    for (const key in filterFields) {
      const fieldInfo = filterFields[key];
      if ("ordinal" === fieldInfo.type) {
        if (!(d[key] in fieldInfo._domainCache))
          return false;
      } else if (fieldInfo.domain[0] > d[key] || fieldInfo.domain[1] < d[key])
        return false;
    }
    return true;
  })), sortFields.sort((a3, b) => a3.index - b.index), data.sort((a3, b) => sortData(a3, b, sortFields)), data;
};
function sortData(a3, b, sortFields) {
  for (let i = 0; i < sortFields.length; i++) {
    const sortInfo = sortFields[i];
    let v = 0;
    if ("ordinal" === sortInfo.type ? (void 0 === sortInfo.sortIndex[b[sortInfo.key]] && (sortInfo.sortIndex[b[sortInfo.key]] = sortInfo.sortIndexCount++), void 0 === sortInfo.sortIndex[a3[sortInfo.key]] && (sortInfo.sortIndex[a3[sortInfo.key]] = sortInfo.sortIndexCount++), v = sortInfo.sortIndex[a3[sortInfo.key]] - sortInfo.sortIndex[b[sortInfo.key]]) : "linear" === sortInfo.type && (v = a3[sortInfo.key] - b[sortInfo.key]), sortInfo.sortReverse && (v = -v), 0 !== v)
      return v;
  }
  return 0;
}

// http-url:https://unpkg.com/d3-dsv@2.0.0/src/dsv.js
var EOL = {};
var EOF = {};
var QUOTE = 34;
var NEWLINE = 10;
var RETURN = 13;
function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name, i) {
    return JSON.stringify(name) + ": d[" + i + '] || ""';
  }).join(",") + "}");
}
function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function(row, i) {
    return f(object(row), i, columns);
  };
}
function inferColumns(rows) {
  var columnSet = /* @__PURE__ */ Object.create(null), columns = [];
  rows.forEach(function(row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });
  return columns;
}
function pad(value, width) {
  var s2 = value + "", length2 = s2.length;
  return length2 < width ? new Array(width - length2 + 1).join(0) + s2 : s2;
}
function formatYear(year) {
  return year < 0 ? "-" + pad(-year, 6) : year > 9999 ? "+" + pad(year, 6) : pad(year, 4);
}
function formatDate(date) {
  var hours = date.getUTCHours(), minutes = date.getUTCMinutes(), seconds = date.getUTCSeconds(), milliseconds = date.getUTCMilliseconds();
  return isNaN(date) ? "Invalid Date" : formatYear(date.getUTCFullYear(), 4) + "-" + pad(date.getUTCMonth() + 1, 2) + "-" + pad(date.getUTCDate(), 2) + (milliseconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "." + pad(milliseconds, 3) + "Z" : seconds ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + ":" + pad(seconds, 2) + "Z" : minutes || hours ? "T" + pad(hours, 2) + ":" + pad(minutes, 2) + "Z" : "");
}
function dsv_default(delimiter) {
  var reFormat = new RegExp('["' + delimiter + "\n\r]"), DELIMITER = delimiter.charCodeAt(0);
  function parse2(text2, f) {
    var convert, columns, rows = parseRows(text2, function(row, i) {
      if (convert)
        return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }
  function parseRows(text2, f) {
    var rows = [], N = text2.length, I = 0, n = 0, t, eof = N <= 0, eol = false;
    if (text2.charCodeAt(N - 1) === NEWLINE)
      --N;
    if (text2.charCodeAt(N - 1) === RETURN)
      --N;
    function token2() {
      if (eof)
        return EOF;
      if (eol)
        return eol = false, EOL;
      var i, j = I, c3;
      if (text2.charCodeAt(j) === QUOTE) {
        while (I++ < N && text2.charCodeAt(I) !== QUOTE || text2.charCodeAt(++I) === QUOTE)
          ;
        if ((i = I) >= N)
          eof = true;
        else if ((c3 = text2.charCodeAt(I++)) === NEWLINE)
          eol = true;
        else if (c3 === RETURN) {
          eol = true;
          if (text2.charCodeAt(I) === NEWLINE)
            ++I;
        }
        return text2.slice(j + 1, i - 1).replace(/""/g, '"');
      }
      while (I < N) {
        if ((c3 = text2.charCodeAt(i = I++)) === NEWLINE)
          eol = true;
        else if (c3 === RETURN) {
          eol = true;
          if (text2.charCodeAt(I) === NEWLINE)
            ++I;
        } else if (c3 !== DELIMITER)
          continue;
        return text2.slice(j, i);
      }
      return eof = true, text2.slice(j, N);
    }
    while ((t = token2()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF)
        row.push(t), t = token2();
      if (f && (row = f(row, n++)) == null)
        continue;
      rows.push(row);
    }
    return rows;
  }
  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column) {
        return formatValue(row[column]);
      }).join(delimiter);
    });
  }
  function format(rows, columns) {
    if (columns == null)
      columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
  }
  function formatBody(rows, columns) {
    if (columns == null)
      columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }
  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }
  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }
  function formatValue(value) {
    return value == null ? "" : value instanceof Date ? formatDate(value) : reFormat.test(value += "") ? '"' + value.replace(/"/g, '""') + '"' : value;
  }
  return {
    parse: parse2,
    parseRows,
    format,
    formatBody,
    formatRows,
    formatRow,
    formatValue
  };
}

// http-url:https://unpkg.com/d3-dsv@2.0.0/src/csv.js
var csv = dsv_default(",");
var csvParse = csv.parse;
var csvParseRows = csv.parseRows;
var csvFormat = csv.format;
var csvFormatBody = csv.formatBody;
var csvFormatRows = csv.formatRows;
var csvFormatRow = csv.formatRow;
var csvFormatValue = csv.formatValue;

// http-url:https://unpkg.com/d3-dsv@2.0.0/src/tsv.js
var tsv = dsv_default("	");
var tsvParse = tsv.parse;
var tsvParseRows = tsv.parseRows;
var tsvFormat = tsv.format;
var tsvFormatBody = tsv.formatBody;
var tsvFormatRows = tsv.formatRows;
var tsvFormatRow = tsv.formatRow;
var tsvFormatValue = tsv.formatValue;

// http-url:https://unpkg.com/@visactor/vdataset@0.18.9/es/parser/dsv
var DEFAULT_DSV_PARSER_OPTIONS = {
  delimiter: ","
};
var dsvParser = (data, options = {}, dataView) => {
  dataView.type = DATAVIEW_TYPE.DSV;
  const mergeOptions = mergeDeepImmer(DEFAULT_DSV_PARSER_OPTIONS, options), { delimiter } = mergeOptions;
  if (!isString_default(delimiter))
    throw new TypeError("Invalid delimiter: must be a string!");
  return dsv_default(delimiter).parse(data);
};
var csvParser = (data, options = {}, dataView) => (dataView.type = DATAVIEW_TYPE.DSV, csvParse(data));
var tsvParser = (data, options = {}, dataView) => (dataView.type = DATAVIEW_TYPE.DSV, tsvParse(data));

// http-url:https://unpkg.com/@visactor/vdataset@0.18.9/es/parser/data-view
var dataViewParser = (data, options, dataView) => {
  const dependencyUpdate = !isBoolean_default(null == options ? void 0 : options.dependencyUpdate) || (null == options ? void 0 : options.dependencyUpdate);
  if (!data || !isArray_default(data))
    throw new TypeError("Invalid data: must be DataView array!");
  return isArray_default(dataView.rawData) && dataView.rawData.forEach((rd) => {
    rd.target && (rd.target.removeListener("change", dataView.reRunAllTransform), rd.target.removeListener("markRunning", dataView.markRunning));
  }), dependencyUpdate && data.forEach((d) => {
    d.target.addListener("change", dataView.reRunAllTransform), d.target.addListener("markRunning", dataView.markRunning);
  }), data;
};

// http-url:https://unpkg.com/@visactor/vdataset@0.18.9/es/utils/uuid
var idIndex = 0;
var maxId = 1e8;
function getUUID(prefix = "dataset") {
  return idIndex > maxId && (idIndex = 0), prefix + "_" + idIndex++;
}

// http-url:https://unpkg.com/@visactor/vdataset@0.18.9/es/data-set
var DataSet = class {
  constructor(options) {
    var _a;
    let name;
    this.options = options, this.isDataSet = true, this.transformMap = {}, this.parserMap = {}, this.dataViewMap = {}, this.target = new import_eventemitter3.default(), name = (null == options ? void 0 : options.name) ? options.name : getUUID("dataset"), this.name = name, this._logger = null !== (_a = null == options ? void 0 : options.logger) && void 0 !== _a ? _a : Logger.getInstance();
  }
  setLogger(logger) {
    this._logger = logger;
  }
  getDataView(name) {
    return this.dataViewMap[name];
  }
  setDataView(name, dataView) {
    var _a;
    this.dataViewMap[name] && (null === (_a = this._logger) || void 0 === _a || _a.error(`Error: dataView ${name} \u4E4B\u524D\u5DF2\u5B58\u5728\uFF0C\u8BF7\u91CD\u65B0\u547D\u540D`)), this.dataViewMap[name] = dataView;
  }
  removeDataView(name) {
    this.dataViewMap[name] = null, delete this.dataViewMap[name];
  }
  registerParser(name, parser) {
    var _a;
    this.parserMap[name] && (null === (_a = this._logger) || void 0 === _a || _a.warn(`Warn: transform ${name} \u4E4B\u524D\u5DF2\u6CE8\u518C\uFF0C\u6267\u884C\u8986\u76D6\u903B\u8F91`)), this.parserMap[name] = parser;
  }
  removeParser(name) {
    this.parserMap[name] = null, delete this.parserMap[name];
  }
  getParser(name) {
    return this.parserMap[name] || this.parserMap.default;
  }
  registerTransform(name, transform5) {
    var _a;
    this.transformMap[name] && (null === (_a = this._logger) || void 0 === _a || _a.warn(`Warn: transform ${name} \u4E4B\u524D\u5DF2\u6CE8\u518C\uFF0C\u6267\u884C\u8986\u76D6\u903B\u8F91`)), this.transformMap[name] = transform5;
  }
  removeTransform(name) {
    this.transformMap[name] = null, delete this.transformMap[name];
  }
  getTransform(name) {
    return this.transformMap[name];
  }
  multipleDataViewAddListener(list, event, call) {
    this._callMap || (this._callMap = /* @__PURE__ */ new Map());
    let callAd = this._callMap.get(call);
    callAd || (callAd = () => {
      list.some((l) => l.isRunning) || call();
    }), list.forEach((l) => {
      l.target.addListener(event, callAd);
    }), this._callMap.set(call, callAd);
  }
  allDataViewAddListener(event, call) {
    this.multipleDataViewAddListener(Object.values(this.dataViewMap), event, call);
  }
  multipleDataViewRemoveListener(list, event, call) {
    if (this._callMap) {
      const callAd = this._callMap.get(call);
      callAd && list.forEach((l) => {
        l.target.removeListener(event, callAd);
      }), this._callMap.delete(call);
    }
  }
  multipleDataViewUpdateInParse(newData) {
    newData.forEach((d) => {
      var _a;
      return null === (_a = this.getDataView(d.name)) || void 0 === _a ? void 0 : _a.markRunning();
    }), newData.forEach((d) => {
      var _a;
      return null === (_a = this.getDataView(d.name)) || void 0 === _a ? void 0 : _a.parseNewData(d.data, d.options);
    });
  }
  multipleDataViewUpdateInRawData(newData) {
    newData.forEach((d) => {
      var _a;
      return null === (_a = this.getDataView(d.name)) || void 0 === _a ? void 0 : _a.markRunning();
    }), newData.forEach((d) => {
      var _a;
      return null === (_a = this.getDataView(d.name)) || void 0 === _a ? void 0 : _a.updateRawData(d.data, d.options);
    });
  }
  destroy() {
    this.transformMap = null, this.parserMap = null, this.dataViewMap = null, this._callMap = null, this.target.removeAllListeners();
  }
};

// http-url:https://unpkg.com/@visactor/vdataset@0.18.9/es/data-view
var DataViewDiffRank = "_data-view-diff-rank";
var DataView = class _DataView {
  constructor(dataSet, options) {
    let name;
    this.dataSet = dataSet, this.options = options, this.isDataView = true, this.target = new import_eventemitter3.default(), this.parseOption = null, this.transformsArr = [], this.isRunning = false, this.rawData = {}, this.history = false, this.parserData = {}, this.latestData = {}, this._fields = null, this.reRunAllTransform = (opt = {
      pushHistory: true,
      emitMessage: true
    }) => (this.isRunning = true, this.resetTransformData(), this.transformsArr.forEach((t) => {
      this.executeTransform(t, {
        pushHistory: opt.pushHistory,
        emitMessage: false
      }), this.isLastTransform(t) && this.diffLastData();
    }), this.isRunning = false, false !== opt.emitMessage && this.target.emit("change", []), this), this.markRunning = () => {
      this.isRunning = true, this.target.emit("markRunning", []);
    }, name = (null == options ? void 0 : options.name) ? options.name : getUUID("dataview"), this.name = name, (null == options ? void 0 : options.history) && (this.history = options.history, this.historyData = []), this.dataSet.setDataView(name, this), this.setFields(null == options ? void 0 : options.fields);
  }
  parse(data, options, emit = false) {
    var _a;
    this.isRunning = true, emit && this.target.emit("beforeParse", []), options && (this.parseOption = options);
    const cloneData = this.cloneParseData(data, options);
    if (null == options ? void 0 : options.type) {
      const parserData = (null !== (_a = this.dataSet.getParser(options.type)) && void 0 !== _a ? _a : this.dataSet.getParser("bytejson"))(cloneData, options.options, this);
      this.rawData = cloneData, this.parserData = parserData, this.history && this.historyData.push(cloneData, parserData), this.latestData = parserData;
    } else
      this.parserData = cloneData, this.rawData = cloneData, this.history && this.historyData.push(cloneData), this.latestData = cloneData;
    return this.isRunning = false, emit && this.target.emit("afterParse", []), this;
  }
  transform(options, execute = true) {
    if (this.isRunning = true, options && options.type) {
      let pushOption = true;
      if ("fields" === options.type) {
        this._fields = options.options.fields;
        const index = this.transformsArr.findIndex((_op) => _op.type === options.type);
        index >= 0 && (pushOption = false, this.transformsArr[index].options.fields = this._fields);
      }
      if (pushOption && this.transformsArr.push(options), execute) {
        const lastTag = this.isLastTransform(options);
        this.executeTransform(options), lastTag && this.diffLastData();
      }
    }
    return this.sortTransform(), this.isRunning = false, this;
  }
  isLastTransform(options) {
    return this.transformsArr[this.transformsArr.length - 1] === options;
  }
  sortTransform() {
    this.transformsArr.length >= 2 && this.transformsArr.sort((a3, b) => {
      var _a, _b;
      return (null !== (_a = a3.level) && void 0 !== _a ? _a : 0) - (null !== (_b = b.level) && void 0 !== _b ? _b : 0);
    });
  }
  executeTransform(options, opt = {
    pushHistory: true,
    emitMessage: true
  }) {
    const { pushHistory, emitMessage } = opt, transformData = this.dataSet.getTransform(options.type)(this.latestData, options.options);
    this.history && false !== pushHistory && this.historyData.push(transformData), this.latestData = transformData, false !== emitMessage && this.target.emit("change", []);
  }
  resetTransformData() {
    this.latestData = this.parserData, this.history && (this.historyData.length = 0, this.historyData.push(this.rawData, this.parserData));
  }
  enableDiff(keys2) {
    this._diffData = true, this._diffKeys = keys2, this._diffMap = /* @__PURE__ */ new Map(), this._diffRank = 0;
  }
  disableDiff() {
    this._diffData = false, this._diffMap = null, this._diffRank = null;
  }
  resetDiff() {
    this._diffMap = /* @__PURE__ */ new Map(), this._diffRank = 0;
  }
  diffLastData() {
    var _a;
    if (!this._diffData)
      return;
    if (!this.latestData.forEach)
      return;
    if (!(null === (_a = this._diffKeys) || void 0 === _a ? void 0 : _a.length))
      return;
    const next = this._diffRank + 1;
    if (0 === this._diffRank)
      this.latestData.forEach((d) => {
        d[DataViewDiffRank] = next, this._diffMap.set(this._diffKeys.reduce((pre, k2) => pre + d[k2], ""), d);
      }), this.latestDataAUD = {
        add: Array.from(this.latestData),
        del: [],
        update: []
      };
    else {
      let tempKey;
      this.latestDataAUD = {
        add: [],
        del: [],
        update: []
      }, this.latestData.forEach((d) => {
        d[DataViewDiffRank] = next, tempKey = this._diffKeys.reduce((pre, k2) => pre + d[k2], ""), this._diffMap.get(tempKey) ? this.latestDataAUD.update.push(d) : this.latestDataAUD.add.push(d), this._diffMap.set(tempKey, d);
      }), this._diffMap.forEach((v, k2) => {
        v[DataViewDiffRank] < next && (this.latestDataAUD.del.push(v), this._diffMap.delete(k2));
      });
    }
    this._diffRank = next;
  }
  cloneParseData(data, options) {
    let clone = false;
    return data instanceof _DataView || true !== (null == options ? void 0 : options.clone) || (clone = true), clone ? cloneDeep(data) : data;
  }
  parseNewData(data, options) {
    this.parse(data, options || this.parseOption), this.reRunAllTransform();
  }
  updateRawData(data, options) {
    const cloneData = this.cloneParseData(data, options);
    this.rawData = cloneData, this.parserData = cloneData, this.latestData = cloneData, this.reRunAllTransform();
  }
  getFields() {
    var _a;
    return this._fields ? this._fields : "dataview" === (null === (_a = this.parseOption) || void 0 === _a ? void 0 : _a.type) && 1 === this.rawData.length && this.rawData[0].getFields ? this.rawData[0].getFields() : null;
  }
  setFields(f, foreMerge = false) {
    this._fields = f && foreMerge ? merge({}, this._fields, f) : f;
    const fieldsOption = this.transformsArr.find((_op) => "fields" === _op.type);
    !isNil_default(this._fields) && isNil_default(fieldsOption) ? (this.dataSet.registerTransform("fields", fields), this.transform({
      type: "fields",
      options: {
        fields: this._fields
      }
    }, false)) : fieldsOption && (fieldsOption.options.fields = this._fields);
  }
  destroy() {
    this.dataSet.removeDataView(this.name), this._diffMap = null, this._diffRank = null, this.latestData = null, this.rawData = null, this.parserData = null, this.transformsArr = null, this.target = null;
  }
};
function isDataView(obj) {
  return obj instanceof DataView;
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/generator
var Generator = class _Generator {
  static GenAutoIncrementId() {
    return _Generator.auto_increment_id++;
  }
};
Generator.auto_increment_id = 0;

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/inversify/cotainer-module
var ContainerModule = class {
  constructor(registry) {
    this.id = Generator.GenAutoIncrementId(), this.registry = registry;
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/inversify/metadata_keys
var NAMED_TAG = "named";
var INJECT_TAG = "inject";
var MULTI_INJECT_TAG = "multi_inject";
var TAGGED = "inversify:tagged";
var PARAM_TYPES = "inversify:paramtypes";
function getNonCustomTagKeys() {
  return ["inject", "multi_inject", "name", "unmanaged", "named", "optional"];
}
var NON_CUSTOM_TAG_KEYS = getNonCustomTagKeys();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/inversify/meta-data
var Metadata = class {
  constructor(key, value) {
    this.key = key, this.value = value;
  }
  toString() {
    return this.key === NAMED_TAG ? `named: ${String(this.value).toString()} ` : `tagged: { key:${this.key.toString()}, value: ${String(this.value)} }`;
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/Reflect-metadata
var Reflect_metadata_default = function(Reflect2) {
  var target, previous;
  return function(exporter) {
    const hasOwn = Object.prototype.hasOwnProperty, supportsSymbol = "function" == typeof Symbol, toPrimitiveSymbol = supportsSymbol && void 0 !== Symbol.toPrimitive ? Symbol.toPrimitive : "@@toPrimitive", iteratorSymbol = supportsSymbol && void 0 !== Symbol.iterator ? Symbol.iterator : "@@iterator", supportsCreate = "function" == typeof Object.create, supportsProto = {
      __proto__: []
    } instanceof Array, downLevel = !supportsCreate && !supportsProto, HashMap = {
      create: supportsCreate ? function() {
        return MakeDictionary(/* @__PURE__ */ Object.create(null));
      } : supportsProto ? function() {
        return MakeDictionary({
          __proto__: null
        });
      } : function() {
        return MakeDictionary({});
      },
      has: downLevel ? function(map4, key) {
        return hasOwn.call(map4, key);
      } : function(map4, key) {
        return key in map4;
      },
      get: downLevel ? function(map4, key) {
        return hasOwn.call(map4, key) ? map4[key] : void 0;
      } : function(map4, key) {
        return map4[key];
      }
    }, functionPrototype = Object.getPrototypeOf(Function), usePolyfill = "object" == typeof process && process.env && "true" === process.env.REFLECT_METADATA_USE_MAP_POLYFILL, _Map = usePolyfill || "function" != typeof Map || "function" != typeof Map.prototype.entries ? CreateMapPolyfill() : Map, Metadata2 = (usePolyfill || "function" != typeof Set || "function" != typeof Set.prototype.entries ? CreateSetPolyfill() : Set, new (usePolyfill || "function" != typeof WeakMap ? CreateWeakMapPolyfill() : WeakMap)());
    function defineMetadata(metadataKey, metadataValue, target2, propertyKey) {
      if (!IsObject(target2))
        throw new TypeError();
      return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target2, propertyKey);
    }
    function hasMetadata(metadataKey, target2, propertyKey) {
      if (!IsObject(target2))
        throw new TypeError();
      return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryHasMetadata(metadataKey, target2, propertyKey);
    }
    function hasOwnMetadata(metadataKey, target2, propertyKey) {
      if (!IsObject(target2))
        throw new TypeError();
      return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryHasOwnMetadata(metadataKey, target2, propertyKey);
    }
    function getMetadata(metadataKey, target2, propertyKey) {
      if (!IsObject(target2))
        throw new TypeError();
      return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryGetMetadata(metadataKey, target2, propertyKey);
    }
    function GetOrCreateMetadataMap(O, P, Create) {
      let targetMetadata = Metadata2.get(O);
      if (IsUndefined(targetMetadata)) {
        if (!Create)
          return;
        targetMetadata = new _Map(), Metadata2.set(O, targetMetadata);
      }
      let metadataMap = targetMetadata.get(P);
      if (IsUndefined(metadataMap)) {
        if (!Create)
          return;
        metadataMap = new _Map(), targetMetadata.set(P, metadataMap);
      }
      return metadataMap;
    }
    function OrdinaryHasMetadata(MetadataKey, O, P) {
      if (OrdinaryHasOwnMetadata(MetadataKey, O, P))
        return true;
      const parent = OrdinaryGetPrototypeOf(O);
      return !IsNull(parent) && OrdinaryHasMetadata(MetadataKey, parent, P);
    }
    function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
      const metadataMap = GetOrCreateMetadataMap(O, P, false);
      return !IsUndefined(metadataMap) && ToBoolean(metadataMap.has(MetadataKey));
    }
    function OrdinaryGetMetadata(MetadataKey, O, P) {
      if (OrdinaryHasOwnMetadata(MetadataKey, O, P))
        return OrdinaryGetOwnMetadata(MetadataKey, O, P);
      const parent = OrdinaryGetPrototypeOf(O);
      return IsNull(parent) ? void 0 : OrdinaryGetMetadata(MetadataKey, parent, P);
    }
    function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
      const metadataMap = GetOrCreateMetadataMap(O, P, false);
      if (!IsUndefined(metadataMap))
        return metadataMap.get(MetadataKey);
    }
    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
      GetOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
    }
    function Type(x) {
      if (null === x)
        return 1;
      switch (typeof x) {
        case "undefined":
          return 0;
        case "boolean":
          return 2;
        case "string":
          return 3;
        case "symbol":
          return 4;
        case "number":
          return 5;
        case "object":
          return null === x ? 1 : 6;
        default:
          return 6;
      }
    }
    function IsUndefined(x) {
      return void 0 === x;
    }
    function IsNull(x) {
      return null === x;
    }
    function IsSymbol(x) {
      return "symbol" == typeof x;
    }
    function IsObject(x) {
      return "object" == typeof x ? null !== x : "function" == typeof x;
    }
    function ToPrimitive(input, PreferredType) {
      switch (Type(input)) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          return input;
      }
      const hint = 3 === PreferredType ? "string" : 5 === PreferredType ? "number" : "default", exoticToPrim = GetMethod(input, toPrimitiveSymbol);
      if (void 0 !== exoticToPrim) {
        const result2 = exoticToPrim.call(input, hint);
        if (IsObject(result2))
          throw new TypeError();
        return result2;
      }
      return OrdinaryToPrimitive(input, "default" === hint ? "number" : hint);
    }
    function OrdinaryToPrimitive(O, hint) {
      if ("string" === hint) {
        const toString_1 = O.toString;
        if (IsCallable(toString_1)) {
          const result2 = toString_1.call(O);
          if (!IsObject(result2))
            return result2;
        }
        const valueOf = O.valueOf;
        if (IsCallable(valueOf)) {
          const result2 = valueOf.call(O);
          if (!IsObject(result2))
            return result2;
        }
      } else {
        const valueOf = O.valueOf;
        if (IsCallable(valueOf)) {
          const result2 = valueOf.call(O);
          if (!IsObject(result2))
            return result2;
        }
        const toString_2 = O.toString;
        if (IsCallable(toString_2)) {
          const result2 = toString_2.call(O);
          if (!IsObject(result2))
            return result2;
        }
      }
      throw new TypeError();
    }
    function ToBoolean(argument) {
      return !!argument;
    }
    function ToString(argument) {
      return "" + argument;
    }
    function ToPropertyKey(argument) {
      const key = ToPrimitive(argument, 3);
      return IsSymbol(key) ? key : ToString(key);
    }
    function IsCallable(argument) {
      return "function" == typeof argument;
    }
    function GetMethod(V, P) {
      const func = V[P];
      if (null != func) {
        if (!IsCallable(func))
          throw new TypeError();
        return func;
      }
    }
    function OrdinaryGetPrototypeOf(O) {
      const proto = Object.getPrototypeOf(O);
      if ("function" != typeof O || O === functionPrototype)
        return proto;
      if (proto !== functionPrototype)
        return proto;
      const prototype = O.prototype, prototypeProto = prototype && Object.getPrototypeOf(prototype);
      if (null == prototypeProto || prototypeProto === Object.prototype)
        return proto;
      const constructor = prototypeProto.constructor;
      return "function" != typeof constructor || constructor === O ? proto : constructor;
    }
    function CreateMapPolyfill() {
      const cacheSentinel = {}, arraySentinel = [], MapIterator = function() {
        function MapIterator2(keys2, values, selector) {
          this._index = 0, this._keys = keys2, this._values = values, this._selector = selector;
        }
        return MapIterator2.prototype["@@iterator"] = function() {
          return this;
        }, MapIterator2.prototype[iteratorSymbol] = function() {
          return this;
        }, MapIterator2.prototype.next = function() {
          const index = this._index;
          if (index >= 0 && index < this._keys.length) {
            const result2 = this._selector(this._keys[index], this._values[index]);
            return index + 1 >= this._keys.length ? (this._index = -1, this._keys = arraySentinel, this._values = arraySentinel) : this._index++, {
              value: result2,
              done: false
            };
          }
          return {
            value: void 0,
            done: true
          };
        }, MapIterator2.prototype.throw = function(error3) {
          throw this._index >= 0 && (this._index = -1, this._keys = arraySentinel, this._values = arraySentinel), error3;
        }, MapIterator2.prototype.return = function(value) {
          return this._index >= 0 && (this._index = -1, this._keys = arraySentinel, this._values = arraySentinel), {
            value,
            done: true
          };
        }, MapIterator2;
      }();
      return function() {
        function Map2() {
          this._keys = [], this._values = [], this._cacheKey = cacheSentinel, this._cacheIndex = -2;
        }
        return Object.defineProperty(Map2.prototype, "size", {
          get: function() {
            return this._keys.length;
          },
          enumerable: true,
          configurable: true
        }), Map2.prototype.has = function(key) {
          return this._find(key, false) >= 0;
        }, Map2.prototype.get = function(key) {
          const index = this._find(key, false);
          return index >= 0 ? this._values[index] : void 0;
        }, Map2.prototype.set = function(key, value) {
          const index = this._find(key, true);
          return this._values[index] = value, this;
        }, Map2.prototype.delete = function(key) {
          const index = this._find(key, false);
          if (index >= 0) {
            const size = this._keys.length;
            for (let i = index + 1; i < size; i++)
              this._keys[i - 1] = this._keys[i], this._values[i - 1] = this._values[i];
            return this._keys.length--, this._values.length--, key === this._cacheKey && (this._cacheKey = cacheSentinel, this._cacheIndex = -2), true;
          }
          return false;
        }, Map2.prototype.clear = function() {
          this._keys.length = 0, this._values.length = 0, this._cacheKey = cacheSentinel, this._cacheIndex = -2;
        }, Map2.prototype.keys = function() {
          return new MapIterator(this._keys, this._values, getKey);
        }, Map2.prototype.values = function() {
          return new MapIterator(this._keys, this._values, getValue);
        }, Map2.prototype.entries = function() {
          return new MapIterator(this._keys, this._values, getEntry);
        }, Map2.prototype["@@iterator"] = function() {
          return this.entries();
        }, Map2.prototype[iteratorSymbol] = function() {
          return this.entries();
        }, Map2.prototype._find = function(key, insert) {
          return this._cacheKey !== key && (this._cacheIndex = this._keys.indexOf(this._cacheKey = key)), this._cacheIndex < 0 && insert && (this._cacheIndex = this._keys.length, this._keys.push(key), this._values.push(void 0)), this._cacheIndex;
        }, Map2;
      }();
      function getKey(key, _) {
        return key;
      }
      function getValue(_, value) {
        return value;
      }
      function getEntry(key, value) {
        return [key, value];
      }
    }
    function CreateSetPolyfill() {
      return function() {
        function Set2() {
          this._map = new _Map();
        }
        return Object.defineProperty(Set2.prototype, "size", {
          get: function() {
            return this._map.size;
          },
          enumerable: true,
          configurable: true
        }), Set2.prototype.has = function(value) {
          return this._map.has(value);
        }, Set2.prototype.add = function(value) {
          return this._map.set(value, value), this;
        }, Set2.prototype.delete = function(value) {
          return this._map.delete(value);
        }, Set2.prototype.clear = function() {
          this._map.clear();
        }, Set2.prototype.keys = function() {
          return this._map.keys();
        }, Set2.prototype.values = function() {
          return this._map.values();
        }, Set2.prototype.entries = function() {
          return this._map.entries();
        }, Set2.prototype["@@iterator"] = function() {
          return this.keys();
        }, Set2.prototype[iteratorSymbol] = function() {
          return this.keys();
        }, Set2;
      }();
    }
    function CreateWeakMapPolyfill() {
      const UUID_SIZE = 16, keys2 = HashMap.create(), rootKey = CreateUniqueKey();
      return function() {
        function WeakMap2() {
          this._key = CreateUniqueKey();
        }
        return WeakMap2.prototype.has = function(target2) {
          const table = GetOrCreateWeakMapTable(target2, false);
          return void 0 !== table && HashMap.has(table, this._key);
        }, WeakMap2.prototype.get = function(target2) {
          const table = GetOrCreateWeakMapTable(target2, false);
          return void 0 !== table ? HashMap.get(table, this._key) : void 0;
        }, WeakMap2.prototype.set = function(target2, value) {
          return GetOrCreateWeakMapTable(target2, true)[this._key] = value, this;
        }, WeakMap2.prototype.delete = function(target2) {
          const table = GetOrCreateWeakMapTable(target2, false);
          return void 0 !== table && delete table[this._key];
        }, WeakMap2.prototype.clear = function() {
          this._key = CreateUniqueKey();
        }, WeakMap2;
      }();
      function CreateUniqueKey() {
        let key;
        do {
          key = "@@WeakMap@@" + CreateUUID();
        } while (HashMap.has(keys2, key));
        return keys2[key] = true, key;
      }
      function GetOrCreateWeakMapTable(target2, create2) {
        if (!hasOwn.call(target2, rootKey)) {
          if (!create2)
            return;
          Object.defineProperty(target2, rootKey, {
            value: HashMap.create()
          });
        }
        return target2[rootKey];
      }
      function FillRandomBytes(buffer, size) {
        for (let i = 0; i < size; ++i)
          buffer[i] = 255 * Math.random() | 0;
        return buffer;
      }
      function GenRandomBytes(size) {
        return "function" == typeof Uint8Array ? "undefined" != typeof crypto ? crypto.getRandomValues(new Uint8Array(size)) : FillRandomBytes(new Uint8Array(size), size) : FillRandomBytes(new Array(size), size);
      }
      function CreateUUID() {
        const data = GenRandomBytes(UUID_SIZE);
        data[6] = 79 & data[6] | 64, data[8] = 191 & data[8] | 128;
        let result2 = "";
        for (let offset = 0; offset < UUID_SIZE; ++offset) {
          const byte = data[offset];
          4 !== offset && 6 !== offset && 8 !== offset || (result2 += "-"), byte < 16 && (result2 += "0"), result2 += byte.toString(16).toLowerCase();
        }
        return result2;
      }
    }
    function MakeDictionary(obj) {
      return obj.__ = void 0, delete obj.__, obj;
    }
    exporter("defineMetadata", defineMetadata), exporter("hasMetadata", hasMetadata), exporter("hasOwnMetadata", hasOwnMetadata), exporter("getMetadata", getMetadata);
  }((target = Reflect2, function(key, value) {
    "function" != typeof target[key] && Object.defineProperty(target, key, {
      configurable: true,
      writable: true,
      value
    }), previous && previous(key, value);
  })), Reflect2;
}({});

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/inversify/annotation/inject_base
function _tagParameterOrProperty(metadataKey, annotationTarget, key, metadata) {
  const metadatas = [metadata];
  let paramsOrPropertiesMetadata = {};
  Reflect_metadata_default.hasOwnMetadata(metadataKey, annotationTarget) && (paramsOrPropertiesMetadata = Reflect_metadata_default.getMetadata(metadataKey, annotationTarget));
  let paramOrPropertyMetadata = paramsOrPropertiesMetadata[key];
  void 0 === paramOrPropertyMetadata && (paramOrPropertyMetadata = []), paramOrPropertyMetadata.push(...metadatas), paramsOrPropertiesMetadata[key] = paramOrPropertyMetadata, Reflect_metadata_default.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget);
}
function tagParameter(annotationTarget, parameterName, parameterIndex, metadata) {
  _tagParameterOrProperty(TAGGED, annotationTarget, parameterIndex.toString(), metadata);
}
function createTaggedDecorator(metadata) {
  return (target, targetKey, indexOrPropertyDescriptor) => {
    tagParameter(target, targetKey, indexOrPropertyDescriptor, metadata);
  };
}
function injectBase(metadataKey) {
  return (serviceIdentifier) => (target, targetKey, indexOrPropertyDescriptor) => createTaggedDecorator(new Metadata(metadataKey, serviceIdentifier))(target, targetKey, indexOrPropertyDescriptor);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/inversify/annotation/inject
var inject = injectBase(INJECT_TAG);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/inversify/annotation/multi_inject
var multiInject = injectBase(MULTI_INJECT_TAG);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/inversify/annotation/injectable
function injectable() {
  return function(target) {
    return Reflect_metadata_default.defineMetadata(PARAM_TYPES, null, target), target;
  };
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/inversify/annotation/named
function named(name) {
  return createTaggedDecorator(new Metadata(NAMED_TAG, name));
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/inversify/literal_types
var BindingScopeEnum = {
  Singleton: "Singleton",
  Transient: "Transient"
};
var BindingTypeEnum = {
  ConstantValue: "ConstantValue",
  Constructor: "Constructor",
  DynamicValue: "DynamicValue",
  Factory: "Factory",
  Function: "Function",
  Instance: "Instance",
  Invalid: "Invalid",
  Provider: "Provider"
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/inversify/binding
var Binding = class _Binding {
  constructor(serviceIdentifier, scope) {
    this.id = Generator.GenAutoIncrementId(), this.activated = false, this.serviceIdentifier = serviceIdentifier, this.scope = scope, this.type = BindingTypeEnum.Invalid, this.constraint = (request) => true, this.implementationType = null, this.cache = null, this.factory = null, this.provider = null, this.dynamicValue = null;
  }
  clone() {
    const clone = new _Binding(this.serviceIdentifier, this.scope);
    return clone.activated = clone.scope === BindingScopeEnum.Singleton && this.activated, clone.implementationType = this.implementationType, clone.dynamicValue = this.dynamicValue, clone.scope = this.scope, clone.type = this.type, clone.provider = this.provider, clone.constraint = this.constraint, clone.cache = this.cache, clone;
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/inversify/metadata_reader
var MetadataReader = class {
  getConstructorMetadata(constructorFunc) {
    return {
      compilerGeneratedMetadata: Reflect_metadata_default.getMetadata(PARAM_TYPES, constructorFunc),
      userGeneratedMetadata: Reflect_metadata_default.getMetadata(TAGGED, constructorFunc) || {}
    };
  }
  getPropertiesMetadata(constructorFunc) {
    throw new Error("\u6682\u672A\u5B9E\u73B0");
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/inversify/syntax/constraint_helpers
var taggedConstraint = (key) => (value) => {
  const constraint = (request) => {
    if (null == request)
      return false;
    if (request.key === key && request.value === value)
      return true;
    if (null == request.constructorArgsMetadata)
      return false;
    const constructorArgsMetadata = request.constructorArgsMetadata;
    for (let i = 0; i < constructorArgsMetadata.length; i++)
      if (constructorArgsMetadata[i].key === key && constructorArgsMetadata[i].value === value)
        return true;
    return false;
  };
  return constraint.metaData = new Metadata(key, value), constraint;
};
var namedConstraint = taggedConstraint(NAMED_TAG);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/inversify/syntax/binding_in_syntax
var BindingInSyntax = class {
  constructor(binding) {
    this._binding = binding;
  }
  inRequestScope() {
    throw new Error("\u6682\u672A\u5B9E\u73B0");
  }
  inSingletonScope() {
    return this._binding.scope = BindingScopeEnum.Singleton, this;
  }
  inTransientScope() {
    return this._binding.scope = BindingScopeEnum.Transient, this;
  }
  whenTargetNamed(name) {
    return this._binding.constraint = namedConstraint(name), this;
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/inversify/syntax/binding_to_syntax
var BindingToSyntax = class {
  constructor(binding) {
    this._binding = binding;
  }
  to(constructor) {
    return this._binding.type = BindingTypeEnum.Instance, this._binding.implementationType = constructor, new BindingInSyntax(this._binding);
  }
  toSelf() {
    const self = this._binding.serviceIdentifier;
    return this.to(self);
  }
  toDynamicValue(func) {
    return this._binding.type = BindingTypeEnum.DynamicValue, this._binding.cache = null, this._binding.dynamicValue = func, this._binding.implementationType = null, new BindingInSyntax(this._binding);
  }
  toConstantValue(value) {
    return this._binding.type = BindingTypeEnum.ConstantValue, this._binding.cache = value, this._binding.dynamicValue = null, this._binding.implementationType = null, this._binding.scope = BindingScopeEnum.Singleton, new BindingInSyntax(this._binding);
  }
  toFactory(factory) {
    return this._binding.type = BindingTypeEnum.Factory, this._binding.factory = factory, this._binding.scope = BindingScopeEnum.Singleton, new BindingInSyntax(this._binding);
  }
  toService(service) {
    this.toDynamicValue((context) => context.container.get(service));
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/inversify/container
var Container = class {
  constructor(containerOptions) {
    const options = containerOptions || {};
    options.defaultScope = options.defaultScope || BindingScopeEnum.Transient, this.options = options, this.id = Generator.GenAutoIncrementId(), this._bindingDictionary = /* @__PURE__ */ new Map(), this._metadataReader = new MetadataReader();
  }
  load(module) {
    const containerModuleHelpers = this._getContainerModuleHelpersFactory()(module.id);
    module.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction);
  }
  get(serviceIdentifier) {
    const getArgs = this._getNotAllArgs(serviceIdentifier, false);
    return this._get(getArgs);
  }
  getAll(serviceIdentifier) {
    const getArgs = this._getAllArgs(serviceIdentifier);
    return this._get(getArgs);
  }
  getTagged(serviceIdentifier, key, value) {
    const getArgs = this._getNotAllArgs(serviceIdentifier, false, key, value);
    return this._get(getArgs);
  }
  getNamed(serviceIdentifier, named2) {
    return this.getTagged(serviceIdentifier, NAMED_TAG, named2);
  }
  isBound(serviceIdentifier) {
    return this._bindingDictionary.has(serviceIdentifier);
  }
  bind(serviceIdentifier) {
    const scope = this.options.defaultScope, binding = new Binding(serviceIdentifier, scope), list = this._bindingDictionary.get(serviceIdentifier) || [];
    return list.push(binding), this._bindingDictionary.set(serviceIdentifier, list), new BindingToSyntax(binding);
  }
  unbind(serviceIdentifier) {
    this._bindingDictionary.delete(serviceIdentifier);
  }
  rebind(serviceIdentifier) {
    return this.unbind(serviceIdentifier), this.bind(serviceIdentifier);
  }
  _getContainerModuleHelpersFactory() {
    const setModuleId = (bindingToSyntax, moduleId) => {
      bindingToSyntax._binding.moduleId = moduleId;
    }, getBindFunction = (moduleId) => (serviceIdentifier) => {
      const bindingToSyntax = this.bind(serviceIdentifier);
      return setModuleId(bindingToSyntax, moduleId), bindingToSyntax;
    }, getUnbindFunction = () => (serviceIdentifier) => this.unbind(serviceIdentifier), getIsboundFunction = () => (serviceIdentifier) => this.isBound(serviceIdentifier), getRebindFunction = (moduleId) => (serviceIdentifier) => {
      const bindingToSyntax = this.rebind(serviceIdentifier);
      return setModuleId(bindingToSyntax, moduleId), bindingToSyntax;
    };
    return (mId) => ({
      bindFunction: getBindFunction(mId),
      isboundFunction: getIsboundFunction(),
      rebindFunction: getRebindFunction(mId),
      unbindFunction: getUnbindFunction(),
      unbindAsyncFunction: (serviceIdentifier) => null
    });
  }
  _getNotAllArgs(serviceIdentifier, isMultiInject, key, value) {
    return {
      avoidConstraints: false,
      isMultiInject,
      serviceIdentifier,
      key,
      value
    };
  }
  _getAllArgs(serviceIdentifier) {
    return {
      avoidConstraints: true,
      isMultiInject: true,
      serviceIdentifier
    };
  }
  _get(getArgs) {
    const result2 = [];
    return this._bindingDictionary.get(getArgs.serviceIdentifier).filter((b) => b.constraint(getArgs)).forEach((binding) => {
      result2.push(this._resolveFromBinding(binding));
    }), getArgs.isMultiInject || 1 !== result2.length ? result2 : result2[0];
  }
  _getChildRequest(binding) {
    const constr = binding.implementationType, { userGeneratedMetadata } = this._metadataReader.getConstructorMetadata(constr), keys2 = Object.keys(userGeneratedMetadata), arr = [];
    for (let i = 0; i < keys2.length; i++) {
      const constructorArgsMetadata = userGeneratedMetadata[i], targetMetadataMap = {};
      constructorArgsMetadata.forEach((md) => {
        targetMetadataMap[md.key] = md.value;
      });
      const metadata = {
        inject: targetMetadataMap[INJECT_TAG],
        multiInject: targetMetadataMap[MULTI_INJECT_TAG]
      }, injectIdentifier = metadata.inject || metadata.multiInject, target = {
        serviceIdentifier: injectIdentifier,
        constructorArgsMetadata
      }, request = {
        injectIdentifier,
        metadata: constructorArgsMetadata,
        bindings: this._bindingDictionary.get(injectIdentifier).filter((b) => b.constraint(target))
      };
      arr.push(request);
    }
    return arr;
  }
  _resolveFromBinding(binding) {
    const result2 = this._getResolvedFromBinding(binding);
    return this._saveToScope(binding, result2), result2;
  }
  _getResolvedFromBinding(binding) {
    let result2;
    switch (binding.type) {
      case BindingTypeEnum.ConstantValue:
      case BindingTypeEnum.Function:
        result2 = binding.cache;
        break;
      case BindingTypeEnum.Instance:
        result2 = this._resolveInstance(binding, binding.implementationType);
        break;
      default:
        result2 = binding.dynamicValue({
          container: this
        });
    }
    return result2;
  }
  _resolveInstance(binding, constr) {
    if (binding.activated)
      return binding.cache;
    const childRequests = this._getChildRequest(binding);
    return this._createInstance(constr, childRequests);
  }
  _createInstance(constr, childRequests) {
    if (childRequests.length) {
      return new constr(...this._resolveRequests(childRequests));
    }
    return new constr();
  }
  _resolveRequests(childRequests) {
    return childRequests.map((request) => request.bindings.length > 1 ? request.bindings.map((binding) => this._resolveFromBinding(binding)) : this._resolveFromBinding(request.bindings[0]));
  }
  _saveToScope(binding, result2) {
    binding.scope === BindingScopeEnum.Singleton && (binding.cache = result2, binding.activated = true);
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/contribution-provider
var ContributionProvider = Symbol("ContributionProvider");
var ContributionProviderCache = class {
  constructor(serviceIdentifier, container2) {
    this.serviceIdentifier = serviceIdentifier, this.container = container2;
  }
  getContributions() {
    return this.caches || (this.caches = [], this.container && this.container.isBound(this.serviceIdentifier) && this.caches.push(...this.container.getAll(this.serviceIdentifier))), this.caches;
  }
};
function bindContributionProvider(bind, id2) {
  bind(ContributionProvider).toDynamicValue(({ container: container2 }) => new ContributionProviderCache(id2, container2)).inSingletonScope().whenTargetNamed(id2);
}
function bindContributionProviderNoSingletonScope(bind, id2) {
  bind(ContributionProvider).toDynamicValue(({ container: container2 }) => new ContributionProviderCache(id2, container2)).whenTargetNamed(id2);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/tapable/Hook
var Hook = class {
  constructor(args, name) {
    this._args = args, this.name = name, this.taps = [];
  }
  tap(options, fn) {
    this._tap("sync", options, fn);
  }
  unTap(options, fn) {
    const name = "string" == typeof options ? options.trim() : options.name;
    name && (this.taps = this.taps.filter((tap) => !(tap.name === name && (!fn || tap.fn === fn))));
  }
  _parseOptions(type, options, fn) {
    let _options;
    if ("string" == typeof options)
      _options = {
        name: options.trim()
      };
    else if ("object" != typeof options || null === options)
      throw new Error("Invalid tap options");
    if ("string" != typeof _options.name || "" === _options.name)
      throw new Error("Missing name for tap");
    return _options = Object.assign({
      type,
      fn
    }, _options), _options;
  }
  _tap(type, options, fn) {
    this._insert(this._parseOptions(type, options, fn));
  }
  _insert(item) {
    let before;
    "string" == typeof item.before ? before = /* @__PURE__ */ new Set([item.before]) : Array.isArray(item.before) && (before = new Set(item.before));
    let stage = 0;
    "number" == typeof item.stage && (stage = item.stage);
    let i = this.taps.length;
    for (; i > 0; ) {
      i--;
      const x = this.taps[i];
      this.taps[i + 1] = x;
      const xStage = x.stage || 0;
      if (before) {
        if (before.has(x.name)) {
          before.delete(x.name);
          continue;
        }
        if (before.size > 0)
          continue;
      }
      if (!(xStage > stage)) {
        i++;
        break;
      }
    }
    this.taps[i] = item;
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/tapable/SyncHook
var SyncHook = class extends Hook {
  call(...args) {
    this.taps.map((t) => t.fn).forEach((cb) => cb(...args));
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/constants
var EnvContribution = Symbol.for("EnvContribution");
var VGlobal = Symbol.for("VGlobal");

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/core/global
var __decorate = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultGlobal = class {
  get env() {
    return this._env;
  }
  get devicePixelRatio() {
    return this._env || this.setEnv("browser"), this.envContribution.getDevicePixelRatio();
  }
  get supportEvent() {
    return this._env || this.setEnv("browser"), this.envContribution.supportEvent;
  }
  set supportEvent(support) {
    this._env || this.setEnv("browser"), this.envContribution.supportEvent = support;
  }
  get supportsTouchEvents() {
    return this._env || this.setEnv("browser"), this.envContribution.supportsTouchEvents;
  }
  set supportsTouchEvents(support) {
    this._env || this.setEnv("browser"), this.envContribution.supportsTouchEvents = support;
  }
  get supportsPointerEvents() {
    return this._env || this.setEnv("browser"), this.envContribution.supportsPointerEvents;
  }
  set supportsPointerEvents(support) {
    this._env || this.setEnv("browser"), this.envContribution.supportsPointerEvents = support;
  }
  get supportsMouseEvents() {
    return this._env || this.setEnv("browser"), this.envContribution.supportsMouseEvents;
  }
  set supportsMouseEvents(support) {
    this._env || this.setEnv("browser"), this.envContribution.supportsMouseEvents = support;
  }
  get applyStyles() {
    return this._env || this.setEnv("browser"), this.envContribution.applyStyles;
  }
  set applyStyles(support) {
    this._env || this.setEnv("browser"), this.envContribution.applyStyles = support;
  }
  constructor(contributions) {
    this.contributions = contributions, this.id = Generator.GenAutoIncrementId(), this.hooks = {
      onSetEnv: new SyncHook(["lastEnv", "env", "global"])
    }, this.measureTextMethod = "native", this.optimizeVisible = false;
  }
  bindContribution(params2) {
    const promiseArr = [];
    if (this.contributions.getContributions().forEach((contribution) => {
      const data = contribution.configure(this, params2);
      data && data.then && promiseArr.push(data);
    }), promiseArr.length)
      return Promise.all(promiseArr);
  }
  getDynamicCanvasCount() {
    return this._env || this.setEnv("browser"), this.envContribution.getDynamicCanvasCount();
  }
  getStaticCanvasCount() {
    return this._env || this.setEnv("browser"), this.envContribution.getStaticCanvasCount();
  }
  setEnv(env, params2) {
    if (params2 && true === params2.force || this._env !== env)
      return this.deactiveCurrentEnv(), this.activeEnv(env, params2);
  }
  deactiveCurrentEnv() {
    this.envContribution && this.envContribution.release();
  }
  activeEnv(env, params2) {
    const lastEnv = this._env;
    this._env = env;
    const data = this.bindContribution(params2);
    if (data && data.then)
      return data.then(() => {
        this.envParams = params2, this.hooks.onSetEnv.call(lastEnv, env, this);
      });
    this.envParams = params2, this.hooks.onSetEnv.call(lastEnv, env, this);
  }
  setActiveEnvContribution(contribution) {
    this.envContribution = contribution;
  }
  createCanvas(params2) {
    return this._env || this.setEnv("browser"), this.envContribution.createCanvas(params2);
  }
  createOffscreenCanvas(params2) {
    return this._env || this.setEnv("browser"), this.envContribution.createOffscreenCanvas(params2);
  }
  releaseCanvas(canvas) {
    return this._env || this.setEnv("browser"), this.envContribution.releaseCanvas(canvas);
  }
  addEventListener(type, listener, options) {
    return this._env || this.setEnv("browser"), this.envContribution.addEventListener(type, listener, options);
  }
  removeEventListener(type, listener, options) {
    return this._env || this.setEnv("browser"), this.envContribution.removeEventListener(type, listener, options);
  }
  dispatchEvent(event) {
    return this._env || this.setEnv("browser"), this.envContribution.dispatchEvent(event);
  }
  getRequestAnimationFrame() {
    return this._env || this.setEnv("browser"), this.envContribution.getRequestAnimationFrame();
  }
  getCancelAnimationFrame() {
    return this._env || this.setEnv("browser"), this.envContribution.getCancelAnimationFrame();
  }
  getElementById(str) {
    return this._env || this.setEnv("browser"), this.envContribution.getElementById ? this.envContribution.getElementById(str) : null;
  }
  getRootElement() {
    return this._env || this.setEnv("browser"), this.envContribution.getRootElement ? this.envContribution.getRootElement() : null;
  }
  getDocument() {
    return this._env || this.setEnv("browser"), this.envContribution.getDocument ? this.envContribution.getDocument() : null;
  }
  mapToCanvasPoint(event, domElement) {
    return this._env || this.setEnv("browser"), this.envContribution.mapToCanvasPoint ? this.envContribution.mapToCanvasPoint(event, domElement) : null;
  }
  loadImage(url) {
    return this._env || this.setEnv("browser"), this.envContribution.loadImage(url);
  }
  loadSvg(str) {
    return this._env || this.setEnv("browser"), this.envContribution.loadSvg(str);
  }
  loadJson(url) {
    return this._env || this.setEnv("browser"), this.envContribution.loadJson(url);
  }
  loadArrayBuffer(url) {
    return this._env || this.setEnv("browser"), this.envContribution.loadArrayBuffer(url);
  }
  loadBlob(url) {
    return this._env || this.setEnv("browser"), this.envContribution.loadBlob(url);
  }
  isChrome() {
    return null != this._isChrome || (this._env || this.setEnv("browser"), this._isChrome = "browser" === this._env && navigator.userAgent.indexOf("Chrome") > -1), this._isChrome;
  }
  isSafari() {
    return null != this._isSafari || (this._env || this.setEnv("browser"), this._isSafari = "browser" === this._env && /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent)), this._isSafari;
  }
  getNativeAABBBounds(dom) {
    return this._env || this.setEnv("browser"), this.envContribution.getNativeAABBBounds(dom);
  }
  removeDom(dom) {
    return this._env || this.setEnv("browser"), this.envContribution.removeDom(dom);
  }
  createDom(params2) {
    return this._env || this.setEnv("browser"), this.envContribution.createDom(params2);
  }
  updateDom(dom, params2) {
    return this._env || this.setEnv("browser"), this.envContribution.updateDom(dom, params2);
  }
  getElementTop(dom, baseWindow = false) {
    return this._env || this.setEnv("browser"), this.envContribution.getElementTop(dom, baseWindow);
  }
  getElementLeft(dom, baseWindow = false) {
    return this._env || this.setEnv("browser"), this.envContribution.getElementLeft(dom, baseWindow);
  }
  getElementTopLeft(dom, baseWindow = false) {
    return this._env || this.setEnv("browser"), this.envContribution.getElementTopLeft(dom, baseWindow);
  }
};
DefaultGlobal = __decorate([injectable(), __param(0, inject(ContributionProvider)), __param(0, named(EnvContribution)), __metadata("design:paramtypes", [Object])], DefaultGlobal);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/bounds-context
var circleThreshold = tau - 1e-8;
var BoundsContext = class {
  constructor(bounds) {
    this.init(bounds);
  }
  init(bounds) {
    this.bounds = bounds;
  }
  arc(cx, cy, r, sa, ea, ccw) {
    if (Math.abs(ea - sa) > circleThreshold)
      return this.bounds.add(cx - r, cy - r), void this.bounds.add(cx + r, cy + r);
    let s2, i, x, y, xmin = 1 / 0, xmax = -1 / 0, ymin = 1 / 0, ymax = -1 / 0;
    function update2(a3) {
      x = r * Math.cos(a3), y = r * Math.sin(a3), x < xmin && (xmin = x), x > xmax && (xmax = x), y < ymin && (ymin = y), y > ymax && (ymax = y);
    }
    if (update2(sa), update2(ea), ea !== sa)
      if ((sa %= tau) < 0 && (sa += tau), (ea %= tau) < 0 && (ea += tau), ea < sa && (ccw = !ccw, s2 = sa, sa = ea, ea = s2), ccw)
        for (ea -= tau, s2 = sa - sa % halfPi, i = 0; i < 4 && s2 > ea; ++i, s2 -= halfPi)
          update2(s2);
      else
        for (s2 = sa - sa % halfPi + halfPi, i = 0; i < 4 && s2 < ea; ++i, s2 += halfPi)
          update2(s2);
    this.bounds.add(cx + xmin, cy + ymin), this.bounds.add(cx + xmax, cy + ymax);
  }
  arcTo(x14, y14, x23, y23, radius) {
    throw new Error("\u4E0D\u652F\u6301arcTo");
  }
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
    this.bounds.add(cp1x, cp1y), this.bounds.add(cp2x, cp2y), this.bounds.add(x, y);
  }
  closePath() {
  }
  ellipse() {
    throw new Error("\u4E0D\u652F\u6301ellipse");
  }
  lineTo(x, y) {
    this.bounds.add(x, y);
  }
  moveTo(x, y) {
    this.bounds.add(x, y);
  }
  quadraticCurveTo(cpx, cpy, x, y) {
    this.bounds.add(cpx, cpy), this.bounds.add(x, y);
  }
  rect(x, y, w, h) {
    this.bounds.add(x, y), this.bounds.add(x + w, y + h);
  }
  clear() {
    this.bounds.clear();
  }
  release(...params2) {
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/segment/curve/path
var CurvePath = class {
  constructor() {
    this.curves = [], this.bounds = new AABBBounds();
  }
  getCurveLengths() {
    return this.curves.map((curve) => curve.getLength());
  }
  getPointAt(t) {
    return {
      x: 0,
      y: 0
    };
  }
  getLength() {
    return 0;
  }
  getBounds() {
    return this.bounds;
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/path-svg
var rePathCommand = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:[eE][-+]?\d+)?)/gi;
var commandLengths = {
  m: 2,
  l: 2,
  h: 1,
  v: 1,
  c: 6,
  s: 4,
  q: 4,
  t: 2,
  a: 7,
  M: 2,
  L: 2,
  H: 1,
  V: 1,
  C: 6,
  S: 4,
  Q: 4,
  T: 2,
  A: 7
};
var enumCommandMap = {
  A: 0,
  AT: 1,
  C: 2,
  Z: 3,
  E: 4,
  L: 5,
  M: 6,
  Q: 7,
  R: 8
};
var currPath;
var coordsStr;
var commandChar;
var coordStr;
var coordNumber;
var standardCommandLen;
function parseSvgPath(str) {
  if (!str)
    return [];
  const paths = str.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);
  if (null === paths)
    return [];
  let currCommandData, coordsStrArr;
  const result2 = [];
  for (let i = 0, len = paths.length; i < len; i++)
    if (currPath = paths[i], coordsStr = currPath.slice(1), commandChar = currPath[0], currCommandData = [commandChar], coordsStrArr = coordsStr.match(rePathCommand), null !== coordsStrArr) {
      for (let i2 = 0, len2 = coordsStrArr.length; i2 < len2; i2++)
        coordStr = coordsStrArr[i2], coordNumber = parseFloat(coordStr), Number.isNaN(coordNumber) || currCommandData.push(coordNumber);
      if (standardCommandLen = commandLengths[commandChar], currCommandData.length - 1 > standardCommandLen) {
        let subCommand;
        for (let i2 = 1, len2 = currCommandData.length; i2 < len2; i2 += standardCommandLen) {
          subCommand = [commandChar];
          for (let j = i2, subLen = i2 + standardCommandLen; j < subLen; j++)
            subCommand.push(currCommandData[j]);
          result2.push(subCommand);
        }
      } else
        result2.push(currCommandData);
    } else
      result2.push(currCommandData);
  return result2;
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/enums
var UpdateTag;
!function(UpdateTag2) {
  UpdateTag2[UpdateTag2.NONE = 0] = "NONE", UpdateTag2[UpdateTag2.UPDATE_BOUNDS = 1] = "UPDATE_BOUNDS", UpdateTag2[UpdateTag2.UPDATE_SHAPE = 2] = "UPDATE_SHAPE", UpdateTag2[UpdateTag2.CLEAR_SHAPE = 253] = "CLEAR_SHAPE", UpdateTag2[UpdateTag2.UPDATE_SHAPE_AND_BOUNDS = 3] = "UPDATE_SHAPE_AND_BOUNDS", UpdateTag2[UpdateTag2.INIT = 179] = "INIT", UpdateTag2[UpdateTag2.CLEAR_BOUNDS = 254] = "CLEAR_BOUNDS", UpdateTag2[UpdateTag2.UPDATE_GLOBAL_MATRIX = 32] = "UPDATE_GLOBAL_MATRIX", UpdateTag2[UpdateTag2.CLEAR_GLOBAL_MATRIX = 223] = "CLEAR_GLOBAL_MATRIX", UpdateTag2[UpdateTag2.UPDATE_LOCAL_MATRIX = 16] = "UPDATE_LOCAL_MATRIX", UpdateTag2[UpdateTag2.CLEAR_LOCAL_MATRIX = 239] = "CLEAR_LOCAL_MATRIX", UpdateTag2[UpdateTag2.UPDATE_GLOBAL_LOCAL_MATRIX = 48] = "UPDATE_GLOBAL_LOCAL_MATRIX", UpdateTag2[UpdateTag2.UPDATE_LAYOUT = 128] = "UPDATE_LAYOUT", UpdateTag2[UpdateTag2.CLEAR_LAYOUT = 127] = "CLEAR_LAYOUT";
}(UpdateTag || (UpdateTag = {}));
var IContainPointMode;
!function(IContainPointMode2) {
  IContainPointMode2[IContainPointMode2.GLOBAL = 1] = "GLOBAL", IContainPointMode2[IContainPointMode2.LOCAL = 16] = "LOCAL", IContainPointMode2[IContainPointMode2.GLOBAL_ACCURATE = 3] = "GLOBAL_ACCURATE", IContainPointMode2[IContainPointMode2.LOCAL_ACCURATE = 48] = "LOCAL_ACCURATE";
}(IContainPointMode || (IContainPointMode = {}));
var AttributeUpdateType;
!function(AttributeUpdateType2) {
  AttributeUpdateType2[AttributeUpdateType2.INIT = 0] = "INIT", AttributeUpdateType2[AttributeUpdateType2.DEFAULT = 1] = "DEFAULT", AttributeUpdateType2[AttributeUpdateType2.STATE = 2] = "STATE", AttributeUpdateType2[AttributeUpdateType2.ANIMATE_BIND = 10] = "ANIMATE_BIND", AttributeUpdateType2[AttributeUpdateType2.ANIMATE_PLAY = 11] = "ANIMATE_PLAY", AttributeUpdateType2[AttributeUpdateType2.ANIMATE_START = 12] = "ANIMATE_START", AttributeUpdateType2[AttributeUpdateType2.ANIMATE_UPDATE = 13] = "ANIMATE_UPDATE", AttributeUpdateType2[AttributeUpdateType2.ANIMATE_END = 14] = "ANIMATE_END", AttributeUpdateType2[AttributeUpdateType2.TRANSLATE = 20] = "TRANSLATE", AttributeUpdateType2[AttributeUpdateType2.TRANSLATE_TO = 21] = "TRANSLATE_TO", AttributeUpdateType2[AttributeUpdateType2.SCALE = 22] = "SCALE", AttributeUpdateType2[AttributeUpdateType2.SCALE_TO = 23] = "SCALE_TO", AttributeUpdateType2[AttributeUpdateType2.ROTATE = 24] = "ROTATE", AttributeUpdateType2[AttributeUpdateType2.ROTATE_TO = 25] = "ROTATE_TO";
}(AttributeUpdateType || (AttributeUpdateType = {}));
var AnimateStatus;
!function(AnimateStatus2) {
  AnimateStatus2[AnimateStatus2.INITIAL = 0] = "INITIAL", AnimateStatus2[AnimateStatus2.RUNNING = 1] = "RUNNING", AnimateStatus2[AnimateStatus2.PAUSED = 2] = "PAUSED", AnimateStatus2[AnimateStatus2.END = 3] = "END";
}(AnimateStatus || (AnimateStatus = {}));
var AnimateMode;
!function(AnimateMode2) {
  AnimateMode2[AnimateMode2.NORMAL = 0] = "NORMAL", AnimateMode2[AnimateMode2.SET_ATTR_IMMEDIATELY = 1] = "SET_ATTR_IMMEDIATELY";
}(AnimateMode || (AnimateMode = {}));
var AnimateStepType;
!function(AnimateStepType2) {
  AnimateStepType2.wait = "wait", AnimateStepType2.from = "from", AnimateStepType2.to = "to", AnimateStepType2.customAnimate = "customAnimate";
}(AnimateStepType || (AnimateStepType = {}));
var Direction;
!function(Direction3) {
  Direction3[Direction3.ROW = 1] = "ROW", Direction3[Direction3.COLUMN = 2] = "COLUMN";
}(Direction || (Direction = {}));
var CurveTypeEnum;
!function(CurveTypeEnum2) {
  CurveTypeEnum2[CurveTypeEnum2.CubicBezierCurve = 0] = "CubicBezierCurve", CurveTypeEnum2[CurveTypeEnum2.QuadraticBezierCurve = 1] = "QuadraticBezierCurve", CurveTypeEnum2[CurveTypeEnum2.ArcCurve = 2] = "ArcCurve", CurveTypeEnum2[CurveTypeEnum2.LineCurve = 3] = "LineCurve", CurveTypeEnum2[CurveTypeEnum2.EllipseCurve = 4] = "EllipseCurve", CurveTypeEnum2[CurveTypeEnum2.MoveCurve = 5] = "MoveCurve";
}(CurveTypeEnum || (CurveTypeEnum = {}));
var BaseRenderContributionTime;
!function(BaseRenderContributionTime2) {
  BaseRenderContributionTime2[BaseRenderContributionTime2.beforeFillStroke = 0] = "beforeFillStroke", BaseRenderContributionTime2[BaseRenderContributionTime2.afterFillStroke = 1] = "afterFillStroke";
}(BaseRenderContributionTime || (BaseRenderContributionTime = {}));

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/shape/arc
function segments(x, y, rx, ry, large, sweep, rotateX2, ox, oy) {
  const th = degreeToRadian(rotateX2), sin_th = Math.sin(th), cos_th = Math.cos(th), px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5, py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;
  let pl = px * px / ((rx = Math.abs(rx)) * rx) + py * py / ((ry = Math.abs(ry)) * ry);
  pl > 1 && (pl = Math.sqrt(pl), rx *= pl, ry *= pl);
  const a00 = cos_th / rx, a01 = sin_th / rx, a10 = -sin_th / ry, a11 = cos_th / ry, x05 = a00 * ox + a01 * oy, y05 = a10 * ox + a11 * oy, x14 = a00 * x + a01 * y, y14 = a10 * x + a11 * y;
  let sfactor_sq = 1 / ((x14 - x05) * (x14 - x05) + (y14 - y05) * (y14 - y05)) - 0.25;
  sfactor_sq < 0 && (sfactor_sq = 0);
  let sfactor = Math.sqrt(sfactor_sq);
  sweep === large && (sfactor = -sfactor);
  const xc = 0.5 * (x05 + x14) - sfactor * (y14 - y05), yc = 0.5 * (y05 + y14) + sfactor * (x14 - x05), th0 = Math.atan2(y05 - yc, x05 - xc);
  let th_arc = Math.atan2(y14 - yc, x14 - xc) - th0;
  th_arc < 0 && 1 === sweep ? th_arc += tau : th_arc > 0 && 0 === sweep && (th_arc -= tau);
  const segs = Math.ceil(Math.abs(th_arc / (halfPi + 1e-3))), result2 = [];
  for (let i = 0; i < segs; ++i) {
    const th2 = th0 + i * th_arc / segs, th3 = th0 + (i + 1) * th_arc / segs;
    result2[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
  }
  return result2;
}
function bezier(params2) {
  const cx = params2[0], cy = params2[1], th0 = params2[2], th1 = params2[3], rx = params2[4], ry = params2[5], sin_th = params2[6], cos_th = params2[7], a00 = cos_th * rx, a01 = -sin_th * ry, a10 = sin_th * rx, a11 = cos_th * ry, cos_th0 = Math.cos(th0), sin_th0 = Math.sin(th0), cos_th1 = Math.cos(th1), sin_th1 = Math.sin(th1), th_half = 0.5 * (th1 - th0), sin_th_h2 = Math.sin(0.5 * th_half), t = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half), x14 = cx + cos_th0 - t * sin_th0, y14 = cy + sin_th0 + t * cos_th0, x3 = cx + cos_th1, y3 = cy + sin_th1, x23 = x3 + t * sin_th1, y23 = y3 - t * cos_th1;
  return [a00 * x14 + a01 * y14, a10 * x14 + a11 * y14, a00 * x23 + a01 * y23, a10 * x23 + a11 * y23, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];
}
function drawArc(context, x, y, coords) {
  const seg = segments(coords[5], coords[6], coords[0], coords[1], coords[3], coords[4], coords[2], x, y);
  for (let i = 0; i < seg.length; ++i) {
    const bez = bezier(seg[i]);
    context.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);
  }
}
var addArcToBezierPath = (bezierPath, startAngle, endAngle, cx, cy, rx, ry) => {
  const delta = Math.abs(endAngle - startAngle), len = 4 * Math.tan(delta / 4) / 3, dir = endAngle < startAngle ? -1 : 1, c1 = Math.cos(startAngle), s1 = Math.sin(startAngle), c22 = Math.cos(endAngle), s2 = Math.sin(endAngle), x14 = c1 * rx + cx, y14 = s1 * ry + cy, x4 = c22 * rx + cx, y4 = s2 * ry + cy, hx = rx * len * dir, hy = ry * len * dir;
  bezierPath.push(x14 - hx * s1, y14 + hy * c1, x4 + hx * s2, y4 - hy * c22, x4, y4);
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/render-command-list
var commandFuncs = [(command, context, x, y, sx, sy, z) => context.arc(command[1] * sx + x, command[2] * sy + y, command[3] * (sx + sy) / 2, command[4], command[5], command[6], z), (command, context, x, y, sx, sy, z) => context.arcTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, command[5] * (sx + sy) / 2, z), (command, context, x, y, sx, sy, z) => context.bezierCurveTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, command[5] * sx + x, command[6] * sy + y, z), (command, context, x, y) => context.closePath(), (command, context, x, y, sx, sy) => context.ellipse(command[1] * sx + x, command[2] * sy + y, command[3] * sx, command[4] * sy, command[5], command[6], command[7], command[8]), (command, context, x, y, sx, sy, z) => context.lineTo(command[1] * sx + x, command[2] * sy + y, z), (command, context, x, y, sx, sy, z) => context.moveTo(command[1] * sx + x, command[2] * sy + y, z), (command, context, x, y, sx, sy, z) => context.quadraticCurveTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, z), (command, context, x, y, sx, sy, z) => context.rect(command[1] * sx + x, command[2] * sy + y, command[3] * sx, command[4] * sy, z)];
function renderCommandList(commandList, context, x = 0, y = 0, sx = 1, sy = 1, z) {
  for (let i = 0; i < commandList.length; i++) {
    const command = commandList[i];
    commandFuncs[command[0]](command, context, x, y, sx, sy, z);
  }
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/segment/curve/base
var Curve = class {
  getLength(direction2) {
    return null != direction2 ? this.calcProjLength(direction2) : (Number.isFinite(this.length) || (this.length = this.calcLength()), this.length);
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/bezier-utils
function snapLength(xArr, yArr) {
  let totalLength = 0;
  const count = xArr.length;
  for (let i = 0; i < count; i++) {
    const x = xArr[i], y = yArr[i], nextX = xArr[(i + 1) % count], nextY = yArr[(i + 1) % count];
    totalLength += PointService.distanceNN(x, y, nextX, nextY);
  }
  return totalLength / 2;
}
function cubicLength(p0, p1, p2, p3, iterationCount) {
  return snapLength([p0.x, p1.x, p2.x, p3.x], [p0.y, p1.y, p2.y, p3.y]);
}
function cubicCalc(p0, p1, p2, p3, t) {
  const one3 = 1 - t;
  return one3 * one3 * one3 * p0 + 3 * p1 * t * one3 * one3 + 3 * p2 * t * t * one3 + p3 * t * t * t;
}
function cubicPointAt(p0, p1, p2, p3, t) {
  const x = cubicCalc(p0.x, p1.x, p2.x, p3.x, t), y = cubicCalc(p0.y, p1.y, p2.y, p3.y, t);
  return new Point(x, y);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/segment/curve/cubic-bezier
function divideCubic(curve, t) {
  const { p0, p1, p2, p3 } = curve, pt = cubicPointAt(p0, p1, p2, p3, t), c1 = PointService.pointAtPP(p0, p1, t), c22 = PointService.pointAtPP(p1, p2, t), c3 = PointService.pointAtPP(p2, p3, t), c12 = PointService.pointAtPP(c1, c22, t), c23 = PointService.pointAtPP(c22, c3, t);
  return [new CubicBezierCurve(p0, c1, c12, pt), new CubicBezierCurve(pt, c23, c3, p3)];
}
var CubicBezierCurve = class extends Curve {
  constructor(p0, p1, p2, p3) {
    super(), this.type = CurveTypeEnum.CubicBezierCurve, this.p0 = p0, this.p1 = p1, this.p2 = p2, this.p3 = p3;
  }
  _validPoint() {
    return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y + this.p2.x + this.p2.y + this.p3.x + this.p3.y);
  }
  getPointAt(t) {
    if (false !== this.defined)
      return cubicPointAt(this.p0, this.p1, this.p2, this.p3, t);
    throw new Error("defined\u4E3Afalse\u7684\u70B9\u4E0D\u80FDgetPointAt");
  }
  calcLength() {
    return this._validPoint() ? cubicLength(this.p0, this.p1, this.p2, this.p3, 0) : 60;
  }
  calcProjLength(direction2) {
    return direction2 === Direction.ROW ? abs(this.p0.x - this.p3.x) : direction2 === Direction.COLUMN ? abs(this.p0.y - this.p3.y) : 0;
  }
  getAngleAt(t) {
    const minT = max(t - 0.01, 0), maxT = min(t + 0.01, 1), minP = this.getPointAt(minT), maxP = this.getPointAt(maxT);
    return atan2(maxP.y - minP.y, maxP.x - minP.x);
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/segment/curve/line
function divideLinear(curve, t) {
  const { p0, p1 } = curve, c1 = PointService.pointAtPP(p0, p1, t);
  return [new LineCurve(p0, c1), new LineCurve(c1, p1)];
}
var LineCurve = class extends Curve {
  constructor(p0, p1) {
    super(), this.type = CurveTypeEnum.LineCurve, this.p0 = p0, this.p1 = p1;
  }
  getPointAt(t) {
    if (false !== this.defined)
      return PointService.pointAtPP(this.p0, this.p1, t);
    throw new Error("defined\u4E3Afalse\u7684\u70B9\u4E0D\u80FDgetPointAt");
  }
  getAngleAt(t) {
    return null == this.angle && (this.angle = atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x)), this.angle;
  }
  _validPoint() {
    return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y);
  }
  calcLength() {
    return this._validPoint() ? PointService.distancePP(this.p0, this.p1) : 60;
  }
  calcProjLength(direction2) {
    return direction2 === Direction.ROW ? abs(this.p0.x - this.p1.x) : direction2 === Direction.COLUMN ? abs(this.p0.y - this.p1.y) : 0;
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/seg-context
var SegContext = class {
  get endX() {
    return this._lastX;
  }
  get endY() {
    return this._lastY;
  }
  constructor(curveType, direction2) {
    this.init(curveType, direction2);
  }
  init(curveType, direction2) {
    this._lastX = this._lastY = this._startX = this._startY = 0, this.curveType = curveType, this.direction = direction2, this.curves = [];
  }
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, defined, p) {
    const curve = new CubicBezierCurve(new Point(this._lastX, this._lastY), new Point(cp1x, cp1y), new Point(cp2x, cp2y), new Point(x, y));
    curve.originP1 = this._lastOriginP, curve.originP2 = p, curve.defined = defined, this.curves.push(curve), this._lastX = x, this._lastY = y, this._lastOriginP = p;
  }
  closePath() {
    if (this.curves.length < 2)
      return;
    const lastCurve = this.curves[this.curves.length - 1];
    this.lineTo(this._startX, this._startY, lastCurve.defined, this._startOriginP);
  }
  ellipse() {
    throw new Error("SegContext\u4E0D\u652F\u6301\u8C03\u7528ellipse");
  }
  lineTo(x, y, defined, p) {
    const curve = this.addLinearCurve(x, y, defined, this._lastOriginP, p);
    this.curves.push(curve), this._lastX = x, this._lastY = y, this._lastOriginP = p;
  }
  moveTo(x, y, p) {
    return this._lastX = this._startX = x, this._lastY = this._startY = y, this._lastOriginP = p, this._startOriginP = p, this;
  }
  quadraticCurveTo(cpx, cpy, x, y) {
    throw new Error("SegContext\u4E0D\u652F\u6301\u8C03\u7528quadraticCurveTo");
  }
  clear() {
    this.curves = [], this.length = NaN;
  }
  tryUpdateLength(direction2) {
    return this.getLength(direction2);
  }
  addLinearCurve(x, y, defined, p1, p2) {
    const curve = new LineCurve(new Point(this._lastX, this._lastY), new Point(x, y));
    return curve.originP1 = p1, curve.originP2 = p2, curve.defined = defined, curve;
  }
  getPointAt(t) {
    throw new Error("\u6682\u672A\u5B9E\u73B0");
  }
  getCurveLengths() {
    return [];
  }
  getLength(direction2) {
    var _a, _b;
    if (direction2 === Direction.COLUMN) {
      if (!this.curves.length)
        return 0;
      const sc = this.curves[0], ec = this.curves[this.curves.length - 1], endP = null !== (_a = ec.p3) && void 0 !== _a ? _a : ec.p1;
      return abs(sc.p0.y - endP.y);
    }
    if (direction2 === Direction.ROW) {
      if (!this.curves.length)
        return 0;
      const sc = this.curves[0], ec = this.curves[this.curves.length - 1], endP = null !== (_b = ec.p3) && void 0 !== _b ? _b : ec.p1;
      return abs(sc.p0.x - endP.x);
    }
    return Number.isFinite(this.length) || (this.length = this.curves.reduce((l, c3) => l + c3.getLength(), 0)), this.length;
  }
};
var ReflectSegContext = class extends SegContext {
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, defined, p) {
    return super.bezierCurveTo(cp1y, cp1x, cp2y, cp2x, y, x, defined, p);
  }
  lineTo(x, y, defined, p) {
    return super.lineTo(y, x, defined, p);
  }
  moveTo(x, y, p) {
    return super.moveTo(y, x, p);
  }
  clear() {
    return super.clear();
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/segment/common
function genCurveSegments(path, points, step = 1) {
  let defined0 = false;
  for (let i = 0, n = points.length; i <= n; i++)
    i >= n === defined0 && ((defined0 = !defined0) ? path.lineStart() : path.lineEnd()), defined0 && path.point(points[i]);
}
function genSegContext(curveType, direction2, points) {
  const curveDirection = null != direction2 ? direction2 : abs(points[points.length - 1].x - points[0].x) > abs(points[points.length - 1].y - points[0].y) ? Direction.ROW : Direction.COLUMN;
  return "monotoneY" === curveType ? new ReflectSegContext(curveType, curveDirection) : new SegContext(curveType, curveDirection);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/segment/linear
var Linear = class {
  constructor(context, startPoint) {
    this.context = context, startPoint && (this.startPoint = startPoint);
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0, this.startPoint && this.point(this.startPoint);
  }
  lineEnd() {
    (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line = 1 - this._line;
  }
  point(p) {
    const x = p.x, y = p.y;
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this.context.lineTo(x, y, false !== this._lastDefined && false !== p.defined, p) : this.context.moveTo(x, y, p);
        break;
      case 1:
        this._point = 2;
      default:
        this.context.lineTo(x, y, false !== this._lastDefined && false !== p.defined, p);
    }
    this._lastDefined = p.defined;
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
};
function genLinearSegments(points, params2 = {}) {
  const { direction: direction2, startPoint } = params2;
  if (points.length < 2 - Number(!!startPoint))
    return null;
  const segContext = genSegContext("linear", direction2, points);
  return genLinearTypeSegments(new Linear(segContext, startPoint), points), segContext;
}
function genLinearTypeSegments(path, points) {
  return genCurveSegments(path, points, 1);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/segment/basis
function point(curveClass, x, y, defined, p) {
  curveClass.context.bezierCurveTo((2 * curveClass._x0 + curveClass._x1) / 3, (2 * curveClass._y0 + curveClass._y1) / 3, (curveClass._x0 + 2 * curveClass._x1) / 3, (curveClass._y0 + 2 * curveClass._y1) / 3, (curveClass._x0 + 4 * curveClass._x1 + x) / 6, (curveClass._y0 + 4 * curveClass._y1 + y) / 6, defined, curveClass.lastPoint1);
}
var Basis = class {
  constructor(context, startPoint) {
    this.context = context, this.startPoint = startPoint;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);
  }
  lineEnd() {
    if (2 === this._point)
      point(this, 6 * this._x1 - (this._x0 + 4 * this._x1), 6 * this._y1 - (this._y0 + 4 * this._y1), false !== this._lastDefined1 && false !== this._lastDefined2, this.lastPoint1);
    (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line = 1 - this._line;
  }
  point(p) {
    const x = p.x, y = p.y;
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this.context.lineTo(x, y, false !== this._lastDefined1 && false !== this._lastDefined2, p) : this.context.moveTo(x, y, p);
        break;
      case 1:
        this._point = 2;
        break;
      default:
        point(this, x, y, false !== this._lastDefined1 && false !== this._lastDefined2, p);
    }
    this._x0 = this._x1, this._x1 = x, this._y0 = this._y1, this._y1 = y, this._lastDefined1 = this._lastDefined2, this._lastDefined2 = p.defined, this.lastPoint0 = this.lastPoint1, this.lastPoint1 = p;
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
};
function genBasisTypeSegments(path, points) {
  return genCurveSegments(path, points, 2);
}
function genBasisSegments(points, params2 = {}) {
  const { direction: direction2, startPoint } = params2;
  if (points.length < 2 - Number(!!startPoint))
    return null;
  if (points.length < 3 - Number(!!startPoint))
    return genLinearSegments(points, params2);
  const segContext = genSegContext("basis", direction2, points);
  return genBasisTypeSegments(new Basis(segContext, startPoint), points), segContext;
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/segment/monotone
function sign2(x) {
  return x < 0 ? -1 : 1;
}
function slope3(curveClass, x23, y23) {
  const h0 = curveClass._x1 - curveClass._x0, h1 = x23 - curveClass._x1, s0 = (curveClass._y1 - curveClass._y0) / (h0 || Number(h1 < 0 && -0)), s1 = (y23 - curveClass._y1) / (h1 || Number(h0 < 0 && -0)), p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign2(s0) + sign2(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
function slope2(curveClass, t) {
  const h = curveClass._x1 - curveClass._x0;
  return h ? (3 * (curveClass._y1 - curveClass._y0) / h - t) / 2 : t;
}
function point2(curveClass, t0, t1, defined, p) {
  const x05 = curveClass._x0, y05 = curveClass._y0, x14 = curveClass._x1, y14 = curveClass._y1, dx = (x14 - x05) / 3;
  curveClass.context.bezierCurveTo(x05 + dx, y05 + dx * t0, x14 - dx, y14 - dx * t1, x14, y14, defined, curveClass.lastPoint1);
}
var MonotoneX = class {
  constructor(context, startPoint) {
    this.context = context, this.startPoint = startPoint;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);
  }
  lineEnd() {
    switch (this._point) {
      case 2:
        this.context.lineTo(this._x1, this._y1, false !== this._lastDefined1 && false !== this._lastDefined2, this.lastPoint1);
        break;
      case 3:
        point2(this, this._t0, slope2(this, this._t0), false !== this._lastDefined1 && false !== this._lastDefined2, this.lastPoint1);
    }
    (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line = 1 - this._line;
  }
  point(p) {
    let t1 = NaN;
    const x = p.x, y = p.y;
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this.context.lineTo(x, y, false !== this._lastDefined1 && false !== this._lastDefined2, p) : this.context.moveTo(x, y, p);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, point2(this, slope2(this, t1 = slope3(this, x, y)), t1, false !== this._lastDefined1 && false !== this._lastDefined2, p);
        break;
      default:
        point2(this, this._t0, t1 = slope3(this, x, y), false !== this._lastDefined1 && false !== this._lastDefined2, p);
    }
    this._x0 = this._x1, this._x1 = x, this._y0 = this._y1, this._y1 = y, this._t0 = t1, this._lastDefined1 = this._lastDefined2, this._lastDefined2 = false !== p.defined, this.lastPoint0 = this.lastPoint1, this.lastPoint1 = p;
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
};
var MonotoneY = class extends MonotoneX {
  constructor(context, startPoint) {
    super(context, startPoint);
  }
  point(p) {
    return super.point({
      y: p.x,
      x: p.y,
      defined: p.defined
    });
  }
};
function genMonotoneXTypeSegments(path, points) {
  return genCurveSegments(path, points, 2);
}
function genMonotoneXSegments(points, params2 = {}) {
  const { direction: direction2, startPoint } = params2;
  if (points.length < 2 - Number(!!startPoint))
    return null;
  if (points.length < 3 - Number(!!startPoint))
    return genLinearSegments(points, params2);
  const segContext = genSegContext("monotoneX", direction2, points);
  return genMonotoneXTypeSegments(new MonotoneX(segContext, startPoint), points), segContext;
}
function genMonotoneYTypeSegments(path, points) {
  return genCurveSegments(path, points, 2);
}
function genMonotoneYSegments(points, params2 = {}) {
  const { direction: direction2, startPoint } = params2;
  if (points.length < 2 - Number(!!startPoint))
    return null;
  if (points.length < 3 - Number(!!startPoint))
    return genLinearSegments(points, params2);
  const segContext = genSegContext("monotoneY", direction2, points);
  return genMonotoneYTypeSegments(new MonotoneY(segContext, startPoint), points), segContext;
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/segment/step
var Step = class {
  constructor(context, t = 0.5, startPoint) {
    this.context = context, this._t = t, this.startPoint = startPoint;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._x = this._y = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);
  }
  lineEnd() {
    0 < this._t && this._t < 1 && 2 === this._point && this.context.lineTo(this._x, this._y, false !== this._lastDefined, this.lastPoint), (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  }
  point(p) {
    const x = p.x, y = p.y;
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this.context.lineTo(x, y, false !== this._lastDefined && false !== p.defined, p) : this.context.moveTo(x, y, p);
        break;
      case 1:
        this._point = 2;
      default:
        if (this._t <= 0)
          this.context.lineTo(this._x, y, false !== this._lastDefined && false !== p.defined, this.lastPoint), this.context.lineTo(x, y, false !== this._lastDefined && false !== p.defined, p);
        else {
          const x14 = this._x * (1 - this._t) + x * this._t;
          this.context.lineTo(x14, this._y, false !== this._lastDefined && false !== p.defined, this.lastPoint), this.context.lineTo(x14, y, false !== this._lastDefined && false !== p.defined, p);
        }
    }
    this._lastDefined = p.defined, this._x = x, this._y = y, this.lastPoint = p;
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
};
function genStepSegments(points, t, params2 = {}) {
  const { direction: direction2, startPoint } = params2;
  if (points.length < 2 - Number(!!startPoint))
    return null;
  const segContext = new SegContext("step", null != direction2 ? direction2 : abs(points[points.length - 1].x - points[0].x) > abs(points[points.length - 1].y - points[0].y) ? Direction.ROW : Direction.COLUMN);
  return genStepTypeSegments(new Step(segContext, t, startPoint), points), segContext;
}
function genStepTypeSegments(path, points) {
  return genCurveSegments(path, points, 1);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/segment/linear-closed
var LinearClosed = class extends Linear {
  lineEnd() {
    this.context.closePath();
  }
};
function genLinearClosedSegments(points, params2 = {}) {
  const { direction: direction2, startPoint } = params2;
  if (points.length < 2 - Number(!!startPoint))
    return null;
  const segContext = genSegContext("linear", direction2, points);
  return genLinearClosedTypeSegments(new LinearClosed(segContext, startPoint), points), segContext;
}
function genLinearClosedTypeSegments(path, points) {
  return genCurveSegments(path, points, 1);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/segment
function calcLineCache(points, curveType, params2) {
  switch (curveType) {
    case "linear":
    default:
      return genLinearSegments(points, params2);
    case "basis":
      return genBasisSegments(points, params2);
    case "monotoneX":
      return genMonotoneXSegments(points, params2);
    case "monotoneY":
      return genMonotoneYSegments(points, params2);
    case "step":
      return genStepSegments(points, 0.5, params2);
    case "stepBefore":
      return genStepSegments(points, 0, params2);
    case "stepAfter":
      return genStepSegments(points, 1, params2);
    case "linearClosed":
      return genLinearClosedSegments(points, params2);
  }
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/custom-path2d
var CustomPath2D = class extends CurvePath {
  constructor(ctx) {
    super(), this.commandList = [], ctx && (this._ctx = ctx), this._boundsContext = new BoundsContext(this.bounds);
  }
  setCtx(ctx) {
    this._ctx = ctx;
  }
  moveTo(x, y) {
    return this.commandList.push([enumCommandMap.M, x, y]), this._ctx && this._ctx.moveTo(x, y), this;
  }
  lineTo(x, y) {
    return this.commandList.push([enumCommandMap.L, x, y]), this._ctx && this._ctx.lineTo(x, y), this;
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    return this.commandList.push([enumCommandMap.Q, aCPx, aCPy, aX, aY]), this._ctx && this._ctx.quadraticCurveTo(aCPx, aCPy, aX, aY), this;
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    return this.commandList.push([enumCommandMap.C, aCP1x, aCP1y, aCP2x, aCP2y, aX, aY]), this._ctx && this._ctx.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY), this;
  }
  arcTo(aX1, aY1, aX2, aY2, aRadius) {
    return this.commandList.push([enumCommandMap.AT, aX1, aY1, aX2, aY2, aRadius]), this._ctx && this._ctx.arcTo(aX1, aY1, aX2, aY2, aRadius), this;
  }
  ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise) {
    return this.commandList.push([enumCommandMap.E, aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise]), this._ctx && this._ctx.ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise), this;
  }
  rect(x, y, w, h) {
    return this.commandList.push([enumCommandMap.R, x, y, w, h]), this._ctx && this._ctx.rect(x, y, w, h), this;
  }
  arc(x, y, radius, startAngle, endAngle, counterclockwise) {
    return this.commandList.push([enumCommandMap.A, x, y, radius, startAngle, endAngle, counterclockwise]), this._ctx && this._ctx.arc(x, y, radius, startAngle, endAngle, counterclockwise), this;
  }
  closePath() {
    return this.commandList.push([enumCommandMap.Z]), this._ctx && this._ctx.closePath(), this;
  }
  addCurve(curve) {
    this.curves.push(curve);
  }
  clear() {
    this.transformCbList = null, this.commandList.length = 0, this.curves.length = 0;
  }
  beginPath() {
    this.clear();
  }
  toString() {
    if (!this.toStringCbList) {
      const list2 = [];
      list2[enumCommandMap.M] = (cmd) => `M${cmd[1]} ${cmd[2]}`, list2[enumCommandMap.L] = (cmd) => `L${cmd[1]} ${cmd[2]}`, list2[enumCommandMap.Q] = (cmd) => `Q${cmd[1]} ${cmd[2]} ${cmd[3]} ${cmd[4]}`, list2[enumCommandMap.C] = (cmd) => `C${cmd[1]} ${cmd[2]} ${cmd[3]} ${cmd[4]} ${cmd[5]} ${cmd[6]}`, list2[enumCommandMap.A] = (cmd) => {
        const bezierPathList = [];
        addArcToBezierPath(bezierPathList, cmd[4], cmd[5], cmd[1], cmd[2], cmd[3], cmd[3]);
        let path2 = "";
        for (let i = 0; i < bezierPathList.length; i += 6)
          path2 += `C${bezierPathList[i]} ${bezierPathList[i + 1]} ${bezierPathList[i + 2]} ${bezierPathList[i + 3]} ${bezierPathList[i + 4]} ${bezierPathList[i + 5]}`;
        return path2;
      }, list2[enumCommandMap.R] = (cmd) => `M${cmd[1]} ${cmd[2]} h${cmd[3]} v${cmd[4]} H${cmd[1]}Z`, list2[enumCommandMap.Z] = (cmd) => "Z", this.toStringCbList = list2;
    }
    const list = this.toStringCbList;
    let path = "";
    return this.commandList.forEach((c3) => {
      path += list[c3[0]](c3);
    }), path;
  }
  fromString(str, x, y, sX, sY) {
    this.clear();
    const commandStrList = parseSvgPath(str);
    return this._runCommandStrList(commandStrList, x, y, sX, sY), this._updateBounds(), this;
  }
  fromLine(line2) {
    const { points, curveType, clipRangeByDimension } = line2.attribute;
    if (!points)
      return;
    const cache = calcLineCache(points, curveType);
    "x" === clipRangeByDimension ? this.direction = Direction.ROW : "y" === clipRangeByDimension ? this.direction = Direction.COLUMN : "auto" === clipRangeByDimension && (this.direction = cache.direction), this.curves = cache.curves;
  }
  fromCustomPath2D(path, x, y, sX, sY) {
    return this.clear(), this._runCommandList(path.commandList, x, y, sX, sY), this._updateBounds(), this;
  }
  transform(x, y, sx, sy) {
    const commandList = this.commandList;
    if (!this.transformCbList) {
      const list = [];
      list[enumCommandMap.M] = this.moveToTransform, list[enumCommandMap.L] = this.lineToTransform, list[enumCommandMap.Q] = this.quadraticCurveToTransform, list[enumCommandMap.C] = this.bezierCurveToTransform, list[enumCommandMap.AT] = this.arcToTransform, list[enumCommandMap.E] = this.ellipseTransform, list[enumCommandMap.R] = this.rectTransform, list[enumCommandMap.A] = this.arcTransform, list[enumCommandMap.Z] = this.closePathTransform, this.transformCbList = list;
    }
    commandList.forEach((cmd) => {
      this.transformCbList[cmd[0]](cmd, x, y, sx, sy);
    }), this._updateBounds();
  }
  moveToTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y;
  }
  lineToTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y;
  }
  quadraticCurveToTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx + x, cmd[4] = cmd[4] * sy + y;
  }
  bezierCurveToTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx + x, cmd[4] = cmd[4] * sy + y, cmd[5] = cmd[5] * sx + x, cmd[6] = cmd[6] * sy + y;
  }
  arcToTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx + x, cmd[4] = cmd[4] * sy + y, cmd[5] = cmd[5] * (sx + sy) / 2;
  }
  ellipseTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx, cmd[4] = cmd[4] * sy;
  }
  rectTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx, cmd[4] = cmd[4] * sy;
  }
  arcTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * (sx + sy) / 2;
  }
  closePathTransform() {
  }
  _runCommandStrList(commandStrList, l = 0, t = 0, sX = 1, sY = 1) {
    let current, tempX, tempY, tempControlX, tempControlY, previous = null, x = 0, y = 0, controlX = 0, controlY = 0;
    for (let i = 0, len = commandStrList.length; i < len; ++i) {
      switch (current = commandStrList[i], 1 === sX && 1 === sY || (current = scale(current, sX, sY)), current[0]) {
        case "l":
          x += current[1], y += current[2], this.lineTo(x + l, y + t);
          break;
        case "L":
          x = current[1], y = current[2], this.lineTo(x + l, y + t);
          break;
        case "h":
          x += current[1], this.lineTo(x + l, y + t);
          break;
        case "H":
          x = current[1], this.lineTo(x + l, y + t);
          break;
        case "v":
          y += current[1], this.lineTo(x + l, y + t);
          break;
        case "V":
          y = current[1], this.lineTo(x + l, y + t);
          break;
        case "m":
          x += current[1], y += current[2], this.moveTo(x + l, y + t);
          break;
        case "M":
          x = current[1], y = current[2], this.moveTo(x + l, y + t);
          break;
        case "c":
          tempX = x + current[5], tempY = y + current[6], controlX = x + current[3], controlY = y + current[4], this.bezierCurveTo(x + current[1] + l, y + current[2] + t, controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, y = tempY;
          break;
        case "C":
          x = current[5], y = current[6], controlX = current[3], controlY = current[4], this.bezierCurveTo(current[1] + l, current[2] + t, controlX + l, controlY + t, x + l, y + t);
          break;
        case "s":
          tempX = x + current[3], tempY = y + current[4], controlX = 2 * x - controlX, controlY = 2 * y - controlY, this.bezierCurveTo(controlX + l, controlY + t, x + current[1] + l, y + current[2] + t, tempX + l, tempY + t), controlX = x + current[1], controlY = y + current[2], x = tempX, y = tempY;
          break;
        case "S":
          tempX = current[3], tempY = current[4], controlX = 2 * x - controlX, controlY = 2 * y - controlY, this.bezierCurveTo(controlX + l, controlY + t, current[1] + l, current[2] + t, tempX + l, tempY + t), x = tempX, y = tempY, controlX = current[1], controlY = current[2];
          break;
        case "q":
          tempX = x + current[3], tempY = y + current[4], controlX = x + current[1], controlY = y + current[2], this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, y = tempY;
          break;
        case "Q":
          tempX = current[3], tempY = current[4], this.quadraticCurveTo(current[1] + l, current[2] + t, tempX + l, tempY + t), x = tempX, y = tempY, controlX = current[1], controlY = current[2];
          break;
        case "t":
          tempX = x + current[1], tempY = y + current[2], null === previous[0].match(/[QqTt]/) ? (controlX = x, controlY = y) : "t" === previous[0] ? (controlX = 2 * x - tempControlX, controlY = 2 * y - tempControlY) : "q" === previous[0] && (controlX = 2 * x - controlX, controlY = 2 * y - controlY), tempControlX = controlX, tempControlY = controlY, this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, y = tempY, controlX = x + current[1], controlY = y + current[2];
          break;
        case "T":
          tempX = current[1], tempY = current[2], controlX = 2 * x - controlX, controlY = 2 * y - controlY, this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, y = tempY;
          break;
        case "a":
          drawArc(this, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + x + l, current[7] + y + t]), x += current[6], y += current[7];
          break;
        case "A":
          drawArc(this, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + l, current[7] + t]), x = current[6], y = current[7];
          break;
        case "z":
        case "Z":
          this.closePath();
      }
      previous = current;
    }
  }
  _runCommandList(commandList, l = 0, t = 0, sX = 1, sY = 1) {
    if (0 !== l || 0 !== t || 1 !== sX || 1 !== sY)
      for (let i = 0, len = commandList.length; i < len; ++i) {
        const current = commandList[i].slice();
        switch (current[0]) {
          case enumCommandMap.L:
            this.lineToTransform(current, l, t, sX, sY);
            break;
          case enumCommandMap.M:
            this.moveToTransform(current, l, t, sX, sY);
            break;
          case enumCommandMap.C:
            this.bezierCurveToTransform(current, l, t, sX, sY);
            break;
          case enumCommandMap.Q:
            this.quadraticCurveToTransform(current, l, t, sX, sY);
            break;
          case enumCommandMap.A:
            this.arcToTransform(current, l, t, sX, sY);
            break;
          case enumCommandMap.E:
            this.ellipseTransform(current, l, t, sX, sY);
            break;
          case enumCommandMap.R:
            this.rectTransform(current, l, t, sX, sY);
            break;
          case enumCommandMap.AT:
            this.arcToTransform(current, l, t, sX, sY);
            break;
          case enumCommandMap.Z:
            this.closePath();
        }
      }
    else
      this.commandList = commandList.map((entry) => entry.slice());
  }
  _updateBounds() {
    this.bounds.clear(), renderCommandList(this.commandList, this._boundsContext);
  }
  release() {
    this.commandList = [], this._boundsContext = null, this._ctx = null;
  }
  getLength() {
    if (this.direction === Direction.COLUMN) {
      if (!this.curves.length)
        return 0;
      const sc = this.curves[0], ec = this.curves[this.curves.length - 1];
      return abs(sc.p0.y - ec.p1.y);
    }
    if (this.direction === Direction.ROW) {
      if (!this.curves.length)
        return 0;
      const sc = this.curves[0], ec = this.curves[this.curves.length - 1];
      return abs(sc.p0.x - ec.p1.x);
    }
    return this.curves.reduce((l, c3) => l + c3.getLength(), 0);
  }
  getAttrAt(distance2) {
    if (!this.curves)
      return {
        pos: {
          x: 0,
          y: 0
        },
        angle: 0
      };
    let curve, _dis = 0;
    for (let i = 0; i < this.curves.length; i++) {
      curve = this.curves[i];
      const cl = curve.getLength(this.direction);
      if (_dis + cl >= distance2)
        break;
      _dis += cl;
    }
    const t = (distance2 - _dis) / curve.getLength(this.direction);
    return {
      pos: curve.getPointAt(t),
      angle: curve.getAngleAt(t)
    };
  }
};
var temp2 = ["l", 0, 0, 0, 0, 0, 0, 0];
function scale(current, sX, sY) {
  const c3 = temp2[0] = current[0];
  if ("a" === c3 || "A" === c3)
    temp2[1] = sX * current[1], temp2[2] = sY * current[2], temp2[3] = current[3], temp2[4] = current[4], temp2[5] = current[5], temp2[6] = sX * current[6], temp2[7] = sY * current[7];
  else if ("h" === c3 || "H" === c3)
    temp2[1] = sX * current[1];
  else if ("v" === c3 || "V" === c3)
    temp2[1] = sY * current[1];
  else
    for (let i = 1, n = current.length; i < n; ++i)
      temp2[i] = (i % 2 == 1 ? sX : sY) * current[i];
  return temp2;
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/config
var DefaultLayout = {
  alignSelf: "auto"
};
var DefaultTransform = {
  x: 0,
  y: 0,
  z: 0,
  dx: 0,
  dy: 0,
  dz: 0,
  scrollX: 0,
  scrollY: 0,
  scaleX: 1,
  scaleY: 1,
  scaleZ: 1,
  angle: 0,
  alpha: 0,
  beta: 0,
  scaleCenter: [0, 0],
  anchor: [0, 0],
  anchor3d: [0, 0],
  postMatrix: new Matrix()
};
var DefaultFillStyle = {
  fillOpacity: 1,
  fill: false,
  shadowBlur: 0,
  shadowColor: "black",
  shadowOffsetX: 0,
  shadowOffsetY: 0
};
var commonStroke = {
  strokeOpacity: 1,
  lineDash: [],
  lineDashOffset: 0,
  lineWidth: 1,
  lineCap: "butt",
  lineJoin: "miter",
  miterLimit: 10,
  strokeBoundsBuffer: 2,
  stroke: false
};
var DefaultStrokeStyle = Object.assign({
  outerBorder: Object.assign(Object.assign({}, commonStroke), {
    distance: 0
  }),
  innerBorder: Object.assign(Object.assign({}, commonStroke), {
    distance: 0
  })
}, commonStroke);
var DefaultTextStyle = {
  text: "",
  maxLineWidth: 1 / 0,
  textAlign: "left",
  textBaseline: "alphabetic",
  fontSize: 16,
  fontFamily: "PingFang SC,Microsoft Yahei,system-ui,-apple-system,segoe ui,\n    Roboto,Helvetica,Arial,sans-serif, apple color emoji,segoe ui emoji,segoe ui symbol",
  fontWeight: "",
  ellipsis: "\u2026",
  fontVariant: "",
  fontStyle: "",
  lineHeight: void 0,
  underline: 0,
  lineThrough: 0,
  scaleIn3d: false,
  direction: "horizontal",
  wordBreak: "break-all",
  ignoreBuf: false,
  verticalMode: 0,
  wrap: false,
  whiteSpace: "no-wrap",
  heightLimit: 1 / 0,
  lineClamp: 1 / 0,
  suffixPosition: "end",
  underlineDash: [],
  underlineOffset: 0,
  disableAutoClipedPoptip: void 0
};
var DefaultPickStyle = {
  pickStrokeBuffer: 0
};
var DefaultStyle = Object.assign(Object.assign(Object.assign(Object.assign({
  forceBoundsWidth: void 0,
  forceBoundsHeight: void 0,
  opacity: 1,
  background: null,
  backgroundOpacity: 1,
  backgroundCornerRadius: 0,
  texture: null,
  textureColor: "black",
  textureSize: 10,
  texturePadding: 2,
  backgroundMode: "no-repeat",
  backgroundFit: true,
  blur: 0,
  cursor: null,
  html: null,
  react: null
}, DefaultFillStyle), DefaultStrokeStyle), DefaultLayout), DefaultPickStyle);
var DefaultConnectAttribute = {
  connectedType: "none",
  connectedStyle: {},
  connectedX: NaN,
  connectedY: NaN
};
var DefaultDebugAttribute = {
  _debug_bounds: false
};
var DefaultAttribute = Object.assign(Object.assign(Object.assign({
  strokeSeg: null,
  renderable: true,
  pickable: true,
  shadowGraphic: void 0,
  childrenPickable: true,
  fillPickable: true,
  strokePickable: true,
  visible: true,
  zIndex: 0,
  layout: null,
  boundsPadding: 0,
  renderStyle: "default",
  pickMode: "accurate",
  customPickShape: null,
  boundsMode: "accurate",
  keepDirIn3d: true,
  shadowRootIdx: 1,
  globalZIndex: 1,
  globalCompositeOperation: "",
  overflow: "hidden"
}, DefaultDebugAttribute), DefaultStyle), DefaultTransform);
var DefaultArcAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  startAngle: 0,
  endAngle: pi2,
  innerRadius: 0,
  outerRadius: 1,
  innerPadding: 0,
  outerPadding: 0,
  cornerRadius: 0,
  padRadius: 0,
  padAngle: 0,
  cap: false,
  forceShowCap: false
});
var DefaultAreaAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultConnectAttribute), {
  points: [],
  segments: [],
  curveType: "linear",
  clipRange: 1,
  closePath: false
});
var DefaultCircleAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  radius: 1,
  startAngle: 0,
  endAngle: pi2
});
var DefaultGroupAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  width: 0,
  height: 0,
  cornerRadius: 0,
  path: [],
  clip: false,
  visibleAll: true,
  display: "relative",
  flexDirection: "row",
  flexWrap: "wrap",
  justifyContent: "flex-start",
  alignItems: "flex-start",
  alignContent: "flex-start",
  baseOpacity: 1
});
var DefaultGlyphAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  path: "",
  width: 0,
  height: 0,
  cornerRadius: 0,
  clip: false
});
var DefaultLineAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultConnectAttribute), {
  points: [],
  segments: [],
  curveType: "linear",
  clipRange: 1,
  clipRangeByDimension: "default",
  closePath: false
});
var DefaultPathAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  path: new CustomPath2D(),
  customPath: () => {
    Logger.getInstance().warn("\u7A7A\u51FD\u6570");
  }
});
var DefaultPolygonAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  points: [],
  cornerRadius: 0,
  closePath: true
});
var DefaultRectAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  width: 0,
  height: 0,
  x1: 0,
  y1: 0,
  strokeBoundsBuffer: 0,
  cornerRadius: 0
});
var DefaultRect3dAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  width: 0,
  height: 0,
  x1: 0,
  y1: 0,
  cornerRadius: 0,
  length: 0
});
var DefaultSymbolAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  symbolType: "circle",
  size: 10,
  keepDirIn3d: true
});
var DefaultTextAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultTextStyle), {
  strokeBoundsBuffer: 0,
  keepDirIn3d: true
});
var DefaultRichTextAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultTextStyle), {
  width: 300,
  height: 300,
  ellipsis: true,
  wordBreak: "break-word",
  verticalDirection: "top",
  textAlign: "left",
  textBaseline: "top",
  layoutDirection: "horizontal",
  textConfig: [],
  disableAutoWrapLine: false,
  maxHeight: void 0,
  maxWidth: void 0,
  singleLine: false
});
var DefaultImageAttribute = Object.assign(Object.assign({
  repeatX: "no-repeat",
  repeatY: "no-repeat",
  image: "",
  width: 0,
  height: 0
}, DefaultAttribute), {
  fill: true,
  cornerRadius: 0
});
var DefaultRichTextIconAttribute = Object.assign(Object.assign({}, DefaultImageAttribute), {
  backgroundShowMode: "never",
  backgroundWidth: 0,
  backgroundHeight: 0,
  textAlign: "left",
  textBaseline: "middle",
  direction: "horizontal",
  margin: 0,
  id: "",
  width: 20,
  height: 20,
  backgroundFill: "rgba(101, 117, 168, 0.1)",
  backgroundFillOpacity: 1,
  backgroundStroke: false,
  backgroundStrokeOpacity: 1,
  backgroundRadius: 4,
  opacity: 1
});

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/application
var Application = class {
};
var application = new Application();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/richtext/utils
var DIRECTION_KEY = {
  horizontal: {
    width: "width",
    height: "height",
    left: "left",
    top: "top",
    x: "x",
    y: "y",
    bottom: "bottom"
  },
  vertical: {
    width: "height",
    height: "width",
    left: "top",
    top: "left",
    x: "y",
    y: "x",
    bottom: "right"
  }
};
var defaultFormatting = {
  fontSize: 16,
  fontFamily: "sans-serif",
  fill: true,
  stroke: false,
  fontWeight: "normal",
  lineHeight: "normal",
  fontStyle: "normal",
  textDecoration: "none",
  textAlign: "left",
  script: "normal"
};
var nbsp = String.fromCharCode(160);
var regLetter = /\w|\(|\)|-/;
var regPunctuation = /[.?!,;:/]/;
var regFirstSpace = /\S/;
function applyFillStyle(ctx, character) {
  const fillStyle = character && character.fill || defaultFormatting.fill;
  if (!fillStyle)
    return void (ctx.globalAlpha = 0);
  const { fillOpacity = 1, opacity = 1 } = character;
  ctx.globalAlpha = fillOpacity * opacity, ctx.fillStyle = fillStyle;
  let fontSize = character.fontSize || 16;
  switch (character.script) {
    case "super":
    case "sub":
      fontSize *= 0.8;
  }
  ctx.setTextStyle({
    textAlign: "left",
    textBaseline: character.textBaseline || "alphabetic",
    fontStyle: character.fontStyle || "",
    fontWeight: character.fontWeight || "",
    fontSize,
    fontFamily: character.fontFamily || "sans-serif"
  });
}
function applyStrokeStyle(ctx, character) {
  const strokeStyle = character && character.stroke || defaultFormatting.stroke;
  if (!strokeStyle)
    return void (ctx.globalAlpha = 0);
  const { strokeOpacity = 1, opacity = 1 } = character;
  ctx.globalAlpha = strokeOpacity * opacity, ctx.lineWidth = character && "number" == typeof character.lineWidth ? character.lineWidth : 1, ctx.strokeStyle = strokeStyle;
  let fontSize = character.fontSize || 16;
  switch (character.script) {
    case "super":
    case "sub":
      fontSize *= 0.8;
  }
  ctx.setTextStyle({
    textAlign: "left",
    textBaseline: character.textBaseline || "alphabetic",
    fontStyle: character.fontStyle || "",
    fontWeight: character.fontWeight || "",
    fontSize,
    fontFamily: character.fontFamily || "sans-serif"
  });
}
function getStrByWithCanvas(desc, width, character, guessIndex, needTestLetter) {
  if (!width || width <= 0)
    return 0;
  const textMeasure = application.graphicUtil.textMeasure;
  let index = guessIndex, temp3 = desc.slice(0, index), tempWidth = Math.floor(textMeasure.measureText(temp3, character).width), tempNext = desc.slice(0, index + 1), tempWidthNext = Math.floor(textMeasure.measureText(tempNext, character).width);
  for (; tempWidth > width || tempWidthNext <= width; ) {
    if (tempWidth > width ? index-- : index++, index > desc.length) {
      index = desc.length;
      break;
    }
    if (index < 0) {
      index = 0;
      break;
    }
    temp3 = desc.slice(0, index), tempWidth = Math.floor(textMeasure.measureText(temp3, character).width), tempNext = desc.slice(0, index + 1), tempWidthNext = Math.floor(textMeasure.measureText(tempNext, character).width);
  }
  return needTestLetter && (index = testLetter(desc, index)), index;
}
function testLetter(string, index) {
  let i = index;
  for (; regLetter.test(string[i - 1]) && regLetter.test(string[i]) || regPunctuation.test(string[i]); )
    if (i--, i <= 0)
      return index;
  return i;
}
function measureTextCanvas(text2, character) {
  const measurement = application.graphicUtil.textMeasure.measureText(text2, character), result2 = {
    ascent: 0,
    height: 0,
    descent: 0,
    width: 0
  };
  return "number" != typeof measurement.actualBoundingBoxAscent || "number" != typeof measurement.actualBoundingBoxDescent ? (result2.width = Math.floor(measurement.width), result2.height = character.fontSize || 0, result2.ascent = result2.height, result2.descent = 0) : (result2.width = Math.floor(measurement.width), result2.height = Math.floor(measurement.actualBoundingBoxAscent + measurement.actualBoundingBoxDescent), result2.ascent = Math.floor(measurement.actualBoundingBoxAscent), result2.descent = result2.height - result2.ascent), result2;
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/core/contributions/textMeasure/AtextMeasure
var __decorate2 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var ATextMeasure = class {
  configure(service, env) {
    this.canvas = service.canvas, this.context = service.context, service.bindTextMeasure(this);
  }
  measureTextWidth(text2, options) {
    if (!this.context)
      return this.estimate(text2, options).width;
    this.context.setTextStyleWithoutAlignBaseline(options);
    return this.context.measureText(text2).width;
  }
  estimate(text2, { fontSize = DefaultTextAttribute.fontSize }) {
    let eCharLen = 0, cCharLen = 0;
    for (let i = 0; i < text2.length; i++)
      text2.charCodeAt(i) < 128 ? eCharLen++ : cCharLen++;
    return {
      width: ~~(0.8 * eCharLen * fontSize + cCharLen * fontSize),
      height: fontSize
    };
  }
  measureTextPixelHeight(text2, options) {
    var _a;
    if (!this.context)
      return null !== (_a = options.fontSize) && void 0 !== _a ? _a : DefaultTextStyle.fontSize;
    this.context.setTextStyleWithoutAlignBaseline(options);
    const textMeasure = this.context.measureText(text2);
    return Math.abs(textMeasure.actualBoundingBoxAscent - textMeasure.actualBoundingBoxDescent);
  }
  measureTextBoundHieght(text2, options) {
    var _a;
    if (!this.context)
      return null !== (_a = options.fontSize) && void 0 !== _a ? _a : DefaultTextStyle.fontSize;
    this.context.setTextStyleWithoutAlignBaseline(options);
    const textMeasure = this.context.measureText(text2);
    return Math.abs(textMeasure.fontBoundingBoxAscent - textMeasure.fontBoundingBoxDescent);
  }
  measureText(text2, options) {
    return this.context ? (this.context.setTextStyleWithoutAlignBaseline(options), this.context.measureText(text2)) : this.estimate(text2, options);
  }
  clipTextVertical(verticalList, options, width, wordBreak) {
    if (0 === verticalList.length)
      return {
        verticalList,
        width: 0
      };
    const { fontSize = 12 } = options;
    verticalList.forEach((item) => {
      item.width = 0 === item.direction ? fontSize : this.measureTextWidth(item.text, options);
    });
    const out = [];
    let length2 = 0, i = 0;
    for (; i < verticalList.length && length2 + verticalList[i].width < width; i++)
      length2 += verticalList[i].width, out.push(verticalList[i]);
    if (verticalList[i] && verticalList[i].text.length > 1) {
      const clipedData = this._clipText(verticalList[i].text, options, width - length2, 0, verticalList[i].text.length - 1, "end", false);
      if (wordBreak && clipedData.str !== verticalList[i].text) {
        let text2 = "", length3 = 0;
        for (let j = 0; j < i; j++) {
          const item = verticalList[j];
          text2 += item.text, length3 += item.text.length;
        }
        text2 += verticalList[i].text;
        const totalLength = length3 + clipedData.str.length;
        let index = testLetter(text2, totalLength);
        index -= length3, index !== clipedData.str.length - 1 && (clipedData.str = clipedData.str.substring(0, index), clipedData.width = this.measureTextWidth(clipedData.str, options));
      }
      out.push(Object.assign(Object.assign({}, verticalList[i]), {
        text: clipedData.str,
        width: clipedData.width
      })), length2 += clipedData.width;
    }
    return {
      verticalList: out,
      width: length2
    };
  }
  clipText(text2, options, width, wordBreak) {
    if (0 === text2.length)
      return {
        str: "",
        width: 0
      };
    let length2 = this.measureTextWidth(text2, options);
    if (length2 <= width)
      return {
        str: text2,
        width: length2
      };
    if (length2 = this.measureTextWidth(text2[0], options), length2 > width)
      return {
        str: "",
        width: 0
      };
    const data = this._clipText(text2, options, width, 0, text2.length - 1, "end", false);
    if (wordBreak && data.str !== text2) {
      const index = testLetter(text2, data.str.length);
      index !== data.str.length && (data.str = text2.substring(0, index), data.width = this.measureTextWidth(data.str, options));
    }
    return data;
  }
  _clipText(text2, options, width, leftIdx, rightIdx, position, suffix) {
    let data;
    if ("start" === position)
      data = this._clipTextStart(text2, options, width, leftIdx, rightIdx), suffix && (data.result = suffix + data.str);
    else if ("middle" === position) {
      const d = this._clipTextMiddle(text2, options, width, "", "", 0, 0, 1);
      data = {
        str: "none",
        width: d.width,
        result: d.left + suffix + d.right
      };
    } else
      data = this._clipTextEnd(text2, options, width, leftIdx, rightIdx), suffix && (data.result = data.str + suffix);
    return data;
  }
  _clipTextEnd(text2, options, width, leftIdx, rightIdx) {
    const middleIdx = Math.floor((leftIdx + rightIdx) / 2), subText = text2.substring(0, middleIdx + 1), strWidth = this.measureTextWidth(subText, options);
    let length2;
    if (strWidth > width) {
      if (subText.length <= 1)
        return {
          str: "",
          width: 0
        };
      const str = text2.substring(0, middleIdx);
      return length2 = this.measureTextWidth(str, options), length2 <= width ? {
        str,
        width: length2
      } : this._clipTextEnd(text2, options, width, leftIdx, middleIdx);
    }
    if (strWidth < width) {
      if (middleIdx >= text2.length - 1)
        return {
          str: text2,
          width: this.measureTextWidth(text2, options)
        };
      const str = text2.substring(0, middleIdx + 2);
      return length2 = this.measureTextWidth(str, options), length2 >= width ? {
        str: subText,
        width: strWidth
      } : this._clipTextEnd(text2, options, width, middleIdx, rightIdx);
    }
    return {
      str: subText,
      width: strWidth
    };
  }
  _clipTextStart(text2, options, width, leftIdx, rightIdx) {
    const middleIdx = Math.ceil((leftIdx + rightIdx) / 2), subText = text2.substring(middleIdx - 1, text2.length - 1), strWidth = this.measureTextWidth(subText, options);
    let length2;
    if (strWidth > width) {
      if (subText.length <= 1)
        return {
          str: "",
          width: 0
        };
      const str = text2.substring(middleIdx, text2.length - 1);
      return length2 = this.measureTextWidth(str, options), length2 <= width ? {
        str,
        width: length2
      } : this._clipTextStart(text2, options, width, middleIdx, text2.length - 1);
    }
    if (strWidth < width) {
      if (middleIdx <= 0)
        return {
          str: text2,
          width: this.measureTextWidth(text2, options)
        };
      const str = text2.substring(middleIdx - 2, text2.length - 1);
      return length2 = this.measureTextWidth(str, options), length2 >= width ? {
        str: subText,
        width: strWidth
      } : this._clipTextStart(text2, options, width, leftIdx, middleIdx);
    }
    return {
      str: subText,
      width: strWidth
    };
  }
  _clipTextMiddle(text2, options, width, left2, right2, leftW, rightW, buffer) {
    const subLeftText = text2.substring(0, buffer), strLeftWidth = this.measureTextWidth(subLeftText, options);
    if (strLeftWidth + rightW > width)
      return {
        left: left2,
        right: right2,
        width: leftW + rightW
      };
    const subRightText = text2.substring(text2.length - buffer, text2.length), strRightWidth = this.measureTextWidth(subRightText, options);
    return strLeftWidth + strRightWidth > width ? {
      left: subLeftText,
      right: right2,
      width: strLeftWidth + rightW
    } : this._clipTextMiddle(text2, options, width, subLeftText, subRightText, strLeftWidth, strRightWidth, buffer + 1);
  }
  clipTextWithSuffixVertical(verticalList, options, width, suffix, wordBreak, suffixPosition) {
    if ("" === suffix)
      return this.clipTextVertical(verticalList, options, width, wordBreak);
    if (0 === verticalList.length)
      return {
        verticalList,
        width: 0
      };
    const output = this.clipTextVertical(verticalList, options, width, wordBreak);
    if (output.verticalList.length === verticalList.length && output.verticalList[output.verticalList.length - 1].width === verticalList[verticalList.length - 1].width)
      return output;
    const suffixWidth = this.measureTextWidth(suffix, options);
    if (suffixWidth > width)
      return output;
    let out;
    if (width -= suffixWidth, "start" === suffixPosition) {
      const nextVerticalList = this.revertVerticalList(verticalList);
      out = this.clipTextVertical(nextVerticalList, options, width, wordBreak);
      const v = this.revertVerticalList(out.verticalList);
      v.unshift({
        text: suffix,
        direction: 1,
        width: suffixWidth
      }), out.verticalList = v;
    } else if ("middle" === suffixPosition) {
      const leftOut = this.clipTextVertical(verticalList, options, width / 2, wordBreak), nextVerticalList = this.revertVerticalList(verticalList), rightOut = this.clipTextVertical(nextVerticalList, options, width / 2, wordBreak);
      leftOut.verticalList.push({
        text: suffix,
        direction: 1,
        width: suffixWidth
      }), this.revertVerticalList(rightOut.verticalList).forEach((v) => leftOut.verticalList.push(v)), out = {
        verticalList: leftOut.verticalList,
        width: leftOut.width + rightOut.width
      };
    } else
      out = this.clipTextVertical(verticalList, options, width, wordBreak), out.verticalList.push({
        text: suffix,
        direction: 1,
        width: suffixWidth
      });
    return out.width += suffixWidth, out;
  }
  revertVerticalList(verticalList) {
    return verticalList.reverse().map((l) => {
      const t = l.text.split("").reverse().join("");
      return Object.assign(Object.assign({}, l), {
        text: t
      });
    });
  }
  clipTextWithSuffix(text2, options, width, suffix, wordBreak, position, forceSuffix = false) {
    if ("" === suffix)
      return this.clipText(text2, options, width, wordBreak);
    if (0 === text2.length)
      return {
        str: "",
        width: 0
      };
    const length2 = this.measureTextWidth(text2, options);
    if (!forceSuffix && length2 <= width)
      return {
        str: text2,
        width: length2
      };
    const suffixWidth = this.measureTextWidth(suffix, options);
    if (suffixWidth > width)
      return {
        str: "",
        width: 0
      };
    if (forceSuffix && length2 + suffixWidth <= width)
      return {
        str: text2 + suffix,
        width: length2 + suffixWidth
      };
    width -= suffixWidth;
    const data = this._clipText(text2, options, width, 0, text2.length - 1, position, suffix);
    if (wordBreak && data.str !== text2) {
      const index = testLetter(text2, data.str.length);
      index !== data.str.length && (data.result = text2.substring(0, index), data.width = this.measureTextWidth(data.str, options));
    } else
      forceSuffix && data.str === text2 && (data.result = text2 + suffix);
    return data.str = data.result, data.width += suffixWidth, data;
  }
};
ATextMeasure = __decorate2([injectable()], ATextMeasure);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/core/contributions/textMeasure/textMeasure-contribution
var __decorate3 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var TextMeasureContribution = Symbol.for("TextMeasureContribution");
var DefaultTextMeasureContribution = class extends ATextMeasure {
};
DefaultTextMeasureContribution = __decorate3([injectable()], DefaultTextMeasureContribution);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/container
var container = new Container();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/canvas/constants
var CanvasFactory = Symbol.for("CanvasFactory");
var Context2dFactory = Symbol.for("Context2dFactory");

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/canvas/util
function wrapCanvas(params2) {
  return container.getNamed(CanvasFactory, application.global.env)(params2);
}
var EPSILON_NUMERIC = 1e-4;
var THREE_SQRT = Math.sqrt(3);
var ONE_THIRD = 1 / 3;
function isAroundZero(val) {
  return val > -EPSILON2 && val < EPSILON2;
}
function isNotAroundZero(val) {
  return val > EPSILON2 || val < -EPSILON2;
}
var _v0 = [0, 0];
var _v1 = [0, 0];
var _v2 = [0, 0];
function distanceSquare(v1, v2) {
  return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
}
function quadraticAt(p0, p1, p2, t) {
  const onet = 1 - t;
  return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
}
function cubicAt(p0, p1, p2, p3, t) {
  const onet = 1 - t;
  return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
}
function quadraticRootAt(p0, p1, p2, val, roots2) {
  const a3 = p0 - 2 * p1 + p2, b = 2 * (p1 - p0), c3 = p0 - val;
  let n = 0;
  if (isAroundZero(a3)) {
    if (isNotAroundZero(b)) {
      const t1 = -c3 / b;
      t1 >= 0 && t1 <= 1 && (roots2[n++] = t1);
    }
  } else {
    const disc = b * b - 4 * a3 * c3;
    if (isAroundZero(disc)) {
      const t1 = -b / (2 * a3);
      t1 >= 0 && t1 <= 1 && (roots2[n++] = t1);
    } else if (disc > 0) {
      const discSqrt = Math.sqrt(disc), t1 = (-b + discSqrt) / (2 * a3), t2 = (-b - discSqrt) / (2 * a3);
      t1 >= 0 && t1 <= 1 && (roots2[n++] = t1), t2 >= 0 && t2 <= 1 && (roots2[n++] = t2);
    }
  }
  return n;
}
function quadraticExtremum(p0, p1, p2) {
  const divider = p0 + p2 - 2 * p1;
  return 0 === divider ? 0.5 : (p0 - p1) / divider;
}
function quadraticProjectPoint(x05, y05, x14, y14, x23, y23, x, y, out) {
  let t = 0, interval = 5e-3, d = 1 / 0;
  _v0[0] = x, _v0[1] = y;
  for (let _t = 0; _t < 1; _t += 0.05) {
    _v1[0] = quadraticAt(x05, x14, x23, _t), _v1[1] = quadraticAt(y05, y14, y23, _t);
    const d1 = distanceSquare(_v0, _v1);
    d1 < d && (t = _t, d = d1);
  }
  d = 1 / 0;
  for (let i = 0; i < 32 && !(interval < EPSILON_NUMERIC); i++) {
    const prev = t - interval, next = t + interval;
    _v1[0] = quadraticAt(x05, x14, x23, prev), _v1[1] = quadraticAt(y05, y14, y23, prev);
    const d1 = distanceSquare(_v1, _v0);
    if (prev >= 0 && d1 < d)
      t = prev, d = d1;
    else {
      _v2[0] = quadraticAt(x05, x14, x23, next), _v2[1] = quadraticAt(y05, y14, y23, next);
      const d2 = distanceSquare(_v2, _v0);
      next <= 1 && d2 < d ? (t = next, d = d2) : interval *= 0.5;
    }
  }
  return out && (out[0] = quadraticAt(x05, x14, x23, t), out[1] = quadraticAt(y05, y14, y23, t)), Math.sqrt(d);
}
function cubicProjectPoint(x05, y05, x14, y14, x23, y23, x3, y3, x, y, out) {
  let prev, next, d1, d2, t = 0, interval = 5e-3, d = 1 / 0;
  _v0[0] = x, _v0[1] = y;
  for (let _t = 0; _t < 1; _t += 0.05)
    _v1[0] = cubicAt(x05, x14, x23, x3, _t), _v1[1] = cubicAt(y05, y14, y23, y3, _t), d1 = distanceSquare(_v0, _v1), d1 < d && (t = _t, d = d1);
  d = 1 / 0;
  for (let i = 0; i < 32 && !(interval < EPSILON_NUMERIC); i++)
    prev = t - interval, next = t + interval, _v1[0] = cubicAt(x05, x14, x23, x3, prev), _v1[1] = cubicAt(y05, y14, y23, y3, prev), d1 = distanceSquare(_v1, _v0), prev >= 0 && d1 < d ? (t = prev, d = d1) : (_v2[0] = cubicAt(x05, x14, x23, x3, next), _v2[1] = cubicAt(y05, y14, y23, y3, next), d2 = distanceSquare(_v2, _v0), next <= 1 && d2 < d ? (t = next, d = d2) : interval *= 0.5);
  return out && (out[0] = cubicAt(x05, x14, x23, x3, t), out[1] = cubicAt(y05, y14, y23, y3, t)), Math.sqrt(d);
}
function normalizeRadian(angle2) {
  return (angle2 %= pi2) < 0 && (angle2 += pi2), angle2;
}
function windingLine(x05, y05, x14, y14, x, y) {
  if (y > y05 && y > y14 || y < y05 && y < y14)
    return 0;
  if (y14 === y05)
    return 0;
  const t = (y - y05) / (y14 - y05);
  let dir = y14 < y05 ? 1 : -1;
  1 !== t && 0 !== t || (dir = y14 < y05 ? 0.5 : -0.5);
  const x_ = t * (x14 - x05) + x05;
  return x_ === x ? 1 / 0 : x_ > x ? dir : 0;
}
function containQuadStroke(x05, y05, x14, y14, x23, y23, lineWidth, x, y) {
  if (0 === lineWidth)
    return false;
  const _l = lineWidth;
  if (y > y05 + _l && y > y14 + _l && y > y23 + _l || y < y05 - _l && y < y14 - _l && y < y23 - _l || x > x05 + _l && x > x14 + _l && x > x23 + _l || x < x05 - _l && x < x14 - _l && x < x23 - _l)
    return false;
  return quadraticProjectPoint(x05, y05, x14, y14, x23, y23, x, y, null) <= _l / 2;
}
function containCubicStroke(x05, y05, x14, y14, x23, y23, x3, y3, lineWidth, x, y) {
  if (0 === lineWidth)
    return false;
  const _l = lineWidth;
  if (y > y05 + _l && y > y14 + _l && y > y23 + _l && y > y3 + _l || y < y05 - _l && y < y14 - _l && y < y23 - _l && y < y3 - _l || x > x05 + _l && x > x14 + _l && x > x23 + _l && x > x3 + _l || x < x05 - _l && x < x14 - _l && x < x23 - _l && x < x3 - _l)
    return false;
  return cubicProjectPoint(x05, y05, x14, y14, x23, y23, x3, y3, x, y, null) <= _l / 2;
}
function containArcStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
  if (0 === lineWidth)
    return false;
  const _l = lineWidth;
  x -= cx, y -= cy;
  const d = Math.sqrt(x * x + y * y);
  if (d - _l > r || d + _l < r)
    return false;
  if (Math.abs(startAngle - endAngle) % pi2 < 1e-4)
    return true;
  if (anticlockwise) {
    const tmp = startAngle;
    startAngle = normalizeRadian(endAngle), endAngle = normalizeRadian(tmp);
  } else
    startAngle = normalizeRadian(startAngle), endAngle = normalizeRadian(endAngle);
  startAngle > endAngle && (endAngle += pi2);
  let angle2 = Math.atan2(y, x);
  return angle2 < 0 && (angle2 += pi2), angle2 >= startAngle && angle2 <= endAngle || angle2 + pi2 >= startAngle && angle2 + pi2 <= endAngle;
}
function containLineStroke(x05, y05, x14, y14, lineWidth, x, y) {
  if (0 === lineWidth)
    return false;
  const _l = lineWidth, _halfL = lineWidth / 2;
  let _a = 0, _b = x05;
  if (y > y05 + _halfL && y > y14 + _halfL || y < y05 - _halfL && y < y14 - _halfL || x > x05 + _halfL && x > x14 + _halfL || x < x05 - _halfL && x < x14 - _halfL)
    return false;
  if (x05 === x14)
    return Math.abs(x - x05) <= _l / 2;
  _a = (y05 - y14) / (x05 - x14), _b = (x05 * y14 - x14 * y05) / (x05 - x14);
  const tmp = _a * x - y + _b;
  return tmp * tmp / (_a * _a + 1) <= _l / 2 * _l / 2;
}
var EPSILON2 = 1e-4;
function cubicRootAt(p0, p1, p2, p3, val, roots2) {
  const a3 = p3 + 3 * (p1 - p2) - p0, b = 3 * (p2 - 2 * p1 + p0), c3 = 3 * (p1 - p0), d = p0 - val, A = b * b - 3 * a3 * c3, B = b * c3 - 9 * a3 * d, C = c3 * c3 - 3 * b * d;
  let n = 0;
  if (isAroundZero(A) && isAroundZero(B))
    if (isAroundZero(b))
      roots2[0] = 0;
    else {
      const t1 = -c3 / b;
      t1 >= 0 && t1 <= 1 && (roots2[n++] = t1);
    }
  else {
    const disc = B * B - 4 * A * C;
    if (isAroundZero(disc)) {
      const K = B / A, t1 = -b / a3 + K, t2 = -K / 2;
      t1 >= 0 && t1 <= 1 && (roots2[n++] = t1), t2 >= 0 && t2 <= 1 && (roots2[n++] = t2);
    } else if (disc > 0) {
      const discSqrt = Math.sqrt(disc);
      let Y12 = A * b + 1.5 * a3 * (-B + discSqrt), Y22 = A * b + 1.5 * a3 * (-B - discSqrt);
      Y12 = Y12 < 0 ? -Math.pow(-Y12, ONE_THIRD) : Math.pow(Y12, ONE_THIRD), Y22 = Y22 < 0 ? -Math.pow(-Y22, ONE_THIRD) : Math.pow(Y22, ONE_THIRD);
      const t1 = (-b - (Y12 + Y22)) / (3 * a3);
      t1 >= 0 && t1 <= 1 && (roots2[n++] = t1);
    } else {
      const T = (2 * A * b - 3 * a3 * B) / (2 * Math.sqrt(A * A * A)), theta = Math.acos(T) / 3, ASqrt = Math.sqrt(A), tmp = Math.cos(theta), t1 = (-b - 2 * ASqrt * tmp) / (3 * a3), t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a3), t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a3);
      t1 >= 0 && t1 <= 1 && (roots2[n++] = t1), t2 >= 0 && t2 <= 1 && (roots2[n++] = t2), t3 >= 0 && t3 <= 1 && (roots2[n++] = t3);
    }
  }
  return n;
}
function cubicExtrema(p0, p1, p2, p3, extrema2) {
  const b = 6 * p2 - 12 * p1 + 6 * p0, a3 = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2, c3 = 3 * p1 - 3 * p0;
  let n = 0;
  if (isAroundZero(a3)) {
    if (isNotAroundZero(b)) {
      const t1 = -c3 / b;
      t1 >= 0 && t1 <= 1 && (extrema2[n++] = t1);
    }
  } else {
    const disc = b * b - 4 * a3 * c3;
    if (isAroundZero(disc))
      extrema2[0] = -b / (2 * a3);
    else if (disc > 0) {
      const discSqrt = Math.sqrt(disc), t1 = (-b + discSqrt) / (2 * a3), t2 = (-b - discSqrt) / (2 * a3);
      t1 >= 0 && t1 <= 1 && (extrema2[n++] = t1), t2 >= 0 && t2 <= 1 && (extrema2[n++] = t2);
    }
  }
  return n;
}
function isAroundEqual2(a3, b) {
  return Math.abs(a3 - b) < EPSILON2;
}
var roots = [-1, -1, -1];
var extrema = [-1, -1];
function swapExtrema() {
  const tmp = extrema[0];
  extrema[0] = extrema[1], extrema[1] = tmp;
}
function windingCubic(x05, y05, x14, y14, x23, y23, x3, y3, x, y) {
  if (y > y05 && y > y14 && y > y23 && y > y3 || y < y05 && y < y14 && y < y23 && y < y3)
    return 0;
  const nRoots = cubicRootAt(y05, y14, y23, y3, y, roots);
  if (0 === nRoots)
    return 0;
  let w = 0, nExtrema = -1, y0_ = 0, y1_ = 0;
  for (let i = 0; i < nRoots; i++) {
    const t = roots[i], unit = 0 === t || 1 === t ? 0.5 : 1;
    cubicAt(x05, x14, x23, x3, t) < x || (nExtrema < 0 && (nExtrema = cubicExtrema(y05, y14, y23, y3, extrema), extrema[1] < extrema[0] && nExtrema > 1 && swapExtrema(), y0_ = cubicAt(y05, y14, y23, y3, extrema[0]), nExtrema > 1 && (y1_ = cubicAt(y05, y14, y23, y3, extrema[1]))), 2 === nExtrema ? t < extrema[0] ? w += y0_ < y05 ? unit : -unit : t < extrema[1] ? w += y1_ < y0_ ? unit : -unit : w += y3 < y1_ ? unit : -unit : t < extrema[0] ? w += y0_ < y05 ? unit : -unit : w += y3 < y0_ ? unit : -unit);
  }
  return w;
}
function windingQuadratic(x05, y05, x14, y14, x23, y23, x, y) {
  if (y > y05 && y > y14 && y > y23 || y < y05 && y < y14 && y < y23)
    return 0;
  const nRoots = quadraticRootAt(y05, y14, y23, y, roots);
  if (0 === nRoots)
    return 0;
  const t = quadraticExtremum(y05, y14, y23);
  if (t >= 0 && t <= 1) {
    let w = 0;
    const y_ = quadraticAt(y05, y14, y23, t);
    for (let i = 0; i < nRoots; i++) {
      const unit2 = 0 === roots[i] || 1 === roots[i] ? 0.5 : 1;
      quadraticAt(x05, x14, x23, roots[i]) < x || (roots[i] < t ? w += y_ < y05 ? unit2 : -unit2 : w += y23 < y_ ? unit2 : -unit2);
    }
    return w;
  }
  const unit = 0 === roots[0] || 1 === roots[0] ? 0.5 : 1;
  return quadraticAt(x05, x14, x23, roots[0]) < x ? 0 : y23 < y05 ? unit : -unit;
}
function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
  if ((y -= cy) > r || y < -r)
    return 0;
  const tmp = Math.sqrt(r * r - y * y);
  roots[0] = -tmp, roots[1] = tmp;
  const dTheta = Math.abs(startAngle - endAngle);
  if (dTheta < 1e-4)
    return 0;
  if (dTheta >= pi2 - 1e-4) {
    startAngle = 0, endAngle = pi2;
    const dir = anticlockwise ? 1 : -1;
    return x >= roots[0] + cx && x <= roots[1] + cx ? dir : 0;
  }
  if (startAngle > endAngle) {
    const tmp2 = startAngle;
    startAngle = endAngle, endAngle = tmp2;
  }
  startAngle < 0 && (startAngle += pi2, endAngle += pi2);
  let w = 0;
  for (let i = 0; i < 2; i++) {
    const x_ = roots[i];
    if (x_ + cx > x) {
      let angle2 = Math.atan2(y, x_), dir = anticlockwise ? 1 : -1;
      angle2 < 0 && (angle2 = pi2 + angle2), (angle2 >= startAngle && angle2 <= endAngle || angle2 + pi2 >= startAngle && angle2 + pi2 <= endAngle) && (angle2 > pi / 2 && angle2 < 1.5 * pi && (dir = -dir), w += dir);
    }
  }
  return w;
}
function modpi2(radian) {
  return Math.round(radian / pi * 1e8) / 1e8 % 2 * pi;
}
function normalizeArcAngles(angles, anticlockwise) {
  let newStartAngle = modpi2(angles[0]);
  newStartAngle < 0 && (newStartAngle += pi2);
  const delta = newStartAngle - angles[0];
  let newEndAngle = angles[1];
  newEndAngle += delta, !anticlockwise && newEndAngle - newStartAngle >= pi2 ? newEndAngle = newStartAngle + pi2 : anticlockwise && newStartAngle - newEndAngle >= pi2 ? newEndAngle = newStartAngle - pi2 : !anticlockwise && newStartAngle > newEndAngle ? newEndAngle = newStartAngle + (pi2 - modpi2(newStartAngle - newEndAngle)) : anticlockwise && newStartAngle < newEndAngle && (newEndAngle = newStartAngle - (pi2 - modpi2(newEndAngle - newStartAngle))), angles[0] = newStartAngle, angles[1] = newEndAngle;
}
var tmpAngles = [0, 0];
function containPath(commands, lineWidth, isStroke, x, y) {
  const data = commands, len = commands.length;
  let x14, y14, w = 0, xi = 0, yi = 0, x05 = 0, y05 = 0;
  for (let i = 0; i < len; i++) {
    const command = data[i], isFirst = 0 === i;
    command[0] === enumCommandMap.M && i > 1 && (isStroke || (w += windingLine(xi, yi, x05, y05, x, y))), isFirst && (xi = command[1], yi = command[2], x05 = xi, y05 = yi);
    const c0 = command[0], c1 = command[1], c22 = command[2], c3 = command[3], c4 = command[4], c5 = command[5], c6 = command[6];
    let startAngle = c4, endAngle = c5;
    tmpAngles[0] = startAngle, tmpAngles[1] = endAngle, normalizeArcAngles(tmpAngles, Boolean(command[6])), startAngle = tmpAngles[0], endAngle = tmpAngles[1];
    const theta = startAngle, dTheta = endAngle - startAngle, anticlockwise = !!(1 - (command[6] ? 0 : 1)), _x = (x - c1) * c3 / c3 + c1;
    switch (c0) {
      case enumCommandMap.M:
        x05 = c1, y05 = c22, xi = x05, yi = y05;
        break;
      case enumCommandMap.L:
        if (isStroke) {
          if (containLineStroke(xi, yi, c1, c22, lineWidth, x, y))
            return true;
        } else
          w += windingLine(xi, yi, c1, c22, x, y) || 0;
        xi = c1, yi = c22;
        break;
      case enumCommandMap.C:
        if (isStroke) {
          if (containCubicStroke(xi, yi, c1, c22, c3, c4, c5, c6, lineWidth, x, y))
            return true;
        } else
          w += windingCubic(xi, yi, c1, c22, c3, c4, c5, c6, x, y) || 0;
        xi = c5, yi = c6;
        break;
      case enumCommandMap.Q:
        if (isStroke) {
          if (containQuadStroke(xi, yi, c1, c22, c3, c4, lineWidth, x, y))
            return true;
        } else
          w += windingQuadratic(xi, yi, c1, c22, c3, c4, x, y) || 0;
        xi = c3, yi = c4;
        break;
      case enumCommandMap.A:
        if (x14 = Math.cos(theta) * c3 + c1, y14 = Math.sin(theta) * c3 + c22, isFirst ? (x05 = x14, y05 = y14) : w += windingLine(xi, yi, x14, y14, x, y), isStroke) {
          if (containArcStroke(c1, c22, c3, theta, theta + dTheta, anticlockwise, lineWidth, _x, y))
            return true;
        } else
          w += windingArc(c1, c22, c3, theta, theta + dTheta, anticlockwise, _x, y);
        xi = Math.cos(theta + dTheta) * c3 + c1, yi = Math.sin(theta + dTheta) * c3 + c22;
        break;
      case enumCommandMap.R:
        if (x05 = xi = c1, y05 = yi = c22, x14 = x05 + c3, y14 = y05 + c4, isStroke) {
          if (containLineStroke(x05, y05, x14, y05, lineWidth, x, y) || containLineStroke(x14, y05, x14, y14, lineWidth, x, y) || containLineStroke(x14, y14, x05, y14, lineWidth, x, y) || containLineStroke(x05, y14, x05, y05, lineWidth, x, y))
            return true;
        } else
          w += windingLine(x14, y05, x14, y14, x, y), w += windingLine(x05, y14, x05, y05, x, y);
        break;
      case enumCommandMap.Z:
        if (isStroke) {
          if (containLineStroke(xi, yi, x05, y05, lineWidth, x, y))
            return true;
        } else
          w += windingLine(xi, yi, x05, y05, x, y);
        xi = x05, yi = y05;
    }
  }
  return isStroke || isAroundEqual2(yi, y05) || (w += windingLine(xi, yi, x05, y05, x, y) || 0), 0 !== w;
}
function contain(commands, x, y) {
  return containPath(commands, 0, false, x, y);
}
function containStroke(commands, lineWidth, x, y) {
  return containPath(commands, lineWidth, true, x, y);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/allocator/canvas-allocate
var DefaultCanvasAllocate = class {
  constructor() {
    this.pools = [], this.allocatedCanvas = [];
  }
  shareCanvas() {
    return this.allocatedCanvas.length ? this.allocatedCanvas[0] : this.getCommonCanvas();
  }
  getCommonCanvas() {
    return this._commonCanvas || (this._commonCanvas = this.allocate({
      width: 100,
      height: 100,
      dpr: 2
    })), this._commonCanvas;
  }
  allocate(data) {
    if (!this.pools.length) {
      const c3 = wrapCanvas(Object.assign({
        nativeCanvas: application.global.createCanvas(data)
      }, data));
      return this.allocatedCanvas.push(c3), c3;
    }
    const m4 = this.pools.pop();
    return m4.resize(data.width, data.height), m4.dpr = data.dpr, m4;
  }
  allocateByObj(canvas) {
    if (!this.pools.length) {
      const data = {
        width: canvas.width / canvas.dpr,
        height: canvas.height / canvas.dpr,
        dpr: canvas.dpr
      }, c3 = wrapCanvas(Object.assign({
        nativeCanvas: application.global.createCanvas(data)
      }, data));
      return this.allocatedCanvas.push(c3), c3;
    }
    const m4 = this.pools.pop();
    return m4.width = canvas.width, m4.height = canvas.height, m4;
  }
  free(d) {
    this.pools.push(d);
  }
  get length() {
    return this.pools.length;
  }
  release(...params2) {
    this.pools = [];
  }
};
var canvasAllocate = new DefaultCanvasAllocate();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/core/window
var __decorate4 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata2 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var VWindow = Symbol.for("VWindow");
var WindowHandlerContribution = Symbol.for("WindowHandlerContribution");
var DefaultWindow = class {
  get width() {
    if (this._handler) {
      const wh = this._handler.getWH();
      return this._width = wh.width;
    }
    return this._width;
  }
  get height() {
    if (this._handler) {
      const wh = this._handler.getWH();
      return this._height = wh.height;
    }
    return this._height;
  }
  get dpr() {
    return this._handler.getDpr();
  }
  constructor() {
    this.hooks = {
      onChange: new SyncHook(["x", "y", "width", "height"])
    }, this.active = () => {
      const global = this.global;
      if (!global.env || this.actived)
        return;
      container.getNamed(WindowHandlerContribution, global.env).configure(this, global), this.actived = true;
    }, this._uid = Generator.GenAutoIncrementId(), this.global = application.global, this.postInit();
  }
  postInit() {
    this.global.hooks.onSetEnv.tap("window", this.active), this.active();
  }
  get style() {
    var _a;
    return null !== (_a = this._handler.getStyle()) && void 0 !== _a ? _a : {};
  }
  set style(style) {
    this._handler.setStyle(style);
  }
  create(params2) {
    var _a, _b;
    this._handler.createWindow(params2);
    const windowWH = this._handler.getWH();
    this._width = windowWH.width, this._height = windowWH.height, params2.viewBox ? this.setViewBox(params2.viewBox) : false !== params2.canvasControled ? this.setViewBox({
      x1: 0,
      y1: 0,
      x2: this._width,
      y2: this._height
    }) : this.setViewBox({
      x1: 0,
      y1: 0,
      x2: null !== (_a = params2.width) && void 0 !== _a ? _a : this._width,
      y2: null !== (_b = params2.height) && void 0 !== _b ? _b : this._height
    }), this.title = this._handler.getTitle(), this.resizable = true;
  }
  setWindowHandler(handler) {
    this._handler = handler;
  }
  setDpr(dpr) {
    return this._handler.setDpr(dpr);
  }
  resize(w, h) {
    return this._handler.resizeWindow(w, h);
  }
  configure() {
    throw new Error("\u6682\u4E0D\u652F\u6301");
  }
  release() {
    return this.global.hooks.onSetEnv.unTap("window", this.active), this._handler.releaseWindow();
  }
  getContext() {
    return this._handler.getContext();
  }
  getNativeHandler() {
    return this._handler.getNativeHandler();
  }
  getImageBuffer(type) {
    return this._handler.getImageBuffer ? this._handler.getImageBuffer(type) : null;
  }
  addEventListener(type, listener, options) {
    return this._handler.addEventListener(type, listener, options);
  }
  removeEventListener(type, listener, options) {
    return this._handler.removeEventListener(type, listener, options);
  }
  dispatchEvent(event) {
    return this._handler.dispatchEvent(event);
  }
  getBoundingClientRect() {
    return this._handler.getBoundingClientRect();
  }
  getContainer() {
    return this._handler.container;
  }
  clearViewBox(color) {
    this._handler.clearViewBox(color);
  }
  setViewBox(viewBox) {
    this._handler.setViewBox(viewBox);
  }
  setViewBoxTransform(a3, b, c3, d, e, f) {
    this._handler.setViewBoxTransform(a3, b, c3, d, e, f);
  }
  getViewBox() {
    return this._handler.getViewBox();
  }
  getViewBoxTransform() {
    return this._handler.getViewBoxTransform();
  }
  pointTransform(x, y) {
    const vb = this._handler.getViewBox(), nextP = {
      x,
      y
    };
    return this._handler.getViewBoxTransform().transformPoint({
      x,
      y
    }, nextP), nextP.x -= vb.x1, nextP.y -= vb.y1, nextP;
  }
  hasSubView() {
    const viewBox = this._handler.getViewBox();
    return !(0 === viewBox.x1 && 0 === viewBox.y1 && this.width === viewBox.width() && this.height === viewBox.height());
  }
  isVisible(bbox) {
    return this._handler.isVisible(bbox);
  }
  onVisibleChange(cb) {
    return this._handler.onVisibleChange(cb);
  }
  getTopLeft(baseWindow) {
    return this._handler.getTopLeft(baseWindow);
  }
};
DefaultWindow = __decorate4([injectable(), __metadata2("design:paramtypes", [])], DefaultWindow);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/core/graphic-utils
var __decorate5 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata3 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param2 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultGraphicUtil = class {
  get canvas() {
    return this.tryInitCanvas(), this._canvas;
  }
  get context() {
    return this.tryInitCanvas(), this._context;
  }
  constructor(contributions) {
    this.contributions = contributions, this.configured = false, this.global = application.global, this.global.hooks.onSetEnv.tap("graphic-util", (lastEnv, env, global) => {
      this.configured = false, this.configure(global, env);
    });
  }
  get textMeasure() {
    return this._textMeasure || this.configure(this.global, this.global.env), this._textMeasure;
  }
  configure(global, env) {
    this.configured || (this.contributions.getContributions().forEach((contribution) => {
      contribution.configure(this, env);
    }), this.configured = true);
  }
  tryInitCanvas() {
    if (!this._canvas) {
      const canvas = canvasAllocate.shareCanvas();
      this._canvas = canvas, this._context = canvas.getContext("2d");
    }
  }
  bindTextMeasure(tm) {
    this._textMeasure = tm;
  }
  measureText(text2, tc, method = "native") {
    var _a;
    this.configure(this.global, this.global.env);
    const m4 = this.global.measureTextMethod;
    this.global.measureTextMethod = method;
    const data = {
      width: this._textMeasure.measureTextWidth(text2, tc),
      height: null !== (_a = tc.fontSize) && void 0 !== _a ? _a : DefaultTextStyle.fontSize
    };
    return this.global.measureTextMethod = m4, data;
  }
  createTextMeasureInstance(textSpec, option, getCanvasForMeasure) {
    return this.configure(this.global, this.global.env), new TextMeasure(Object.assign({
      defaultFontParams: {
        fontFamily: DefaultTextStyle.fontFamily,
        fontSize: DefaultTextStyle.fontSize
      },
      getCanvasForMeasure: getCanvasForMeasure || (() => this.canvas),
      getTextBounds: void 0,
      specialCharSet: `-/: .,@%'"~` + TextMeasure.ALPHABET_CHAR_SET + TextMeasure.ALPHABET_CHAR_SET.toUpperCase()
    }, null != option ? option : {}), textSpec);
  }
  drawGraphicToCanvas(graphic, stage, canvas) {
    if (!stage.defaultLayer)
      return null;
    const window2 = container.get(VWindow), bounds = graphic.AABBBounds, width = bounds.width(), height = bounds.height(), x14 = -bounds.x1, y14 = -bounds.y1;
    window2.create({
      viewBox: {
        x1: x14,
        y1: y14,
        x2: bounds.x2,
        y2: bounds.y2
      },
      width,
      height,
      canvas,
      dpr: stage.window.dpr,
      canvasControled: true,
      offscreen: true,
      title: ""
    });
    const disableCheckGraphicWidthOutRange = stage.params.optimize.disableCheckGraphicWidthOutRange;
    stage.params.optimize.disableCheckGraphicWidthOutRange = true, stage.defaultLayer.getNativeHandler().drawTo(window2, [graphic], {
      transMatrix: window2.getViewBoxTransform(),
      viewBox: window2.getViewBox(),
      stage,
      layer: stage.defaultLayer,
      renderService: stage.renderService,
      background: "transparent",
      clear: true,
      updateBounds: false
    }), stage.params.optimize.disableCheckGraphicWidthOutRange = disableCheckGraphicWidthOutRange;
    const c3 = window2.getNativeHandler();
    return c3.nativeCanvas ? c3.nativeCanvas : null;
  }
};
DefaultGraphicUtil = __decorate5([injectable(), __param2(0, inject(ContributionProvider)), __param2(0, named(TextMeasureContribution)), __metadata3("design:paramtypes", [Object])], DefaultGraphicUtil);
var TransformMode;
!function(TransformMode2) {
  TransformMode2[TransformMode2.transform = 0] = "transform", TransformMode2[TransformMode2.matrix = 1] = "matrix";
}(TransformMode || (TransformMode = {}));
var _matrix = new Matrix();
var DefaultTransformUtil = class {
  constructor() {
    this.matrix = new Matrix();
  }
  init(origin) {
    return this.mode = TransformMode.transform, this.originTransform = origin, this.matrix.reset(), this;
  }
  fromMatrix(source, target) {
    return this.mode = TransformMode.matrix, this.outSourceMatrix = source, this.outTargetMatrix = target, this;
  }
  scaleMatrix(sx, sy, center2) {
    const sMatrix = this.outSourceMatrix;
    if (_matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f), this.outTargetMatrix.reset(), center2) {
      const { x, y } = center2;
      this.outTargetMatrix.translate(x, y), this.outTargetMatrix.scale(sx, sy), this.outTargetMatrix.translate(-x, -y);
    } else
      this.outTargetMatrix.scale(sx, sy);
    return this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f), this;
  }
  rotateMatrix(angle2, center2) {
    const sMatrix = this.outSourceMatrix;
    if (_matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f), this.outTargetMatrix.reset(), center2) {
      const { x, y } = center2;
      this.outTargetMatrix.translate(x, y), this.outTargetMatrix.rotate(angle2), this.outTargetMatrix.translate(-x, -y);
    } else
      this.outTargetMatrix.rotate(angle2);
    return this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f), this;
  }
  scale(sx, sy, center2) {
    return this.mode === TransformMode.matrix ? this.scaleMatrix(sx, sy, center2) : this;
  }
  rotate(angle2, center2) {
    return this.mode === TransformMode.matrix ? this.rotateMatrix(angle2, center2) : this;
  }
  translateMatrix(dx, dy) {
    const sMatrix = this.outSourceMatrix;
    return _matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f), this.outTargetMatrix.reset(), this.outTargetMatrix.translate(dx, dy), this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f), this;
  }
  translate(dx, dy) {
    return this.mode === TransformMode.matrix ? this.translateMatrix(dx, dy) : this;
  }
  simplify(target) {
    return this.mode === TransformMode.matrix ? this.simplifyMatrix(target) : this;
  }
  simplifyMatrix(target) {
    return this;
  }
};
DefaultTransformUtil = __decorate5([injectable(), __metadata3("design:paramtypes", [])], DefaultTransformUtil);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/theme
var defaultThemeObj = {
  arc: DefaultArcAttribute,
  area: DefaultAreaAttribute,
  circle: DefaultCircleAttribute,
  line: DefaultLineAttribute,
  path: DefaultPathAttribute,
  symbol: DefaultSymbolAttribute,
  text: DefaultTextAttribute,
  rect: DefaultRectAttribute,
  polygon: DefaultPolygonAttribute,
  richtext: DefaultRichTextAttribute,
  richtextIcon: DefaultRichTextIconAttribute,
  image: DefaultImageAttribute,
  group: DefaultGroupAttribute,
  glyph: DefaultGlyphAttribute
};
var themeKeys = Object.keys(defaultThemeObj);
function newThemeObj() {
  return {
    arc: Object.assign({}, defaultThemeObj.arc),
    area: Object.assign({}, defaultThemeObj.area),
    circle: Object.assign({}, defaultThemeObj.circle),
    line: Object.assign({}, defaultThemeObj.line),
    path: Object.assign({}, defaultThemeObj.path),
    symbol: Object.assign({}, defaultThemeObj.symbol),
    text: Object.assign({}, defaultThemeObj.text),
    rect: Object.assign({}, defaultThemeObj.rect),
    polygon: Object.assign({}, defaultThemeObj.polygon),
    richtext: Object.assign({}, defaultThemeObj.richtext),
    richtextIcon: Object.assign({}, defaultThemeObj.richtextIcon),
    image: Object.assign({}, defaultThemeObj.image),
    group: Object.assign({}, defaultThemeObj.group),
    glyph: Object.assign({}, defaultThemeObj.glyph)
  };
}
function combine(out, t) {
  Object.keys(t).forEach((k2) => {
    out[k2] = t[k2];
  });
}
var globalThemeObj = newThemeObj();
var Theme = class {
  constructor() {
    this.initTheme(), this.dirty = false;
  }
  initTheme() {
    this._defaultTheme = {}, themeKeys.forEach((key) => {
      this._defaultTheme[key] = Object.create(globalThemeObj[key]);
    }), this.combinedTheme = this._defaultTheme;
  }
  getTheme(group) {
    if (!group)
      return this.combinedTheme;
    if (!this.dirty)
      return this.combinedTheme;
    let parentTheme = {};
    const parentGroup = this.getParentWithTheme(group);
    return parentGroup && (parentTheme = parentGroup.theme), this.applyTheme(group, parentTheme), this.combinedTheme;
  }
  getParentWithTheme(group) {
    for (; group.parent; )
      if ((group = group.parent).theme)
        return group;
    return null;
  }
  applyTheme(group, pt, force = false) {
    if (this.dirty) {
      const parentGroup = this.getParentWithTheme(group);
      if (parentGroup) {
        const parentTheme = parentGroup.theme;
        (parentTheme.dirty || force) && parentTheme.applyTheme(parentGroup, pt, true);
      }
      this.userTheme ? this.doCombine(parentGroup && parentGroup.theme.combinedTheme) : (parentGroup ? this.combinedTheme = parentGroup.theme.combinedTheme : (this.combinedTheme = this._defaultTheme, Logger.getInstance().warn("\u672A\u77E5\u9519\u8BEF\uFF0C\u8D70\u5230\u4E0D\u5E94\u8BE5\u8D70\u7684\u533A\u57DF\u91CC")), this.dirty = false);
    }
    return this.combinedTheme;
  }
  doCombine(parentCombinedTheme) {
    const userTheme = this.userTheme, combinedTheme = this.combinedTheme;
    themeKeys.forEach((k2) => {
      const obj = Object.create(globalThemeObj[k2]);
      parentCombinedTheme && parentCombinedTheme[k2] && combine(obj, parentCombinedTheme[k2]), combinedTheme[k2] && combine(obj, combinedTheme[k2]), userTheme[k2] && combine(obj, userTheme[k2]), this.combinedTheme[k2] = obj;
    }), userTheme.common && themeKeys.forEach((k2) => {
      combine(this.combinedTheme[k2], userTheme.common);
    }), this.dirty = false;
  }
  setTheme(t, g) {
    let userTheme = this.userTheme;
    userTheme ? Object.keys(t).forEach((k2) => {
      userTheme[k2] ? Object.assign(userTheme[k2], t[k2]) : userTheme[k2] = Object.assign({}, t[k2]);
    }) : userTheme = t, this.userTheme = userTheme, this.dirty = true, this.dirtyChildren(g);
  }
  resetTheme(t, g) {
    this.userTheme = t, this.dirty = true, this.dirtyChildren(g);
  }
  dirtyChildren(g) {
    g.forEachChildren((item) => {
      item.isContainer && (item.theme && (item.theme.dirty = true), this.dirtyChildren(item));
    });
  }
};
var globalTheme = new Theme();
function getTheme(graphic, theme2) {
  return graphic.glyphHost ? getTheme(graphic.glyphHost) : theme2 ? (graphic.isContainer, theme2) : getThemeFromGroup(graphic) || graphic.attachedThemeGraphic && getTheme(graphic.attachedThemeGraphic) || globalTheme.getTheme();
}
function getThemeFromGroup(graphic) {
  let g;
  if (g = graphic.isContainer ? graphic : graphic.parent, g) {
    for (; g && !g.theme; )
      g = g.parent;
    return g ? (g.theme || g.createTheme(), g.theme.getTheme(g)) : globalTheme.getTheme();
  }
  return null;
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/node-tree
var __awaiter = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Node = class extends import_eventemitter3.default {
  get previousSibling() {
    return this._prev;
  }
  get nextSibling() {
    return this._next;
  }
  get children() {
    return this.getChildren();
  }
  get firstChild() {
    return this._firstChild;
  }
  get lastChild() {
    return this._lastChild;
  }
  get count() {
    return this._count;
  }
  get childrenCount() {
    return this._idMap ? this._idMap.size : 0;
  }
  constructor() {
    super(), this._uid = Generator.GenAutoIncrementId(), this._firstChild = null, this._lastChild = null, this.parent = null, this._count = 1;
  }
  forEachChildren(cb, reverse = false) {
    if (reverse) {
      let child = this._lastChild, i = 0;
      for (; child; ) {
        if (cb(child, i++))
          return;
        child = child._prev;
      }
    } else {
      let child = this._firstChild, i = 0;
      for (; child; ) {
        if (cb(child, i++))
          return;
        child = child._next;
      }
    }
  }
  forEachChildrenAsync(cb, reverse = false) {
    return __awaiter(this, void 0, void 0, function* () {
      if (reverse) {
        let child = this._lastChild, i = 0;
        for (; child; ) {
          let breakTag = cb(child, i++);
          if (breakTag.then && (breakTag = yield breakTag), breakTag)
            return;
          child = child._prev;
        }
      } else {
        let child = this._firstChild, i = 0;
        for (; child; ) {
          let breakTag = cb(child, i++);
          if (breakTag.then && (breakTag = yield breakTag), breakTag)
            return;
          child = child._next;
        }
      }
    });
  }
  forEach(cb) {
    return this.forEachChildren(cb);
  }
  appendChild(node, highPerformance = true) {
    if (this._uid === node._uid)
      return null;
    if (!highPerformance && node.isAncestorsOf(this))
      throw new Error("\u3010Node::appendChild\u3011\u4E0D\u80FD\u5C06\u7236\u8F88\u5143\u7D20append\u4E3A\u5B50\u5143\u7D20");
    return node.parent && node.parent.removeChild(node), node.parent = this, this._lastChild ? (this._lastChild._next = node, node._prev = this._lastChild, this._lastChild = node) : (this._firstChild = this._lastChild = node, node._prev = node._next = null), this._idMap || (this._idMap = /* @__PURE__ */ new Map()), this._idMap.set(node._uid, node), this.setCount(node.count), this._structEdit = true, node;
  }
  appendChildArrHighPerformance(nodes, replace = false) {
    return console.error("\u6682\u4E0D\u652F\u6301\u8BE5\u51FD\u6570"), nodes;
  }
  insertBefore(newNode, referenceNode) {
    if (!referenceNode)
      return this.appendChild(newNode);
    if (this._uid === newNode._uid)
      return null;
    if (newNode.isAncestorsOf(this))
      throw new Error("\u3010Node::insertBefore\u3011\u4E0D\u80FD\u5C06\u7236\u8F88\u5143\u7D20insert\u4E3A\u5B50\u5143\u7D20");
    return referenceNode.parent !== this ? null : (newNode.parent && newNode.parent.removeChild(newNode), newNode.parent = this, newNode._prev = referenceNode._prev, referenceNode._prev ? referenceNode._prev._next = newNode : this._firstChild = newNode, referenceNode._prev = newNode, newNode._next = referenceNode, this._idMap || (this._idMap = /* @__PURE__ */ new Map()), this._idMap.set(newNode._uid, newNode), this._structEdit = true, this.setCount(newNode.count), newNode);
  }
  insertAfter(newNode, referenceNode) {
    if (!referenceNode)
      return this.appendChild(newNode);
    if (this._uid === newNode._uid)
      return null;
    if (newNode.isAncestorsOf(this))
      throw new Error("\u3010Node::insertAfter\u3011\u4E0D\u80FD\u5C06\u7236\u8F88\u5143\u7D20insert\u4E3A\u5B50\u5143\u7D20");
    return referenceNode.parent !== this ? null : (newNode.parent && newNode.parent.removeChild(newNode), newNode.parent = this, referenceNode._next ? (referenceNode._next._prev = newNode, newNode._next = referenceNode._next) : this._lastChild = newNode, referenceNode._next = newNode, newNode._prev = referenceNode, this._idMap || (this._idMap = /* @__PURE__ */ new Map()), this._idMap.set(newNode._uid, newNode), this._structEdit = true, this.setCount(newNode.count), newNode);
  }
  insertInto(newNode, idx) {
    if (!this._ignoreWarn && this._nodeList && Logger.getInstance().warn("insertIntoKeepIdx\u548CinsertInto\u6DF7\u7528\u53EF\u80FD\u4F1A\u5B58\u5728\u9519\u8BEF"), idx >= this.childrenCount)
      return this.appendChild(newNode);
    if (this._uid === newNode._uid)
      return null;
    if (newNode.isAncestorsOf(this))
      throw new Error("\u3010Node::insertBefore\u3011\u4E0D\u80FD\u5C06\u7236\u8F88\u5143\u7D20insert\u4E3A\u5B50\u5143\u7D20");
    if (newNode.parent && newNode.parent.removeChild(newNode), newNode.parent = this, 0 === idx)
      newNode._next = this._firstChild, this._firstChild && (this._firstChild._prev = newNode), newNode._prev = null, this._firstChild = newNode;
    else {
      let child = this._firstChild;
      for (let i = 0; i < idx; i++) {
        if (!child)
          return null;
        i > 0 && (child = child._next);
      }
      if (!child)
        return null;
      newNode._next = child._next, newNode._prev = child, child._next = newNode, newNode._next && (newNode._next._prev = newNode);
    }
    return this._idMap || (this._idMap = /* @__PURE__ */ new Map()), this._idMap.set(newNode._uid, newNode), this._structEdit = true, this.setCount(newNode.count), newNode;
  }
  insertIntoKeepIdx(newNode, idx) {
    if (this._nodeList || (this._nodeList = this.children), this._nodeList[idx]) {
      const node2 = this._nodeList[idx];
      return this._nodeList.splice(idx, 0, newNode), this.insertBefore(newNode, node2);
    }
    let node;
    this._nodeList[idx] = newNode;
    for (let i = idx - 1; i >= 0 && (node = this._nodeList[i], !node); i--)
      ;
    if (node)
      return node._next ? this.insertBefore(newNode, node._next) : this.appendChild(newNode);
    this._ignoreWarn = true;
    const data = this.insertInto(newNode, 0);
    return this._ignoreWarn = false, data;
  }
  removeChild(child) {
    if (!this._idMap)
      return null;
    if (!this._idMap.has(child._uid))
      return null;
    if (this._idMap.delete(child._uid), this._nodeList) {
      const idx = this._nodeList.findIndex((n) => n === child);
      idx >= 0 && this._nodeList.splice(idx, 1);
    }
    return child._prev ? child._prev._next = child._next : this._firstChild = child._next, child._next ? child._next._prev = child._prev : this._lastChild = child._prev, child.parent = null, child._prev = null, child._next = null, this._structEdit = true, this.setCount(-child.count), child;
  }
  delete() {
    this.parent && this.parent.removeChild(this);
  }
  removeAllChild(deep) {
    if (!this._idMap)
      return;
    this._nodeList && (this._nodeList.length = 0);
    let child = this._firstChild;
    for (; child; ) {
      const next = child._next;
      child.parent = null, child._prev = null, child._next = null, child = child._next, child = next;
    }
    this._firstChild = null, this._lastChild = null, this._idMap.clear(), this._structEdit = true, this.setCount(1 - this._count);
  }
  replaceChild(newChild, oldChild) {
    throw new Error("\u6682\u4E0D\u652F\u6301");
  }
  find(callback, deep = false) {
    let target = null;
    return this.forEachChildren((node, index) => !(node === this || !callback(node, index)) && (target = node, true)), deep && this.forEachChildren((child) => {
      if (child.isContainer) {
        const node = child.find(callback, true);
        if (node)
          return target = node, true;
      }
      return false;
    }), target;
  }
  findAll(callback, deep = false) {
    let nodes = [];
    return this.forEachChildren((node, index) => {
      node !== this && callback(node, index) && nodes.push(node);
    }), deep && this.forEachChildren((child) => {
      if (child.isContainer) {
        const targets = child.findAll(callback, true);
        targets.length && (nodes = nodes.concat(targets));
      }
    }), nodes;
  }
  getElementById(id2) {
    return this.find((node) => node.id === id2, true);
  }
  findChildById(id2) {
    return this.getElementById(id2);
  }
  findChildByUid(uid) {
    return this._idMap && this._idMap.get(uid) || null;
  }
  getElementsByName(name) {
    return this.findAll((node) => node.name === name, true);
  }
  findChildrenByName(name) {
    return this.getElementsByName(name);
  }
  getElementsByType(type) {
    return this.findAll((node) => node.type === type, true);
  }
  getChildByName(name, deep = false) {
    return this.find((node) => node.name === name, deep);
  }
  getChildAt(idx) {
    let c3 = this._firstChild;
    if (!c3)
      return null;
    for (let i = 0; i < idx; i++) {
      if (!c3._next)
        return null;
      c3 = c3._next;
    }
    return c3;
  }
  at(idx) {
    return this.getChildAt(idx);
  }
  containNode(node) {
    if (!this._idMap)
      return false;
    if (this._idMap.has(node._uid))
      return true;
    let child = this._firstChild;
    for (; child; ) {
      if (child.containNode(node))
        return true;
      child = child._next;
    }
    return false;
  }
  getRootNode() {
    let parent = this.parent;
    for (; null == parent ? void 0 : parent.parent; )
      parent = parent.parent;
    return parent || this;
  }
  hasChildNodes() {
    return null !== this._firstChild;
  }
  addChild(node) {
    return this.appendChild(node);
  }
  add(node) {
    return this.appendChild(node);
  }
  getChildren() {
    const nodes = [];
    let child = this._firstChild;
    for (; child; )
      nodes.push(child), child = child._next;
    return nodes;
  }
  isChildOf(node) {
    return !!this.parent && this.parent._uid === node._uid;
  }
  isParentOf(node) {
    return node.isChildOf(this);
  }
  isDescendantsOf(node) {
    let parent = this.parent;
    if (!parent)
      return false;
    do {
      if (parent._uid === node._uid)
        return true;
      parent = parent.parent;
    } while (null !== parent);
    return false;
  }
  isAncestorsOf(node) {
    return node.isDescendantsOf(this);
  }
  getAncestor(idx) {
    throw new Error("\u6682\u4E0D\u652F\u6301");
  }
  setAllDescendantsProps(propsName, propsValue) {
    let child = this._firstChild;
    for (; child; )
      child[propsName] = propsValue, child.setAllDescendantsProps(propsName, propsValue), child = child._next;
  }
  setCount(deltaCount) {
    this._count += deltaCount;
    let parent = this.parent;
    if (parent)
      do {
        parent._count += deltaCount, parent = parent.parent;
      } while (null !== parent);
  }
  clone() {
    throw new Error("\u6682\u4E0D\u652F\u6301");
  }
  cloneTo(node) {
    throw new Error("\u6682\u4E0D\u652F\u6301");
  }
  getParent() {
    return this.parent;
  }
  del(child) {
    return this.removeChild(child);
  }
  addEventListener(type, listener, options) {
    const capture = isBoolean_default(options, true) && options || isObject_default(options) && options.capture, once = isObject_default(options) && options.once, context = isFunction_default(listener) ? void 0 : listener;
    return type = capture ? `${type}capture` : type, listener = isFunction_default(listener) ? listener : listener.handleEvent, once ? super.once(type, listener, context) : super.on(type, listener, context), this;
  }
  on(type, listener, options) {
    return this.addEventListener(type, listener, options);
  }
  removeEventListener(type, listener, options) {
    const capture = isBoolean_default(options, true) && options || isObject_default(options) && options.capture, context = isFunction_default(listener) ? void 0 : listener;
    type = capture ? `${type}capture` : type, listener = isFunction_default(listener) ? listener : listener.handleEvent;
    const once = isObject_default(options) && options.once;
    return super.off(type, listener, context, once), this;
  }
  off(type, listener, options) {
    return this.removeEventListener(type, listener, options);
  }
  once(type, listener, options) {
    return isObject_default(options) ? (options.once = true, this.addEventListener(type, listener, options)) : this.addEventListener(type, listener, {
      once: true
    });
  }
  removeAllEventListeners() {
    return super.removeAllListeners(), this;
  }
  removeAllListeners() {
    return this.removeAllEventListeners();
  }
  dispatchEvent(event, ...args) {
    return super.emit(event.type, event, ...args), !event.defaultPrevented;
  }
  emit(event, data) {
    return this.dispatchEvent(event, data);
  }
  release() {
    this.removeAllListeners();
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/event/federated-event/base-event
var FederatedEvent = class _FederatedEvent {
  get layerX() {
    return this.layer.x;
  }
  get layerY() {
    return this.layer.y;
  }
  get pageX() {
    return this.page.x;
  }
  get pageY() {
    return this.page.y;
  }
  get x() {
    return this.canvas.x;
  }
  get y() {
    return this.canvas.y;
  }
  get canvasX() {
    return this.canvas.x;
  }
  get canvasY() {
    return this.canvas.y;
  }
  get viewX() {
    return this.viewport.x;
  }
  get viewY() {
    return this.viewport.y;
  }
  constructor(manager) {
    this.bubbles = true, this.cancelBubble = true, this.cancelable = false, this.composed = false, this.defaultPrevented = false, this.eventPhase = _FederatedEvent.prototype.NONE, this.propagationStopped = false, this.propagationImmediatelyStopped = false, this.layer = {
      x: 0,
      y: 0
    }, this.page = {
      x: 0,
      y: 0
    }, this.canvas = {
      x: 0,
      y: 0
    }, this.viewport = {
      x: 0,
      y: 0
    }, this.NONE = 0, this.CAPTURING_PHASE = 1, this.AT_TARGET = 2, this.BUBBLING_PHASE = 3, this.manager = manager;
  }
  composedPath() {
    return !this.manager || this.path && this.path[this.path.length - 1] === this.target || (this.path = this.target ? this.manager.propagationPath(this.target) : []), this.composedDetailPath(), this.path;
  }
  composedDetailPath() {
    return this.pickParams && this.pickParams.graphic ? (this.detailPath = this.path.slice(), this._composedDetailPath(this.pickParams)) : this.detailPath = this.path.slice(), this.detailPath;
  }
  _composedDetailPath(params2) {
    if (params2 && params2.graphic) {
      const g = this.pickParams.graphic;
      if (g.stage) {
        const path = g.stage.eventSystem.manager.propagationPath(g);
        this.detailPath.push(path), this._composedDetailPath(params2.params);
      }
    }
  }
  preventDefault() {
    this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(), this.defaultPrevented = true;
  }
  stopImmediatePropagation() {
    this.propagationImmediatelyStopped = true;
  }
  stopPropagation() {
    this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.stopPropagation(), this.propagationStopped = true;
  }
  initEvent() {
  }
  initUIEvent() {
  }
  clone() {
    throw new Error("Method not implemented.");
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/event/federated-event/mouse-event
var FederatedMouseEvent = class extends FederatedEvent {
  constructor() {
    super(...arguments), this.client = {
      x: 0,
      y: 0
    }, this.movement = {
      x: 0,
      y: 0
    }, this.offset = {
      x: 0,
      y: 0
    }, this.global = {
      x: 0,
      y: 0
    }, this.screen = {
      x: 0,
      y: 0
    };
  }
  get clientX() {
    return this.client.x;
  }
  get clientY() {
    return this.client.y;
  }
  get movementX() {
    return this.movement.x;
  }
  get movementY() {
    return this.movement.y;
  }
  get offsetX() {
    return this.offset.x;
  }
  get offsetY() {
    return this.offset.y;
  }
  get globalX() {
    return this.global.x;
  }
  get globalY() {
    return this.global.y;
  }
  get screenX() {
    return this.screen.x;
  }
  get screenY() {
    return this.screen.y;
  }
  getModifierState(key) {
    return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
  }
  initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
    throw new Error("Method not implemented.");
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/event/federated-event/pointer-event
var FederatedPointerEvent = class _FederatedPointerEvent extends FederatedMouseEvent {
  constructor() {
    super(...arguments), this.width = 0, this.height = 0, this.isPrimary = false;
  }
  getCoalescedEvents() {
    return "pointermove" === this.type || "mousemove" === this.type || "touchmove" === this.type ? [this] : [];
  }
  getPredictedEvents() {
    throw new Error("getPredictedEvents is not supported!");
  }
  clone() {
    var _a, _b, _c;
    const event = new _FederatedPointerEvent(this.manager);
    event.eventPhase = event.NONE, event.currentTarget = null, event.path = [], event.detailPath = [], event.target = null, event.nativeEvent = this.nativeEvent, event.originalEvent = this.originalEvent, null === (_a = this.manager) || void 0 === _a || _a.copyPointerData(this, event), null === (_b = this.manager) || void 0 === _b || _b.copyMouseData(this, event), null === (_c = this.manager) || void 0 === _c || _c.copyData(this, event), event.target = this.target, event.path = this.composedPath().slice();
    const p = this.composedDetailPath();
    return event.detailPath = p && p.slice(), event.type = this.type, event;
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/event/federated-event/wheel-event
var FederatedWheelEvent = class _FederatedWheelEvent extends FederatedMouseEvent {
  constructor() {
    super(...arguments), this.DOM_DELTA_PIXEL = 0, this.DOM_DELTA_LINE = 1, this.DOM_DELTA_PAGE = 2;
  }
  clone() {
    var _a, _b, _c;
    const event = new _FederatedWheelEvent(this.manager);
    event.eventPhase = event.NONE, event.currentTarget = null, event.path = [], event.detailPath = [], event.target = null, event.nativeEvent = this.nativeEvent, event.originalEvent = this.originalEvent, null === (_a = this.manager) || void 0 === _a || _a.copyWheelData(this, event), null === (_b = this.manager) || void 0 === _b || _b.copyMouseData(this, event), null === (_c = this.manager) || void 0 === _c || _c.copyData(this, event), event.target = this.target, event.path = this.composedPath().slice();
    const p = this.composedDetailPath();
    return event.detailPath = p && p.slice(), event.type = this.type, event;
  }
};
FederatedWheelEvent.DOM_DELTA_PIXEL = 0, FederatedWheelEvent.DOM_DELTA_LINE = 1, FederatedWheelEvent.DOM_DELTA_PAGE = 2;

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/event/federated-event/custom-event
var CustomEvent = class extends FederatedEvent {
  constructor(eventName, object) {
    super(), this.type = eventName, this.detail = object;
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/event/constant
var WILDCARD = "*";

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/event/util
var clock = "object" == typeof performance && performance.now ? performance : Date;

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/event/event-manager
function isMouseLike(pointerType) {
  return "mouse" === pointerType || "pen" === pointerType;
}
var EventManager = class {
  constructor(root, config2) {
    this.dispatch = new import_eventemitter3.default(), this.cursorTarget = null, this.pauseNotify = false, this.mappingState = {
      trackingData: {}
    }, this.eventPool = /* @__PURE__ */ new Map(), this.onPointerDown = (from, target) => {
      if (!(from instanceof FederatedPointerEvent))
        return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
      const e = this.createPointerEvent(from, from.type, target);
      if (this.dispatchEvent(e, "pointerdown"), "touch" === e.pointerType)
        this.dispatchEvent(e, "touchstart");
      else if (isMouseLike(e.pointerType)) {
        const isRightButton = 2 === e.button;
        this.dispatchEvent(e, isRightButton ? "rightdown" : "mousedown");
      }
      this.trackingData(from.pointerId).pressTargetsByButton[from.button] = e.composedPath(), this.freeEvent(e);
    }, this.onPointerMove = (from, target) => {
      var _a, _b;
      if (!(from instanceof FederatedPointerEvent))
        return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
      const e = this.createPointerEvent(from, from.type, target), isMouse = isMouseLike(e.pointerType), trackingData = this.trackingData(from.pointerId), outTarget = this.findMountedTarget(trackingData.overTargets);
      if (trackingData.overTargets && outTarget && outTarget !== this.rootTarget && outTarget !== e.target) {
        const outType = "mousemove" === from.type ? "mouseout" : "pointerout", outEvent = this.createPointerEvent(from, outType, outTarget || void 0);
        if (this.dispatchEvent(outEvent, "pointerout"), isMouse && this.dispatchEvent(outEvent, "mouseout"), !e.composedPath().includes(outTarget)) {
          const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget || void 0);
          for (leaveEvent.eventPhase = leaveEvent.AT_TARGET; leaveEvent.target && !e.composedPath().includes(leaveEvent.target); )
            leaveEvent.currentTarget = leaveEvent.target, this.notifyTarget(leaveEvent), isMouse && this.notifyTarget(leaveEvent, "mouseleave"), leaveEvent.target = leaveEvent.target.parent;
          this.freeEvent(leaveEvent);
        }
        this.freeEvent(outEvent);
      }
      if (outTarget !== e.target) {
        const overType = "mousemove" === from.type ? "mouseover" : "pointerover", overEvent = this.clonePointerEvent(e, overType);
        this.dispatchEvent(overEvent, "pointerover"), isMouse && this.dispatchEvent(overEvent, "mouseover");
        let overTargetAncestor = null == outTarget ? void 0 : outTarget.parent;
        for (; overTargetAncestor && overTargetAncestor !== this.rootTarget.parent && overTargetAncestor !== e.target; )
          overTargetAncestor = overTargetAncestor.parent;
        if (!overTargetAncestor || overTargetAncestor === this.rootTarget.parent) {
          const enterEvent = this.clonePointerEvent(e, "pointerenter");
          enterEvent.eventPhase = enterEvent.AT_TARGET;
          let currentTarget = enterEvent.target;
          const outTargetAncestors = /* @__PURE__ */ new Set();
          let ancestor = outTarget;
          for (; ancestor && ancestor !== this.rootTarget; )
            outTargetAncestors.add(ancestor), ancestor = ancestor.parent;
          for (; currentTarget && currentTarget !== outTarget && currentTarget !== this.rootTarget.parent; )
            outTargetAncestors.has(currentTarget) || (enterEvent.currentTarget = currentTarget, this.notifyTarget(enterEvent), isMouse && this.notifyTarget(enterEvent, "mouseenter")), currentTarget = currentTarget.parent;
          this.freeEvent(enterEvent);
        }
        this.freeEvent(overEvent);
      }
      this.dispatchEvent(e, "pointermove"), "touch" === e.pointerType && this.dispatchEvent(e, "touchmove"), isMouse && (this.dispatchEvent(e, "mousemove"), this.cursorTarget = e.target, this.cursor = (null === (_b = null === (_a = e.target) || void 0 === _a ? void 0 : _a.attribute) || void 0 === _b ? void 0 : _b.cursor) || this.rootTarget.getCursor()), trackingData.overTargets = e.composedPath(), this.freeEvent(e);
    }, this.onPointerOver = (from, target) => {
      var _a, _b;
      if (!(from instanceof FederatedPointerEvent))
        return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
      const trackingData = this.trackingData(from.pointerId), e = this.createPointerEvent(from, from.type, target), isMouse = isMouseLike(e.pointerType);
      this.dispatchEvent(e, "pointerover"), isMouse && this.dispatchEvent(e, "mouseover"), "mouse" === e.pointerType && (this.cursorTarget = e.target, this.cursor = (null === (_b = null === (_a = e.target) || void 0 === _a ? void 0 : _a.attribute) || void 0 === _b ? void 0 : _b.cursor) || this.rootTarget.getCursor());
      const enterEvent = this.clonePointerEvent(e, "pointerenter");
      for (enterEvent.eventPhase = enterEvent.AT_TARGET; enterEvent.target && enterEvent.target !== this.rootTarget.parent; )
        enterEvent.currentTarget = enterEvent.target, this.notifyTarget(enterEvent), isMouse && this.notifyTarget(enterEvent, "mouseenter"), enterEvent.target = enterEvent.target.parent;
      trackingData.overTargets = e.composedPath(), this.freeEvent(e), this.freeEvent(enterEvent);
    }, this.onPointerOut = (from, target) => {
      if (!(from instanceof FederatedPointerEvent))
        return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
      const trackingData = this.trackingData(from.pointerId);
      if (trackingData.overTargets) {
        const isMouse = isMouseLike(from.pointerType), outTarget = this.findMountedTarget(trackingData.overTargets), outEvent = this.createPointerEvent(from, "pointerout", outTarget || void 0);
        this.dispatchEvent(outEvent), isMouse && this.dispatchEvent(outEvent, "mouseout");
        const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget || void 0);
        for (leaveEvent.eventPhase = leaveEvent.AT_TARGET; leaveEvent.target && leaveEvent.target !== this.rootTarget.parent; )
          leaveEvent.currentTarget = leaveEvent.target, this.notifyTarget(leaveEvent), isMouse && this.notifyTarget(leaveEvent, "mouseleave"), leaveEvent.target = leaveEvent.target.parent;
        trackingData.overTargets = [], this.freeEvent(outEvent), this.freeEvent(leaveEvent);
      }
      this.cursorTarget = null, this.cursor = "";
    }, this.onPointerUp = (from, target) => {
      var _a;
      if (!(from instanceof FederatedPointerEvent))
        return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
      const now = clock.now(), e = this.createPointerEvent(from, from.type, target);
      if (this.dispatchEvent(e, "pointerup"), "touch" === e.pointerType)
        this.dispatchEvent(e, "touchend");
      else if (isMouseLike(e.pointerType)) {
        const isRightButton = 2 === e.button;
        this.dispatchEvent(e, isRightButton ? "rightup" : "mouseup");
      }
      const trackingData = this.trackingData(from.pointerId), pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
      let clickTarget = pressTarget;
      if (pressTarget && !e.composedPath().includes(pressTarget)) {
        let currentTarget = pressTarget;
        for (; currentTarget && !e.composedPath().includes(currentTarget); ) {
          if (e.currentTarget = currentTarget, this.notifyTarget(e, "pointerupoutside"), "touch" === e.pointerType)
            this.notifyTarget(e, "touchendoutside");
          else if (isMouseLike(e.pointerType)) {
            const isRightButton = 2 === e.button;
            this.notifyTarget(e, isRightButton ? "rightupoutside" : "mouseupoutside");
          }
          currentTarget = currentTarget.parent;
        }
        delete trackingData.pressTargetsByButton[from.button], clickTarget = currentTarget;
      }
      if (clickTarget) {
        const clickEvent = this.clonePointerEvent(e, "click");
        clickEvent.target = clickTarget, clickEvent.path = [], clickEvent.detailPath = [], trackingData.clicksByButton[from.button] || (trackingData.clicksByButton[from.button] = {
          clickCount: 0,
          target: clickEvent.target,
          timeStamp: now
        });
        const clickHistory = trackingData.clicksByButton[from.button];
        clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < (null !== (_a = this._config.clickInterval) && void 0 !== _a ? _a : 200) ? ++clickHistory.clickCount : clickHistory.clickCount = 1, clickHistory.target = clickEvent.target, clickHistory.timeStamp = now, clickEvent.detail = clickHistory.clickCount, isMouseLike(clickEvent.pointerType) ? (this.dispatchEvent(clickEvent, "click"), 2 === clickHistory.clickCount && this.dispatchEvent(clickEvent, "dblclick")) : "touch" === clickEvent.pointerType && (this.dispatchEvent(clickEvent, "tap"), 2 === clickHistory.clickCount && this.dispatchEvent(clickEvent, "dbltap")), this.dispatchEvent(clickEvent, "pointertap"), this.freeEvent(clickEvent);
      }
      this.freeEvent(e);
    }, this.onPointerUpOutside = (from, target) => {
      if (!(from instanceof FederatedPointerEvent))
        return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
      const trackingData = this.trackingData(from.pointerId), pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]), e = this.createPointerEvent(from, from.type, target);
      if (pressTarget) {
        let currentTarget = pressTarget;
        for (; currentTarget; )
          e.currentTarget = currentTarget, this.notifyTarget(e, "pointerupoutside"), "touch" === e.pointerType ? this.notifyTarget(e, "touchendoutside") : isMouseLike(e.pointerType) && this.notifyTarget(e, 2 === e.button ? "rightupoutside" : "mouseupoutside"), currentTarget = currentTarget.parent;
        delete trackingData.pressTargetsByButton[from.button];
      }
      this.freeEvent(e);
    }, this.onWheel = (from, target) => {
      if (!(from instanceof FederatedWheelEvent))
        return void Logger.getInstance().warn("EventManager cannot map a non-wheel event as a wheel event");
      const wheelEvent = this.createWheelEvent(from, target);
      this.dispatchEvent(wheelEvent), this.freeEvent(wheelEvent);
    }, this.rootTarget = root, this.mappingTable = {}, this._config = Object.assign({
      clickInterval: 200
    }, config2), this.addEventMapping("pointerdown", this.onPointerDown), this.addEventMapping("pointermove", this.onPointerMove), this.addEventMapping("pointerout", this.onPointerOut), this.addEventMapping("pointerleave", this.onPointerOut), this.addEventMapping("pointerover", this.onPointerOver), this.addEventMapping("pointerup", this.onPointerUp), this.addEventMapping("pointerupoutside", this.onPointerUpOutside), this.addEventMapping("wheel", this.onWheel);
  }
  addEventMapping(type, fn) {
    this.mappingTable[type] || (this.mappingTable[type] = []), this.mappingTable[type].push({
      fn,
      priority: 0
    }), this.mappingTable[type].sort((a3, b) => a3.priority - b.priority);
  }
  dispatchEvent(e, type) {
    e.propagationStopped = false, e.propagationImmediatelyStopped = false, this.propagate(e, type), this.dispatch.emit(type || e.type, e);
  }
  mapEvent(e) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (!this.rootTarget)
      return;
    const mappers = this.mappingTable[e.type];
    let target;
    const cacheKey = `${e.canvasX}-${e.canvasY}`;
    if ((null === (_a = this._prePointTargetCache) || void 0 === _a ? void 0 : _a[cacheKey]) && (null === (_c = null === (_b = this._prePointTargetCache) || void 0 === _b ? void 0 : _b[cacheKey]) || void 0 === _c ? void 0 : _c.stage) && (null === (_e = null === (_d = this._prePointTargetCache) || void 0 === _d ? void 0 : _d[cacheKey]) || void 0 === _e ? void 0 : _e.stage.renderCount) === (null === (_f = this._prePointTargetCache) || void 0 === _f ? void 0 : _f.stageRenderCount) ? target = this._prePointTargetCache[cacheKey] : (target = this.pickTarget(e.viewX, e.viewY, e), e.pickParams || (this._prePointTargetCache = {
      [cacheKey]: target,
      stageRenderCount: null !== (_g = null == target ? void 0 : target.stage.renderCount) && void 0 !== _g ? _g : -1
    })), mappers)
      for (let i = 0, j = mappers.length; i < j; i++)
        mappers[i].fn(e, target);
    else
      Logger.getInstance().warn(`[EventManager]: Event mapping not defined for ${e.type}`);
  }
  propagate(e, type) {
    if (!e.target)
      return;
    const composedPath = e.composedPath();
    e.eventPhase = e.CAPTURING_PHASE;
    for (let i = 0, j = composedPath.length - 1; i < j; i++)
      if (e.currentTarget = composedPath[i], this.notifyTarget(e, type), e.propagationStopped || e.propagationImmediatelyStopped)
        return;
    if (e.eventPhase = e.AT_TARGET, e.currentTarget = e.target, this.notifyTarget(e, type), !e.propagationStopped && !e.propagationImmediatelyStopped) {
      e.eventPhase = e.BUBBLING_PHASE;
      for (let i = composedPath.length - 2; i >= 0; i--)
        if (e.currentTarget = composedPath[i], this.notifyTarget(e, type), e.propagationStopped || e.propagationImmediatelyStopped)
          return;
    }
  }
  propagationPath(target) {
    const propagationPath = [target];
    for (let i = 0; i < 2048 && target !== this.rootTarget && target.parent; i++) {
      if (!target.parent)
        throw new Error("Cannot find propagation path to disconnected target");
      propagationPath.push(target.parent), target = target.parent;
    }
    return propagationPath.reverse(), propagationPath;
  }
  notifyTarget(e, type) {
    if (this.pauseNotify)
      return;
    type = null != type ? type : e.type;
    const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;
    this.notifyListeners(e, key), e.eventPhase === e.AT_TARGET && this.notifyListeners(e, type);
  }
  findMountedTarget(propagationPath) {
    if (!propagationPath)
      return null;
    let currentTarget = propagationPath[0];
    for (let i = 1; i < propagationPath.length && propagationPath[i].parent === currentTarget; i++)
      currentTarget = propagationPath[i];
    return currentTarget;
  }
  createPointerEvent(from, type, target) {
    var _a, _b;
    const event = this.allocateEvent(FederatedPointerEvent);
    return this.copyPointerData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.nativeEvent = from.nativeEvent, event.originalEvent = from, event.target = target || this.pickTarget(null !== (_a = event.viewX) && void 0 !== _a ? _a : event.global.x, null !== (_b = event.viewY) && void 0 !== _b ? _b : event.global.y, event), "string" == typeof type && (event.type = type), event;
  }
  createWheelEvent(from, target) {
    var _a, _b;
    const event = this.allocateEvent(FederatedWheelEvent);
    return this.copyWheelData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.nativeEvent = from.nativeEvent, event.originalEvent = from, event.target = target || this.pickTarget(null !== (_a = event.viewX) && void 0 !== _a ? _a : event.global.x, null !== (_b = event.viewY) && void 0 !== _b ? _b : event.global.y, event), event;
  }
  clonePointerEvent(from, type) {
    const event = this.allocateEvent(FederatedPointerEvent);
    event.nativeEvent = from.nativeEvent, event.originalEvent = from.originalEvent, this.copyPointerData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.target = from.target, event.path = from.composedPath().slice();
    const p = from.composedDetailPath();
    return event.detailPath = p && p.slice(), event.type = null != type ? type : event.type, event;
  }
  copyWheelData(from, to) {
    to.deltaMode = from.deltaMode, to.deltaX = from.deltaX, to.deltaY = from.deltaY, to.deltaZ = from.deltaZ;
  }
  copyPointerData(from, to) {
    from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent && (to.pointerId = from.pointerId, to.width = from.width, to.height = from.height, to.isPrimary = from.isPrimary, to.pointerType = from.pointerType, to.pressure = from.pressure, to.tangentialPressure = from.tangentialPressure, to.tiltX = from.tiltX, to.tiltY = from.tiltY, to.twist = from.twist);
  }
  copyMouseData(from, to) {
    from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent && (to.altKey = from.altKey, to.button = from.button, to.buttons = from.buttons, to.ctrlKey = from.ctrlKey, to.shiftKey = from.shiftKey, to.metaKey = from.metaKey, ["client", "movement", "canvas", "screen", "global", "offset", "viewport"].forEach((key) => {
      to[key].x = from[key].x, to[key].y = from[key].y;
    }));
  }
  copyData(from, to) {
    to.isTrusted = from.isTrusted, to.srcElement = from.srcElement, to.timeStamp = clock.now(), to.type = from.type, to.detail = from.detail, to.view = from.view, to.which = from.which, to.layer.x = from.layer.x, to.layer.y = from.layer.y, to.page.x = from.page.x, to.page.y = from.page.y, to.pickParams = from.pickParams;
  }
  trackingData(id2) {
    return this.mappingState.trackingData[id2] || (this.mappingState.trackingData[id2] = {
      pressTargetsByButton: {},
      clicksByButton: {},
      overTarget: null
    }), this.mappingState.trackingData[id2];
  }
  allocateEvent(constructor) {
    var _a;
    this.eventPool.has(constructor) || this.eventPool.set(constructor, []);
    const event = (null === (_a = this.eventPool.get(constructor)) || void 0 === _a ? void 0 : _a.pop()) || new constructor(this);
    return event.eventPhase = event.NONE, event.currentTarget = null, event.path = [], event.detailPath = [], event.target = null, event;
  }
  freeEvent(event) {
    var _a;
    if (event.manager !== this)
      throw new Error("It is illegal to free an event not managed by this EventManager!");
    const constructor = event.constructor;
    this.eventPool.has(constructor) || this.eventPool.set(constructor, []), null === (_a = this.eventPool.get(constructor)) || void 0 === _a || _a.push(event);
  }
  notifyListeners(e, type) {
    const listeners = e.currentTarget._events[type];
    if (listeners)
      if ("fn" in listeners)
        listeners.once && e.currentTarget.removeEventListener(type, listeners.fn, {
          once: true
        }), listeners.fn.call(listeners.context, e);
      else
        for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++)
          listeners[i].once && e.currentTarget.removeEventListener(type, listeners[i].fn, {
            once: true
          }), listeners[i].fn.call(listeners[i].context, e);
    this.emitDelegation(e, type);
  }
  emitDelegation(e, type) {
    const listeners = e.currentTarget._events[WILDCARD];
    if (listeners)
      if ("fn" in listeners)
        listeners.fn.call(listeners.context, e, type);
      else
        for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++)
          listeners[i].fn.call(listeners[i].context, e, type);
  }
  pickTarget(x, y, e) {
    let target;
    const pickResult = this.rootTarget.pick(x, y);
    return target = pickResult && pickResult.graphic ? pickResult.graphic : pickResult && pickResult.group ? pickResult.group : this.rootTarget.AABBBounds.contains(x, y) ? this.rootTarget : null, e && (e.pickParams = pickResult.params), target;
  }
  release() {
    this.dispatch.removeAllListeners(), this.eventPool.clear(), this.rootTarget = null, this.mappingTable = null, this.mappingState = null, this.cursorTarget = null;
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/event/event-target
var EventTarget = {
  dispatchEvent(e) {
    var _a;
    if (!(e instanceof FederatedEvent))
      throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
    return e.defaultPrevented = false, e.path = [], e.detailPath && (e.detailPath = []), e.target = this, null === (_a = null == e ? void 0 : e.manager) || void 0 === _a || _a.dispatchEvent(e), !e.defaultPrevented;
  },
  emit(eventName, object) {
    return this.dispatchEvent(new CustomEvent(eventName, object));
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/event/event-system
var TOUCH_TO_POINTER = {
  touchstart: "pointerdown",
  touchend: "pointerup",
  touchendoutside: "pointerupoutside",
  touchmove: "pointermove",
  touchcancel: "pointercancel"
};
var EventSystem = class {
  constructor(params2) {
    this.resolution = 1, this.onPointerDown = (nativeEvent) => {
      if (this.supportsTouchEvents && "touch" === nativeEvent.pointerType)
        return;
      const events = this.normalizeToPointerData(nativeEvent);
      if (this.autoPreventDefault && events[0].isNormalized) {
        (nativeEvent.cancelable || !("cancelable" in nativeEvent)) && nativeEvent.preventDefault();
      }
      for (let i = 0, j = events.length; i < j; i++) {
        const nativeEvent2 = events[i], federatedEvent = this.bootstrapEvent(this.rootPointerEvent, nativeEvent2);
        this.manager.mapEvent(federatedEvent);
      }
      this.setCursor(this.manager.cursor, this.manager.cursorTarget);
    }, this.onPointerMove = (nativeEvent) => {
      if (this.supportsTouchEvents && "touch" === nativeEvent.pointerType)
        return;
      if (this.isEventOutsideOfTargetElement(nativeEvent))
        return;
      const normalizedEvents = this.normalizeToPointerData(nativeEvent);
      for (let i = 0, j = normalizedEvents.length; i < j; i++) {
        const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
        this.manager.mapEvent(event);
      }
      this.setCursor(this.manager.cursor, this.manager.cursorTarget);
    }, this.onPointerUp = (nativeEvent) => {
      if (this.supportsTouchEvents && "touch" === nativeEvent.pointerType)
        return;
      const outside = this.isEventOutsideOfTargetViewPort(nativeEvent) ? "outside" : "", normalizedEvents = this.normalizeToPointerData(nativeEvent);
      for (let i = 0, j = normalizedEvents.length; i < j; i++) {
        const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
        event.type += outside, this.manager.mapEvent(event);
      }
      this.setCursor(this.manager.cursor, this.manager.cursorTarget);
    }, this.onPointerOverOut = (nativeEvent) => {
      if (this.supportsTouchEvents && "touch" === nativeEvent.pointerType)
        return;
      const normalizedEvents = this.normalizeToPointerData(nativeEvent);
      for (let i = 0, j = normalizedEvents.length; i < j; i++) {
        const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
        this.manager.mapEvent(event);
      }
      this.setCursor(this.manager.cursor, this.manager.cursorTarget);
    }, this.onWheel = (nativeEvent) => {
      const wheelEvent = this.normalizeWheelEvent(nativeEvent);
      this.manager.mapEvent(wheelEvent);
    };
    const { targetElement, resolution, rootNode, global, autoPreventDefault = false, clickInterval, supportsTouchEvents = global.supportsTouchEvents, supportsPointerEvents = global.supportsPointerEvents } = params2;
    this.manager = new EventManager(rootNode, {
      clickInterval
    }), this.globalObj = global, this.supportsPointerEvents = supportsPointerEvents, this.supportsTouchEvents = supportsTouchEvents, this.supportsMouseEvents = global.supportsMouseEvents, this.applyStyles = global.applyStyles, this.autoPreventDefault = autoPreventDefault, this.eventsAdded = false, this.rootPointerEvent = new FederatedPointerEvent(), this.rootWheelEvent = new FederatedWheelEvent(), this.cursorStyles = {
      default: "inherit",
      pointer: "pointer"
    }, this.resolution = resolution, this.setTargetElement(targetElement);
  }
  release() {
    this.removeEvents(), this.manager && this.manager.release(), this.domElement = null, this.manager = null, this.globalObj = null;
  }
  setCursor(mode, target) {
    if (!target && !this.manager.rootTarget.window._handler.canvas.controled)
      return;
    mode || (mode = "default");
    const { applyStyles, domElement } = this;
    if (this.currentCursor === mode)
      return;
    this.currentCursor = mode;
    const style = this.cursorStyles[mode];
    style ? "string" == typeof style && applyStyles ? domElement.style.cursor = style : "function" == typeof style ? style(mode) : "object" == typeof style && applyStyles && Object.assign(domElement.style, style) : applyStyles && isString_default(mode) && !has_default(this.cursorStyles, mode) && (domElement.style.cursor = mode);
  }
  setTargetElement(element) {
    this.removeEvents(), this.domElement = element, this.addEvents();
  }
  addEvents() {
    if (this.eventsAdded || !this.domElement)
      return;
    const { globalObj, domElement } = this;
    this.supportsPointerEvents ? (globalObj.getDocument() ? (globalObj.getDocument().addEventListener("pointermove", this.onPointerMove, true), globalObj.getDocument().addEventListener("pointerup", this.onPointerUp, true)) : (domElement.addEventListener("pointermove", this.onPointerMove, true), domElement.addEventListener("pointerup", this.onPointerUp, true)), domElement.addEventListener("pointerdown", this.onPointerDown, true), domElement.addEventListener("pointerleave", this.onPointerOverOut, true), domElement.addEventListener("pointerover", this.onPointerOverOut, true)) : (globalObj.getDocument() ? (globalObj.getDocument().addEventListener("mousemove", this.onPointerMove, true), globalObj.getDocument().addEventListener("mouseup", this.onPointerUp, true)) : (domElement.addEventListener("mousemove", this.onPointerMove, true), domElement.addEventListener("mouseup", this.onPointerUp, true)), domElement.addEventListener("mousedown", this.onPointerDown, true), domElement.addEventListener("mouseout", this.onPointerOverOut, true), domElement.addEventListener("mouseover", this.onPointerOverOut, true)), this.supportsTouchEvents && (domElement.addEventListener("touchstart", this.onPointerDown, true), domElement.addEventListener("touchend", this.onPointerUp, true), domElement.addEventListener("touchmove", this.onPointerMove, true)), domElement.addEventListener("wheel", this.onWheel, {
      capture: true
    }), this.eventsAdded = true;
  }
  removeEvents() {
    if (!this.eventsAdded || !this.domElement)
      return;
    const { globalObj, domElement } = this;
    this.supportsPointerEvents ? (globalObj.getDocument() ? (globalObj.getDocument().removeEventListener("pointermove", this.onPointerMove, true), globalObj.getDocument().removeEventListener("pointerup", this.onPointerUp, true)) : (domElement.removeEventListener("pointermove", this.onPointerMove, true), domElement.removeEventListener("pointerup", this.onPointerUp, true)), domElement.removeEventListener("pointerdown", this.onPointerDown, true), domElement.removeEventListener("pointerleave", this.onPointerOverOut, true), domElement.removeEventListener("pointerover", this.onPointerOverOut, true)) : (globalObj.getDocument() ? (globalObj.getDocument().removeEventListener("mousemove", this.onPointerMove, true), globalObj.getDocument().removeEventListener("mouseup", this.onPointerUp, true)) : (domElement.removeEventListener("mousemove", this.onPointerMove, true), domElement.removeEventListener("mouseup", this.onPointerUp, true)), domElement.removeEventListener("mousedown", this.onPointerDown, true), domElement.removeEventListener("mouseout", this.onPointerOverOut, true), domElement.removeEventListener("mouseover", this.onPointerOverOut, true)), this.supportsTouchEvents && (domElement.removeEventListener("touchstart", this.onPointerDown, true), domElement.removeEventListener("touchend", this.onPointerUp, true), domElement.removeEventListener("touchmove", this.onPointerMove, true)), domElement.removeEventListener("wheel", this.onWheel, true), this.domElement = null, this.eventsAdded = false;
  }
  mapToViewportPoint(event) {
    return this.domElement.pointTransform ? this.domElement.pointTransform(event.x, event.y) : event;
  }
  mapToCanvasPoint(nativeEvent) {
    var _a, _b;
    const point5 = null === (_a = this.globalObj) || void 0 === _a ? void 0 : _a.mapToCanvasPoint(nativeEvent, this.domElement);
    if (point5)
      return point5;
    let x = 0, y = 0;
    if (nativeEvent.changedTouches) {
      const data = null !== (_b = nativeEvent.changedTouches[0]) && void 0 !== _b ? _b : {};
      x = data.clientX || 0, y = data.clientY || 0;
    } else
      x = nativeEvent.clientX || 0, y = nativeEvent.clientY || 0;
    const rect = this.domElement.getBoundingClientRect();
    return {
      x: x - rect.left,
      y: y - rect.top
    };
  }
  normalizeToPointerData(event) {
    const normalizedEvents = [];
    if (this.supportsTouchEvents && event.changedTouches && event.changedTouches.length)
      for (let i = 0, li = event.changedTouches.length; i < li; i++) {
        const touch = event.changedTouches[i];
        isUndefined_default(touch.button) && (touch.button = 0), isUndefined_default(touch.buttons) && (touch.buttons = 1), isUndefined_default(touch.isPrimary) && (touch.isPrimary = 1 === event.touches.length && "touchstart" === event.type), isUndefined_default(touch.width) && (touch.width = touch.radiusX || 1), isUndefined_default(touch.height) && (touch.height = touch.radiusY || 1), isUndefined_default(touch.tiltX) && (touch.tiltX = 0), isUndefined_default(touch.tiltY) && (touch.tiltY = 0), isUndefined_default(touch.pointerType) && (touch.pointerType = "touch"), isUndefined_default(touch.pointerId) && (touch.pointerId = touch.identifier || 0), isUndefined_default(touch.pressure) && (touch.pressure = touch.force || 0.5), isUndefined_default(touch.twist) && (touch.twist = 0), isUndefined_default(touch.tangentialPressure) && (touch.tangentialPressure = 0), isUndefined_default(touch.layerX) && (touch.layerX = touch.offsetX = touch.clientX), isUndefined_default(touch.layerY) && (touch.layerY = touch.offsetY = touch.clientY), touch.isNormalized = true, touch.type = event.type, normalizedEvents.push(touch);
      }
    else if (this.globalObj.supportsMouseEvents && (!(event instanceof MouseEvent) || this.supportsPointerEvents && event instanceof PointerEvent))
      normalizedEvents.push(event);
    else {
      const tempEvent = event;
      isUndefined_default(tempEvent.isPrimary) && (tempEvent.isPrimary = true), isUndefined_default(tempEvent.width) && (tempEvent.width = 1), isUndefined_default(tempEvent.height) && (tempEvent.height = 1), isUndefined_default(tempEvent.tiltX) && (tempEvent.tiltX = 0), isUndefined_default(tempEvent.tiltY) && (tempEvent.tiltY = 0), isUndefined_default(tempEvent.pointerType) && (tempEvent.pointerType = "mouse"), isUndefined_default(tempEvent.pointerId) && (tempEvent.pointerId = 1), isUndefined_default(tempEvent.pressure) && (tempEvent.pressure = 0.5), isUndefined_default(tempEvent.twist) && (tempEvent.twist = 0), isUndefined_default(tempEvent.tangentialPressure) && (tempEvent.tangentialPressure = 0), tempEvent.isNormalized = true, normalizedEvents.push(tempEvent);
    }
    return normalizedEvents;
  }
  normalizeWheelEvent(nativeEvent) {
    const event = this.rootWheelEvent;
    this.transferMouseData(event, nativeEvent), event.deltaMode = nativeEvent.deltaMode, event.deltaX = nativeEvent.deltaX, event.deltaY = nativeEvent.deltaY, event.deltaZ = nativeEvent.deltaZ;
    const { x: canvasX, y: canvasY } = this.mapToCanvasPoint(nativeEvent);
    event.canvas.x = canvasX, event.canvas.y = canvasY, event.global.x = canvasX, event.global.y = canvasY, event.offset.x = canvasX, event.offset.y = canvasY;
    const { x: viewX, y: viewY } = this.mapToViewportPoint(event);
    return event.viewport.x = viewX, event.viewport.y = viewY, event.nativeEvent = nativeEvent, event.type = nativeEvent.type, event;
  }
  bootstrapEvent(event, nativeEvent) {
    event.originalEvent = null, event.nativeEvent = nativeEvent, event.pointerId = nativeEvent.pointerId, event.width = nativeEvent.width, event.height = nativeEvent.height, event.isPrimary = nativeEvent.isPrimary, event.pointerType = nativeEvent.pointerType, event.pressure = nativeEvent.pressure, event.tangentialPressure = nativeEvent.tangentialPressure, event.tiltX = nativeEvent.tiltX, event.tiltY = nativeEvent.tiltY, event.twist = nativeEvent.twist, this.transferMouseData(event, nativeEvent);
    const { x: canvasX, y: canvasY } = this.mapToCanvasPoint(nativeEvent);
    event.canvas.x = canvasX, event.canvas.y = canvasY, event.global.x = canvasX, event.global.y = canvasY, event.offset.x = canvasX, event.offset.y = canvasY;
    const { x: viewX, y: viewY } = this.mapToViewportPoint(event);
    return event.viewport.x = viewX, event.viewport.y = viewY, event.isTrusted = nativeEvent.isTrusted, "pointerleave" === event.type && (event.type = "pointerout"), event.type.startsWith("mouse") && (event.type = event.type.replace("mouse", "pointer")), event.type.startsWith("touch") && (event.type = TOUCH_TO_POINTER[event.type] || event.type), event;
  }
  transferMouseData(event, nativeEvent) {
    event.isTrusted = nativeEvent.isTrusted, event.srcElement = nativeEvent.srcElement, event.timeStamp = clock.now(), event.type = nativeEvent.type, event.altKey = nativeEvent.altKey, event.button = nativeEvent.button, event.buttons = nativeEvent.buttons, event.client.x = nativeEvent.clientX, event.client.y = nativeEvent.clientY, event.ctrlKey = nativeEvent.ctrlKey, event.shiftKey = nativeEvent.shiftKey, event.metaKey = nativeEvent.metaKey, event.movement.x = nativeEvent.movementX, event.movement.y = nativeEvent.movementY, event.page.x = nativeEvent.pageX, event.page.y = nativeEvent.pageY, event.relatedTarget = null;
  }
  isEventOutsideOfTargetViewPort(nativeEvent) {
    if (this.isEventOutsideOfTargetElement(nativeEvent))
      return true;
    if (this.domElement.getViewBox) {
      const p = this.mapToViewportPoint(this.mapToCanvasPoint(nativeEvent)), b = this.domElement.getViewBox(), w = b.width(), h = b.height();
      return !(p.x < w && p.y < h && p.x > 0 && p.y > 0);
    }
    return false;
  }
  isEventOutsideOfTargetElement(nativeEvent) {
    let target = nativeEvent.target;
    nativeEvent.composedPath && nativeEvent.composedPath().length > 0 && (target = nativeEvent.composedPath()[0]);
    return target !== (this.domElement.getNativeHandler ? this.domElement.getNativeHandler().nativeCanvas : this.domElement);
  }
  pauseTriggerEvent() {
    this.manager.pauseNotify = true;
  }
  resumeTriggerEvent() {
    this.manager.pauseNotify = false;
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/animate/Ticker/default-ticker
var ManualTickHandler = class _ManualTickHandler {
  constructor() {
    this.time = 0;
  }
  static Avaliable() {
    return true;
  }
  avaliable() {
    return _ManualTickHandler.Avaliable();
  }
  tick(interval, cb) {
    this.time = Math.max(0, interval + this.time), cb(this, {
      once: true
    });
  }
  tickTo(t, cb) {
    this.time = Math.max(0, t), cb(this, {
      once: true
    });
  }
  release() {
    this.timerId > 0 && (this.timerId = -1);
  }
  getTime() {
    return this.time;
  }
};
var TimeOutTickHandler = class _TimeOutTickHandler {
  static Avaliable() {
    return true;
  }
  avaliable() {
    return _TimeOutTickHandler.Avaliable();
  }
  tick(interval, cb) {
    this.timerId = setTimeout(() => {
      cb(this);
    }, interval);
  }
  release() {
    this.timerId > 0 && (clearTimeout(this.timerId), this.timerId = -1);
  }
  getTime() {
    return Date.now();
  }
};
var RAFTickHandler = class _RAFTickHandler {
  static Avaliable() {
    return !!application.global.getRequestAnimationFrame();
  }
  avaliable() {
    return _RAFTickHandler.Avaliable();
  }
  tick(interval, cb) {
    application.global.getRequestAnimationFrame()(() => {
      this.released || cb(this);
    });
  }
  release() {
    this.released = true;
  }
  getTime() {
    return Date.now();
  }
};
var STATUS;
!function(STATUS3) {
  STATUS3[STATUS3.INITIAL = 0] = "INITIAL", STATUS3[STATUS3.RUNNING = 1] = "RUNNING", STATUS3[STATUS3.PAUSE = 2] = "PAUSE";
}(STATUS || (STATUS = {}));
var DefaultTicker = class {
  set mode(m4) {
    this._mode !== m4 && (this._mode = m4, this.setupTickHandler());
  }
  get mode() {
    return this._mode;
  }
  constructor(timelines = []) {
    this.handleTick = (handler, params2) => {
      const { once = false } = null != params2 ? params2 : {};
      this.ifCanStop() ? this.stop() : (this._handlerTick(handler), once || handler.tick(this.interval, this.handleTick));
    }, this._handlerTick = (handler) => {
      const time = this.tickerHandler.getTime();
      let delta = 0;
      this.lastFrameTime >= 0 && (delta = time - this.lastFrameTime), this.lastFrameTime = time, this.status === STATUS.RUNNING && (this.tickCounts++, this.timelines.forEach((t) => {
        t.tick(delta);
      }));
    }, this.init(), this.lastFrameTime = -1, this.tickCounts = 0, this.timelines = timelines, this.autoStop = true;
  }
  init() {
    this.interval = NaN, this.status = STATUS.INITIAL, application.global.hooks.onSetEnv.tap("default-ticker", () => {
      this.initHandler();
    }), application.global.env && this.initHandler();
  }
  addTimeline(timeline) {
    this.timelines.push(timeline);
  }
  remTimeline(timeline) {
    this.timelines = this.timelines.filter((t) => t !== timeline);
  }
  initHandler() {
    if (this._mode)
      return null;
    const ticks4 = [{
      mode: "raf",
      cons: RAFTickHandler
    }, {
      mode: "timeout",
      cons: TimeOutTickHandler
    }, {
      mode: "manual",
      cons: ManualTickHandler
    }];
    for (let i = 0; i < ticks4.length; i++)
      if (ticks4[i].cons.Avaliable()) {
        this.mode = ticks4[i].mode;
        break;
      }
    return null;
  }
  setupTickHandler() {
    let handler;
    switch (this._mode) {
      case "raf":
        handler = new RAFTickHandler();
        break;
      case "timeout":
        handler = new TimeOutTickHandler();
        break;
      case "manual":
        handler = new ManualTickHandler();
        break;
      default:
        Logger.getInstance().warn("\u975E\u6CD5\u7684\u8BA1\u65F6\u5668\u6A21\u5F0F"), handler = new RAFTickHandler();
    }
    return !!handler.avaliable() && (this.tickerHandler && this.tickerHandler.release(), this.tickerHandler = handler, true);
  }
  setInterval(interval) {
    this.interval = interval;
  }
  getInterval() {
    return this.interval;
  }
  setFPS(fps) {
    this.setInterval(1e3 / fps);
  }
  getFPS() {
    return 1e3 / this.interval;
  }
  tick(interval) {
    this.tickerHandler.tick(interval, (handler) => {
      this.handleTick(handler, {
        once: true
      });
    });
  }
  tickTo(t) {
    this.tickerHandler.tickTo && this.tickerHandler.tickTo(t, (handler) => {
      this.handleTick(handler, {
        once: true
      });
    });
  }
  pause() {
    return this.status !== STATUS.INITIAL && (this.status = STATUS.PAUSE, true);
  }
  resume() {
    return this.status !== STATUS.INITIAL && (this.status = STATUS.RUNNING, true);
  }
  ifCanStop() {
    if (this.autoStop) {
      if (!this.timelines.length)
        return true;
      if (0 === this.timelines.reduce((a3, b) => a3 + b.animateCount, 0))
        return true;
    }
    return false;
  }
  start(force = false) {
    if (this.status === STATUS.RUNNING)
      return false;
    if (!this.tickerHandler)
      return false;
    if (!force) {
      if (this.status === STATUS.PAUSE)
        return false;
      if (!this.timelines.length)
        return false;
      if (0 === this.timelines.reduce((a3, b) => a3 + b.animateCount, 0))
        return false;
    }
    return this.status = STATUS.RUNNING, this.tickerHandler.tick(0, this.handleTick), true;
  }
  stop() {
    this.status = STATUS.INITIAL, this.setupTickHandler(), this.lastFrameTime = -1;
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/animate/easing
var Easing = class _Easing {
  constructor() {
  }
  static linear(t) {
    return t;
  }
  static none() {
    return this.linear;
  }
  static get(amount) {
    return amount < -1 ? amount = -1 : amount > 1 && (amount = 1), function(t) {
      return 0 === amount ? t : amount < 0 ? t * (t * -amount + 1 + amount) : t * ((2 - t) * amount + (1 - amount));
    };
  }
  static getPowIn(pow3) {
    return function(t) {
      return Math.pow(t, pow3);
    };
  }
  static getPowOut(pow3) {
    return function(t) {
      return 1 - Math.pow(1 - t, pow3);
    };
  }
  static getPowInOut(pow3) {
    return function(t) {
      return (t *= 2) < 1 ? 0.5 * Math.pow(t, pow3) : 1 - 0.5 * Math.abs(Math.pow(2 - t, pow3));
    };
  }
  static getBackIn(amount) {
    return function(t) {
      return t * t * ((amount + 1) * t - amount);
    };
  }
  static getBackOut(amount) {
    return function(t) {
      return --t * t * ((amount + 1) * t + amount) + 1;
    };
  }
  static getBackInOut(amount) {
    return amount *= 1.525, function(t) {
      return (t *= 2) < 1 ? t * t * ((amount + 1) * t - amount) * 0.5 : 0.5 * ((t -= 2) * t * ((amount + 1) * t + amount) + 2);
    };
  }
  static sineIn(t) {
    return 1 - Math.cos(t * Math.PI / 2);
  }
  static sineOut(t) {
    return Math.sin(t * Math.PI / 2);
  }
  static sineInOut(t) {
    return -(Math.cos(Math.PI * t) - 1) / 2;
  }
  static expoIn(t) {
    return 0 === t ? 0 : Math.pow(2, 10 * t - 10);
  }
  static expoOut(t) {
    return 1 === t ? 1 : 1 - Math.pow(2, -10 * t);
  }
  static expoInOut(t) {
    return 0 === t ? 0 : 1 === t ? 1 : t < 0.5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2;
  }
  static circIn(t) {
    return -(Math.sqrt(1 - t * t) - 1);
  }
  static circOut(t) {
    return Math.sqrt(1 - --t * t);
  }
  static circInOut(t) {
    return (t *= 2) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
  }
  static bounceOut(t) {
    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
  }
  static bounceIn(t) {
    return 1 - _Easing.bounceOut(1 - t);
  }
  static bounceInOut(t) {
    return t < 0.5 ? 0.5 * _Easing.bounceIn(2 * t) : 0.5 * _Easing.bounceOut(2 * t - 1) + 0.5;
  }
  static getElasticIn(amplitude, period) {
    return function(t) {
      if (0 === t || 1 === t)
        return t;
      const s2 = period / pi2 * Math.asin(1 / amplitude);
      return -amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s2) * pi2 / period);
    };
  }
  static getElasticOut(amplitude, period) {
    return function(t) {
      if (0 === t || 1 === t)
        return t;
      const s2 = period / pi2 * Math.asin(1 / amplitude);
      return amplitude * Math.pow(2, -10 * t) * Math.sin((t - s2) * pi2 / period) + 1;
    };
  }
  static getElasticInOut(amplitude, period) {
    return function(t) {
      const s2 = period / pi2 * Math.asin(1 / amplitude);
      return (t *= 2) < 1 ? amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s2) * pi2 / period) * -0.5 : amplitude * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s2) * pi2 / period) * 0.5 + 1;
    };
  }
};
Easing.quadIn = Easing.getPowIn(2), Easing.quadOut = Easing.getPowOut(2), Easing.quadInOut = Easing.getPowInOut(2), Easing.cubicIn = Easing.getPowIn(3), Easing.cubicOut = Easing.getPowOut(3), Easing.cubicInOut = Easing.getPowInOut(3), Easing.quartIn = Easing.getPowIn(4), Easing.quartOut = Easing.getPowOut(4), Easing.quartInOut = Easing.getPowInOut(4), Easing.quintIn = Easing.getPowIn(5), Easing.quintOut = Easing.getPowOut(5), Easing.quintInOut = Easing.getPowInOut(5), Easing.backIn = Easing.getBackIn(1.7), Easing.backOut = Easing.getBackOut(1.7), Easing.backInOut = Easing.getBackInOut(1.7), Easing.elasticIn = Easing.getElasticIn(1, 0.3), Easing.elasticOut = Easing.getElasticOut(1, 0.3), Easing.elasticInOut = Easing.getElasticInOut(1, 0.3 * 1.5);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/animate/timeline
var DefaultTimeline = class {
  constructor() {
    this.id = Generator.GenAutoIncrementId(), this.animateHead = null, this.animateTail = null, this.animateCount = 0, this.paused = false;
  }
  addAnimate(animate) {
    this.animateTail ? (this.animateTail.nextAnimate = animate, animate.prevAnimate = this.animateTail, this.animateTail = animate, animate.nextAnimate = null) : (this.animateHead = animate, this.animateTail = animate), this.animateCount++;
  }
  pause() {
    this.paused = true;
  }
  resume() {
    this.paused = false;
  }
  tick(delta) {
    if (this.paused)
      return;
    let animate = this.animateHead;
    for (this.animateCount = 0; animate; )
      animate.status === AnimateStatus.END ? this.removeAnimate(animate) : animate.status === AnimateStatus.RUNNING || animate.status === AnimateStatus.INITIAL ? (this.animateCount++, animate.advance(delta)) : animate.status === AnimateStatus.PAUSED && this.animateCount++, animate = animate.nextAnimate;
  }
  clear() {
    let animate = this.animateHead;
    for (; animate; )
      animate.release(), animate = animate.nextAnimate;
    this.animateHead = null, this.animateTail = null, this.animateCount = 0;
  }
  removeAnimate(animate, release = true) {
    animate._onRemove && animate._onRemove.forEach((cb) => cb()), animate === this.animateHead ? (this.animateHead = animate.nextAnimate, animate === this.animateTail ? this.animateTail = null : this.animateHead.prevAnimate = null) : animate === this.animateTail ? (this.animateTail = animate.prevAnimate, this.animateTail.nextAnimate = null) : (animate.prevAnimate.nextAnimate = animate.nextAnimate, animate.nextAnimate.prevAnimate = animate.prevAnimate), release && animate.release();
  }
};
var defaultTimeline = new DefaultTimeline();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/animate/animate
var ACustomAnimate = class {
  constructor(from, to, duration, easing, params2) {
    this.from = from, this.to = to, this.duration = duration, this.easing = easing, this.params = params2, this.updateCount = 0;
  }
  bind(target, subAni) {
    this.target = target, this.subAnimate = subAni, this.onBind();
  }
  onBind() {
  }
  onFirstRun() {
  }
  onStart() {
  }
  onEnd() {
  }
  getEndProps() {
  }
  getFromProps() {
    return this.from;
  }
  getMergedEndProps() {
    var _a;
    const thisEndProps = this.getEndProps();
    return thisEndProps ? this._endProps === thisEndProps ? this._mergedEndProps : (this._endProps = thisEndProps, void (this._mergedEndProps = Object.assign({}, null !== (_a = this.step.prev.getLastProps()) && void 0 !== _a ? _a : {}, thisEndProps))) : this.step.prev ? this.step.prev.getLastProps() : thisEndProps;
  }
  update(end, ratio, out) {
    if (0 === this.updateCount) {
      this.onFirstRun();
      const props = this.step.getLastProps();
      Object.keys(props).forEach((k2) => {
        this.subAnimate.animate.validAttr(k2) && (out[k2] = props[k2]);
      });
    }
    this.updateCount += 1, this.onUpdate(end, ratio, out), end && this.onEnd();
  }
};
var CbAnimate = class extends ACustomAnimate {
  constructor(cb) {
    super(null, null, 0, "linear"), this.cb = cb;
  }
  onUpdate(end, ratio, out) {
  }
  onStart() {
    this.cb();
  }
};
var Animate = class _Animate {
  constructor(id2 = Generator.GenAutoIncrementId(), timeline = defaultTimeline) {
    this.id = id2, this.timeline = timeline, this.status = AnimateStatus.INITIAL, this.tailAnimate = new SubAnimate(this), this.subAnimates = [this.tailAnimate], this.timeScale = 1, this.rawPosition = -1, this._startTime = 0, this._duringTime = 0, this.timeline.addAnimate(this);
  }
  setTimeline(timeline) {
    timeline !== this.timeline && (this.timeline.removeAnimate(this, false), timeline.addAnimate(this));
  }
  getStartTime() {
    return this._startTime;
  }
  getDuration() {
    return this.subAnimates.reduce((t, subAnimate) => t + subAnimate.totalDuration, 0);
  }
  after(animate) {
    const t = animate.getDuration();
    return this._startTime = t, this;
  }
  afterAll(list) {
    let maxT = -1 / 0;
    return list.forEach((a3) => {
      maxT = max(a3.getDuration(), maxT);
    }), this._startTime = maxT, this;
  }
  parallel(animate) {
    return this._startTime = animate.getStartTime(), this;
  }
  static AddInterpolate(name, cb) {
    _Animate.interpolateMap.set(name, cb);
  }
  play(customAnimate) {
    if (this.tailAnimate.play(customAnimate), this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return 1 === this.subAnimates.length && this.tailAnimate.duration === customAnimate.duration && this.trySetAttribute(customAnimate.getFromProps(), customAnimate.mode), this;
  }
  trySetAttribute(attr, mode = _Animate.mode) {
    attr && mode & AnimateMode.SET_ATTR_IMMEDIATELY && this.target.setAttributes && this.target.setAttributes(attr, false, {
      type: AttributeUpdateType.ANIMATE_PLAY
    });
  }
  runCb(cb) {
    const customAnimate = new CbAnimate(() => {
      cb(this, customAnimate.step.prev);
    });
    return this.tailAnimate.play(customAnimate), this;
  }
  customInterpolate(key, ratio, from, to, target, ret) {
    const func = _Animate.interpolateMap.get(key) || _Animate.interpolateMap.get("");
    return !!func && func(key, ratio, from, to, target, ret);
  }
  pause() {
    this.status === AnimateStatus.RUNNING && (this.status = AnimateStatus.PAUSED);
  }
  resume() {
    this.status === AnimateStatus.PAUSED && (this.status = AnimateStatus.RUNNING);
  }
  to(props, duration, easing, params2) {
    if (this.tailAnimate.to(props, duration, easing, params2), this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  from(props, duration, easing, params2) {
    if (this.tailAnimate.from(props, duration, easing, params2), this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  wait(duration) {
    if (this.tailAnimate.wait(duration), this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  startAt(t) {
    if (this.tailAnimate.startAt(t), this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  loop(l) {
    if (this.tailAnimate.loop = l, this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  reversed(r) {
    if (this.tailAnimate.reversed = r, this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  bounce(b) {
    if (this.tailAnimate.bounce = b, this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  subAnimate() {
    const sa = new SubAnimate(this, this.tailAnimate);
    return this.tailAnimate = sa, this.subAnimates.push(sa), sa.bind(this.target), this;
  }
  getStartProps() {
    return this.subAnimates[0].getStartProps();
  }
  getEndProps() {
    return this.tailAnimate.getEndProps();
  }
  depreventAttr(key) {
    this._preventAttrs && this._preventAttrs.delete(key);
  }
  preventAttr(key) {
    this._preventAttrs || (this._preventAttrs = /* @__PURE__ */ new Set()), this._preventAttrs.add(key);
  }
  preventAttrs(keys2) {
    keys2.forEach((key) => this.preventAttr(key));
  }
  validAttr(key) {
    return !this._preventAttrs || !this._preventAttrs.has(key);
  }
  bind(target) {
    return this.target = target, this.target.onAnimateBind && this.target.onAnimateBind(this), this.subAnimates.forEach((sa) => {
      sa.bind(target);
    }), this;
  }
  advance(delta) {
    if (this._duringTime < this._startTime) {
      if (this._duringTime + delta * this.timeScale < this._startTime)
        return void (this._duringTime += delta * this.timeScale);
      delta = this._duringTime + delta * this.timeScale - this._startTime, this._duringTime = this._startTime;
    }
    this.status === AnimateStatus.INITIAL && (this.status = AnimateStatus.RUNNING, this._onStart && this._onStart.forEach((cb) => cb()));
    this.setPosition(this.rawPosition + delta * this.timeScale) && this.status === AnimateStatus.RUNNING && (this.status = AnimateStatus.END, this._onEnd && this._onEnd.forEach((cb) => cb()));
  }
  setPosition(rawPosition) {
    let sa, d = 0;
    const prevRawPos = this.rawPosition, maxRawPos = this.subAnimates.reduce((a3, b) => a3 + b.totalDuration, 0);
    rawPosition < 0 && (rawPosition = 0);
    const end = rawPosition >= maxRawPos;
    if (end && (rawPosition = maxRawPos), rawPosition === prevRawPos)
      return end;
    for (let i = 0; i < this.subAnimates.length && (sa = this.subAnimates[i], !(d + sa.totalDuration >= rawPosition)); i++)
      d += sa.totalDuration, sa = void 0;
    return this.rawPosition = rawPosition, sa.setPosition(rawPosition - d), end;
  }
  onStart(cb) {
    this._onStart || (this._onStart = []), this._onStart.push(cb);
  }
  onEnd(cb) {
    this._onEnd || (this._onEnd = []), this._onEnd.push(cb);
  }
  onRemove(cb) {
    this._onRemove || (this._onRemove = []), this._onRemove.push(cb);
  }
  onFrame(cb) {
    this._onFrame || (this._onFrame = []), this._onFrame.push(cb);
  }
  release() {
    this.status = AnimateStatus.END;
  }
  stop(nextVal) {
    nextVal || this.target.onStop(), "start" === nextVal ? this.target.onStop(this.getStartProps()) : "end" === nextVal ? this.target.onStop(this.getEndProps()) : this.target.onStop(nextVal), this.release();
  }
};
Animate.mode = AnimateMode.NORMAL, Animate.interpolateMap = /* @__PURE__ */ new Map();
var SubAnimate = class {
  get totalDuration() {
    return this.calcAttr(), this._totalDuration + this._startAt;
  }
  constructor(animate, lastSubAnimate) {
    this.rawPosition = -1, this.position = 0, this.loop = 0, this.duration = 0, this.animate = animate, this.stepHead = new Step2(0, 0, lastSubAnimate ? Object.assign({}, lastSubAnimate.stepTail.props) : {}), this.stepTail = this.stepHead, this.dirty = true, this._startAt = 0;
  }
  calcAttr() {
    this.dirty && (this._totalDuration = this.duration * (this.loop + 1));
  }
  bind(target) {
    return this.target = target, this;
  }
  play(customAnimate) {
    let duration = customAnimate.duration;
    (null == duration || duration < 0) && (duration = 0);
    const easing = customAnimate.easing, easingFunc = "string" == typeof easing ? Easing[easing] : easing, step = this._addStep(duration, null, easingFunc);
    return step.type = AnimateStepType.customAnimate, this._appendProps(customAnimate.getEndProps(), step, false), this._appendCustomAnimate(customAnimate, step), this;
  }
  to(props, duration, easing, params2) {
    (null == duration || duration < 0) && (duration = 0);
    const easingFunc = "string" == typeof easing ? Easing[easing] : easing, step = this._addStep(duration, null, easingFunc);
    return step.type = AnimateStepType.to, this._appendProps(props, step, !!params2 && params2.tempProps), step.propKeys || (step.propKeys = Object.keys(step.props)), params2 && params2.noPreventAttrs || this.target.animates.forEach((a3) => {
      a3.id !== this.animate.id && a3.preventAttrs(step.propKeys);
    }), this;
  }
  from(props, duration, easing, params2) {
    this.to(props, 0, easing, params2);
    const toProps = {};
    this.stepTail.propKeys || (this.stepTail.propKeys = Object.keys(this.stepTail.props)), this.stepTail.propKeys.forEach((k2) => {
      toProps[k2] = this.getLastPropByName(k2, this.stepTail);
    }), this.to(toProps, duration, easing, params2), this.stepTail.type = AnimateStepType.from;
  }
  startAt(t) {
    return t < 0 && (t = 0), this._startAt = t, this;
  }
  getStartProps() {
    var _a;
    return null === (_a = this.stepHead) || void 0 === _a ? void 0 : _a.props;
  }
  getEndProps() {
    return this.stepTail.props;
  }
  getLastStep() {
    return this._lastStep;
  }
  wait(duration) {
    if (duration > 0) {
      const step = this._addStep(+duration, null);
      step.type = AnimateStepType.wait, step.prev.customAnimate ? step.props = step.prev.customAnimate.getEndProps() : step.props = step.prev.props, this.target.onAddStep && this.target.onAddStep(step);
    }
    return this;
  }
  _addStep(duration, props, easingFunc) {
    const step = new Step2(this.duration, duration, props, easingFunc);
    return this.duration += duration, this.stepTail.append(step), this.stepTail = step, step;
  }
  _appendProps(props, step, tempProps) {
    step.props = tempProps ? props : Object.assign({}, props);
    let lastStep = step.prev;
    const _props = step.props;
    for (step.propKeys || (step.propKeys = Object.keys(step.props)), step.propKeys.forEach((k2) => {
      void 0 === step.props[k2] && (step.props[k2] = this.target.getDefaultAttribute(k2));
    }); lastStep.prev; )
      lastStep.props && (lastStep.propKeys || (lastStep.propKeys = Object.keys(lastStep.props)), lastStep.propKeys.forEach((key) => {
        void 0 === _props[key] && (_props[key] = lastStep.props[key]);
      })), step.propKeys = Object.keys(step.props), lastStep = lastStep.prev;
    const initProps = this.stepHead.props;
    step.propKeys || (step.propKeys = Object.keys(_props)), step.propKeys.forEach((key) => {
      if (void 0 === initProps[key]) {
        const parentAnimateInitProps = this.animate.getStartProps();
        initProps[key] = parentAnimateInitProps[key] = this.target.getComputedAttribute(key);
      }
    }), this.target.onAddStep && this.target.onAddStep(step);
  }
  _appendCustomAnimate(customAnimate, step) {
    step.customAnimate = customAnimate, customAnimate.step = step, customAnimate.bind(this.target, this);
  }
  setPosition(rawPosition) {
    var _a;
    const d = this.duration, loopCount = this.loop, prevRawPos = this.rawPosition;
    let loop, position, end = false;
    const startAt = null !== (_a = this._startAt) && void 0 !== _a ? _a : 0;
    if (rawPosition < 0 && (rawPosition = 0), rawPosition < startAt)
      return this.rawPosition = rawPosition, false;
    if (rawPosition -= startAt, d <= 0)
      return end = true, end;
    if (loop = Math.floor(rawPosition / d), position = rawPosition - loop * d, end = rawPosition >= loopCount * d + d, end && (position = d, loop = loopCount, rawPosition = position * loop + d), rawPosition === prevRawPos)
      return end;
    const rev = !this.reversed != !(this.bounce && loop % 2);
    return rev && (position = d - position), this._deltaPosition = position - this.position, this.position = position, this.rawPosition = rawPosition + startAt, this.updatePosition(end, rev), end;
  }
  updatePosition(end, rev) {
    if (!this.stepHead)
      return;
    let step = this.stepHead.next;
    const position = this.position, duration = this.duration;
    if (this.target && step) {
      let stepNext = step.next;
      for (; stepNext && stepNext.position <= position; )
        step = stepNext, stepNext = step.next;
      let ratio = end ? 0 === duration ? 1 : position / duration : (position - step.position) / step.duration;
      step.easing && (ratio = step.easing(ratio)), this.tryCallCustomAnimateLifeCycle(step, this._lastStep || (rev ? this.stepTail : this.stepHead), rev), this.updateTarget(step, ratio, end), this._lastStep = step, this.animate._onFrame && this.animate._onFrame.forEach((cb) => cb(step, ratio));
    }
  }
  tryCallCustomAnimateLifeCycle(step, lastStep, rev) {
    if (step !== lastStep)
      if (rev) {
        let _step = lastStep.prev;
        for (; _step && _step !== step; )
          _step.customAnimate && (_step.customAnimate.onStart && _step.customAnimate.onStart(), _step.customAnimate.onEnd && _step.customAnimate.onEnd()), _step = step.prev;
        lastStep && lastStep.customAnimate && lastStep.customAnimate.onEnd && lastStep.customAnimate.onEnd(), step && step.customAnimate && step.customAnimate.onStart && step.customAnimate.onStart();
      } else {
        let _step = lastStep.next;
        for (; _step && _step !== step; )
          _step.customAnimate && (_step.customAnimate.onStart && _step.customAnimate.onStart(), _step.customAnimate.onEnd && _step.customAnimate.onEnd()), _step = _step.next;
        lastStep && lastStep.customAnimate && lastStep.customAnimate.onEnd && lastStep.customAnimate.onEnd(), step && step.customAnimate && step.customAnimate.onStart && step.customAnimate.onStart();
      }
  }
  getLastPropByName(name, step) {
    let lastStep = step.prev;
    for (; lastStep; ) {
      if (lastStep.props && void 0 !== lastStep.props[name])
        return lastStep.props[name];
      if (lastStep.customAnimate) {
        const val = lastStep.customAnimate.getEndProps()[name];
        if (void 0 !== val)
          return val;
      }
      lastStep = lastStep.prev;
    }
    return Logger.getInstance().warn("\u672A\u77E5\u9519\u8BEF\uFF0Cstep\u4E2D\u627E\u4E0D\u5230\u5C5E\u6027"), step.props[name];
  }
  updateTarget(step, ratio, end) {
    null == step.props && null == step.customAnimate || this.target.onStep(this, this.animate, step, ratio, end);
  }
};
var Step2 = class {
  constructor(position, duration, props, easing) {
    this.duration = duration, this.position = position, this.props = props, this.easing = easing;
  }
  append(step) {
    step.prev = this, step.next = this.next, this.next = step;
  }
  getLastProps() {
    let step = this.prev;
    for (; step; ) {
      if (step.props)
        return step.props;
      if (step.customAnimate)
        return step.customAnimate.getMergedEndProps();
      step = step.prev;
    }
    return null;
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/animate/config
var DefaultStateAnimateConfig = {
  duration: 200,
  easing: "cubicOut"
};
var DefaultMorphingAnimateConfig = {
  duration: 1e3,
  easing: "quadInOut"
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/utils
var Edge;
!function(Edge2) {
  Edge2[Edge2.Top = 1] = "Top", Edge2[Edge2.Right = 2] = "Right", Edge2[Edge2.Bottom = 4] = "Bottom", Edge2[Edge2.Left = 8] = "Left", Edge2[Edge2.ALL = 15] = "ALL";
}(Edge || (Edge = {}));
var _strokeVec4 = [false, false, false, false];
var parseStroke = (stroke2) => {
  var _a;
  let isFullStroke = true;
  if (isBoolean_default(stroke2, true)) {
    for (let i = 0; i < 4; i++)
      _strokeVec4[i] = stroke2, isFullStroke && (isFullStroke = !(null !== (_a = _strokeVec4[i]) && void 0 !== _a && !_a));
    isFullStroke = stroke2;
  } else if (Array.isArray(stroke2))
    for (let i = 0; i < 4; i++)
      _strokeVec4[i] = !!stroke2[i], isFullStroke && (isFullStroke = !!_strokeVec4[i]);
  else
    _strokeVec4[0] = false, _strokeVec4[1] = false, _strokeVec4[2] = false, _strokeVec4[3] = false;
  return {
    isFullStroke,
    stroke: _strokeVec4
  };
};
var _paddingVec4 = [0, 0, 0, 0];
var parsePadding = (padding) => padding ? isArray_default(padding) ? 0 === padding.length ? 0 : 1 === padding.length ? padding[0] : 2 === padding.length ? (_paddingVec4[0] = padding[0], _paddingVec4[2] = padding[0], _paddingVec4[1] = padding[1], _paddingVec4[3] = padding[1], _paddingVec4) : padding : padding : 0;
var _coords = [{
  x: 0,
  y: 0
}, {
  x: 0,
  y: 0
}, {
  x: 0,
  y: 0
}, {
  x: 0,
  y: 0
}];
var indexList = [1, 2, 3, 0, 1, 2, 3, 0];
function circleBounds(startAngle, endAngle, radius, bounds) {
  for (; startAngle >= pi2; )
    startAngle -= pi2;
  for (; startAngle < 0; )
    startAngle += pi2;
  for (; startAngle > endAngle; )
    endAngle += pi2;
  _coords[0].x = radius, _coords[1].y = radius, _coords[2].x = -radius, _coords[3].y = -radius;
  const startIdx = Math.ceil(startAngle / halfPi) % 4, endIdx = Math.ceil(endAngle / halfPi) % 4;
  if (bounds.add(cos(startAngle) * radius, sin(startAngle) * radius), bounds.add(cos(endAngle) * radius, sin(endAngle) * radius), startIdx !== endIdx || endAngle - startAngle > pi) {
    let match = false;
    for (let i = 0; i < indexList.length; i++)
      if (match || startIdx !== indexList[i]) {
        if (match && endIdx === indexList[i])
          break;
        if (match) {
          const p = _coords[indexList[i]];
          bounds.add(p.x, p.y);
        }
      } else {
        match = true;
        const p = _coords[startIdx];
        bounds.add(p.x, p.y);
      }
  }
}
function pointInterpolation(pointA, pointB, ratio) {
  const { x, y } = pointAt(pointA.x, pointA.y, pointB.x, pointB.y, ratio), { x: x14, y: y14 } = pointAt(pointA.x1, pointA.y1, pointB.x1, pointB.y1, ratio), point5 = new Point(x, y, x14, y14);
  return point5.defined = pointB.defined, point5;
}
function pointsInterpolation(pointsA, pointsB, ratio) {
  if (!pointsA || !pointsB)
    return [];
  Array.isArray(pointsA) || (pointsA = [pointsA]), Array.isArray(pointsB) || (pointsB = [pointsB]);
  let points = [];
  if (pointsA.length > pointsB.length) {
    points = pointsB.map((point5) => {
      const p = new Point(point5.x, point5.y, point5.x1, point5.y1);
      return p.defined = point5.defined, p;
    });
    for (let i = 0; i < pointsB.length; i++)
      points[i] = pointInterpolation(pointsA[i], pointsB[i], ratio);
  } else {
    points = pointsB.map((point5) => {
      const p = new Point(point5.x, point5.y, point5.x1, point5.y1);
      return p.defined = point5.defined, p;
    });
    for (let i = 0; i < pointsA.length; i++)
      points[i] = pointInterpolation(pointsA[i], pointsB[i], ratio);
  }
  return points;
}
var transformKeys = ["x", "y", "dx", "dy", "scaleX", "scaleY", "angle", "anchor", "postMatrix", "scrollX", "scrollY"];
var isTransformKey = (key) => transformKeys.includes(key);
function getAttributeFromDefaultAttrList(attr, key) {
  if (isArray_default(attr)) {
    let val;
    for (let i = 0; i < attr.length && void 0 === val; i++)
      val = attr[i][key];
    return val;
  }
  return attr[key];
}
var RafBasedSTO = class _RafBasedSTO {
  constructor(timeout = _RafBasedSTO.TimeOut) {
    this.durations = [], this.timeout = timeout, this.lastDate = 0, this.durationsListThreshold = 30;
  }
  call(cb) {
    return this.lastDate = Date.now(), setTimeout(() => {
      this.appendDuration(Date.now() - this.lastDate), cb(0);
    }, this.timeout, true);
  }
  clear(h) {
    clearTimeout(h);
  }
  appendDuration(d) {
    this.durations.push(d), this.durations.length > this.durationsListThreshold && this.durations.shift(), this.timeout = Math.min(Math.max(this.durations.reduce((a3, b) => a3 + b, 0) / this.durations.length, 1e3 / 60), 1e3 / 30);
  }
};
RafBasedSTO.TimeOut = 1e3 / 60;
var rafBasedSto = new RafBasedSTO();
var calculateLineHeight = (lineHeight, fontSize) => {
  if (isString_default(lineHeight) && "%" === lineHeight[lineHeight.length - 1]) {
    return fontSize * (Number.parseFloat(lineHeight.substring(0, lineHeight.length - 1)) / 100);
  }
  return lineHeight;
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/animate/custom-animate
var Direction2;
!function(Direction3) {
  Direction3[Direction3.LEFT_TO_RIGHT = 0] = "LEFT_TO_RIGHT", Direction3[Direction3.RIGHT_TO_LEFT = 1] = "RIGHT_TO_LEFT", Direction3[Direction3.TOP_TO_BOTTOM = 2] = "TOP_TO_BOTTOM", Direction3[Direction3.BOTTOM_TO_TOP = 3] = "BOTTOM_TO_TOP", Direction3[Direction3.STROKE = 4] = "STROKE";
}(Direction2 || (Direction2 = {}));
var TagPointsUpdate = class extends ACustomAnimate {
  constructor(from, to, duration, easing, params2) {
    super(from, to, duration, easing, params2), this.newPointAnimateType = "appear" === (null == params2 ? void 0 : params2.newPointAnimateType) ? "appear" : "grow";
  }
  onBind() {
    var _a, _b;
    const originFromPoints = null === (_a = this.from) || void 0 === _a ? void 0 : _a.points, originToPoints = null === (_b = this.to) || void 0 === _b ? void 0 : _b.points;
    this.fromPoints = originFromPoints ? Array.isArray(originFromPoints) ? originFromPoints : [originFromPoints] : [], this.toPoints = originToPoints ? Array.isArray(originToPoints) ? originToPoints : [originToPoints] : [];
    const tagMap = /* @__PURE__ */ new Map();
    this.fromPoints.forEach((point5) => {
      point5.context && tagMap.set(point5.context, point5);
    });
    let firstMatchedPoint, lastMatchedPoint, firstMatchedIndex = 1 / 0, lastMatchedIndex = -1 / 0;
    for (let i = 0; i < this.toPoints.length; i += 1)
      if (tagMap.has(this.toPoints[i].context)) {
        firstMatchedIndex = i, firstMatchedPoint = tagMap.get(this.toPoints[i].context);
        break;
      }
    for (let i = this.toPoints.length - 1; i >= 0; i -= 1)
      if (tagMap.has(this.toPoints[i].context)) {
        lastMatchedIndex = i, lastMatchedPoint = tagMap.get(this.toPoints[i].context);
        break;
      }
    let prevMatchedPoint = this.toPoints[0];
    this.interpolatePoints = this.toPoints.map((point5, index) => {
      const matchedPoint = tagMap.get(point5.context);
      return matchedPoint ? (prevMatchedPoint = matchedPoint, [matchedPoint, point5]) : "appear" === this.newPointAnimateType ? [point5, point5] : index < firstMatchedIndex && firstMatchedPoint ? [firstMatchedPoint, point5] : index > lastMatchedIndex && lastMatchedPoint ? [lastMatchedPoint, point5] : [prevMatchedPoint, point5];
    }), this.points = this.interpolatePoints.map((interpolate2) => {
      const fromPoint = interpolate2[0], toPoint = interpolate2[1], newPoint = new Point(fromPoint.x, fromPoint.y, fromPoint.x1, fromPoint.y1);
      return newPoint.defined = toPoint.defined, newPoint.context = toPoint.context, newPoint;
    });
  }
  onUpdate(end, ratio, out) {
    this.points = this.points.map((point5, index) => {
      const newPoint = pointInterpolation(this.interpolatePoints[index][0], this.interpolatePoints[index][1], ratio);
      return newPoint.context = point5.context, newPoint;
    }), out.points = this.points;
  }
};
var GroupFadeOut = class extends ACustomAnimate {
  getEndProps() {
    return {};
  }
  onBind() {
    this.target.setTheme({
      common: {
        opacity: 1
      }
    });
  }
  onEnd() {
    this.target.setTheme({
      common: {
        opacity: 0
      }
    });
  }
  onUpdate(end, ratio, out) {
    this.target.setTheme({
      common: {
        opacity: 1 - ratio
      }
    });
  }
};
var AnimateGroup = class extends ACustomAnimate {
  constructor(duration, customAnimates) {
    super(null, null, duration, "linear"), this.customAnimates = customAnimates;
  }
  initAnimates() {
    this.customAnimates.forEach((a3) => {
      a3.step = this.step, a3.subAnimate = this.subAnimate, a3.target = this.target;
    });
  }
  getEndProps() {
    const props = {};
    return this.customAnimates.forEach((a3) => {
      Object.assign(props, a3.getEndProps());
    }), props;
  }
  onBind() {
    this.initAnimates(), this.customAnimates.forEach((a3) => {
      a3.onBind();
    });
  }
  onEnd() {
    this.customAnimates.forEach((a3) => {
      a3.onEnd();
    });
  }
  onStart() {
    this.customAnimates.forEach((a3) => {
      a3.onStart();
    });
  }
  onUpdate(end, ratio, out) {
    this.updating || (this.updating = true, this.customAnimates.forEach((a3) => {
      const easing = a3.easing, easingFunc = "string" == typeof easing ? Easing[easing] : easing;
      ratio = easingFunc(ratio), a3.onUpdate(end, ratio, out);
    }), this.updating = false);
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/morphing-utils
function cubicSubdivide(p0, p1, p2, p3, t, out) {
  const p01 = (p1 - p0) * t + p0, p12 = (p2 - p1) * t + p1, p23 = (p3 - p2) * t + p2, p012 = (p12 - p01) * t + p01, p123 = (p23 - p12) * t + p12, p0123 = (p123 - p012) * t + p012;
  out[0] = p0, out[1] = p01, out[2] = p012, out[3] = p0123, out[4] = p0123, out[5] = p123, out[6] = p23, out[7] = p3;
}
function alignSubpath(subpath1, subpath2) {
  const len1 = subpath1.length, len2 = subpath2.length;
  if (len1 === len2)
    return [subpath1, subpath2];
  const tmpSegX = [], tmpSegY = [], shorterPath = len1 < len2 ? subpath1 : subpath2, shorterLen = Math.min(len1, len2), diff = Math.abs(len2 - len1) / 6, shorterBezierCount = (shorterLen - 2) / 6, eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount), newSubpath = [shorterPath[0], shorterPath[1]];
  let remained = diff;
  for (let i = 2; i < shorterLen; i += 6) {
    let x05 = shorterPath[i - 2], y05 = shorterPath[i - 1], x14 = shorterPath[i], y14 = shorterPath[i + 1], x23 = shorterPath[i + 2], y23 = shorterPath[i + 3];
    const x3 = shorterPath[i + 4], y3 = shorterPath[i + 5];
    if (remained <= 0) {
      newSubpath.push(x14, y14, x23, y23, x3, y3);
      continue;
    }
    const actualSubDivCount = Math.min(remained, eachCurveSubDivCount) + 1;
    for (let k2 = 1; k2 <= actualSubDivCount; k2++) {
      const p = k2 / actualSubDivCount;
      cubicSubdivide(x05, x14, x23, x3, p, tmpSegX), cubicSubdivide(y05, y14, y23, y3, p, tmpSegY), x05 = tmpSegX[3], y05 = tmpSegY[3], newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x05, y05), x14 = tmpSegX[5], y14 = tmpSegY[5], x23 = tmpSegX[6], y23 = tmpSegY[6];
    }
    remained -= actualSubDivCount - 1;
  }
  return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];
}
function createSubpath(lastSubpath, otherSubpath) {
  const prevSubPath = lastSubpath || otherSubpath, len = prevSubPath.length, lastX = prevSubPath[len - 2], lastY = prevSubPath[len - 1], newSubpath = [];
  for (let i = 0; i < otherSubpath.length; i += 2)
    newSubpath[i] = lastX, newSubpath[i + 1] = lastY;
  return newSubpath;
}
function reverseSubpath(array3) {
  const newArr = [], len = array3.length;
  for (let i = 0; i < len; i += 2)
    newArr[i] = array3[len - i - 2], newArr[i + 1] = array3[len - i - 1];
  return newArr;
}
function centroidOfSubpath(array3) {
  let signedArea = 0, cx = 0, cy = 0;
  const len = array3.length;
  for (let i = 0, j = len - 2; i < len; j = i, i += 2) {
    const x05 = array3[j], y05 = array3[j + 1], x14 = array3[i], y14 = array3[i + 1], a3 = x05 * y14 - x14 * y05;
    signedArea += a3, cx += (x05 + x14) * a3, cy += (y05 + y14) * a3;
  }
  return 0 === signedArea ? [array3[0] || 0, array3[1] || 0, 0] : [cx / signedArea / 3, cy / signedArea / 3, signedArea];
}
function findBestRotationOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {
  const bezierCount = (fromSubBeziers.length - 2) / 6;
  let bestScore = 1 / 0, bestOffset = 0;
  const len = fromSubBeziers.length, len2 = len - 2;
  for (let offset = 0; offset < bezierCount; offset++) {
    const cursorOffset = 6 * offset;
    let score2 = 0;
    for (let k2 = 0; k2 < len; k2 += 2) {
      const idx = 0 === k2 ? cursorOffset : (cursorOffset + k2 - 2) % len2 + 2, x05 = fromSubBeziers[idx] - fromCp[0], y05 = fromSubBeziers[idx + 1] - fromCp[1], dx = toSubBeziers[k2] - toCp[0] - x05, dy = toSubBeziers[k2 + 1] - toCp[1] - y05;
      score2 += dx * dx + dy * dy;
    }
    score2 < bestScore && (bestScore = score2, bestOffset = offset);
  }
  return bestOffset;
}
function findBestMorphingRotation(fromArr, toArr, searchAngleIteration, searchAngleRange) {
  const result2 = [];
  let fromNeedsReverse;
  for (let i = 0; i < fromArr.length; i++) {
    let fromSubpathBezier = fromArr[i];
    const toSubpathBezier = toArr[i], fromCp = centroidOfSubpath(fromSubpathBezier), toCp = centroidOfSubpath(toSubpathBezier);
    null == fromNeedsReverse && (fromNeedsReverse = fromCp[2] < 0 != toCp[2] < 0);
    const newFromSubpathBezier = [], newToSubpathBezier = [];
    let bestAngle = 0, bestScore = 1 / 0;
    const tmpArr = [], len = fromSubpathBezier.length;
    fromNeedsReverse && (fromSubpathBezier = reverseSubpath(fromSubpathBezier));
    const offset = 6 * findBestRotationOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp), len2 = len - 2;
    for (let k2 = 0; k2 < len2; k2 += 2) {
      const idx = (offset + k2) % len2 + 2;
      newFromSubpathBezier[k2 + 2] = fromSubpathBezier[idx] - fromCp[0], newFromSubpathBezier[k2 + 3] = fromSubpathBezier[idx + 1] - fromCp[1];
    }
    if (newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0], newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1], searchAngleIteration > 0) {
      const step = searchAngleRange / searchAngleIteration;
      for (let angle2 = -searchAngleRange / 2; angle2 <= searchAngleRange / 2; angle2 += step) {
        const sa = Math.sin(angle2), ca = Math.cos(angle2);
        let score2 = 0;
        for (let k2 = 0; k2 < fromSubpathBezier.length; k2 += 2) {
          const x05 = newFromSubpathBezier[k2], y05 = newFromSubpathBezier[k2 + 1], x14 = toSubpathBezier[k2] - toCp[0], y14 = toSubpathBezier[k2 + 1] - toCp[1], newX1 = x14 * ca - y14 * sa, newY1 = x14 * sa + y14 * ca;
          tmpArr[k2] = newX1, tmpArr[k2 + 1] = newY1;
          const dx = newX1 - x05, dy = newY1 - y05;
          score2 += dx * dx + dy * dy;
        }
        if (score2 < bestScore) {
          bestScore = score2, bestAngle = angle2;
          for (let m4 = 0; m4 < tmpArr.length; m4++)
            newToSubpathBezier[m4] = tmpArr[m4];
        }
      }
    } else
      for (let i2 = 0; i2 < len; i2 += 2)
        newToSubpathBezier[i2] = toSubpathBezier[i2] - toCp[0], newToSubpathBezier[i2 + 1] = toSubpathBezier[i2 + 1] - toCp[1];
    result2.push({
      from: newFromSubpathBezier,
      to: newToSubpathBezier,
      fromCp,
      toCp,
      rotation: -bestAngle
    });
  }
  return result2;
}
function alignBezierCurves(array1, array22) {
  let lastSubpath1, lastSubpath2;
  const newArray1 = [], newArray2 = [];
  for (let i = 0; i < Math.max(array1.length, array22.length); i++) {
    const subpath1 = array1[i], subpath2 = array22[i];
    let newSubpath1, newSubpath2;
    subpath1 ? subpath2 ? ([newSubpath1, newSubpath2] = alignSubpath(subpath1, subpath2), lastSubpath1 = newSubpath1, lastSubpath2 = newSubpath2) : (newSubpath2 = createSubpath(lastSubpath2, subpath1), newSubpath1 = subpath1) : (newSubpath1 = createSubpath(lastSubpath1, subpath2), newSubpath2 = subpath2), newArray1.push(newSubpath1), newArray2.push(newSubpath2);
  }
  return [newArray1, newArray2];
}
var addLineToBezierPath = (bezierPath, x05, y05, x14, y14) => {
  isNumberClose(x05, x14) && isNumberClose(y05, y14) || bezierPath.push(x05, y05, x14, y14, x14, y14);
};
function pathToBezierCurves(path) {
  const commandList = path.commandList, bezierArrayGroups = [];
  let currentSubpath, xi = 0, yi = 0, x05 = 0, y05 = 0;
  const createNewSubpath = (x, y) => {
    currentSubpath && currentSubpath.length > 2 && bezierArrayGroups.push(currentSubpath), currentSubpath = [x, y];
  };
  let x14, y14, x23, y23;
  for (let i = 0, len = commandList.length; i < len; i++) {
    const cmd = commandList[i], isFirst = 0 === i;
    switch (isFirst && (x05 = xi = cmd[1], y05 = yi = cmd[2], [enumCommandMap.L, enumCommandMap.C, enumCommandMap.Q].includes(cmd[0]) && (currentSubpath = [x05, y05])), cmd[0]) {
      case enumCommandMap.M:
        xi = x05 = cmd[1], yi = y05 = cmd[2], createNewSubpath(x05, y05);
        break;
      case enumCommandMap.L:
        x14 = cmd[1], y14 = cmd[2], addLineToBezierPath(currentSubpath, xi, yi, x14, y14), xi = x14, yi = y14;
        break;
      case enumCommandMap.C:
        currentSubpath.push(cmd[1], cmd[2], cmd[3], cmd[4], xi = cmd[5], yi = cmd[6]);
        break;
      case enumCommandMap.Q:
        x14 = cmd[1], y14 = cmd[2], x23 = cmd[3], y23 = cmd[4], currentSubpath.push(xi + 2 / 3 * (x14 - xi), yi + 2 / 3 * (y14 - yi), x23 + 2 / 3 * (x14 - x23), y23 + 2 / 3 * (y14 - y23), x23, y23), xi = x23, yi = y23;
        break;
      case enumCommandMap.A: {
        const cx = cmd[1], cy = cmd[2], rx = cmd[3], ry = rx, startAngle = cmd[4], endAngle = cmd[5], counterClockwise = !!cmd[6];
        x14 = Math.cos(startAngle) * rx + cx, y14 = Math.sin(startAngle) * rx + cy, isFirst ? (x05 = x14, y05 = y14, createNewSubpath(x05, y05)) : addLineToBezierPath(currentSubpath, xi, yi, x14, y14), xi = Math.cos(endAngle) * rx + cx, yi = Math.sin(endAngle) * rx + cy;
        const step = (counterClockwise ? -1 : 1) * Math.PI / 2;
        for (let angle2 = startAngle; counterClockwise ? angle2 > endAngle : angle2 < endAngle; angle2 += step) {
          const nextAngle = counterClockwise ? Math.max(angle2 + step, endAngle) : Math.min(angle2 + step, endAngle);
          addArcToBezierPath(currentSubpath, angle2, nextAngle, cx, cy, rx, ry);
        }
        break;
      }
      case enumCommandMap.E: {
        const cx = cmd[1], cy = cmd[2], rx = cmd[3], ry = cmd[4], rotate3 = cmd[5], startAngle = cmd[6], endAngle = cmd[7] + startAngle, anticlockwise = !!cmd[8], hasRotate = !isNumberClose(rotate3, 0), rc = Math.cos(rotate3), rs = Math.sin(rotate3);
        let xTemp = Math.cos(startAngle) * rx, yTemp = Math.sin(startAngle) * ry;
        hasRotate ? (x14 = xTemp * rc - yTemp * rs + cx, y14 = xTemp * rs + yTemp * rc + cy) : (x14 = xTemp + cx, y14 = yTemp + cy), isFirst ? (x05 = x14, y05 = y14, createNewSubpath(x05, y05)) : addLineToBezierPath(currentSubpath, xi, yi, x14, y14), xTemp = Math.cos(endAngle) * rx, yTemp = Math.sin(endAngle) * ry, hasRotate ? (xi = xTemp * rc - yTemp * rs + cx, yi = xTemp * rs + yTemp * rc + cy) : (xi = xTemp + cx, yi = yTemp + cy);
        const step = (anticlockwise ? -1 : 1) * Math.PI / 2;
        for (let angle2 = startAngle; anticlockwise ? angle2 > endAngle : angle2 < endAngle; angle2 += step) {
          const nextAngle = anticlockwise ? Math.max(angle2 + step, endAngle) : Math.min(angle2 + step, endAngle);
          if (addArcToBezierPath(currentSubpath, angle2, nextAngle, cx, cy, rx, ry), hasRotate) {
            const curLen = currentSubpath.length;
            for (let j = curLen - 6; j <= curLen - 1; j += 2)
              xTemp = currentSubpath[j], yTemp = currentSubpath[j + 1], currentSubpath[j] = (xTemp - cx) * rc - (yTemp - cy) * rs + cx, currentSubpath[j + 1] = (xTemp - cx) * rs + (yTemp - cy) * rc + cy;
          }
        }
        break;
      }
      case enumCommandMap.R:
        x05 = xi = cmd[1], y05 = yi = cmd[2], x14 = x05 + cmd[3], y14 = y05 + cmd[4], createNewSubpath(x14, y05), addLineToBezierPath(currentSubpath, x14, y05, x14, y14), addLineToBezierPath(currentSubpath, x14, y14, x05, y14), addLineToBezierPath(currentSubpath, x05, y14, x05, y05), addLineToBezierPath(currentSubpath, x05, y05, x14, y05);
        break;
      case enumCommandMap.AT: {
        const tx1 = cmd[1], ty1 = cmd[2], tx2 = cmd[3], ty2 = cmd[4], r = cmd[5], dis1 = PointService.distancePP({
          x: xi,
          y: yi
        }, {
          x: tx1,
          y: ty1
        }), dis2 = PointService.distancePP({
          x: tx2,
          y: ty2
        }, {
          x: tx1,
          y: ty1
        }), theta = ((xi - tx1) * (tx2 - tx1) + (yi - ty1) * (ty2 - ty1)) / (dis1 * dis2), dis = r / Math.sin(theta / 2), midX = (xi + tx2 - 2 * tx1) / 2, midY = (yi + ty2 - 2 * ty1) / 2, midLen = PointService.distancePP({
          x: midX,
          y: midY
        }, {
          x: 0,
          y: 0
        }), cx = tx1 + dis * midX / midLen, cy = tx2 + dis * midY / midLen, disP = Math.sqrt(dis * dis - r * r);
        x05 = tx1 + disP * (xi - tx1) / dis1, y05 = ty1 + disP * (yi - ty1) / dis1, addLineToBezierPath(currentSubpath, xi, yi, x05, y05), xi = tx1 + disP * (tx2 - tx1) / dis2, yi = ty1 + disP * (ty2 - ty1) / dis2;
        const startAngle = getAngleByPoint({
          x: cx,
          y: cy
        }, {
          x: x05,
          y: y05
        }), endAngle = getAngleByPoint({
          x: cx,
          y: cy
        }, {
          x: xi,
          y: yi
        });
        addArcToBezierPath(currentSubpath, startAngle, endAngle, cx, cy, r, r);
        break;
      }
      case enumCommandMap.Z:
        currentSubpath && addLineToBezierPath(currentSubpath, xi, yi, x05, y05), xi = x05, yi = y05;
    }
  }
  return currentSubpath && currentSubpath.length > 2 && bezierArrayGroups.push(currentSubpath), bezierArrayGroups;
}
function applyTransformOnBezierCurves(bezierCurves, martrix) {
  for (let i = 0; i < bezierCurves.length; i++) {
    const subPath = bezierCurves[i];
    for (let k2 = 0; k2 < subPath.length; k2 += 2) {
      const x = subPath[k2], y = subPath[k2 + 1], res = {
        x,
        y
      };
      martrix.transformPoint({
        x,
        y
      }, res), subPath[k2] = res.x, subPath[k2 + 1] = res.y;
    }
  }
}
function bezierCurversToPath(bezierCurves) {
  const path = new CustomPath2D();
  for (let i = 0; i < bezierCurves.length; i++) {
    const subPath = bezierCurves[i];
    if (subPath.length > 2) {
      path.moveTo(subPath[0], subPath[1]);
      for (let k2 = 2; k2 < subPath.length; k2 += 6)
        path.bezierCurveTo(subPath[k2], subPath[k2 + 1], subPath[k2 + 2], subPath[k2 + 3], subPath[k2 + 4], subPath[k2 + 5]);
    }
  }
  return path;
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/rect-utils
var normalizeRectAttributes = (attribute) => {
  if (!attribute)
    return {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  let width = isNil_default(attribute.width) ? attribute.x1 - attribute.x : attribute.width, height = isNil_default(attribute.height) ? attribute.y1 - attribute.y : attribute.height, x = 0, y = 0;
  return width < 0 ? (x = width, width = -width) : Number.isNaN(width) && (width = 0), height < 0 ? (y = height, height = -height) : Number.isNaN(height) && (height = 0), {
    x,
    y,
    width,
    height
  };
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/split-path
function splitToGrids(width, height, count) {
  const ratio = width / height;
  let rowCount, columnCount;
  width >= height ? (columnCount = Math.ceil(Math.sqrt(count * ratio)), rowCount = Math.floor(count / columnCount), 0 === rowCount && (rowCount = 1, columnCount = count)) : (rowCount = Math.ceil(Math.sqrt(count / ratio)), columnCount = Math.floor(count / rowCount), 0 === columnCount && (columnCount = 1, rowCount = count));
  const grids = [];
  for (let i = 0; i < rowCount; i++)
    grids.push(columnCount);
  const remained = count - rowCount * columnCount;
  if (remained > 0)
    for (let i = 0; i < remained; i += columnCount)
      i + columnCount < remained ? grids.push(columnCount) : grids.push(remained - i);
  return grids;
}
var splitRect = (rect, count) => {
  const { width, height } = normalizeRectAttributes(rect.attribute), grids = splitToGrids(width, height, count), res = [], gridHeight = height / grids.length;
  for (let i = 0, rowCount = grids.length; i < rowCount; i++) {
    const columnCount = grids[i], gridWidth = width / columnCount;
    for (let j = 0; j < columnCount; j++)
      res.push({
        x: 0 + j * gridWidth,
        y: 0 + i * gridHeight,
        width: gridWidth,
        height: gridHeight
      });
  }
  return res;
};
var splitArc = (arc, count) => {
  const angles = arc.getParsedAngle(), startAngle = angles.startAngle, endAngle = angles.endAngle, innerRadius = arc.getComputedAttribute("innerRadius"), outerRadius = arc.getComputedAttribute("outerRadius"), angleDelta = Math.abs(startAngle - endAngle), radiusDelta = Math.abs(outerRadius - innerRadius), grids = splitToGrids(angleDelta * (innerRadius + outerRadius) / 2, radiusDelta, count), res = [], gridRadius = radiusDelta / grids.length, radiusSign = outerRadius >= innerRadius ? 1 : -1, angleSign = endAngle >= startAngle ? 1 : -1;
  for (let i = 0, rowCount = grids.length; i < rowCount; i++) {
    const columnCount = grids[i], gridAngle = angleDelta / columnCount;
    for (let j = 0; j < columnCount; j++)
      res.push({
        innerRadius: outerRadius - gridRadius * i * radiusSign,
        outerRadius: outerRadius - gridRadius * (i + 1) * radiusSign,
        startAngle: startAngle + gridAngle * j * angleSign,
        endAngle: startAngle + gridAngle * (j + 1) * angleSign
      });
  }
  return res;
};
var splitCircle = (arc, count) => {
  const startAngle = arc.getComputedAttribute("startAngle"), endAngle = arc.getComputedAttribute("endAngle"), radius = arc.getComputedAttribute("radius"), angleDelta = Math.abs(startAngle - endAngle), grids = splitToGrids(angleDelta * radius, radius, count), res = [], gridAngle = angleDelta / grids[0], gridRadius = radius / grids.length, angleSign = endAngle >= startAngle ? 1 : -1;
  for (let i = 0, rowCount = grids.length; i < rowCount; i++)
    for (let j = 0, columnCount = grids[i]; j < columnCount; j++)
      res.push({
        innerRadius: gridRadius * i,
        outerRadius: gridRadius * (i + 1),
        startAngle: startAngle + gridAngle * j * angleSign,
        endAngle: startAngle + gridAngle * (j + 1) * angleSign
      });
  return res;
};
var samplingPoints = (points, count) => {
  const validatePoints = points.filter((point5) => false !== point5.defined && isNumber_default(point5.x) && isNumber_default(point5.y));
  if (0 === validatePoints.length)
    return [];
  if (1 === validatePoints.length)
    return new Array(count).fill(0).map((i) => validatePoints[0]);
  const res = [];
  if (count <= validatePoints.length) {
    const step = validatePoints.length / count;
    let i = 0, cur = 0;
    for (; i < count; )
      res.push(validatePoints[Math.floor(cur)]), cur += step, i++;
    return res;
  }
  const insertCount = count - validatePoints.length, insetRatio = 1 / (insertCount / (validatePoints.length - 1) + 1);
  let curCount = 0;
  for (let i = 0, len = points.length; i < len; i++)
    if (res.push(points[i]), i < len - 1) {
      let cur = insetRatio;
      const xCur = points[i].x, yCur = points[i].y, xNext = points[i + 1].x, yNext = points[i + 1].y;
      for (; cur < 1 && curCount < insertCount; )
        res.push({
          x: xCur + (xNext - xCur) * cur,
          y: yCur + (yNext - yCur) * cur
        }), cur += insetRatio, curCount += 1;
    }
  return res;
};
var splitArea = (area2, count) => {
  var _a, _b;
  const attribute = area2.attribute;
  let points = attribute.points;
  const segements = attribute.segments;
  points || (points = segements.reduce((res2, seg) => {
    var _a2;
    return res2.concat(null !== (_a2 = seg.points) && void 0 !== _a2 ? _a2 : []);
  }, []));
  const validatePoints = points.filter((point5) => false !== point5.defined && isNumber_default(point5.x) && isNumber_default(point5.y));
  if (!validatePoints.length)
    return [];
  const allPoints = [];
  validatePoints.forEach((point5) => {
    allPoints.push({
      x: point5.x,
      y: point5.y
    });
  });
  for (let i = validatePoints.length - 1; i >= 0; i--) {
    const point5 = validatePoints[i];
    allPoints.push({
      x: null !== (_a = point5.x1) && void 0 !== _a ? _a : point5.x,
      y: null !== (_b = point5.y1) && void 0 !== _b ? _b : point5.y
    });
  }
  const res = [];
  return recursiveCallBinarySplit(points, count, res), res;
};
var splitLine = (line2, count) => {
  const attribute = line2.attribute, points = attribute.points;
  if (points)
    return samplingPoints(points, count);
  if (attribute.segments) {
    const allPoints = attribute.segments.reduce((res, seg) => {
      var _a;
      return res.concat(null !== (_a = seg.points) && void 0 !== _a ? _a : []);
    }, []);
    return samplingPoints(allPoints, count);
  }
  return [];
};
function crossProduct2(dir1, dir2) {
  return dir1[0] * dir2[1] - dir1[1] * dir2[0];
}
var clonePoints = (points) => points.map((p) => ({
  x: p.x,
  y: p.y
}));
var splitPolygonByLine = (points, p0, p1) => {
  const len = points.length, intersections = [];
  for (let i = 0; i < len; i++) {
    const cur = points[i], next = i === len - 1 ? points[0] : points[i + 1], res = getIntersectPoint([p0.x, p0.y], [p1.x, p1.y], [cur.x, cur.y], [next.x, next.y]);
    res && "boolean" != typeof res && intersections.push({
      dot: crossProduct2([res[0] - p0.x, res[1] - p0.x], [p1.x - p0.x, p1.y - p0.x]),
      point: {
        x: res[0],
        y: res[1]
      },
      edgeIndex: i
    });
  }
  if (intersections.length < 2)
    return [clonePoints(points), clonePoints(points)];
  intersections.sort((a3, b) => a3.dot - b.dot);
  let is0 = intersections[0], is1 = intersections[intersections.length - 1];
  is0.edgeIndex > is1.edgeIndex && ([is0, is1] = [is1, is0]);
  const newP0 = is0.point, newP1 = is1.point, newPointsA = [{
    x: newP0.x,
    y: newP0.y
  }];
  for (let i = is0.edgeIndex + 1; i <= is1.edgeIndex; i++)
    newPointsA.push({
      x: points[i].x,
      y: points[i].y
    });
  newPointsA.push({
    x: newP1.x,
    y: newP1.y
  });
  const newPointsB = [{
    x: newP1.x,
    y: newP1.y
  }];
  for (let i = is1.edgeIndex + 1, maxIndex = is0.edgeIndex + len; i <= maxIndex; i++) {
    const p = points[i % len];
    newPointsB.push({
      x: p.x,
      y: p.y
    });
  }
  return newPointsB.push({
    x: newP0.x,
    y: newP0.y
  }), [newPointsA, newPointsB];
};
var binarySplitPolygon = (points) => {
  const box = new Bounds();
  points.forEach((point5) => {
    box.add(point5.x, point5.y);
  });
  const width = box.width(), height = box.height();
  if (width >= height) {
    const midX = box.x1 + width / 2;
    return splitPolygonByLine(points, {
      x: midX,
      y: box.y1
    }, {
      x: midX,
      y: box.y2
    });
  }
  const midY = box.y1 + height / 2;
  return splitPolygonByLine(points, {
    x: box.x1,
    y: midY
  }, {
    x: box.x2,
    y: midY
  });
};
var recursiveCallBinarySplit = (points, count, out) => {
  if (1 === count)
    out.push({
      points
    });
  else {
    const half = Math.floor(count / 2), res = binarySplitPolygon(points);
    recursiveCallBinarySplit(res[0], half, out), recursiveCallBinarySplit(res[1], count - half, out);
  }
};
var splitPolygon = (polygon, count) => {
  const points = polygon.attribute.points;
  if (!points || !points.length)
    return [];
  if (1 === count)
    return [{
      points: clonePoints(points)
    }];
  const res = [];
  return recursiveCallBinarySplit(points, count, res), res;
};
var splitPath = (path, count) => {
  const pathShape = path.getParsedPathShape(), bezierCurves = pathToBezierCurves(pathShape);
  if (!bezierCurves.length || count < 0)
    return [];
  const subPathCnt = bezierCurves.length;
  if (bezierCurves.length >= count) {
    const res2 = [], stepCount2 = Math.floor(bezierCurves.length / count);
    for (let i = 0; i < count; i++) {
      const curves = bezierCurves.slice(i * stepCount2, i === count - 1 ? subPathCnt : (i + 1) * stepCount2);
      res2.push({
        path: bezierCurversToPath(curves)
      });
    }
    return res2;
  }
  const res = [], stepCount = Math.floor(count / subPathCnt);
  let remain = count;
  for (let c3 = 0; c3 < subPathCnt; c3++) {
    const points = [];
    for (let i = 2, len = bezierCurves[c3].length; i < len; i += 2)
      points.push({
        x: bezierCurves[0][i],
        y: bezierCurves[0][i + 1]
      });
    recursiveCallBinarySplit(points, c3 === subPathCnt - 1 ? remain : stepCount, res), remain -= stepCount;
  }
  return res;
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/color-string/store
var ColorType;
!function(ColorType2) {
  ColorType2[ColorType2.Color255 = 0] = "Color255", ColorType2[ColorType2.Color1 = 1] = "Color1";
}(ColorType || (ColorType = {}));
var ColorStore = class _ColorStore {
  static Get(str, size = ColorType.Color1, arr = [0, 0, 0, 1]) {
    if (size === ColorType.Color1) {
      const color2 = _ColorStore.store1[str];
      if (color2)
        return arr[0] = color2[0], arr[1] = color2[1], arr[2] = color2[2], arr[3] = color2[3], arr;
      const c4 = Color.parseColorString(str);
      if (c4) {
        const data = [c4.r / 255, c4.g / 255, c4.b / 255, c4.opacity];
        _ColorStore.store1[str] = data, _ColorStore.store255[str] = [c4.r, c4.g, c4.b, c4.opacity], arr[0] = data[0], arr[1] = data[1], arr[2] = data[2], arr[3] = data[3];
      }
      return arr;
    }
    const color = _ColorStore.store255[str];
    if (color)
      return arr[0] = color[0], arr[1] = color[1], arr[2] = color[2], arr[3] = color[3], arr;
    const c3 = Color.parseColorString(str);
    return c3 && (_ColorStore.store1[str] = [c3.r / 255, c3.g / 255, c3.b / 255, c3.opacity], _ColorStore.store255[str] = [c3.r, c3.g, c3.b, c3.opacity], arr[0] = c3.r, arr[1] = c3.g, arr[2] = c3.b, arr[3] = c3.opacity), arr;
  }
  static Set(str, size, arr) {
    if (size === ColorType.Color1) {
      if (_ColorStore.store1[str])
        return;
      _ColorStore.store1[str] = arr, _ColorStore.store255[str] = [Math.floor(255 * arr[0]), Math.floor(255 * arr[1]), Math.floor(255 * arr[2]), Math.floor(255 * arr[3])];
    } else {
      if (_ColorStore.store255[str])
        return;
      _ColorStore.store255[str] = arr, _ColorStore.store1[str] = [arr[0] / 255, arr[1] / 255, arr[2] / 255, arr[3]];
    }
  }
};
ColorStore.store255 = {}, ColorStore.store1 = {};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/color-string/interpolate
function colorArrayToString(color, alphaChannel = false) {
  return Array.isArray(color) && isNumber_default(color[0]) ? alphaChannel ? `rgb(${Math.round(color[0])},${Math.round(color[1])},${Math.round(color[2])},${color[3].toFixed(2)})` : `rgb(${Math.round(color[0])},${Math.round(color[1])},${Math.round(color[2])})` : color;
}
function interpolateColor(from, to, ratio, alphaChannel, cb) {
  if (!from || !to)
    return from && colorArrayToString(from) || to && colorArrayToString(to) || false;
  let fromArray, toArray, fromGradient = false, toGradient = false;
  if (Array.isArray(from) ? fromArray = from : "string" == typeof from ? fromArray = ColorStore.Get(from, ColorType.Color255) : fromGradient = true, Array.isArray(to) ? toArray = to : "string" == typeof to ? toArray = ColorStore.Get(to, ColorType.Color255) : toGradient = true, fromGradient !== toGradient) {
    const gradient = fromGradient ? from : to, pure = fromGradient ? to : from, gradientFromPure = Object.assign(Object.assign({}, gradient), {
      stops: gradient.stops.map((v) => Object.assign(Object.assign({}, v), {
        color: colorArrayToString(pure)
      }))
    });
    return fromGradient ? interpolateColor(gradient, gradientFromPure, ratio, alphaChannel, cb) : interpolateColor(gradientFromPure, gradient, ratio, alphaChannel, cb);
  }
  if (fromGradient) {
    if (from.gradient === to.gradient) {
      const fc = from, tc = to, fromStops = fc.stops, toStops = tc.stops;
      if (fromStops.length !== toStops.length)
        return false;
      if ("linear" === fc.gradient)
        return interpolateGradientLinearColor(fc, tc, ratio);
      if ("radial" === fc.gradient)
        return interpolateGradientRadialColor(fc, tc, ratio);
      if ("conical" === fc.gradient)
        return interpolateGradientConicalColor(fc, tc, ratio);
    }
    return false;
  }
  cb && cb(fromArray, toArray);
  return colorArrayToString(interpolatePureColorArray(fromArray, toArray, ratio), alphaChannel);
}
function interpolateGradientLinearColor(fc, tc, ratio) {
  const fStops = fc.stops, tStops = tc.stops;
  return {
    gradient: "linear",
    x0: fc.x0 + (tc.x0 - fc.x0) * ratio,
    x1: fc.x1 + (tc.x1 - fc.x1) * ratio,
    y0: fc.y0 + (tc.y0 - fc.y0) * ratio,
    y1: fc.y1 + (tc.y1 - fc.y1) * ratio,
    stops: new Array(fStops.length).fill(0).map((_, i) => ({
      color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
      offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
    }))
  };
}
function interpolateGradientRadialColor(fc, tc, ratio) {
  const fStops = fc.stops, tStops = tc.stops;
  return {
    gradient: "radial",
    x0: fc.x0 + (tc.x0 - fc.x0) * ratio,
    x1: fc.x1 + (tc.x1 - fc.x1) * ratio,
    y0: fc.y0 + (tc.y0 - fc.y0) * ratio,
    y1: fc.y1 + (tc.y1 - fc.y1) * ratio,
    r0: fc.r0 + (tc.r0 - fc.r0) * ratio,
    r1: fc.r1 + (tc.r1 - fc.r1) * ratio,
    stops: new Array(fStops.length).fill(0).map((_, i) => ({
      color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
      offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
    }))
  };
}
function interpolateGradientConicalColor(fc, tc, ratio) {
  const fStops = fc.stops, tStops = tc.stops;
  return {
    gradient: "conical",
    startAngle: fc.startAngle + (tc.startAngle - fc.startAngle) * ratio,
    endAngle: fc.endAngle + (tc.endAngle - fc.endAngle) * ratio,
    x: fc.x + (tc.x - fc.x) * ratio,
    y: fc.y + (tc.y - fc.y) * ratio,
    stops: new Array(fStops.length).fill(0).map((_, i) => ({
      color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
      offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
    }))
  };
}
function interpolatePureColorArray(from, to, ratio) {
  return [from[0] + (to[0] - from[0]) * ratio, from[1] + (to[1] - from[1]) * ratio, from[2] + (to[2] - from[2]) * ratio, from[3] + (to[3] - from[3]) * ratio];
}
var _fromColorRGB = [0, 0, 0, 0];
var _toColorRGB = [0, 0, 0, 0];
function colorStringInterpolationToStr(fromColor, toColor, ratio) {
  return ColorStore.Get(fromColor, ColorType.Color255, _fromColorRGB), ColorStore.Get(toColor, ColorType.Color255, _toColorRGB), `rgba(${Math.round(_fromColorRGB[0] + (_toColorRGB[0] - _fromColorRGB[0]) * ratio)},${Math.round(_fromColorRGB[1] + (_toColorRGB[1] - _fromColorRGB[1]) * ratio)},${Math.round(_fromColorRGB[2] + (_toColorRGB[2] - _fromColorRGB[2]) * ratio)},${_fromColorRGB[3] + (_toColorRGB[3] - _fromColorRGB[3]) * ratio})`;
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/color-string/colorName
var parsedColors = {};
Object.keys(DEFAULT_COLORS).forEach((k2) => {
  const c3 = DEFAULT_COLORS[k2];
  parsedColors[k2] = [c3 >> 16 & 255, c3 >> 8 & 255, 255 & c3];
});

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/animate/morphing
var interpolateOtherAttrs = (attrs, out, ratio) => {
  attrs.forEach((entry) => {
    if (Number.isFinite(entry.to))
      out[entry.key] = entry.from + (entry.to - entry.from) * ratio;
    else if ("fill" === entry.key || "stroke" === entry.key) {
      const color = interpolateColor(entry.from, entry.to, ratio, false);
      color && (out[entry.key] = color);
    }
  });
};
var interpolateMorphingData = (morphingData, path, ratio) => {
  const tmpArr = [], newCp = [];
  path.clear();
  for (let i = 0; i < morphingData.length; i++) {
    const item = morphingData[i], from = item.from, to = item.to, angle2 = item.rotation * ratio, fromCp = item.fromCp, toCp = item.toCp, sa = Math.sin(angle2), ca = Math.cos(angle2);
    newCp[0] = fromCp[0] + (toCp[0] - fromCp[0]) * ratio, newCp[1] = fromCp[1] + (toCp[1] - fromCp[1]) * ratio;
    for (let m4 = 0; m4 < from.length; m4 += 2) {
      const x06 = from[m4], y06 = from[m4 + 1], x = x06 * (1 - ratio) + to[m4] * ratio, y = y06 * (1 - ratio) + to[m4 + 1] * ratio;
      tmpArr[m4] = x * ca - y * sa + newCp[0], tmpArr[m4 + 1] = x * sa + y * ca + newCp[1];
    }
    let x05 = tmpArr[0], y05 = tmpArr[1];
    path.moveTo(x05, y05);
    for (let m4 = 2; m4 < from.length; m4 += 6) {
      const x14 = tmpArr[m4], y14 = tmpArr[m4 + 1], x23 = tmpArr[m4 + 2], y23 = tmpArr[m4 + 3], x3 = tmpArr[m4 + 4], y3 = tmpArr[m4 + 5];
      x05 === x14 && y05 === y14 && x23 === x3 && y23 === y3 ? path.lineTo(x3, y3) : path.bezierCurveTo(x14, y14, x23, y23, x3, y3), x05 = x3, y05 = y3;
    }
  }
};
var parseMorphingData = (fromPath, toPath, config2) => {
  const fromBezier = fromPath ? pathToBezierCurves(fromPath) : [], toBezier = pathToBezierCurves(toPath);
  config2 && fromBezier && (config2.fromTransform && applyTransformOnBezierCurves(fromBezier, config2.fromTransform.clone().getInverse()), applyTransformOnBezierCurves(fromBezier, config2.toTransfrom));
  const [fromBezierCurves, toBezierCurves] = alignBezierCurves(fromBezier, toBezier);
  return fromPath ? findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI) : toBezierCurves.map((to, index) => ({
    from: fromBezierCurves[index],
    to,
    fromCp: [0, 0],
    toCp: [0, 0],
    rotation: 0
  }));
};
var validateOtherAttrs = ["fill", "fillOpacity", "shadowBlur", "shadowColor", "shadowOffsetX", "shadowOffsetY", "stroke", "strokeOpacity", "lineDashOffset"];
var parseOtherAnimateAttrs = (fromAttrs, toAttrs) => {
  if (!fromAttrs || !toAttrs)
    return null;
  const res = [];
  let hasAttr = false;
  return Object.keys(fromAttrs).forEach((fromKey) => {
    if (!validateOtherAttrs.includes(fromKey))
      return;
    const toValue = toAttrs[fromKey];
    isNil_default(toValue) || isNil_default(fromAttrs[fromKey]) || toValue === fromAttrs[fromKey] || ("fill" === fromKey || "stroke" === fromKey ? res.push({
      from: "string" == typeof fromAttrs[fromKey] ? ColorStore.Get(fromAttrs[fromKey], ColorType.Color255) : fromAttrs[fromKey],
      to: "string" == typeof toValue ? ColorStore.Get(toValue, ColorType.Color255) : toValue,
      key: fromKey
    }) : res.push({
      from: fromAttrs[fromKey],
      to: toValue,
      key: fromKey
    }), hasAttr = true);
  }), hasAttr ? res : null;
};
var MorphingPath = class extends ACustomAnimate {
  constructor(config2, duration, easing) {
    super(0, 1, duration, easing), this.morphingData = config2.morphingData, this.otherAttrs = config2.otherAttrs, this.saveOnEnd = config2.saveOnEnd;
  }
  getEndProps() {
    return {};
  }
  onBind() {
    this.target.createPathProxy(), this.onUpdate(false, 0, this.target.attribute);
  }
  onEnd() {
  }
  onUpdate(end, ratio, out) {
    const target = this.target, pathProxy = "function" == typeof target.pathProxy ? target.pathProxy(target.attribute) : target.pathProxy;
    interpolateMorphingData(this.morphingData, pathProxy, ratio), this.otherAttrs && this.otherAttrs.length && interpolateOtherAttrs(this.otherAttrs, out, ratio), end && !this.saveOnEnd && (this.target.pathProxy = null);
  }
};
var morphPath = (fromGraphic, toGraphic, animationConfig2, fromGraphicTransform) => {
  var _a, _b, _c;
  if (fromGraphic && (!fromGraphic.valid || !fromGraphic.toCustomPath))
    return __DEV__ && console.error(fromGraphic, " is not validate"), null;
  if (!toGraphic.valid || !toGraphic.toCustomPath)
    return __DEV__ && console.error(toGraphic, " is not validate"), null;
  let fromTransform = null == fromGraphic ? void 0 : fromGraphic.globalTransMatrix;
  fromGraphicTransform && fromTransform && (fromTransform = fromGraphicTransform.clone().multiply(fromTransform.a, fromTransform.b, fromTransform.c, fromTransform.d, fromTransform.e, fromTransform.f));
  const morphingData = parseMorphingData(null === (_a = null == fromGraphic ? void 0 : fromGraphic.toCustomPath) || void 0 === _a ? void 0 : _a.call(fromGraphic), toGraphic.toCustomPath(), {
    fromTransform,
    toTransfrom: toGraphic.globalTransMatrix
  }), attrs = parseOtherAnimateAttrs(null == fromGraphic ? void 0 : fromGraphic.attribute, toGraphic.attribute), animate = toGraphic.animate(animationConfig2);
  return (null == animationConfig2 ? void 0 : animationConfig2.delay) && animate.wait(animationConfig2.delay), animate.play(new MorphingPath({
    morphingData,
    otherAttrs: attrs
  }, null !== (_b = null == animationConfig2 ? void 0 : animationConfig2.duration) && void 0 !== _b ? _b : DefaultMorphingAnimateConfig.duration, null !== (_c = null == animationConfig2 ? void 0 : animationConfig2.easing) && void 0 !== _c ? _c : DefaultMorphingAnimateConfig.easing)), animate;
};
var oneToMultiMorph = (fromGraphic, toGraphics, animationConfig2) => {
  var _a;
  const validateToGraphics = toGraphics.filter((graphic) => graphic && graphic.toCustomPath && graphic.valid);
  validateToGraphics.length || __DEV__ && console.error(validateToGraphics, " is not validate"), fromGraphic.valid && fromGraphic.toCustomPath || __DEV__ && console.error(fromGraphic, " is not validate");
  const childGraphics = ("clone" === (null == animationConfig2 ? void 0 : animationConfig2.splitPath) ? cloneGraphic : null !== (_a = null == animationConfig2 ? void 0 : animationConfig2.splitPath) && void 0 !== _a ? _a : splitGraphic)(fromGraphic, validateToGraphics.length, false), oldOnEnd = null == animationConfig2 ? void 0 : animationConfig2.onEnd;
  let count = validateToGraphics.length;
  const onEachEnd = () => {
    count--, 0 === count && oldOnEnd && oldOnEnd();
  };
  validateToGraphics.forEach((toChild, index) => {
    var _a2;
    const fromChild = childGraphics[index], delay = (null !== (_a2 = null == animationConfig2 ? void 0 : animationConfig2.delay) && void 0 !== _a2 ? _a2 : 0) + ((null == animationConfig2 ? void 0 : animationConfig2.individualDelay) ? animationConfig2.individualDelay(index, validateToGraphics.length, fromChild, toChild) : 0);
    morphPath(fromChild, toChild, Object.assign({}, animationConfig2, {
      onEnd: onEachEnd,
      delay
    }), fromGraphic.globalTransMatrix);
  });
};
var MultiToOneMorphingPath = class extends ACustomAnimate {
  constructor(config2, duration, easing) {
    super(0, 1, duration, easing), this.morphingData = config2.morphingData, this.otherAttrs = config2.otherAttrs;
  }
  getEndProps() {
    return {};
  }
  onBind() {
    this.addPathProxy();
  }
  addPathProxy() {
    this.target.shadowRoot.forEachChildren((child) => {
      child.createPathProxy();
    }), this.onUpdate(false, 0, this.target.attribute);
  }
  clearPathProxy() {
    this.target.shadowRoot.forEachChildren((child) => {
      child.pathProxy = null;
    });
  }
  onEnd() {
  }
  onUpdate(end, ratio, out) {
    this.target.shadowRoot.forEachChildren((child, index) => {
      var _a;
      interpolateMorphingData(this.morphingData[index], "function" == typeof child.pathProxy ? child.pathProxy(child.attribute) : child.pathProxy, ratio), (null === (_a = this.otherAttrs) || void 0 === _a ? void 0 : _a[index]) && this.otherAttrs[index].length && interpolateOtherAttrs(this.otherAttrs[index], child.attribute, ratio);
    }), end && (this.clearPathProxy(), this.morphingData = null);
  }
};
var parseShadowChildAttrs = (graphicAttrs) => {
  const attrs = {};
  return Object.keys(graphicAttrs).forEach((key) => {
    isTransformKey(key) || (attrs[key] = graphicAttrs[key]);
  }), attrs;
};
var appendShadowChildrenToGraphic = (graphic, children, count) => {
  const childAttrs = parseShadowChildAttrs(graphic.attribute), shadowRoot = graphic.attachShadow();
  if (children.length)
    shadowRoot.setTheme({
      [children[0].type]: childAttrs
    }), children.forEach((element) => {
      shadowRoot.appendChild(element);
    });
  else {
    const box = graphic.AABBBounds, width = box.width(), height = box.height();
    shadowRoot.setTheme({
      rect: childAttrs
    }), new Array(count).fill(0).forEach((el) => {
      const child = application.graphicService.creator.rect({
        x: 0,
        y: 0,
        width,
        height
      });
      shadowRoot.appendChild(child), children.push(child);
    });
  }
};
var cloneGraphic = (graphic, count, needAppend) => {
  const children = [], childAttrs = needAppend ? null : parseShadowChildAttrs(graphic.attribute), path = graphic.toCustomPath();
  for (let i = 0; i < count; i++) {
    const element = {
      path: new CustomPath2D().fromCustomPath2D(path)
    };
    children.push(application.graphicService.creator.path(needAppend ? element : Object.assign({}, childAttrs, element)));
  }
  return needAppend && appendShadowChildrenToGraphic(graphic, children, count), children;
};
var splitGraphic = (graphic, count, needAppend) => {
  const children = [], childAttrs = needAppend ? null : parseShadowChildAttrs(graphic.attribute);
  if ("rect" === graphic.type) {
    splitRect(graphic, count).forEach((element) => {
      children.push(application.graphicService.creator.rect(needAppend ? element : Object.assign({}, childAttrs, element)));
    });
  } else if ("arc" === graphic.type) {
    splitArc(graphic, count).forEach((element) => {
      children.push(application.graphicService.creator.arc(needAppend ? element : Object.assign({}, childAttrs, element)));
    });
  } else if ("circle" === graphic.type) {
    splitCircle(graphic, count).forEach((element) => {
      children.push(application.graphicService.creator.arc(needAppend ? element : Object.assign({}, childAttrs, element)));
    });
  } else if ("line" === graphic.type) {
    const childrenAttrs = splitLine(graphic, count), defaultSymbol = {
      size: 10,
      symbolType: "circle"
    };
    childrenAttrs.forEach((element) => {
      children.push(application.graphicService.creator.symbol(needAppend ? Object.assign({}, element, defaultSymbol) : Object.assign({}, childAttrs, element, defaultSymbol)));
    });
  } else if ("polygon" === graphic.type) {
    splitPolygon(graphic, count).forEach((element) => {
      children.push(application.graphicService.creator.polygon(needAppend ? element : Object.assign({}, childAttrs, element)));
    });
  } else if ("area" === graphic.type) {
    splitArea(graphic, count).forEach((element) => {
      children.push(application.graphicService.creator.polygon(needAppend ? element : Object.assign({}, childAttrs, element)));
    });
  } else if ("path" === graphic.type) {
    splitPath(graphic, count).forEach((element) => {
      "path" in element ? children.push(application.graphicService.creator.path(needAppend ? element : Object.assign({}, childAttrs, element))) : children.push(application.graphicService.creator.polygon(needAppend ? element : Object.assign({}, childAttrs, element)));
    });
  }
  return needAppend && appendShadowChildrenToGraphic(graphic, children, count), children;
};
var multiToOneMorph = (fromGraphics, toGraphic, animationConfig2) => {
  var _a, _b, _c;
  const validateFromGraphics = fromGraphics.filter((graphic) => graphic.toCustomPath && graphic.valid);
  validateFromGraphics.length || __DEV__ && console.error(fromGraphics, " is not validate"), toGraphic.valid && toGraphic.toCustomPath || __DEV__ && console.error(toGraphic, " is not validate");
  const childGraphics = ("clone" === (null == animationConfig2 ? void 0 : animationConfig2.splitPath) ? cloneGraphic : null !== (_a = null == animationConfig2 ? void 0 : animationConfig2.splitPath) && void 0 !== _a ? _a : splitGraphic)(toGraphic, validateFromGraphics.length, true), toAttrs = toGraphic.attribute;
  toGraphic.setAttribute("visible", false);
  const morphingData = validateFromGraphics.map((graphic, index) => parseMorphingData(graphic.toCustomPath(), childGraphics[index].toCustomPath(), {
    fromTransform: graphic.globalTransMatrix,
    toTransfrom: childGraphics[index].globalTransMatrix
  })), otherAttrs = validateFromGraphics.map((graphic, index) => parseOtherAnimateAttrs(graphic.attribute, toAttrs));
  if (null == animationConfig2 ? void 0 : animationConfig2.individualDelay) {
    const oldOnEnd = animationConfig2.onEnd;
    let count = validateFromGraphics.length;
    const onEachEnd = () => {
      count--, 0 === count && (toGraphic.setAttributes({
        visible: true,
        ratio: null
      }, false, {
        type: AttributeUpdateType.ANIMATE_END
      }), toGraphic.detachShadow(), oldOnEnd && oldOnEnd());
    };
    childGraphics.forEach((to, index) => {
      var _a2, _b2, _c2;
      const delay = (null !== (_a2 = animationConfig2.delay) && void 0 !== _a2 ? _a2 : 0) + animationConfig2.individualDelay(index, validateFromGraphics.length, fromGraphics[index], to), animate = to.animate(Object.assign({}, animationConfig2, {
        onEnd: onEachEnd
      }));
      animate.wait(delay), animate.play(new MorphingPath({
        morphingData: morphingData[index],
        saveOnEnd: true,
        otherAttrs: otherAttrs[index]
      }, null !== (_b2 = animationConfig2.duration) && void 0 !== _b2 ? _b2 : DefaultMorphingAnimateConfig.duration, null !== (_c2 = animationConfig2.easing) && void 0 !== _c2 ? _c2 : DefaultMorphingAnimateConfig.easing));
    });
  } else {
    const oldOnEnd = null == animationConfig2 ? void 0 : animationConfig2.onEnd, config2 = animationConfig2 ? Object.assign({}, animationConfig2) : {};
    config2.onEnd = () => {
      toGraphic.setAttribute("visible", true, false, {
        type: AttributeUpdateType.ANIMATE_END
      }), toGraphic.detachShadow(), oldOnEnd && oldOnEnd();
    };
    const animate = toGraphic.animate(config2);
    (null == animationConfig2 ? void 0 : animationConfig2.delay) && animate.wait(animationConfig2.delay), animate.play(new MultiToOneMorphingPath({
      morphingData,
      otherAttrs
    }, null !== (_b = null == animationConfig2 ? void 0 : animationConfig2.duration) && void 0 !== _b ? _b : DefaultMorphingAnimateConfig.duration, null !== (_c = null == animationConfig2 ? void 0 : animationConfig2.easing) && void 0 !== _c ? _c : DefaultMorphingAnimateConfig.easing));
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/resource-loader/loader
var ResourceLoader = class _ResourceLoader {
  static GetImage(url, mark) {
    var _a;
    const data = _ResourceLoader.cache.get(url);
    data ? "fail" === data.loadState ? application.global.getRequestAnimationFrame()(() => {
      mark.imageLoadFail(url);
    }) : "init" === data.loadState || "loading" === data.loadState ? null === (_a = data.waitingMark) || void 0 === _a || _a.push(mark) : mark && mark.imageLoadSuccess(url, data.data) : _ResourceLoader.loadImage(url, mark);
  }
  static GetSvg(svgStr, mark) {
    var _a;
    let data = _ResourceLoader.cache.get(svgStr);
    data ? "fail" === data.loadState ? application.global.getRequestAnimationFrame()(() => {
      mark.imageLoadFail(svgStr);
    }) : "init" === data.loadState || "loading" === data.loadState ? null === (_a = data.waitingMark) || void 0 === _a || _a.push(mark) : mark && mark.imageLoadSuccess(svgStr, data.data) : (data = {
      type: "image",
      loadState: "init"
    }, _ResourceLoader.cache.set(svgStr, data), data.dataPromise = application.global.loadSvg(svgStr), data.dataPromise ? (data.waitingMark = [mark], data.dataPromise.then((res) => {
      var _a2;
      data.loadState = (null == res ? void 0 : res.data) ? "success" : "fail", data.data = null == res ? void 0 : res.data, null === (_a2 = data.waitingMark) || void 0 === _a2 || _a2.map((mark2, index) => {
        (null == res ? void 0 : res.data) ? (data.loadState = "success", data.data = res.data, mark2.imageLoadSuccess(svgStr, res.data)) : (data.loadState = "fail", mark2.imageLoadFail(svgStr));
      });
    })) : (data.loadState = "fail", mark.imageLoadFail(svgStr)));
  }
  static GetFile(url, type) {
    let data = _ResourceLoader.cache.get(url);
    return data ? "init" === data.loadState || "fail" === data.loadState ? Promise.reject() : "loading" === data.loadState ? data.dataPromise.then((data2) => data2.data) : Promise.resolve(data.data) : (data = {
      type,
      loadState: "init"
    }, _ResourceLoader.cache.set(url, data), "arrayBuffer" === type ? data.dataPromise = application.global.loadArrayBuffer(url) : "blob" === type ? data.dataPromise = application.global.loadBlob(url) : "json" === type && (data.dataPromise = application.global.loadJson(url)), data.dataPromise.then((data2) => data2.data));
  }
  static loading() {
    setTimeout(() => {
      if (!_ResourceLoader.isLoading && _ResourceLoader.toLoadAueue.length) {
        _ResourceLoader.isLoading = true;
        const tasks = _ResourceLoader.toLoadAueue.splice(0, 10), promises = [];
        tasks.forEach((task) => {
          const { url, marks } = task, data = {
            type: "image",
            loadState: "init"
          };
          if (_ResourceLoader.cache.set(url, data), data.dataPromise = application.global.loadImage(url), data.dataPromise) {
            data.waitingMark = marks;
            const end = data.dataPromise.then((res) => {
              var _a;
              data.loadState = (null == res ? void 0 : res.data) ? "success" : "fail", data.data = null == res ? void 0 : res.data, null === (_a = data.waitingMark) || void 0 === _a || _a.map((mark, index) => {
                (null == res ? void 0 : res.data) ? (data.loadState = "success", data.data = res.data, mark.imageLoadSuccess(url, res.data)) : (data.loadState = "fail", mark.imageLoadFail(url));
              });
            });
            promises.push(end);
          } else
            data.loadState = "fail", marks.forEach((mark) => mark.imageLoadFail(url));
        }), Promise.all(promises).then(() => {
          _ResourceLoader.isLoading = false, this.onLoadSuccessCb.forEach((cb) => cb()), _ResourceLoader.loading();
        }).catch((error3) => {
          console.error(error3), _ResourceLoader.isLoading = false, this.onLoadSuccessCb.forEach((cb) => cb()), _ResourceLoader.loading();
        });
      }
    }, 0);
  }
  static loadImage(url, mark) {
    const index = getIndex(url, _ResourceLoader.toLoadAueue);
    if (-1 !== index)
      return _ResourceLoader.toLoadAueue[index].marks.push(mark), void _ResourceLoader.loading();
    _ResourceLoader.toLoadAueue.push({
      url,
      marks: [mark]
    }), _ResourceLoader.loading();
  }
  static improveImageLoading(url) {
    const index = getIndex(url, _ResourceLoader.toLoadAueue);
    if (-1 !== index) {
      const elememt = _ResourceLoader.toLoadAueue.splice(index, 1);
      _ResourceLoader.toLoadAueue.unshift(elememt[0]);
    }
  }
  static onLoadSuccess(cb) {
    this.onLoadSuccessCb.push(cb);
  }
};
function getIndex(url, arr) {
  for (let i = 0; i < arr.length; i++)
    if (arr[i].url === url)
      return i;
  return -1;
}
ResourceLoader.cache = /* @__PURE__ */ new Map(), ResourceLoader.isLoading = false, ResourceLoader.toLoadAueue = [], ResourceLoader.onLoadSuccessCb = [];

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/graphic
var tempMatrix = new Matrix();
var tempBounds = new AABBBounds();
var GRAPHIC_UPDATE_TAG_KEY = ["lineWidth", "scaleX", "scaleY", "angle", "anchor", "visible"];
var tempConstantXYKey = ["x", "y"];
var tempConstantScaleXYKey = ["scaleX", "scaleY"];
var tempConstantAngleKey = ["angle"];
var point3 = new Point();
var NOWORK_ANIMATE_ATTR = {
  strokeSeg: 1,
  boundsPadding: 2,
  pickMode: 1,
  boundsMode: 1,
  customPickShape: 1,
  pickable: 1,
  childrenPickable: 1,
  visible: 1,
  zIndex: 1,
  layout: 1,
  keepDirIn3d: 1,
  globalZIndex: 1,
  outerBorder: 1,
  innerBorder: 1,
  lineDash: 1,
  lineCap: 1,
  lineJoin: 1,
  miterLimit: 2,
  strokeBoundsBuffer: 2,
  scaleCenter: 1,
  anchor: 1,
  anchor3d: 1,
  postMatrix: 1,
  backgroundMode: 2,
  background: 1,
  texture: 1,
  cursor: 1,
  html: 1
};
var Graphic = class _Graphic extends Node {
  static mixin(source) {
    const keys2 = Object.keys(source);
    for (let i = 0; i < keys2.length; ++i) {
      const propertyName = keys2[i];
      Object.defineProperty(_Graphic.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
    }
  }
  get AABBBounds() {
    return this.tryUpdateAABBBounds("imprecise" === this.attribute.boundsMode);
  }
  get OBBBounds() {
    return this.tryUpdateOBBBounds();
  }
  get globalAABBBounds() {
    return this.tryUpdateGlobalAABBBounds();
  }
  get transMatrix() {
    return this.tryUpdateLocalTransMatrix(true);
  }
  get globalTransMatrix() {
    return this.tryUpdateGlobalTransMatrix(true);
  }
  constructor(params2 = {}) {
    var _a;
    super(), this._AABBBounds = new AABBBounds(), this._updateTag = UpdateTag.INIT, this.attribute = params2, this.valid = this.isValid(), params2.background ? this.loadImage(null !== (_a = params2.background.background) && void 0 !== _a ? _a : params2.background, true) : params2.shadowGraphic && this.setShadowGraphic(params2.shadowGraphic);
  }
  setMode(mode) {
    "3d" === mode ? this.set3dMode() : this.set2dMode();
  }
  set3dMode() {
    this.in3dMode = true;
  }
  set2dMode() {
    this.in3dMode = false;
  }
  getOffsetXY(attr, includeScroll = false) {
    var _a, _b;
    const { dx = attr.dx, dy = attr.dy } = this.attribute;
    if (includeScroll && this.parent) {
      const attribute = this.parent.attribute;
      point3.x = dx + (null !== (_a = attribute.scrollX) && void 0 !== _a ? _a : 0), point3.y = dy + (null !== (_b = attribute.scrollY) && void 0 !== _b ? _b : 0);
    } else
      point3.x = dx, point3.y = dy;
    return point3;
  }
  onAnimateBind(animate) {
    this._emitCustomEvent("animate-bind", animate);
  }
  tryUpdateAABBBounds(full) {
    if (!this.shouldUpdateAABBBounds())
      return this._AABBBounds;
    if (!this.valid)
      return this._AABBBounds.clear(), this._AABBBounds;
    application.graphicService.beforeUpdateAABBBounds(this, this.stage, true, this._AABBBounds);
    const bounds = this.doUpdateAABBBounds(full);
    return application.graphicService.afterUpdateAABBBounds(this, this.stage, this._AABBBounds, this, true), bounds;
  }
  combindShadowAABBBounds(bounds) {
    if (this.shadowRoot) {
      const b = this.shadowRoot.AABBBounds.clone();
      bounds.union(b);
    }
  }
  tryUpdateGlobalAABBBounds() {
    const b = this.AABBBounds;
    return this._globalAABBBounds ? this._globalAABBBounds.setValue(b.x1, b.y1, b.x2, b.y2) : this._globalAABBBounds = b.clone(), this._globalAABBBounds.empty() || this.parent && this._globalAABBBounds.transformWithMatrix(this.parent.globalTransMatrix), this._globalAABBBounds;
  }
  tryUpdateGlobalTransMatrix(clearTag = true) {
    if (this._globalTransMatrix) {
      if (this.parent) {
        const m4 = this.parent.globalTransMatrix;
        this._globalTransMatrix.setValue(m4.a, m4.b, m4.c, m4.d, m4.e, m4.f);
      }
    } else
      this._globalTransMatrix = this.parent ? this.parent.globalTransMatrix.clone() : this.transMatrix.clone();
    return this.shouldUpdateGlobalMatrix() && this.doUpdateGlobalMatrix(), this._globalTransMatrix;
  }
  shouldUpdateGlobalMatrix() {
    return true;
  }
  tryUpdateLocalTransMatrix(clearTag = true) {
    return this._transMatrix || (this._transMatrix = new Matrix()), this.shouldUpdateLocalMatrix() && (this.doUpdateLocalMatrix(), clearTag && this.clearUpdateLocalPositionTag()), this._transMatrix;
  }
  shouldUpdateAABBBounds() {
    return this.shadowRoot ? !!(this._updateTag & UpdateTag.UPDATE_BOUNDS) || this.shadowRoot.shouldUpdateAABBBounds() : !!(this._updateTag & UpdateTag.UPDATE_BOUNDS);
  }
  shouldSelfChangeUpdateAABBBounds() {
    return this.shadowRoot ? !!(this._updateTag & UpdateTag.UPDATE_BOUNDS) || this.shadowRoot.shouldUpdateAABBBounds() : !!(this._updateTag & UpdateTag.UPDATE_BOUNDS);
  }
  shouldUpdateLocalMatrix() {
    return !!(this._updateTag & UpdateTag.UPDATE_LOCAL_MATRIX);
  }
  isValid() {
    var _a, _b;
    const attribute = this.attribute;
    return Number.isFinite((null !== (_a = attribute.x) && void 0 !== _a ? _a : 0) + (null !== (_b = attribute.y) && void 0 !== _b ? _b : 0));
  }
  _validNumber(num) {
    return null == num || Number.isFinite(num);
  }
  shouldUpdateShape() {
    return !!(this._updateTag & UpdateTag.UPDATE_SHAPE);
  }
  clearUpdateShapeTag() {
    this._updateTag &= UpdateTag.CLEAR_SHAPE;
  }
  containsPoint(x, y, mode, picker) {
    if (!picker)
      return false;
    if (mode === IContainPointMode.GLOBAL) {
      const point5 = new Point(x, y);
      this.parent && this.parent.globalTransMatrix.transformPoint(point5, point5), x = point5.x, y = point5.y;
    }
    return picker.containsPoint(this, {
      x,
      y
    });
  }
  setAttributes(params2, forceUpdateTag = false, context) {
    (params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(params2, this.attribute, null, context) || params2).background ? this.loadImage(params2.background, true) : params2.shadowGraphic && this.setShadowGraphic(params2.shadowGraphic), this._setAttributes(params2, forceUpdateTag, context);
  }
  _setAttributes(params2, forceUpdateTag = false, context) {
    const keys2 = Object.keys(params2);
    for (let i = 0; i < keys2.length; i++) {
      const key = keys2[i];
      this.attribute[key] = params2[key];
    }
    this.valid = this.isValid(), this.updateShapeAndBoundsTagSetted() || !forceUpdateTag && !this.needUpdateTags(keys2) ? this.addUpdateBoundTag() : this.addUpdateShapeAndBoundsTag(), this.addUpdatePositionTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context);
  }
  setAttribute(key, value, forceUpdateTag, context) {
    var _a;
    const params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
      [key]: value
    }, this.attribute, key, context);
    params2 ? this._setAttributes(params2, forceUpdateTag, context) : isNil_default(null === (_a = this.normalAttrs) || void 0 === _a ? void 0 : _a[key]) ? (this.attribute[key] = value, this.valid = this.isValid(), this.updateShapeAndBoundsTagSetted() || !forceUpdateTag && !this.needUpdateTag(key) ? this.addUpdateBoundTag() : this.addUpdateShapeAndBoundsTag(), this.addUpdatePositionTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context)) : this.normalAttrs[key] = value, "background" === key ? this.loadImage(value, true) : "shadowGraphic" === key && this.setShadowGraphic(value);
  }
  needUpdateTags(keys2, k2 = GRAPHIC_UPDATE_TAG_KEY) {
    for (let i = 0; i < k2.length; i++) {
      const attrKey = k2[i];
      if (-1 !== keys2.indexOf(attrKey))
        return true;
    }
    return false;
  }
  needUpdateTag(key, k2 = GRAPHIC_UPDATE_TAG_KEY) {
    for (let i = 0; i < k2.length; i++) {
      if (key === k2[i])
        return true;
    }
    return false;
  }
  initAttributes(params2) {
    const context = {
      type: AttributeUpdateType.INIT
    };
    params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(params2, this.attribute, null, context) || params2, this.attribute = params2, params2.background ? this.loadImage(params2.background, true) : params2.shadowGraphic && this.setShadowGraphic(params2.shadowGraphic), this._updateTag = UpdateTag.INIT, this.valid = this.isValid(), this.onAttributeUpdate(context);
  }
  translate(x, y) {
    var _a, _b;
    if (0 === x && 0 === y)
      return this;
    const context = {
      type: AttributeUpdateType.TRANSLATE
    }, params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
      x,
      y
    }, this.attribute, tempConstantXYKey, context);
    params2 && (x = params2.x, y = params2.y, delete params2.x, delete params2.y, this._setAttributes(params2));
    const attribute = this.attribute, postMatrix = attribute.postMatrix;
    return postMatrix ? application.transformUtil.fromMatrix(postMatrix, postMatrix).translate(x, y) : (attribute.x = (null !== (_a = attribute.x) && void 0 !== _a ? _a : DefaultTransform.x) + x, attribute.y = (null !== (_b = attribute.y) && void 0 !== _b ? _b : DefaultTransform.y) + y), this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this;
  }
  translateTo(x, y) {
    const attribute = this.attribute;
    if (attribute.x === x && attribute.y === y)
      return this;
    const context = {
      type: AttributeUpdateType.TRANSLATE_TO
    }, params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
      x,
      y
    }, this.attribute, tempConstantXYKey, context);
    return params2 ? (this._setAttributes(params2, false, context), this) : (attribute.x = x, attribute.y = y, this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this);
  }
  scale(scaleX, scaleY, scaleCenter) {
    var _a, _b;
    if (1 === scaleX && 1 === scaleY)
      return this;
    const context = {
      type: AttributeUpdateType.SCALE
    }, params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
      scaleX,
      scaleY,
      scaleCenter
    }, this.attribute, tempConstantScaleXYKey, context);
    params2 && (scaleX = params2.scaleX, scaleY = params2.scaleY, delete params2.scaleX, delete params2.scaleY, this._setAttributes(params2));
    const attribute = this.attribute;
    if (scaleCenter) {
      let { postMatrix } = this.attribute;
      postMatrix || (postMatrix = new Matrix(), attribute.postMatrix = postMatrix), application.transformUtil.fromMatrix(postMatrix, postMatrix).scale(scaleX, scaleY, scaleCenter);
    } else
      attribute.scaleX = (null !== (_a = attribute.scaleX) && void 0 !== _a ? _a : DefaultTransform.scaleX) * scaleX, attribute.scaleY = (null !== (_b = attribute.scaleY) && void 0 !== _b ? _b : DefaultTransform.scaleY) * scaleY;
    return this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this;
  }
  scaleTo(scaleX, scaleY) {
    const attribute = this.attribute;
    if (attribute.scaleX === scaleX && attribute.scaleY === scaleY)
      return this;
    const context = {
      type: AttributeUpdateType.SCALE_TO
    }, params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
      scaleX,
      scaleY
    }, this.attribute, tempConstantScaleXYKey, context);
    return params2 ? (this._setAttributes(params2, false, context), this) : (attribute.scaleX = scaleX, attribute.scaleY = scaleY, this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this);
  }
  rotate(angle2, rotateCenter) {
    var _a;
    if (0 === angle2)
      return this;
    const context = {
      type: AttributeUpdateType.ROTATE
    }, params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
      angle: angle2,
      rotateCenter
    }, this.attribute, tempConstantAngleKey, context);
    params2 && (delete params2.angle, this._setAttributes(params2, false, context));
    const attribute = this.attribute;
    if (rotateCenter) {
      let { postMatrix } = this.attribute;
      postMatrix || (postMatrix = new Matrix(), attribute.postMatrix = postMatrix), application.transformUtil.fromMatrix(postMatrix, postMatrix).rotate(angle2, rotateCenter);
    } else
      attribute.angle = (null !== (_a = attribute.angle) && void 0 !== _a ? _a : DefaultTransform.angle) + angle2;
    return this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this;
  }
  rotateTo(angle2) {
    const attribute = this.attribute;
    if (attribute.angle === angle2)
      return this;
    const context = {
      type: AttributeUpdateType.ROTATE_TO
    }, params2 = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(angle2, this.attribute, tempConstantAngleKey, context);
    return params2 ? (this._setAttributes(params2, false, context), this) : (attribute.angle = angle2, this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this);
  }
  skewTo(b, c3) {
    return this;
  }
  animate(params2) {
    this.animates || (this.animates = /* @__PURE__ */ new Map());
    const animate = new Animate(null == params2 ? void 0 : params2.id, this.stage && this.stage.getTimeline()).bind(this);
    if (params2) {
      const { onStart, onFrame, onEnd, onRemove } = params2;
      null != onStart && animate.onStart(onStart), null != onFrame && animate.onFrame(onFrame), null != onEnd && animate.onEnd(onEnd), null != onRemove && animate.onRemove(onRemove), animate.interpolateFunc = params2.interpolate;
    }
    return this.animates.set(animate.id, animate), animate.onRemove(() => {
      this.animates.delete(animate.id);
    }), animate;
  }
  onAttributeUpdate(context) {
    context && context.skipUpdateCallback || (application.graphicService.onAttributeUpdate(this), this._emitCustomEvent("afterAttributeUpdate", context));
  }
  update(d) {
    d ? (d.bounds && this.tryUpdateAABBBounds("imprecise" === this.attribute.boundsMode), d.trans && this.tryUpdateLocalTransMatrix()) : (this.tryUpdateAABBBounds("imprecise" === this.attribute.boundsMode), this.tryUpdateLocalTransMatrix());
  }
  hasState(stateName) {
    return !(!this.currentStates || !this.currentStates.length) && (!!isNil_default(stateName) || this.currentStates.includes(stateName));
  }
  getState(stateName) {
    var _a;
    return null === (_a = this.states) || void 0 === _a ? void 0 : _a[stateName];
  }
  applyStateAttrs(attrs, stateNames, hasAnimation, isClear) {
    var _a, _b, _c, _d;
    if (hasAnimation) {
      const keys2 = Object.keys(attrs), noWorkAttrs = this.getNoWorkAnimateAttr(), animateAttrs = {};
      let noAnimateAttrs;
      keys2.forEach((key) => {
        noWorkAttrs[key] ? (noAnimateAttrs || (noAnimateAttrs = {}), noAnimateAttrs[key] = attrs[key]) : animateAttrs[key] = isClear && void 0 === attrs[key] ? this.getDefaultAttribute(key) : attrs[key];
      });
      const animate = this.animate();
      animate.stateNames = stateNames, animate.to(animateAttrs, null !== (_b = null === (_a = this.stateAnimateConfig) || void 0 === _a ? void 0 : _a.duration) && void 0 !== _b ? _b : DefaultStateAnimateConfig.duration, null !== (_d = null === (_c = this.stateAnimateConfig) || void 0 === _c ? void 0 : _c.easing) && void 0 !== _d ? _d : DefaultStateAnimateConfig.easing), noAnimateAttrs && this.setAttributes(noAnimateAttrs, false, {
        type: AttributeUpdateType.STATE
      });
    } else
      this.setAttributes(attrs, false, {
        type: AttributeUpdateType.STATE
      });
  }
  updateNormalAttrs(stateAttrs) {
    const newNormalAttrs = {};
    this.normalAttrs ? (Object.keys(stateAttrs).forEach((key) => {
      key in this.normalAttrs ? (newNormalAttrs[key] = this.normalAttrs[key], delete this.normalAttrs[key]) : newNormalAttrs[key] = this.getNormalAttribute(key);
    }), Object.keys(this.normalAttrs).forEach((key) => {
      stateAttrs[key] = this.normalAttrs[key];
    })) : Object.keys(stateAttrs).forEach((key) => {
      newNormalAttrs[key] = this.getNormalAttribute(key);
    }), this.normalAttrs = newNormalAttrs;
  }
  stopStateAnimates(type = "end") {
    this.animates && this.animates.forEach((animate) => {
      animate.stateNames && (animate.stop(type), this.animates.delete(animate.id));
    });
  }
  getNormalAttribute(key) {
    let value = this.attribute[key];
    return this.animates && this.animates.forEach((animate) => {
      if (animate.stateNames) {
        const endProps = animate.getEndProps();
        has_default(endProps, key) && (value = endProps[key]);
      }
    }), value;
  }
  clearStates(hasAnimation) {
    this.stopStateAnimates(), this.hasState() && this.normalAttrs ? (this.currentStates = [], this.applyStateAttrs(this.normalAttrs, this.currentStates, hasAnimation, true)) : this.currentStates = [], this.normalAttrs = null;
  }
  removeState(stateName, hasAnimation) {
    if ((this.currentStates ? this.currentStates.indexOf(stateName) : -1) >= 0) {
      const currentStates = this.currentStates.filter((state) => state !== stateName);
      this.useStates(currentStates, hasAnimation);
    }
  }
  toggleState(stateName, hasAnimation) {
    if (this.hasState(stateName))
      this.removeState(stateName, hasAnimation);
    else {
      if ((this.currentStates ? this.currentStates.indexOf(stateName) : -1) < 0) {
        const nextStates = this.currentStates ? this.currentStates.slice() : [];
        nextStates.push(stateName), this.useStates(nextStates, hasAnimation);
      }
    }
  }
  addState(stateName, keepCurrentStates, hasAnimation) {
    var _a;
    if (this.currentStates && this.currentStates.includes(stateName) && (keepCurrentStates || 1 === this.currentStates.length))
      return;
    const newStates = keepCurrentStates && (null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.length) ? this.currentStates.concat([stateName]) : [stateName];
    this.useStates(newStates, hasAnimation);
  }
  useStates(states, hasAnimation) {
    var _a;
    if (!states.length)
      return void this.clearStates(hasAnimation);
    if (!((null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.length) !== states.length || states.some((stateName, index) => this.currentStates[index] !== stateName)))
      return;
    this.stopStateAnimates();
    const stateAttrs = {};
    states.forEach((stateName) => {
      var _a2;
      const attrs = this.stateProxy ? this.stateProxy(stateName, states) : null === (_a2 = this.states) || void 0 === _a2 ? void 0 : _a2[stateName];
      attrs && Object.assign(stateAttrs, attrs);
    }), this.updateNormalAttrs(stateAttrs), this.currentStates = states, this.applyStateAttrs(stateAttrs, states, hasAnimation);
  }
  addUpdateBoundTag() {
    this._updateTag |= UpdateTag.UPDATE_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag(), this.glyphHost && this.glyphHost.addUpdateBoundTag();
  }
  addUpdateShapeTag() {
    this._updateTag |= UpdateTag.UPDATE_SHAPE;
  }
  addUpdateShapeAndBoundsTag() {
    this._updateTag |= UpdateTag.UPDATE_SHAPE_AND_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag(), this.glyphHost && this.glyphHost.addUpdateBoundTag();
  }
  updateShapeAndBoundsTagSetted() {
    return (this._updateTag & UpdateTag.UPDATE_SHAPE_AND_BOUNDS) === UpdateTag.UPDATE_SHAPE_AND_BOUNDS;
  }
  clearUpdateBoundTag() {
    this._updateTag &= UpdateTag.CLEAR_BOUNDS;
  }
  addUpdatePositionTag() {
    this.shadowRoot && this.shadowRoot.addUpdateGlobalPositionTag(), this._updateTag |= UpdateTag.UPDATE_GLOBAL_LOCAL_MATRIX;
  }
  addUpdateGlobalPositionTag() {
    this.shadowRoot && this.shadowRoot.addUpdateGlobalPositionTag(), this._updateTag |= UpdateTag.UPDATE_GLOBAL_MATRIX;
  }
  clearUpdateLocalPositionTag() {
    this._updateTag &= UpdateTag.CLEAR_LOCAL_MATRIX;
  }
  clearUpdateGlobalPositionTag() {
    this._updateTag &= UpdateTag.CLEAR_GLOBAL_MATRIX;
  }
  addUpdateLayoutTag() {
    this._updateTag |= UpdateTag.UPDATE_LAYOUT;
  }
  clearUpdateLayoutTag() {
    this._updateTag &= UpdateTag.CLEAR_LAYOUT;
  }
  needUpdateLayout() {
    return !!(this._updateTag & UpdateTag.UPDATE_LAYOUT);
  }
  getAnchor(anchor, params2) {
    const _anchor = [0, 0], getBounds = () => {
      if (params2.b)
        return params2.b;
      const { scaleX, scaleY, angle: angle2 } = this.attribute;
      return tempBounds.copy(this._AABBBounds), this.setAttributes({
        scaleX: 1,
        scaleY: 1,
        angle: 0
      }), params2.b = this.AABBBounds.clone(), this._AABBBounds.copy(tempBounds), this.setAttributes({
        scaleX,
        scaleY,
        angle: angle2
      }), params2.b;
    };
    if ("string" == typeof anchor[0]) {
      const ratio = parseFloat(anchor[0]) / 100, bounds = getBounds();
      _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
    } else
      _anchor[0] = anchor[0];
    if ("string" == typeof anchor[1]) {
      const ratio = parseFloat(anchor[1]) / 100, bounds = getBounds();
      _anchor[1] = bounds.y1 + (bounds.y2 - bounds.y1) * ratio;
    } else
      _anchor[1] = anchor[1];
    return _anchor;
  }
  doUpdateLocalMatrix() {
    const { x = DefaultTransform.x, y = DefaultTransform.y, scaleX = DefaultTransform.scaleX, scaleY = DefaultTransform.scaleY, angle: angle2 = DefaultTransform.angle, scaleCenter, anchor, postMatrix } = this.attribute;
    let _anchor = [0, 0];
    const params2 = {};
    if (anchor && (_anchor = this.getAnchor(anchor, params2)), !scaleCenter || 1 === scaleX && 1 === scaleY)
      normalTransform(this._transMatrix, this._transMatrix.reset(), x, y, scaleX, scaleY, angle2, anchor && _anchor);
    else {
      const m4 = this._transMatrix;
      m4.reset(), m4.translate(_anchor[0], _anchor[1]), m4.rotate(angle2), m4.translate(-_anchor[0], -_anchor[1]), m4.translate(x, y), _anchor = this.getAnchor(scaleCenter, params2), application.transformUtil.fromMatrix(m4, m4).scale(scaleX, scaleY, {
        x: _anchor[0],
        y: _anchor[1]
      });
    }
    const p = this.getOffsetXY(DefaultTransform);
    if (this._transMatrix.e += p.x, this._transMatrix.f += p.y, postMatrix) {
      const m1 = tempMatrix.setValue(postMatrix.a, postMatrix.b, postMatrix.c, postMatrix.d, postMatrix.e, postMatrix.f), m22 = this._transMatrix;
      m1.multiply(m22.a, m22.b, m22.c, m22.d, m22.e, m22.f), m22.setValue(m1.a, m1.b, m1.c, m1.d, m1.e, m1.f);
    }
  }
  doUpdateGlobalMatrix() {
    if (this.parent) {
      this._globalTransMatrix.multiply(this.transMatrix.a, this.transMatrix.b, this.transMatrix.c, this.transMatrix.d, this.transMatrix.e, this.transMatrix.f);
      const { scrollX = 0, scrollY = 0 } = this.parent.attribute;
      this._globalTransMatrix.translate(scrollX, scrollY);
    }
  }
  setStage(stage, layer) {
    if (this.stage !== stage) {
      if (this.stage = stage, this.layer = layer, this.setStageToShadowRoot(stage, layer), this.animates && this.animates.size) {
        const timeline = stage.getTimeline();
        this.animates.forEach((a3) => {
          a3.setTimeline(timeline);
        });
      }
      this._onSetStage && this._onSetStage(this, stage, layer), application.graphicService.onSetStage(this, stage);
    }
  }
  setStageToShadowRoot(stage, layer) {
    this.shadowRoot && this.shadowRoot.setStage(stage, layer);
  }
  onAddStep(step) {
  }
  onStop(props) {
    props && this.setAttributes(props, false, {
      type: AttributeUpdateType.ANIMATE_END
    });
  }
  onStep(subAnimate, animate, step, ratio, end) {
    const nextAttributes = {};
    if (step.customAnimate)
      step.customAnimate.update(end, ratio, nextAttributes);
    else {
      const nextProps = step.props, nextParsedProps = step.parsedProps, propKeys = step.propKeys;
      this.stepInterpolate(subAnimate, animate, nextAttributes, step, ratio, end, nextProps, void 0, nextParsedProps, propKeys);
    }
    this.setAttributes(nextAttributes, false, {
      type: AttributeUpdateType.ANIMATE_UPDATE,
      animationState: {
        ratio,
        end,
        step,
        isFirstFrameOfStep: subAnimate.getLastStep() !== step
      }
    }), this.stage && this.stage.renderNextFrame();
  }
  stepInterpolate(subAnimate, animate, nextAttributes, step, ratio, end, nextProps, lastProps, nextParsedProps, propKeys) {
    propKeys || (propKeys = Object.keys(nextProps), step.propKeys = propKeys), end ? step.propKeys.forEach((key) => {
      animate.validAttr(key) && (nextAttributes[key] = nextProps[key]);
    }) : propKeys.forEach((key) => {
      var _a;
      if (!animate.validAttr(key))
        return;
      const nextStepVal = nextProps[key], lastStepVal = null !== (_a = lastProps && lastProps[key]) && void 0 !== _a ? _a : subAnimate.getLastPropByName(key, step);
      if (null == nextStepVal || null == lastStepVal)
        return void (nextAttributes[key] = nextStepVal);
      let match;
      match = animate.interpolateFunc && animate.interpolateFunc(key, ratio, lastStepVal, nextStepVal, nextAttributes), match || (match = animate.customInterpolate(key, ratio, lastStepVal, nextStepVal, this, nextAttributes), match || this.defaultInterpolate(nextStepVal, lastStepVal, key, nextAttributes, nextParsedProps, ratio) || this._interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes));
    }), step.parsedProps = nextParsedProps;
  }
  defaultInterpolate(nextStepVal, lastStepVal, key, nextAttributes, nextParsedProps, ratio) {
    if (Number.isFinite(nextStepVal))
      return nextAttributes[key] = lastStepVal + (nextStepVal - lastStepVal) * ratio, true;
    if ("fill" === key) {
      nextParsedProps || (nextParsedProps = {});
      const fillColorArray = nextParsedProps.fillColorArray, color = interpolateColor(lastStepVal, null != fillColorArray ? fillColorArray : nextStepVal, ratio, false, (fArray, tArray) => {
        nextParsedProps.fillColorArray = tArray;
      });
      return color && (nextAttributes[key] = color), true;
    }
    if ("stroke" === key) {
      nextParsedProps || (nextParsedProps = {});
      const strokeColorArray = nextParsedProps.strokeColorArray, color = interpolateColor(lastStepVal, null != strokeColorArray ? strokeColorArray : nextStepVal, ratio, false, (fArray, tArray) => {
        nextParsedProps.strokeColorArray = tArray;
      });
      return color && (nextAttributes[key] = color), true;
    }
    if ("shadowColor" === key) {
      nextParsedProps || (nextParsedProps = {});
      const shadowColorArray = nextParsedProps.shadowColorArray, color = interpolateColor(lastStepVal, null != shadowColorArray ? shadowColorArray : nextStepVal, ratio, true, (fArray, tArray) => {
        nextParsedProps.shadowColorArray = tArray;
      });
      return color && (nextAttributes[key] = color), true;
    }
    return false;
  }
  _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
  }
  getDefaultAttribute(name) {
    return getTheme(this)[this.type][name];
  }
  getComputedAttribute(name) {
    var _a;
    return null !== (_a = this.attribute[name]) && void 0 !== _a ? _a : this.getDefaultAttribute(name);
  }
  onSetStage(cb, immediate = false) {
    this._onSetStage = cb, immediate && this.stage && cb(this, this.stage);
  }
  attachShadow(shadowRoot) {
    return shadowRoot && (shadowRoot.shadowHost = this), this.shadowRoot = null != shadowRoot ? shadowRoot : application.graphicService.creator.shadowRoot(this), this.addUpdateBoundTag(), this.shadowRoot.setStage(this.stage, this.layer), this.shadowRoot;
  }
  detachShadow() {
    this.shadowRoot && (this.addUpdateBoundTag(), this.shadowRoot = null);
  }
  toJson() {
    return {
      attribute: this.attribute,
      _uid: this._uid,
      type: this.type,
      name: this.name,
      children: this.children.map((item) => item.toJson())
    };
  }
  createPathProxy(path) {
    return isString_default(path, true) ? this.pathProxy = new CustomPath2D().fromString(path) : this.pathProxy = new CustomPath2D(), this.pathProxy;
  }
  loadImage(image, background = false) {
    if (!image || background && backgroundNotImage(image))
      return;
    const url = image;
    this.resources || (this.resources = /* @__PURE__ */ new Map());
    const cache = {
      data: "init",
      state: null
    };
    this.resources.set(url, cache), "string" == typeof image ? (cache.state = "loading", image.startsWith("<svg") ? (ResourceLoader.GetSvg(image, this), this.backgroundImg = this.backgroundImg || background) : (isValidUrl_default(image) || image.includes("/") || isBase64_default(image)) && (ResourceLoader.GetImage(image, this), this.backgroundImg = this.backgroundImg || background)) : isObject_default(image) ? (cache.state = "success", cache.data = image, this.backgroundImg = this.backgroundImg || background) : cache.state = "fail";
  }
  setShadowGraphic(graphic) {
    if (graphic) {
      this.attachShadow().add(graphic);
    } else
      this.detachShadow();
  }
  imageLoadSuccess(url, image, cb) {
    if (!this.resources)
      return;
    const res = this.resources.get(url);
    res && (res.state = "success", res.data = image, cb && cb(), this.addUpdateBoundTag(), this.stage && this.stage.renderNextFrame());
  }
  imageLoadFail(url, cb) {
    if (!this.resources)
      return;
    const res = this.resources.get(url);
    res && (res.state = "fail", cb && cb());
  }
  _stopAnimates(animates) {
    animates && animates.forEach((animate) => {
      animate.stop();
    });
  }
  stopAnimates(stopChildren = false) {
    this._stopAnimates(this.animates), this.shadowRoot && this.shadowRoot.stopAnimates(true), this.isContainer && stopChildren && this.forEachChildren((c3) => {
      c3.stopAnimates(stopChildren);
    });
  }
  release() {
    this.releaseStatus = "released", application.graphicService.onRelease(this);
  }
  _emitCustomEvent(type, context) {
    var _a, _b;
    if (this._events && type in this._events) {
      const changeEvent = new CustomEvent(type, context);
      changeEvent.bubbles = false, changeEvent.manager = null === (_b = null === (_a = this.stage) || void 0 === _a ? void 0 : _a.eventSystem) || void 0 === _b ? void 0 : _b.manager, this.dispatchEvent(changeEvent);
    }
  }
};
function backgroundNotImage(image) {
  return !(!image.fill && !image.stroke);
}
Graphic.mixin(EventTarget);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/xml/utils
var nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
var nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
function getAllMatches(string, regex) {
  const matches = [];
  let match = regex.exec(string);
  for (; match; ) {
    const allmatches = [];
    allmatches.startIndex = regex.lastIndex - match[0].length;
    const len = match.length;
    for (let index = 0; index < len; index++)
      allmatches.push(match[index]);
    matches.push(allmatches), match = regex.exec(string);
  }
  return matches;
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/xml/OrderedObjParser
var XmlNode = class {
  constructor(tagname) {
    this.tagname = tagname, this.child = [], this[":@"] = {};
  }
  add(key, val) {
    "__proto__" === key && (key = "#__proto__"), this.child.push({
      [key]: val
    });
  }
  addChild(node) {
    "__proto__" === node.tagname && (node.tagname = "#__proto__"), node[":@"] && Object.keys(node[":@"]).length > 0 ? this.child.push({
      [node.tagname]: node.child,
      ":@": node[":@"]
    }) : this.child.push({
      [node.tagname]: node.child
    });
  }
};
function findClosingIndex(xmlData, str, i, errMsg) {
  const closingIndex = xmlData.indexOf(str, i);
  if (-1 === closingIndex)
    throw new Error(errMsg);
  return closingIndex + str.length - 1;
}
function tagExpWithClosingIndex(xmlData, i, closingChar = ">") {
  let attrBoundary, tagExp = "";
  for (let index = i; index < xmlData.length; index++) {
    let ch = xmlData[index];
    if (attrBoundary)
      ch === attrBoundary && (attrBoundary = "");
    else if ('"' === ch || "'" === ch)
      attrBoundary = ch;
    else if (ch === closingChar[0]) {
      if (!closingChar[1])
        return {
          data: tagExp,
          index
        };
      if (xmlData[index + 1] === closingChar[1])
        return {
          data: tagExp,
          index
        };
    } else
      "	" === ch && (ch = " ");
    tagExp += ch;
  }
}
function readTagExp(xmlData, i, removeNSPrefix, closingChar = ">") {
  const result2 = tagExpWithClosingIndex(xmlData, i + 1, closingChar);
  if (!result2)
    return;
  let tagExp = result2.data;
  const closeIndex = result2.index, separatorIndex = tagExp.search(/\s/);
  let tagName = tagExp, attrExpPresent = true;
  -1 !== separatorIndex && (tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, ""), tagExp = tagExp.substr(separatorIndex + 1));
  const rawTagName = tagName;
  if (removeNSPrefix) {
    const colonIndex = tagName.indexOf(":");
    -1 !== colonIndex && (tagName = tagName.substr(colonIndex + 1), attrExpPresent = tagName !== result2.data.substr(colonIndex + 1));
  }
  return {
    tagName,
    tagExp,
    closeIndex,
    attrExpPresent,
    rawTagName
  };
}
var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
var OrderedObjParser = class {
  constructor(options) {
    this.currentNode = null, this.options = options, this.tagsNodeStack = [], this.docTypeEntities = {};
  }
  addChild(currentNode, childNode, jPath) {
    const result2 = childNode.tagname;
    "string" == typeof result2 ? (childNode.tagname = result2, currentNode.addChild(childNode)) : currentNode.addChild(childNode);
  }
  buildAttributesMap(attrStr, jPath, tagName) {
    const attrs = {};
    if (!attrStr)
      return;
    const matches = getAllMatches(attrStr, attrsRegx), len = matches.length;
    for (let i = 0; i < len; i++) {
      const attrName = matches[i][1], oldVal = matches[i][4], aName = attrName;
      attrName && (attrs[aName] = void 0 === oldVal || (isNaN(oldVal) ? oldVal : Number(oldVal)));
    }
    return attrs;
  }
  parseXml(xmlData) {
    xmlData = xmlData.replace(/\r\n?/g, "\n");
    const xmlObj = new XmlNode("!xml");
    let currentNode = xmlObj, textData = "", jPath = "";
    for (let i = 0; i < xmlData.length; i++) {
      if ("<" === xmlData[i])
        if ("/" === xmlData[i + 1]) {
          const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed."), propIndex = jPath.lastIndexOf(".");
          jPath = jPath.substring(0, propIndex), currentNode = this.tagsNodeStack.pop(), currentNode && currentNode.child && textData && currentNode.child[currentNode.child.length - 1][":@"] && (currentNode.child[currentNode.child.length - 1][":@"].text = textData), textData = "", i = closeIndex;
        } else if ("?" === xmlData[i + 1]) {
          i = readTagExp(xmlData, i, false, "?>").closeIndex + 1;
        } else if ("!--" === xmlData.substr(i + 1, 3)) {
          i = findClosingIndex(xmlData, "-->", i + 4, "Comment is not closed.");
        } else {
          const result2 = readTagExp(xmlData, i, false);
          let tagName = result2.tagName, tagExp = result2.tagExp;
          const attrExpPresent = result2.attrExpPresent, closeIndex = result2.closeIndex;
          if (tagName !== xmlObj.tagname && (jPath += jPath ? "." + tagName : tagName), tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
            "/" === tagName[tagName.length - 1] ? (tagName = tagName.substr(0, tagName.length - 1), jPath = jPath.substr(0, jPath.length - 1), tagExp = tagName) : tagExp = tagExp.substr(0, tagExp.length - 1);
            const childNode = new XmlNode(tagName);
            tagName !== tagExp && attrExpPresent && (childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName)), this.addChild(currentNode, childNode, jPath), jPath = jPath.substr(0, jPath.lastIndexOf("."));
          } else {
            const childNode = new XmlNode(tagName);
            this.tagsNodeStack.push(currentNode), tagName !== tagExp && attrExpPresent && (childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName)), this.addChild(currentNode, childNode, jPath), currentNode = childNode;
          }
          textData = "", i = closeIndex;
        }
      else
        textData += xmlData[i];
    }
    return xmlObj.child;
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/xml/node2json
function prettify(node, options) {
  return compress(node);
}
function compress(arr, jPath) {
  const compressedObj = {};
  for (let i = 0; i < arr.length; i++) {
    const tagObj = arr[i], property = propName(tagObj);
    let newJpath = "";
    if (newJpath = void 0 === jPath ? property : jPath + "." + property, void 0 !== property && tagObj[property]) {
      const val = compress(tagObj[property], newJpath);
      isLeafTag(val);
      tagObj[":@"] && assignAttributes(val, tagObj[":@"], newJpath), void 0 !== compressedObj[property] && compressedObj.hasOwnProperty(property) ? (Array.isArray(compressedObj[property]) || (compressedObj[property] = [compressedObj[property]]), compressedObj[property].push(val)) : compressedObj[property] = val;
    }
  }
  return compressedObj;
}
function propName(obj) {
  const keys2 = Object.keys(obj);
  for (let i = 0; i < keys2.length; i++) {
    const key = keys2[i];
    if (":@" !== key)
      return key;
  }
}
function assignAttributes(obj, attrMap, jpath) {
  if (attrMap) {
    const keys2 = Object.keys(attrMap), len = keys2.length;
    for (let i = 0; i < len; i++) {
      const atrrName = keys2[i];
      obj[atrrName] = attrMap[atrrName];
    }
  }
}
function isLeafTag(obj) {
  return 0 === Object.keys(obj).length;
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/xml/parser
var XMLParser = class _XMLParser {
  constructor(options) {
    this.options = Object.assign({}, _XMLParser.defaultOptions, options);
  }
  valid(xml) {
    return xml.startsWith("<");
  }
  parse(xmlData) {
    if (!this.valid)
      return false;
    const orderedResult = new OrderedObjParser(this.options).parseXml(xmlData);
    return prettify(orderedResult, this.options);
  }
};
XMLParser.defaultOptions = {};
function isSvg(str) {
  return str.startsWith("<svg") || str.startsWith("<?xml");
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/tools
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function waitForAllSubLayers(stage) {
  return __awaiter2(this, void 0, void 0, function* () {
    const promiseList = [], layers = stage.getChildren();
    yield new Promise((resolve) => {
      application.global.getRequestAnimationFrame()(() => {
        resolve(null);
      });
    }), layers.forEach((l) => {
      l.subLayers.size && l.subLayers.forEach((sl) => {
        sl.drawContribution && sl.drawContribution.hooks && sl.drawContribution.rendering && promiseList.push(new Promise((resolve) => {
          sl.drawContribution.hooks.completeDraw.tap("outWait", () => {
            sl.drawContribution.hooks.completeDraw.taps = sl.drawContribution.hooks.completeDraw.taps.filter((i) => "outWait" !== i.name), resolve(null);
          });
        }));
      });
    }), yield Promise.all(promiseList);
  });
}
function boundStroke(bounds, halfW, miter, pad2 = 0) {
  return bounds.expand(halfW + (pad2 / 2 + (miter ? miterAdjustment(miter, halfW) : 0))), bounds;
}
function miterAdjustment(miter, strokeWidth) {
  return miter ? strokeWidth : 0;
}
var NUMBER_TYPE = 0;
function genNumberType() {
  return NUMBER_TYPE++;
}
var TextDirection;
!function(TextDirection2) {
  TextDirection2[TextDirection2.HORIZONTAL = 0] = "HORIZONTAL", TextDirection2[TextDirection2.VERTICAL = 1] = "VERTICAL";
}(TextDirection || (TextDirection = {}));
function verticalLayout(text2) {
  const nextCharacter = [];
  let flag = 0, currStr = "";
  for (let i = 0; i < text2.length; i++)
    rotateText(text2[i]) ? flag ? currStr += text2[i] : (flag = 1, currStr = text2[i]) : (flag && (nextCharacter.push({
      text: currStr,
      direction: TextDirection.VERTICAL
    }), currStr = "", flag = 0), nextCharacter.push({
      text: text2[i],
      direction: TextDirection.HORIZONTAL
    }));
  return currStr && nextCharacter.push({
    text: currStr,
    direction: TextDirection.VERTICAL
  }), nextCharacter;
}
var rotateCharList = ["\u2026", "\uFF08", "\uFF09", "\u2014", "\u3010", "\u3011", "\u300C", "\u300D", "\u300A", "\u300B"];
var rotateCharMap = /* @__PURE__ */ new Map();
rotateCharList.forEach((c3) => rotateCharMap.set(c3, true));
var noRotateCharList = [""];
var noRotateCharMap = /* @__PURE__ */ new Map();
function rotateText(c3) {
  if (rotateCharMap.has(c3))
    return true;
  if (noRotateCharMap.has(c3))
    return false;
  let rotate3 = false;
  return c3.codePointAt(0) < 256 && (rotate3 = true), rotate3;
}
noRotateCharList.forEach((c3) => noRotateCharMap.set(c3, true));

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/constants
var ARC_NUMBER_TYPE = genNumberType();
var ARC3D_NUMBER_TYPE = genNumberType();
var AREA_NUMBER_TYPE = genNumberType();
var CIRCLE_NUMBER_TYPE = genNumberType();
var GLYPH_NUMBER_TYPE = genNumberType();
var GROUP_NUMBER_TYPE = genNumberType();
var IMAGE_NUMBER_TYPE = genNumberType();
var LINE_NUMBER_TYPE = genNumberType();
var PATH_NUMBER_TYPE = genNumberType();
var POLYGON_NUMBER_TYPE = genNumberType();
var PYRAMID3D_NUMBER_TYPE = genNumberType();
var RECT_NUMBER_TYPE = genNumberType();
var RECT3D_NUMBER_TYPE = genNumberType();
var RICHTEXT_NUMBER_TYPE = genNumberType();
var SYMBOL_NUMBER_TYPE = genNumberType();
var TEXT_NUMBER_TYPE = genNumberType();
var GraphicService = Symbol.for("GraphicService");
var GraphicCreator = Symbol.for("GraphicCreator");
var SVG_ATTRIBUTE_MAP = {
  "stroke-linecap": "lineCap",
  "stroke-linejoin": "lineJoin",
  "stroke-dasharray": "lineDash",
  "stroke-dashoffset": "lineDashOffset",
  "stroke-width": "lineWidth",
  "fill-opacity": "fillOpacity",
  "stroke-opacity": "strokeOpacity"
};
var SVG_ATTRIBUTE_MAP_KEYS = Object.keys(SVG_ATTRIBUTE_MAP);
var SVG_PARSE_ATTRIBUTE_MAP = {
  "stroke-linecap": "lineCap",
  "stroke-linejoin": "lineJoin",
  "stroke-dasharray": "lineDash",
  "stroke-dashoffset": "lineDashOffset",
  "stroke-width": "lineWidth",
  "fill-opacity": "fillOpacity",
  "stroke-opacity": "strokeOpacity",
  stroke: "stroke",
  fill: "fill"
};
var SVG_PARSE_ATTRIBUTE_MAP_KEYS = Object.keys(SVG_PARSE_ATTRIBUTE_MAP);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/group
var GroupUpdateAABBBoundsMode;
!function(GroupUpdateAABBBoundsMode2) {
  GroupUpdateAABBBoundsMode2[GroupUpdateAABBBoundsMode2.LESS_GROUP = 0] = "LESS_GROUP", GroupUpdateAABBBoundsMode2[GroupUpdateAABBBoundsMode2.MORE_GROUP = 1] = "MORE_GROUP";
}(GroupUpdateAABBBoundsMode || (GroupUpdateAABBBoundsMode = {}));
var Group = class _Group extends Graphic {
  constructor(params2) {
    super(params2), this.type = "group", this.parent = null, this.isContainer = true, this.numberType = GROUP_NUMBER_TYPE, this._childUpdateTag = UpdateTag.UPDATE_BOUNDS;
  }
  setMode(mode) {
    "3d" === mode ? this.set3dMode() : this.set2dMode();
  }
  set3dMode() {
    this.in3dMode = true;
  }
  set2dMode() {
    this.in3dMode = false;
  }
  setTheme(t) {
    return this.theme || (this.theme = new Theme()), this.theme.setTheme(t, this);
  }
  createTheme() {
    this.theme || (this.theme = new Theme());
  }
  hideAll() {
    this.setAttribute("visible", false), this.forEachChildren((item) => {
      item.isContainer && item.hideAll ? item.hideAll() : item.setAttribute("visible", false);
    });
  }
  showAll() {
    this.setAttribute("visible", true), this.forEachChildren((item) => {
      item.isContainer && item.showAll ? item.showAll() : item.setAttribute("visible", true);
    });
  }
  containsPoint(x, y, mode) {
    if (mode === IContainPointMode.GLOBAL) {
      const point5 = new Point(x, y);
      return this.parent && this.parent.globalTransMatrix.transformPoint(point5, point5), this.AABBBounds.contains(point5.x, point5.y);
    }
    return this.AABBBounds.contains(x, y);
  }
  shouldUpdateAABBBounds() {
    return !!super.shouldUpdateAABBBounds() || !!(this._childUpdateTag & UpdateTag.UPDATE_BOUNDS);
  }
  tryUpdateAABBBounds() {
    if (!this.shouldUpdateAABBBounds())
      return this._AABBBounds;
    application.graphicService.beforeUpdateAABBBounds(this, this.stage, true, this._AABBBounds);
    const selfChange = this.shouldSelfChangeUpdateAABBBounds(), bounds = this.doUpdateAABBBounds();
    return this.addUpdateLayoutTag(), application.graphicService.afterUpdateAABBBounds(this, this.stage, this._AABBBounds, this, selfChange), bounds;
  }
  doUpdateLocalMatrix() {
    const { x = DefaultTransform.x, y = DefaultTransform.y, dx = DefaultTransform.dx, dy = DefaultTransform.dy, scaleX = DefaultTransform.scaleX, scaleY = DefaultTransform.scaleY, angle: angle2 = DefaultTransform.angle, postMatrix } = this.attribute;
    if (0 !== x || 0 !== y || 0 !== dx || 0 !== dy || 1 !== scaleX || 1 !== scaleY || 0 !== angle2 || postMatrix)
      return super.doUpdateLocalMatrix();
    this._transMatrix.reset();
  }
  doUpdateAABBBounds() {
    const attribute = this.attribute, groupTheme = getTheme(this).group;
    this._AABBBounds.clear();
    const bounds = application.graphicService.updateGroupAABBBounds(attribute, groupTheme, this._AABBBounds, this), { boundsPadding = groupTheme.boundsPadding } = attribute, paddingArray = parsePadding(boundsPadding);
    return paddingArray && bounds.expand(paddingArray), this.parent && this.parent.addChildUpdateBoundTag(), this.clearUpdateBoundTag(), this._emitCustomEvent("AAABBBoundsChange"), bounds;
  }
  clearUpdateBoundTag() {
    this._updateTag &= UpdateTag.CLEAR_BOUNDS, this._childUpdateTag &= UpdateTag.CLEAR_BOUNDS;
  }
  tryUpdateOBBBounds() {
    throw new Error("\u6682\u4E0D\u652F\u6301");
  }
  addUpdateBoundTag() {
    this._updateTag |= UpdateTag.UPDATE_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag();
  }
  addChildUpdateBoundTag() {
    this._childUpdateTag & UpdateTag.UPDATE_BOUNDS || (this._childUpdateTag |= UpdateTag.UPDATE_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag());
  }
  getTheme() {
    return this.theme.getTheme(this);
  }
  incrementalAppendChild(node) {
    const data = super.appendChild(node);
    return this.stage && data && (data.stage = this.stage, data.layer = this.layer), this.addUpdateBoundTag(), application.graphicService.onAddIncremental(node, this, this.stage), data;
  }
  incrementalClearChild() {
    super.removeAllChild(), this.addUpdateBoundTag(), application.graphicService.onClearIncremental(this, this.stage);
  }
  appendChild(node, addStage = true) {
    const data = super.appendChild(node);
    return addStage && this.stage && data && data.setStage(this.stage, this.layer), this.addUpdateBoundTag(), data;
  }
  insertBefore(newNode, referenceNode) {
    const data = super.insertBefore(newNode, referenceNode);
    return this.stage && data && data.setStage(this.stage, this.layer), this.addUpdateBoundTag(), data;
  }
  insertAfter(newNode, referenceNode) {
    const data = super.insertAfter(newNode, referenceNode);
    return this.stage && data && data.setStage(this.stage, this.layer), this.addUpdateBoundTag(), data;
  }
  insertInto(newNode, idx) {
    const data = super.insertInto(newNode, idx);
    return this.stage && data && data.setStage(this.stage, this.layer), this.addUpdateBoundTag(), data;
  }
  removeChild(child) {
    const data = super.removeChild(child);
    return child.stage = null, application.graphicService.onRemove(child), this.addUpdateBoundTag(), data;
  }
  removeAllChild(deep = false) {
    this.forEachChildren((child) => {
      application.graphicService.onRemove(child), deep && child.isContainer && child.removeAllChild(deep);
    }), super.removeAllChild(), this.addUpdateBoundTag();
  }
  setStage(stage, layer) {
    this.stage !== stage && (this.stage = stage, this.layer = layer, this.setStageToShadowRoot(stage, layer), this._onSetStage && this._onSetStage(this, stage, layer), application.graphicService.onSetStage(this, stage), this.forEachChildren((item) => {
      item.setStage(stage, this.layer);
    }));
  }
  addUpdatePositionTag() {
    super.addUpdatePositionTag(), this.forEachChildren((g) => {
      g.isContainer && g.addUpdateGlobalPositionTag();
    });
  }
  addUpdateGlobalPositionTag() {
    super.addUpdateGlobalPositionTag(), this.forEachChildren((g) => {
      g.isContainer && g.addUpdateGlobalPositionTag();
    });
  }
  tryUpdateGlobalTransMatrix(clearTag = true) {
    if (this.shouldUpdateGlobalMatrix()) {
      if (this._globalTransMatrix) {
        if (this.parent) {
          const m4 = this.parent.globalTransMatrix;
          this._globalTransMatrix.setValue(m4.a, m4.b, m4.c, m4.d, m4.e, m4.f);
        }
      } else
        this._globalTransMatrix = this.parent ? this.parent.globalTransMatrix.clone() : this.transMatrix.clone();
      this.doUpdateGlobalMatrix(), clearTag && this.clearUpdateGlobalPositionTag();
    }
    return this._globalTransMatrix;
  }
  shouldUpdateGlobalMatrix() {
    return !!(this._updateTag & UpdateTag.UPDATE_GLOBAL_MATRIX);
  }
  _getChildByName(name, deep) {
    return this.find((node) => node.name === name, deep);
  }
  createOrUpdateChild(graphicName, attributes, graphicType) {
    let graphic = this._getChildByName(graphicName);
    return graphic ? graphic.setAttributes(attributes) : (graphic = application.graphicService.creator[graphicType](attributes), graphic.name = graphicName, this.add(graphic)), graphic;
  }
  clone() {
    return new _Group(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Group.NOWORK_ANIMATE_ATTR;
  }
};
Group.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createGroup(attributes) {
  return new Group(attributes);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/core/layer
var Layer = class extends Group {
  get offscreen() {
    return this.layerHandler.offscreen;
  }
  get layerMode() {
    return this.layerHandler.type;
  }
  get width() {
    return this.stage ? this.stage.width : 0;
  }
  get height() {
    return this.stage ? this.stage.height : 0;
  }
  get viewWidth() {
    return this.stage ? this.stage.viewWidth : 0;
  }
  get viewHeight() {
    return this.stage ? this.stage.viewHeight : 0;
  }
  get dirtyBound() {
    throw new Error("\u6682\u4E0D\u652F\u6301");
  }
  get dpr() {
    return this._dpr;
  }
  constructor(stage, global, window2, params2) {
    var _a;
    super({}), this.stage = stage, this.global = global, this.window = window2, this.main = params2.main, this.layerHandler = params2.layerHandler, this.layerHandler.init(this, window2, {
      main: params2.main,
      canvasId: params2.canvasId,
      width: this.viewWidth,
      height: this.viewHeight,
      zIndex: null !== (_a = params2.zIndex) && void 0 !== _a ? _a : 0
    }), this.layer = this, this.subLayers = /* @__PURE__ */ new Map(), this.theme = new Theme(), this.background = "rgba(0, 0, 0, 0)", this.afterDrawCbs = [];
  }
  combineSubLayer(removeIncrementalKey = true) {
    const subLayers = Array.from(this.subLayers.values()).sort((a3, b) => a3.zIndex - b.zIndex);
    this.layerHandler.merge(subLayers.map((l) => (l.layer.subLayers.size && l.layer.combineSubLayer(removeIncrementalKey), l.layer.getNativeHandler()))), removeIncrementalKey && subLayers.forEach((l) => {
      l.group && (l.group.incremental = 0);
    }), subLayers.forEach((l) => {
      application.layerService.releaseLayer(this.stage, l.layer);
    }), this.subLayers.clear();
  }
  getNativeHandler() {
    return this.layerHandler;
  }
  setStage(stage, layer) {
    super.setStage(stage, this);
  }
  pick(x, y) {
    throw new Error("\u6682\u4E0D\u652F\u6301");
  }
  tryRenderSecondaryLayer(params2, userParams) {
    this.layerHandler.secondaryHandlers && this.layerHandler.secondaryHandlers.length && this.layerHandler.secondaryHandlers.forEach((h) => {
      h.layer.renderCount = this.renderCount, h.layer.render(params2, userParams);
    });
  }
  render(params2, userParams) {
    var _a;
    this.layerHandler.render([this], {
      renderService: params2.renderService,
      stage: this.stage,
      layer: this,
      viewBox: params2.viewBox,
      transMatrix: params2.transMatrix,
      background: null !== (_a = params2.background) && void 0 !== _a ? _a : this.background,
      updateBounds: params2.updateBounds
    }, userParams), this.afterDrawCbs.forEach((c3) => c3(this)), this.tryRenderSecondaryLayer(params2, userParams);
  }
  resize(w, h) {
    this.layerHandler.resize(w, h);
  }
  resizeView(w, h) {
    this.layerHandler.resizeView(w, h);
  }
  setDpr(dpr) {
    this.layerHandler.setDpr(dpr);
  }
  afterDraw(cb) {
    this.afterDrawCbs.push(cb);
  }
  startAnimate(t) {
    throw new Error("\u6682\u4E0D\u652F\u6301");
  }
  setToFrame(t) {
    throw new Error("\u6682\u4E0D\u652F\u6301");
  }
  prepare(dirtyBounds, params2) {
  }
  release() {
    super.release(), this.layerHandler.release(), this.subLayers && this.subLayers.forEach((l) => {
      application.layerService.releaseLayer(this.stage, l.layer);
    });
  }
  drawTo(target, params2) {
    var _a;
    this.layerHandler.drawTo(target, [this], Object.assign({
      background: null !== (_a = params2.background) && void 0 !== _a ? _a : this.background,
      renderService: params2.renderService,
      viewBox: params2.viewBox,
      transMatrix: params2.transMatrix,
      stage: this.stage,
      layer: this
    }, params2)), this.afterDrawCbs.forEach((c3) => c3(this));
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/core/constants
var TransformUtil = Symbol.for("TransformUtil");
var GraphicUtil = Symbol.for("GraphicUtil");
var LayerService = Symbol.for("LayerService");
var StaticLayerHandlerContribution = Symbol.for("StaticLayerHandlerContribution");
var DynamicLayerHandlerContribution = Symbol.for("DynamicLayerHandlerContribution");
var VirtualLayerHandlerContribution = Symbol.for("VirtualLayerHandlerContribution");

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/core/layer-service
var DefaultLayerService_1;
var __decorate6 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata4 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var DefaultLayerService = DefaultLayerService_1 = class {
  static GenerateLayerId() {
    return `${DefaultLayerService_1.idprefix}_${DefaultLayerService_1.prefix_count++}`;
  }
  constructor() {
    this.layerMap = /* @__PURE__ */ new Map(), this.global = application.global;
  }
  tryInit() {
    this.inited || (this.staticLayerCountInEnv = this.global.getStaticCanvasCount(), this.dynamicLayerCountInEnv = this.global.getDynamicCanvasCount(), this.inited = true);
  }
  getStageLayer(stage) {
    return this.layerMap.get(stage);
  }
  getRecommendedLayerType(layerMode) {
    return layerMode || (0 !== this.staticLayerCountInEnv ? "static" : 0 !== this.dynamicLayerCountInEnv ? "dynamic" : "virtual");
  }
  getLayerHandler(layerMode) {
    let layerHandler;
    return layerHandler = "static" === layerMode ? container.get(StaticLayerHandlerContribution) : "dynamic" === layerMode ? container.get(DynamicLayerHandlerContribution) : container.get(VirtualLayerHandlerContribution), layerHandler;
  }
  createLayer(stage, options = {
    main: false
  }) {
    var _a;
    this.tryInit();
    let layerMode = this.getRecommendedLayerType(options.layerMode);
    layerMode = options.main || options.canvasId ? "static" : layerMode;
    const layerHandler = this.getLayerHandler(layerMode), layer = new Layer(stage, this.global, stage.window, Object.assign(Object.assign({
      main: false
    }, options), {
      layerMode,
      canvasId: null !== (_a = options.canvasId) && void 0 !== _a ? _a : DefaultLayerService_1.GenerateLayerId(),
      layerHandler
    })), stageLayers = this.layerMap.get(stage) || [];
    return stageLayers.push(layer), this.layerMap.set(stage, stageLayers), this.staticLayerCountInEnv--, layer;
  }
  prepareStageLayer(stage) {
    let mainHandler;
    stage.forEachChildren((l) => {
      const handler = l.getNativeHandler();
      "virtual" === handler.type ? (handler.mainHandler = mainHandler, mainHandler.secondaryHandlers.push(handler)) : (mainHandler = handler, mainHandler.secondaryHandlers = []);
    });
  }
  releaseLayer(stage, layer) {
    layer.release();
    const stageLayers = this.layerMap.get(stage) || [];
    this.layerMap.set(stage, stageLayers.filter((l) => l !== layer));
  }
  layerCount(stage) {
    return (this.layerMap.get(stage) || []).length;
  }
  restLayerCount(stage) {
    return "browser" === this.global.env ? 10 : 0;
  }
  releaseStage(stage) {
    this.layerMap.delete(stage);
  }
};
DefaultLayerService.idprefix = "visactor_layer", DefaultLayerService.prefix_count = 0, DefaultLayerService = DefaultLayerService_1 = __decorate6([injectable(), __metadata4("design:paramtypes", [])], DefaultLayerService);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/core/core-modules
var core_modules_default = new ContainerModule((bind) => {
  bind(VGlobal).to(DefaultGlobal).inSingletonScope(), bind(VWindow).to(DefaultWindow), bind(GraphicUtil).to(DefaultGraphicUtil).inSingletonScope(), bind(TransformUtil).to(DefaultTransformUtil).inSingletonScope(), bind(LayerService).to(DefaultLayerService).inSingletonScope();
});

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/utils
function runFill(fill, background) {
  return !(!fill && !background);
}
function runStroke(stroke2, lineWidth) {
  let s2;
  return s2 = isArray_default(stroke2) ? stroke2.some((item) => item || void 0 === item) : !!stroke2, s2 && lineWidth > 0;
}
function fillVisible(opacity, fillOpacity, fill) {
  return fill && opacity * fillOpacity > 0;
}
function rectFillVisible(opacity, fillOpacity, width, height, fill) {
  return fill && opacity * fillOpacity > 0 && 0 !== width && 0 !== height;
}
function strokeVisible(opacity, strokeOpacity) {
  return opacity * strokeOpacity > 0;
}
function rectStrokeVisible(opacity, strokeOpacity, width, height) {
  return opacity * strokeOpacity > 0 && 0 !== width && 0 !== height;
}
function drawPathProxy(graphic, context, x, y, drawContext, params2, fillCb, strokeCb) {
  if (!graphic.pathProxy)
    return false;
  const themeAttributes = getTheme(graphic, null == params2 ? void 0 : params2.theme)[graphic.type.replace("3d", "")], { fill = themeAttributes.fill, stroke: stroke2 = themeAttributes.stroke, opacity = themeAttributes.opacity, fillOpacity = themeAttributes.fillOpacity, lineWidth = themeAttributes.lineWidth, strokeOpacity = themeAttributes.strokeOpacity, visible = themeAttributes.visible, x: originX = themeAttributes.x, y: originY = themeAttributes.y } = graphic.attribute, fVisible = fillVisible(opacity, fillOpacity, fill), sVisible = strokeVisible(opacity, strokeOpacity), doFill = runFill(fill), doStroke = runStroke(stroke2, lineWidth);
  if (!visible)
    return true;
  if (!doFill && !doStroke)
    return true;
  if (!(fVisible || sVisible || fillCb || strokeCb))
    return true;
  context.beginPath();
  const path = "function" == typeof graphic.pathProxy ? graphic.pathProxy(graphic.attribute) : graphic.pathProxy;
  return renderCommandList(path.commandList, context, x, y), context.setShadowBlendStyle && context.setShadowBlendStyle(graphic, graphic.attribute, themeAttributes), doStroke && (strokeCb ? strokeCb(context, graphic.attribute, themeAttributes) : sVisible && (context.setStrokeStyle(graphic, graphic.attribute, x - originX, y - originY, themeAttributes), context.stroke())), doFill && (fillCb ? fillCb(context, graphic.attribute, themeAttributes) : fVisible && (context.setCommonStyle(graphic, graphic.attribute, x - originX, y - originY, themeAttributes), context.fill())), true;
}
function intersect(x05, y05, x14, y14, x23, y23, x3, y3) {
  const x10 = x14 - x05, y10 = y14 - y05, x32 = x3 - x23, y32 = y3 - y23;
  let t = y32 * x10 - x32 * y10;
  return t * t < epsilon ? [] : (t = (x32 * (y05 - y23) - y32 * (x05 - x23)) / t, [x05 + t * x10, y05 + t * y10]);
}
function cornerTangents(x05, y05, x14, y14, r1, rc, clockwise) {
  const x01 = x05 - x14, y01 = y05 - y14, lo = (clockwise ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x112 = x05 + ox, y112 = y05 + oy, x10 = x14 + ox, y10 = y14 + oy, x004 = (x112 + x10) / 2, y004 = (y112 + y10) / 2, dx = x10 - x112, dy = y10 - y112, d2 = dx * dx + dy * dy, r = r1 - rc, D = x112 * y10 - x10 * y112, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D));
  let cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2;
  const cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x004, dy0 = cy0 - y004, dx1 = cx1 - x004, dy1 = cy1 - y004;
  return dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1 && (cx0 = cx1, cy0 = cy1), {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}
function drawArcPath(arc, context, cx, cy, outerRadius, innerRadius, partStroke) {
  const { startAngle, endAngle } = arc.getParsedAngle(), deltaAngle = abs(endAngle - startAngle), clockwise = endAngle > startAngle;
  let collapsedToLine = false;
  if (outerRadius < innerRadius) {
    const temp3 = outerRadius;
    outerRadius = innerRadius, innerRadius = temp3;
  }
  if (outerRadius <= epsilon)
    context.moveTo(cx, cy);
  else if (deltaAngle >= pi2 - epsilon)
    context.moveTo(cx + outerRadius * cos(startAngle), cy + outerRadius * sin(startAngle)), context.arc(cx, cy, outerRadius, startAngle, endAngle, !clockwise), innerRadius > epsilon && (context.moveTo(cx + innerRadius * cos(endAngle), cy + innerRadius * sin(endAngle)), context.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise));
  else {
    const cornerRadius = arc.getParsedCornerRadius(), { outerDeltaAngle, innerDeltaAngle, outerStartAngle, outerEndAngle, innerEndAngle, innerStartAngle } = arc.getParsePadAngle(startAngle, endAngle), outerCornerRadiusStart = cornerRadius, outerCornerRadiusEnd = cornerRadius, innerCornerRadiusEnd = cornerRadius, innerCornerRadiusStart = cornerRadius, maxOuterCornerRadius = Math.max(outerCornerRadiusEnd, outerCornerRadiusStart), maxInnerCornerRadius = Math.max(innerCornerRadiusEnd, innerCornerRadiusStart);
    let limitedOcr = maxOuterCornerRadius, limitedIcr = maxInnerCornerRadius;
    const xors = outerRadius * cos(outerStartAngle), yors = outerRadius * sin(outerStartAngle), xire = innerRadius * cos(innerEndAngle), yire = innerRadius * sin(innerEndAngle);
    let xore, yore, xirs, yirs;
    if ((maxInnerCornerRadius > epsilon || maxOuterCornerRadius > epsilon) && (xore = outerRadius * cos(outerEndAngle), yore = outerRadius * sin(outerEndAngle), xirs = innerRadius * cos(innerStartAngle), yirs = innerRadius * sin(innerStartAngle), deltaAngle < pi)) {
      const oc = intersect(xors, yors, xirs, yirs, xore, yore, xire, yire);
      if (oc) {
        const ax = xors - oc[0], ay = yors - oc[1], bx = xore - oc[0], by = yore - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
        limitedIcr = min(maxInnerCornerRadius, (innerRadius - lc) / (kc - 1)), limitedOcr = min(maxOuterCornerRadius, (outerRadius - lc) / (kc + 1));
      }
    }
    if (outerDeltaAngle < 1e-3)
      partStroke && (partStroke[3] || partStroke[1]) && context.moveTo(cx + xors, cy + yors), collapsedToLine = true;
    else if (limitedOcr > epsilon) {
      const cornerRadiusStart = min(outerCornerRadiusStart, limitedOcr), cornerRadiusEnd = min(outerCornerRadiusEnd, limitedOcr), t0 = cornerTangents(xirs, yirs, xors, yors, outerRadius, cornerRadiusStart, Number(clockwise)), t1 = cornerTangents(xore, yore, xire, yire, outerRadius, cornerRadiusEnd, Number(clockwise));
      limitedOcr < maxOuterCornerRadius && cornerRadiusStart === cornerRadiusEnd ? !partStroke || partStroke[0] ? (context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), context.arc(cx + t0.cx, cy + t0.cy, limitedOcr, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !clockwise)) : context.moveTo(cx + t0.cx + limitedOcr * cos(atan2(t1.y01, t1.x01)), cy + t0.cy + limitedOcr * sin(atan2(t1.y01, t1.x01))) : !partStroke || partStroke[0] ? (context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), cornerRadiusStart > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusStart, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !clockwise), context.arc(cx, cy, outerRadius, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !clockwise), cornerRadiusEnd > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusEnd, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !clockwise)) : cornerRadiusEnd > 0 ? context.moveTo(cx + t1.cx + cornerRadiusEnd * cos(atan2(t1.y01, t1.x01)), cy + t1.cy + cornerRadiusEnd * sin(atan2(t1.y01, t1.x01))) : context.moveTo(cx + xore, cy + outerRadius * sin(outerEndAngle));
    } else
      !partStroke || partStroke[0] ? (context.moveTo(cx + xors, cy + yors), context.arc(cx, cy, outerRadius, outerStartAngle, outerEndAngle, !clockwise)) : context.moveTo(cx + outerRadius * cos(outerEndAngle), cy + outerRadius * sin(outerEndAngle));
    if (!(innerRadius > epsilon) || innerDeltaAngle < 1e-3)
      !partStroke || partStroke[1] ? context.lineTo(cx + xire, cy + yire) : context.moveTo(cx + xire, cy + yire), collapsedToLine = true;
    else if (limitedIcr > epsilon) {
      const cornerRadiusStart = min(innerCornerRadiusStart, limitedIcr), cornerRadiusEnd = min(innerCornerRadiusEnd, limitedIcr), t0 = cornerTangents(xire, yire, xore, yore, innerRadius, -cornerRadiusEnd, Number(clockwise)), t1 = cornerTangents(xors, yors, xirs, yirs, innerRadius, -cornerRadiusStart, Number(clockwise));
      if (!partStroke || partStroke[1] ? context.lineTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01) : context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), limitedIcr < maxInnerCornerRadius && cornerRadiusStart === cornerRadiusEnd) {
        const arcEndAngle = atan2(t1.y01, t1.x01);
        !partStroke || partStroke[2] ? context.arc(cx + t0.cx, cy + t0.cy, limitedIcr, atan2(t0.y01, t0.x01), arcEndAngle, !clockwise) : context.moveTo(cx + t0.cx + cos(arcEndAngle), cy + t0.cy + sin(arcEndAngle));
      } else
        !partStroke || partStroke[2] ? (cornerRadiusEnd > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusEnd, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !clockwise), context.arc(cx, cy, innerRadius, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), clockwise), cornerRadiusStart > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusStart, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !clockwise)) : cornerRadiusStart > 0 ? context.moveTo(cx + t1.cx + cornerRadiusStart * cos(atan2(t1.y01, t1.x01)), cy + t1.cy + cornerRadiusStart * sin(atan2(t1.y01, t1.x01))) : context.moveTo(cx + xirs, cy + yirs);
    } else
      !partStroke || partStroke[1] ? context.lineTo(cx + xire, cy + yire) : context.moveTo(cx + xire, cy + yire), !partStroke || partStroke[2] ? context.arc(cx, cy, innerRadius, innerEndAngle, innerStartAngle, clockwise) : context.moveTo(cx + innerRadius * cos(innerStartAngle), cy + innerRadius * sin(innerStartAngle));
  }
  return partStroke ? partStroke[3] && context.lineTo(cx + outerRadius * cos(startAngle), cy + outerRadius * sin(startAngle)) : context.closePath(), collapsedToLine;
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/canvas/conical-gradient
var ConicalCanvas = class _ConicalCanvas {
  static GetCanvas() {
    try {
      return _ConicalCanvas.canvas || (_ConicalCanvas.canvas = application.global.createCanvas({})), _ConicalCanvas.canvas;
    } catch (err) {
      return null;
    }
  }
  static GetCtx() {
    if (!_ConicalCanvas.ctx) {
      const conicalCanvas = _ConicalCanvas.GetCanvas();
      _ConicalCanvas.ctx = conicalCanvas.getContext("2d");
    }
    return _ConicalCanvas.ctx;
  }
};
var ColorInterpolate = class _ColorInterpolate extends LRU {
  static getInstance() {
    return _ColorInterpolate._instance || (_ColorInterpolate._instance = new _ColorInterpolate()), _ColorInterpolate._instance;
  }
  constructor(stops = [], precision = 100) {
    super(), this.cacheParams = {
      CLEAN_THRESHOLD: 100,
      L_TIME: 1e3
    }, this.dataMap = /* @__PURE__ */ new Map();
    const canvas = ConicalCanvas.GetCanvas(), conicalCtx = ConicalCanvas.GetCtx();
    if (canvas.width = precision, canvas.height = 1, !conicalCtx)
      return;
    if (conicalCtx.translate(0, 0), !conicalCtx)
      throw new Error("\u83B7\u53D6ctx\u53D1\u751F\u9519\u8BEF");
    const gradient = conicalCtx.createLinearGradient(0, 0, precision, 0);
    stops.forEach((stop) => {
      gradient.addColorStop(stop[0], stop[1]);
    }), conicalCtx.fillStyle = gradient, conicalCtx.fillRect(0, 0, precision, 1), this.rgbaSet = conicalCtx.getImageData(0, 0, precision, 1).data;
  }
  getColor(offset) {
    const rgba2 = this.rgbaSet.slice(4 * offset, 4 * offset + 4);
    return `rgba(${rgba2[0]}, ${rgba2[1]}, ${rgba2[2]}, ${rgba2[3] / 255})`;
  }
  GetOrCreate(x, y, w, h, stops = [], precision = 100) {
    let str = `${x}${y}${w}${h}`;
    stops.forEach((item) => str += item.join()), str += precision;
    let colorInter = this.dataMap.get(str);
    if (!colorInter) {
      colorInter = {
        data: new _ColorInterpolate(stops, precision),
        timestamp: []
      }, this.addLimitedTimestamp(colorInter, Date.now(), {}), this.dataMap.set(str, colorInter);
    }
    return this.clearCache(this.dataMap, this.cacheParams), colorInter.data;
  }
};
var ConicalPatternStore = class _ConicalPatternStore {
  static GetSize(minSize) {
    for (let i = 0; i < _ConicalPatternStore.ImageSize.length; i++)
      if (_ConicalPatternStore.ImageSize[i] >= minSize)
        return _ConicalPatternStore.ImageSize[i];
    return minSize;
  }
  static Get(stops, x, y, startAngle, endAngle, w, h) {
    const key = _ConicalPatternStore.GenKey(stops, x, y, startAngle, endAngle), data = _ConicalPatternStore.cache[key];
    if (!data || 0 === data.length)
      return null;
    for (let i = 0; i < data.length; i++)
      if (data[i].width >= w && data[i].height >= h)
        return data[i].pattern;
    return null;
  }
  static Set(stops, x, y, startAngle, endAngle, pattern, w, h) {
    const key = _ConicalPatternStore.GenKey(stops, x, y, startAngle, endAngle);
    _ConicalPatternStore.cache[key] ? _ConicalPatternStore.cache[key].push({
      width: w,
      height: h,
      pattern
    }) : _ConicalPatternStore.cache[key] = [{
      width: w,
      height: h,
      pattern
    }];
  }
  static GenKey(stops, x, y, startAngle, endAngle) {
    return `${x},${y},${startAngle},${endAngle},${stops.join()}`;
  }
};
ConicalPatternStore.cache = {}, ConicalPatternStore.ImageSize = [20, 40, 80, 160, 320, 640, 1280, 2560];
function getConicGradientAt(x, y, angle2, color) {
  const { stops, startAngle, endAngle } = color;
  for (; angle2 < 0; )
    angle2 += pi2;
  for (; angle2 > pi2; )
    angle2 -= pi2;
  if (angle2 < startAngle)
    return stops[0].color;
  if (angle2 > endAngle)
    return stops[0].color;
  let startStop, endStop, percent = (angle2 - startAngle) / (endAngle - startAngle);
  for (let i = 0; i < stops.length; i++)
    if (stops[i].offset >= percent) {
      startStop = stops[i - 1], endStop = stops[i];
      break;
    }
  return percent = (percent - startStop.offset) / (endStop.offset - startStop.offset), interpolateColor(startStop.color, endStop.color, percent, false);
}
function createConicalGradient(context, stops, x, y, deltaAngle, startAngle, endAngle, minW, minH) {
  const deltaDeg = Math.floor(180 * deltaAngle / Math.PI), conicalCanvas = ConicalCanvas.GetCanvas(), conicalCtx = ConicalCanvas.GetCtx();
  if (!conicalCtx)
    return null;
  const width = ConicalPatternStore.GetSize(minW), height = ConicalPatternStore.GetSize(minH);
  let pattern = ConicalPatternStore.Get(stops, x, y, startAngle, endAngle, width, height);
  if (pattern)
    return pattern;
  const r = Math.sqrt(Math.max(Math.max(Math.pow(x, 2) + Math.pow(y, 2), Math.pow(width - x, 2) + Math.pow(y, 2)), Math.max(Math.pow(width - x, 2) + Math.pow(height - y, 2), Math.pow(x, 2) + Math.pow(height - y, 2)))), stepNum = deltaDeg + 1, step = deltaAngle / Math.max(1, stepNum - 1), colorInter = ColorInterpolate.getInstance().GetOrCreate(x, y, width, height, stops, stepNum), lineWidth = 2 * Math.PI * r / 360;
  conicalCanvas.width = width, conicalCanvas.height = height, conicalCtx.setTransform(1, 0, 0, 1, 0, 0), conicalCtx.clearRect(0, 0, width, height), conicalCtx.translate(x, y), conicalCtx.rotate(startAngle);
  for (let i = 0, len = stepNum - 1; i < len && !(startAngle + i * step > endAngle); i++) {
    const color = colorInter.getColor(i);
    conicalCtx.beginPath(), conicalCtx.rotate(step), conicalCtx.moveTo(0, 0), conicalCtx.lineTo(r, -2 * lineWidth), conicalCtx.lineTo(r, 0), conicalCtx.fillStyle = color, conicalCtx.closePath(), conicalCtx.fill();
  }
  const imageData = conicalCtx.getImageData(0, 0, width, height);
  return conicalCanvas.width = imageData.width, conicalCanvas.height = imageData.height, conicalCtx.putImageData(imageData, 0, 0), pattern = context.createPattern(conicalCanvas, "no-repeat"), pattern && ConicalPatternStore.Set(stops, x, y, startAngle, endAngle, pattern, width, height), pattern;
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/contributions/constants
var ArcRenderContribution = Symbol.for("ArcRenderContribution");
var AreaRenderContribution = Symbol.for("AreaRenderContribution");
var CircleRenderContribution = Symbol.for("CircleRenderContribution");
var GroupRenderContribution = Symbol.for("GroupRenderContribution");
var ImageRenderContribution = Symbol.for("ImageRenderContribution");
var PathRenderContribution = Symbol.for("PathRenderContribution");
var PolygonRenderContribution = Symbol.for("PolygonRenderContribution");
var RectRenderContribution = Symbol.for("RectRenderContribution");
var SymbolRenderContribution = Symbol.for("SymbolRenderContribution");
var TextRenderContribution = Symbol.for("TextRenderContribution");
var CommonRenderContribution = Symbol.for("CommonRenderContribution");
var InteractiveSubRenderContribution = Symbol.for("InteractiveSubRenderContribution");

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/circle
var CIRCLE_UPDATE_TAG_KEY = ["radius", "startAngle", "endAngle", ...GRAPHIC_UPDATE_TAG_KEY];
var Circle = class _Circle extends Graphic {
  constructor(params2 = {
    radius: 1
  }) {
    super(params2), this.type = "circle", this.numberType = CIRCLE_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const { startAngle, endAngle, radius } = this.attribute;
    return this._validNumber(startAngle) && this._validNumber(endAngle) && this._validNumber(radius);
  }
  doUpdateAABBBounds(full) {
    const circleTheme = getTheme(this).circle;
    this._AABBBounds.clear();
    const attribute = this.attribute, bounds = application.graphicService.updateCircleAABBBounds(attribute, getTheme(this).circle, this._AABBBounds, full, this), { boundsPadding = circleTheme.boundsPadding } = attribute, paddingArray = parsePadding(boundsPadding);
    return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
  }
  tryUpdateOBBBounds() {
    throw new Error("\u6682\u4E0D\u652F\u6301");
  }
  getDefaultAttribute(name) {
    return getTheme(this).circle[name];
  }
  needUpdateTags(keys2) {
    return super.needUpdateTags(keys2, CIRCLE_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, CIRCLE_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    var _a, _b, _c;
    const attribute = this.attribute, radius = null !== (_a = attribute.radius) && void 0 !== _a ? _a : this.getDefaultAttribute("radius"), startAngle = null !== (_b = attribute.startAngle) && void 0 !== _b ? _b : this.getDefaultAttribute("startAngle"), endAngle = null !== (_c = attribute.endAngle) && void 0 !== _c ? _c : this.getDefaultAttribute("endAngle"), path = new CustomPath2D();
    return path.arc(0, 0, radius, startAngle, endAngle), path;
  }
  clone() {
    return new _Circle(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Circle.NOWORK_ANIMATE_ATTR;
  }
};
Circle.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createCircle(attributes) {
  return new Circle(attributes);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/text
function getContextFont2(text2, defaultAttr = {}, fontSizeScale) {
  fontSizeScale || (fontSizeScale = 1);
  const { fontStyle = defaultAttr.fontStyle, fontVariant = defaultAttr.fontVariant, fontWeight = defaultAttr.fontWeight, fontSize = defaultAttr.fontSize, fontFamily = defaultAttr.fontFamily } = text2;
  return (fontStyle ? fontStyle + " " : "") + (fontVariant ? fontVariant + " " : "") + (fontWeight ? fontWeight + " " : "") + fontSize * fontSizeScale + "px " + (fontFamily || "sans-serif");
}
function textDrawOffsetY(baseline, h) {
  return "top" === baseline ? Math.ceil(0.79 * h) : "middle" === baseline ? Math.round(0.3 * h) : "bottom" === baseline ? Math.round(-0.21 * h) : 0;
}
function textDrawOffsetX(textAlign, width) {
  return "end" === textAlign || "right" === textAlign ? -width : "center" === textAlign ? -width / 2 : 0;
}
function textLayoutOffsetY(baseline, lineHeight, fontSize, buf = 0) {
  return "middle" === baseline ? -lineHeight / 2 : "top" === baseline ? 0 : "bottom" === baseline ? buf - lineHeight : baseline && "alphabetic" !== baseline ? 0 : (fontSize || (fontSize = lineHeight), -(lineHeight - fontSize) / 2 - 0.79 * fontSize);
}
function textAttributesToStyle(attrs) {
  const style = {};
  return ["textAlign", "fontFamily", "fontVariant", "fontStyle", "fontWeight"].forEach((key) => {
    attrs[key] && (style[lowerCamelCaseToMiddle(key)] = attrs[key]);
  }), ["fontSize", "lineHeight"].forEach((key) => {
    const styleKey = lowerCamelCaseToMiddle(key);
    isNil_default(attrs[key]) || (style[styleKey] = /^[0-9]*$/.test(`${attrs[key]}`) ? `${attrs[key]}px` : `${attrs[key]}`);
  }), attrs.underline ? style["text-decoration"] = "underline" : attrs.lineThrough && (style["text-decoration"] = "line-through"), attrs.fill && isString_default(attrs.fill) && (style.color = attrs.fill), style;
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/core/contributions/textMeasure/layout
var CanvasTextLayout = class {
  constructor(fontFamily, options, textMeasure) {
    this.fontFamily = fontFamily, this.textOptions = options, this.textMeasure = textMeasure;
  }
  LayoutBBox(bbox, textAlign, textBaseline) {
    if ("left" === textAlign || "start" === textAlign)
      bbox.xOffset = 0;
    else if ("center" === textAlign)
      bbox.xOffset = bbox.width / -2;
    else {
      if ("right" !== textAlign && "end" !== textAlign)
        throw new Error("\u975E\u6CD5\u7684textAlign");
      bbox.xOffset = -bbox.width;
    }
    return bbox.yOffset = "top" === textBaseline ? 0 : "middle" === textBaseline ? bbox.height / -2 : "alphabetic" === textBaseline ? -0.79 * bbox.height : -bbox.height, bbox;
  }
  GetLayout(str, width, height, textAlign, textBaseline, lineHeight, suffix, wordBreak, suffixPosition) {
    const linesLayout = [], bboxWH = [width, height], bboxOffset = [0, 0];
    for (; str.length > 0; ) {
      const { str: clipText } = this.textMeasure.clipTextWithSuffix(str, this.textOptions, width, suffix, wordBreak, suffixPosition);
      linesLayout.push({
        str: clipText,
        width: this.textMeasure.measureTextWidth(clipText, this.textOptions)
      }), str = str.substring(clipText.length);
    }
    "left" === textAlign || "start" === textAlign || ("center" === textAlign ? bboxOffset[0] = bboxWH[0] / -2 : "right" !== textAlign && "end" !== textAlign || (bboxOffset[0] = -bboxWH[0])), "top" === textBaseline || ("middle" === textBaseline ? bboxOffset[1] = bboxWH[1] / -2 : "bottom" === textBaseline && (bboxOffset[1] = -bboxWH[1]));
    const bbox = {
      xOffset: bboxOffset[0],
      yOffset: bboxOffset[1],
      width: bboxWH[0],
      height: bboxWH[1]
    };
    return this.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
  }
  GetLayoutByLines(lines, textAlign, textBaseline, lineHeight, suffix = "", wordBreak, lineWidth, suffixPosition = "end") {
    lines = lines.map((l) => l.toString());
    const linesLayout = [], bboxWH = [0, 0];
    if ("number" == typeof lineWidth && lineWidth !== 1 / 0) {
      let width;
      for (let i = 0, len = lines.length; i < len; i++)
        width = Math.min(this.textMeasure.measureTextWidth(lines[i], this.textOptions), lineWidth), linesLayout.push({
          str: this.textMeasure.clipTextWithSuffix(lines[i], this.textOptions, width, suffix, wordBreak, suffixPosition).str,
          width
        });
      bboxWH[0] = lineWidth;
    } else {
      let width, text2;
      lineWidth = 0;
      for (let i = 0, len = lines.length; i < len; i++)
        text2 = lines[i], width = this.textMeasure.measureTextWidth(text2, this.textOptions), lineWidth = Math.max(lineWidth, width), linesLayout.push({
          str: text2,
          width
        });
      bboxWH[0] = lineWidth;
    }
    bboxWH[1] = linesLayout.length * lineHeight, bboxWH[0] = linesLayout.reduce((a3, b) => Math.max(a3, b.width), 0);
    const bbox = {
      xOffset: 0,
      yOffset: 0,
      width: bboxWH[0],
      height: bboxWH[1]
    };
    return this.LayoutBBox(bbox, textAlign, textBaseline), this.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
  }
  layoutWithBBox(bbox, lines, textAlign, textBaseline, lineHeight) {
    const origin = [0, 0], totalLineHeight = lines.length * lineHeight;
    "top" === textBaseline || ("middle" === textBaseline ? origin[1] = (bbox.height - totalLineHeight) / 2 : "bottom" === textBaseline && (origin[1] = bbox.height - totalLineHeight));
    for (let i = 0; i < lines.length; i++)
      this.lineOffset(bbox, lines[i], textAlign, textBaseline, lineHeight, origin);
    return {
      bbox,
      lines,
      fontFamily: this.fontFamily,
      fontSize: this.textOptions.fontSize,
      fontWeight: this.textOptions.fontWeight,
      lineHeight,
      textAlign,
      textBaseline
    };
  }
  lineOffset(bbox, line2, textAlign, textBaseline, lineHeight, origin) {
    return "left" === textAlign || "start" === textAlign ? line2.leftOffset = 0 : "center" === textAlign ? line2.leftOffset = (bbox.width - line2.width) / 2 : "right" !== textAlign && "end" !== textAlign || (line2.leftOffset = bbox.width - line2.width), line2.topOffset = (lineHeight - this.textOptions.fontSize) / 2 + 0.79 * this.textOptions.fontSize + origin[1], origin[1] += lineHeight, line2;
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/text
var TEXT_UPDATE_TAG_KEY = ["text", "maxLineWidth", "textAlign", "textBaseline", "heightLimit", "lineClamp", "fontSize", "fontFamily", "fontWeight", "ellipsis", "lineHeight", "direction", "wordBreak", "heightLimit", "lineClamp", ...GRAPHIC_UPDATE_TAG_KEY];
var Text = class _Text extends Graphic {
  get font() {
    const textTheme = getTheme(this).text;
    return this._font || (this._font = getContextFont2(this.attribute, textTheme)), this._font;
  }
  get clipedText() {
    var _a;
    const attribute = this.attribute, textTheme = getTheme(this).text;
    if (!this.isSimplify())
      return;
    const { maxLineWidth = textTheme.maxLineWidth } = attribute;
    return Number.isFinite(maxLineWidth) ? (this.tryUpdateAABBBounds(), this.cache.clipedText) : (null !== (_a = attribute.text) && void 0 !== _a ? _a : textTheme.text).toString();
  }
  get clipedWidth() {
    if (this.isSimplify())
      return this.tryUpdateAABBBounds(), this.cache.clipedWidth;
  }
  get cliped() {
    const textTheme = getTheme(this).text, attribute = this.attribute;
    if (this.isMultiLine)
      return;
    const { maxLineWidth = textTheme.maxLineWidth } = attribute;
    return !!Number.isFinite(maxLineWidth) && (this.tryUpdateAABBBounds(), "vertical" === attribute.direction && this.cache.verticalList && this.cache.verticalList[0] ? this.cache.verticalList[0].map((item) => item.text).join("") !== attribute.text.toString() : null != this.clipedText && this.clipedText !== attribute.text.toString());
  }
  get multilineLayout() {
    if (this.isMultiLine)
      return this.tryUpdateAABBBounds(), this.cache.layoutData;
  }
  isSimplify() {
    return !this.isMultiLine && "vertical" !== this.attribute.direction;
  }
  get isMultiLine() {
    return Array.isArray(this.attribute.text) || "normal" === this.attribute.whiteSpace;
  }
  constructor(params2 = {
    text: "",
    fontSize: 16
  }) {
    super(params2), this.type = "text", this.numberType = TEXT_NUMBER_TYPE, this.cache = {};
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const { text: text2 } = this.attribute;
    return isArray_default(text2) ? !text2.every((t) => null == t || "" === t) : null != text2 && "" !== text2;
  }
  doUpdateAABBBounds() {
    const textTheme = getTheme(this).text;
    this._AABBBounds.clear();
    const attribute = this.attribute, bounds = application.graphicService.updateTextAABBBounds(attribute, textTheme, this._AABBBounds, this), { boundsPadding = textTheme.boundsPadding } = this.attribute, paddingArray = parsePadding(boundsPadding);
    return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
  }
  updateWrapAABBBounds(text2) {
    var _a, _b, _c, _d;
    const textTheme = getTheme(this).text, { fontFamily = textTheme.fontFamily, textAlign = textTheme.textAlign, textBaseline = textTheme.textBaseline, fontSize = textTheme.fontSize, ellipsis = textTheme.ellipsis, maxLineWidth, stroke: stroke2 = textTheme.stroke, lineWidth = textTheme.lineWidth, wordBreak = textTheme.wordBreak, fontWeight = textTheme.fontWeight, ignoreBuf = textTheme.ignoreBuf, suffixPosition = textTheme.suffixPosition, heightLimit = 0, lineClamp } = this.attribute, lineHeight = null !== (_a = calculateLineHeight(this.attribute.lineHeight, this.attribute.fontSize || textTheme.fontSize)) && void 0 !== _a ? _a : this.attribute.fontSize || textTheme.fontSize, buf = ignoreBuf ? 0 : 2;
    if (!this.shouldUpdateShape() && (null === (_b = this.cache) || void 0 === _b ? void 0 : _b.layoutData)) {
      const bbox2 = this.cache.layoutData.bbox;
      return this._AABBBounds.set(bbox2.xOffset, bbox2.yOffset, bbox2.xOffset + bbox2.width, bbox2.yOffset + bbox2.height), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
    }
    const textMeasure = application.graphicUtil.textMeasure, layoutObj = new CanvasTextLayout(fontFamily, {
      fontSize,
      fontWeight,
      fontFamily
    }, textMeasure), lines = isArray_default(text2) ? text2.map((l) => l.toString()) : [text2.toString()], linesLayout = [], bboxWH = [0, 0];
    let lineCountLimit = 1 / 0;
    if (heightLimit > 0 && (lineCountLimit = Math.max(Math.floor(heightLimit / lineHeight), 1)), lineClamp && (lineCountLimit = Math.min(lineCountLimit, lineClamp)), "number" == typeof maxLineWidth && maxLineWidth !== 1 / 0) {
      if (maxLineWidth > 0)
        for (let i = 0; i < lines.length; i++) {
          const str = lines[i];
          let needCut = true;
          if (i === lineCountLimit - 1) {
            const clip2 = layoutObj.textMeasure.clipTextWithSuffix(str, layoutObj.textOptions, maxLineWidth, ellipsis, false, suffixPosition, i !== lines.length - 1);
            linesLayout.push({
              str: clip2.str,
              width: clip2.width
            });
            break;
          }
          const clip = layoutObj.textMeasure.clipText(str, layoutObj.textOptions, maxLineWidth, "break-word" === wordBreak);
          if ("" !== str && "" === clip.str) {
            if (ellipsis) {
              const clipEllipsis = layoutObj.textMeasure.clipTextWithSuffix(str, layoutObj.textOptions, maxLineWidth, ellipsis, false, suffixPosition);
              clip.str = null !== (_c = clipEllipsis.str) && void 0 !== _c ? _c : "", clip.width = null !== (_d = clipEllipsis.width) && void 0 !== _d ? _d : 0;
            } else
              clip.str = "", clip.width = 0;
            needCut = false;
          }
          if (linesLayout.push({
            str: clip.str,
            width: clip.width
          }), clip.str.length === str.length)
            ;
          else if (needCut) {
            const newStr = str.substring(clip.str.length);
            lines.splice(i + 1, 0, newStr);
          }
        }
      let maxWidth = 0;
      linesLayout.forEach((layout) => {
        maxWidth = Math.max(maxWidth, layout.width);
      }), bboxWH[0] = maxWidth;
    } else {
      let width, text3, lineWidth2 = 0;
      for (let i = 0, len = lines.length; i < len; i++) {
        if (i === lineCountLimit - 1) {
          const clip = layoutObj.textMeasure.clipTextWithSuffix(lines[i], layoutObj.textOptions, maxLineWidth, ellipsis, false, suffixPosition);
          linesLayout.push({
            str: clip.str,
            width: clip.width
          }), lineWidth2 = Math.max(lineWidth2, clip.width);
          break;
        }
        text3 = lines[i], width = layoutObj.textMeasure.measureTextWidth(text3, layoutObj.textOptions, "break-word" === wordBreak), lineWidth2 = Math.max(lineWidth2, width), linesLayout.push({
          str: text3,
          width
        });
      }
      bboxWH[0] = lineWidth2;
    }
    bboxWH[1] = linesLayout.length * (lineHeight + buf);
    const bbox = {
      xOffset: 0,
      yOffset: 0,
      width: bboxWH[0],
      height: bboxWH[1]
    };
    layoutObj.LayoutBBox(bbox, textAlign, textBaseline);
    const layoutData = layoutObj.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
    return this.cache.layoutData = layoutData, this.clearUpdateShapeTag(), this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
  }
  updateSingallineAABBBounds(text2) {
    const textTheme = getTheme(this).text, { direction: direction2 = textTheme.direction, underlineOffset = textTheme.underlineOffset } = this.attribute, b = "horizontal" === direction2 ? this.updateHorizontalSinglelineAABBBounds(text2) : this.updateVerticalSinglelineAABBBounds(text2);
    return "horizontal" === direction2 && underlineOffset && this._AABBBounds.add(this._AABBBounds.x1, this._AABBBounds.y2 + underlineOffset), b;
  }
  updateMultilineAABBBounds(text2) {
    const textTheme = getTheme(this).text, { direction: direction2 = textTheme.direction, underlineOffset = textTheme.underlineOffset } = this.attribute, b = "horizontal" === direction2 ? this.updateHorizontalMultilineAABBBounds(text2) : this.updateVerticalMultilineAABBBounds(text2);
    return "horizontal" === direction2 && underlineOffset && this._AABBBounds.add(this._AABBBounds.x1, this._AABBBounds.y2 + underlineOffset), b;
  }
  updateHorizontalSinglelineAABBBounds(text2) {
    var _a, _b;
    const textTheme = getTheme(this).text, { wrap = textTheme.wrap } = this.attribute;
    if (wrap)
      return this.updateWrapAABBBounds([text2]);
    const textMeasure = application.graphicUtil.textMeasure;
    let width, str;
    const attribute = this.attribute, { maxLineWidth = textTheme.maxLineWidth, ellipsis = textTheme.ellipsis, textAlign = textTheme.textAlign, textBaseline = textTheme.textBaseline, fontFamily = textTheme.fontFamily, fontSize = textTheme.fontSize, fontWeight = textTheme.fontWeight, stroke: stroke2 = textTheme.stroke, lineWidth = textTheme.lineWidth, ignoreBuf = textTheme.ignoreBuf, whiteSpace = textTheme.whiteSpace, suffixPosition = textTheme.suffixPosition } = attribute;
    if ("normal" === whiteSpace)
      return this.updateWrapAABBBounds(text2);
    const buf = ignoreBuf ? 0 : Math.max(2, 0.075 * fontSize), textFontSize = attribute.fontSize || textTheme.fontSize, lineHeight = null !== (_a = calculateLineHeight(attribute.lineHeight, textFontSize)) && void 0 !== _a ? _a : textFontSize + buf;
    if (!this.shouldUpdateShape() && this.cache) {
      width = null !== (_b = this.cache.clipedWidth) && void 0 !== _b ? _b : 0;
      const dx2 = textDrawOffsetX(textAlign, width), dy2 = textLayoutOffsetY(textBaseline, lineHeight, fontSize);
      return this._AABBBounds.set(dx2, dy2, dx2 + width, dy2 + lineHeight), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
    }
    if (Number.isFinite(maxLineWidth)) {
      if (ellipsis) {
        const strEllipsis = true === ellipsis ? textTheme.ellipsis : ellipsis, data = textMeasure.clipTextWithSuffix(text2.toString(), {
          fontSize,
          fontWeight,
          fontFamily
        }, maxLineWidth, strEllipsis, false, suffixPosition);
        str = data.str, width = data.width;
      } else {
        const data = textMeasure.clipText(text2.toString(), {
          fontSize,
          fontWeight,
          fontFamily
        }, maxLineWidth, false);
        str = data.str, width = data.width;
      }
      this.cache.clipedText = str, this.cache.clipedWidth = width;
    } else
      width = textMeasure.measureTextWidth(text2.toString(), {
        fontSize,
        fontWeight,
        fontFamily
      }), this.cache.clipedText = text2.toString(), this.cache.clipedWidth = width;
    this.clearUpdateShapeTag();
    const dx = textDrawOffsetX(textAlign, width);
    let lh = lineHeight;
    application.global && application.global.isSafari() && (lh += 0.2 * fontSize);
    const dy = textLayoutOffsetY(textBaseline, lh, fontSize, buf);
    return this._AABBBounds.set(dx, dy, dx + width, dy + lh), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
  }
  getBaselineMapAlign() {
    return _Text.baselineMapAlign;
  }
  getAlignMapBaseline() {
    return _Text.alignMapBaseline;
  }
  updateVerticalSinglelineAABBBounds(text2) {
    var _a, _b, _c;
    const textTheme = getTheme(this).text, textMeasure = application.graphicUtil.textMeasure;
    let width;
    const attribute = this.attribute, { ignoreBuf = textTheme.ignoreBuf } = attribute, buf = ignoreBuf ? 0 : 2, { maxLineWidth = textTheme.maxLineWidth, ellipsis = textTheme.ellipsis, fontSize = textTheme.fontSize, fontWeight = textTheme.fontWeight, fontFamily = textTheme.fontFamily, stroke: stroke2 = textTheme.stroke, lineWidth = textTheme.lineWidth, verticalMode = textTheme.verticalMode, suffixPosition = textTheme.suffixPosition } = attribute, lineHeight = null !== (_a = calculateLineHeight(attribute.lineHeight, attribute.fontSize || textTheme.fontSize)) && void 0 !== _a ? _a : (attribute.fontSize || textTheme.fontSize) + buf;
    let { textAlign = textTheme.textAlign, textBaseline = textTheme.textBaseline } = attribute;
    if (!verticalMode) {
      const t = textAlign;
      textAlign = null !== (_b = _Text.baselineMapAlign[textBaseline]) && void 0 !== _b ? _b : "left", textBaseline = null !== (_c = _Text.alignMapBaseline[t]) && void 0 !== _c ? _c : "top";
    }
    if (!this.shouldUpdateShape() && this.cache) {
      width = this.cache.clipedWidth;
      const dx2 = textDrawOffsetX(textAlign, width), dy2 = textLayoutOffsetY(textBaseline, lineHeight, fontSize);
      return this._AABBBounds.set(dy2, dx2, dy2 + lineHeight, dx2 + width), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
    }
    let verticalList = [verticalLayout(text2.toString())];
    if (Number.isFinite(maxLineWidth)) {
      if (ellipsis) {
        const strEllipsis = true === ellipsis ? textTheme.ellipsis : ellipsis, data = textMeasure.clipTextWithSuffixVertical(verticalList[0], {
          fontSize,
          fontWeight,
          fontFamily
        }, maxLineWidth, strEllipsis, false, suffixPosition);
        verticalList = [data.verticalList], width = data.width;
      } else {
        const data = textMeasure.clipTextVertical(verticalList[0], {
          fontSize,
          fontWeight,
          fontFamily
        }, maxLineWidth, false);
        verticalList = [data.verticalList], width = data.width;
      }
      this.cache.verticalList = verticalList, this.cache.clipedWidth = width;
    } else
      width = 0, verticalList[0].forEach((t) => {
        const w = t.direction === TextDirection.HORIZONTAL ? fontSize : textMeasure.measureTextWidth(t.text, {
          fontSize,
          fontWeight,
          fontFamily
        });
        width += w, t.width = w;
      }), this.cache.verticalList = verticalList, this.cache.clipedWidth = width;
    this.clearUpdateShapeTag();
    const dx = textDrawOffsetX(textAlign, width), dy = textLayoutOffsetY(textBaseline, lineHeight, fontSize);
    return this._AABBBounds.set(dy, dx, dy + lineHeight, dx + width), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
  }
  updateHorizontalMultilineAABBBounds(text2) {
    var _a, _b;
    const textTheme = getTheme(this).text, { wrap = textTheme.wrap } = this.attribute;
    if (wrap)
      return this.updateWrapAABBBounds(text2);
    const attribute = this.attribute, { fontFamily = textTheme.fontFamily, textAlign = textTheme.textAlign, textBaseline = textTheme.textBaseline, fontSize = textTheme.fontSize, fontWeight = textTheme.fontWeight, ellipsis = textTheme.ellipsis, maxLineWidth, stroke: stroke2 = textTheme.stroke, lineWidth = textTheme.lineWidth, whiteSpace = textTheme.whiteSpace, suffixPosition = textTheme.suffixPosition } = attribute, lineHeight = null !== (_a = calculateLineHeight(attribute.lineHeight, attribute.fontSize || textTheme.fontSize)) && void 0 !== _a ? _a : attribute.fontSize || textTheme.fontSize;
    if ("normal" === whiteSpace)
      return this.updateWrapAABBBounds(text2);
    if (!this.shouldUpdateShape() && (null === (_b = this.cache) || void 0 === _b ? void 0 : _b.layoutData)) {
      const bbox2 = this.cache.layoutData.bbox;
      return this._AABBBounds.set(bbox2.xOffset, bbox2.yOffset, bbox2.xOffset + bbox2.width, bbox2.yOffset + bbox2.height), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
    }
    const textMeasure = application.graphicUtil.textMeasure, layoutData = new CanvasTextLayout(fontFamily, {
      fontSize,
      fontWeight,
      fontFamily
    }, textMeasure).GetLayoutByLines(text2, textAlign, textBaseline, lineHeight, true === ellipsis ? textTheme.ellipsis : ellipsis || void 0, false, maxLineWidth, suffixPosition), { bbox } = layoutData;
    return this.cache.layoutData = layoutData, this.clearUpdateShapeTag(), this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
  }
  updateVerticalMultilineAABBBounds(text2) {
    var _a, _b, _c;
    const textTheme = getTheme(this).text, textMeasure = application.graphicUtil.textMeasure;
    let width;
    const attribute = this.attribute, { ignoreBuf = textTheme.ignoreBuf } = attribute, buf = ignoreBuf ? 0 : 2, { maxLineWidth = textTheme.maxLineWidth, ellipsis = textTheme.ellipsis, fontFamily = textTheme.fontFamily, fontSize = textTheme.fontSize, fontWeight = textTheme.fontWeight, stroke: stroke2 = textTheme.stroke, lineWidth = textTheme.lineWidth, verticalMode = textTheme.verticalMode, suffixPosition = textTheme.suffixPosition } = attribute, lineHeight = null !== (_a = calculateLineHeight(attribute.lineHeight, attribute.fontSize || textTheme.fontSize)) && void 0 !== _a ? _a : (attribute.fontSize || textTheme.fontSize) + buf;
    let { textAlign = textTheme.textAlign, textBaseline = textTheme.textBaseline } = attribute;
    if (!verticalMode) {
      const t = textAlign;
      textAlign = null !== (_b = _Text.baselineMapAlign[textBaseline]) && void 0 !== _b ? _b : "left", textBaseline = null !== (_c = _Text.alignMapBaseline[t]) && void 0 !== _c ? _c : "top";
    }
    if (width = 0, !this.shouldUpdateShape() && this.cache) {
      this.cache.verticalList.forEach((item) => {
        const w = item.reduce((a3, b) => a3 + b.width, 0);
        width = max(w, width);
      });
      const dx2 = textDrawOffsetX(textAlign, width), height2 = this.cache.verticalList.length * lineHeight, dy2 = textLayoutOffsetY(textBaseline, height2, fontSize);
      return this._AABBBounds.set(dy2, dx2, dy2 + height2, dx2 + width), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
    }
    const verticalLists = text2.map((str) => verticalLayout(str.toString()));
    verticalLists.forEach((verticalData, i) => {
      if (Number.isFinite(maxLineWidth))
        if (ellipsis) {
          const strEllipsis = true === ellipsis ? textTheme.ellipsis : ellipsis, data = textMeasure.clipTextWithSuffixVertical(verticalData, {
            fontSize,
            fontWeight,
            fontFamily
          }, maxLineWidth, strEllipsis, false, suffixPosition);
          verticalLists[i] = data.verticalList, width = data.width;
        } else {
          const data = textMeasure.clipTextVertical(verticalData, {
            fontSize,
            fontWeight,
            fontFamily
          }, maxLineWidth, false);
          verticalLists[i] = data.verticalList, width = data.width;
        }
      else
        width = 0, verticalData.forEach((t) => {
          const w = t.direction === TextDirection.HORIZONTAL ? fontSize : textMeasure.measureTextWidth(t.text, {
            fontSize,
            fontWeight,
            fontFamily
          });
          width += w, t.width = w;
        });
    }), this.cache.verticalList = verticalLists, this.clearUpdateShapeTag(), this.cache.verticalList.forEach((item) => {
      const w = item.reduce((a3, b) => a3 + b.width, 0);
      width = max(w, width);
    });
    const dx = textDrawOffsetX(textAlign, width), height = this.cache.verticalList.length * lineHeight, dy = textLayoutOffsetY(textBaseline, height, fontSize);
    return this._AABBBounds.set(dy, dx, dy + height, dx + width), stroke2 && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
  }
  tryUpdateOBBBounds() {
    throw new Error("\u6682\u4E0D\u652F\u6301");
  }
  getDefaultAttribute(name) {
    return getTheme(this).text[name];
  }
  needUpdateTags(keys2, k2 = TEXT_UPDATE_TAG_KEY) {
    return super.needUpdateTags(keys2, k2);
  }
  needUpdateTag(key, k2 = TEXT_UPDATE_TAG_KEY) {
    return super.needUpdateTag(key, k2);
  }
  clone() {
    return new _Text(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Text.NOWORK_ANIMATE_ATTR;
  }
};
Text.NOWORK_ANIMATE_ATTR = Object.assign({
  ellipsis: 1,
  wordBreak: 1,
  direction: 1,
  textAlign: 1,
  textBaseline: 1,
  fontFamily: 1,
  fontWeight: 1
}, NOWORK_ANIMATE_ATTR), Text.baselineMapAlign = {
  top: "left",
  bottom: "right",
  middle: "center"
}, Text.alignMapBaseline = {
  left: "top",
  right: "bottom",
  center: "middle"
};
function createText(attributes) {
  return new Text(attributes);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/builtin-symbol/base
var BaseSymbol = class {
  bounds(size, bounds) {
    if (isNumber_default(size)) {
      const halfS = size / 2;
      bounds.x1 = -halfS, bounds.x2 = halfS, bounds.y1 = -halfS, bounds.y2 = halfS;
    } else
      bounds.x1 = -size[0] / 2, bounds.x2 = size[0] / 2, bounds.y1 = -size[1] / 2, bounds.y2 = size[1] / 2;
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/builtin-symbol/circle
function circle2(ctx, r, x, y, z) {
  return z ? ctx.arc(x, y, r, 0, tau, false, z) : ctx.arc(x, y, r, 0, tau), false;
}
var CircleSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "circle", this.pathStr = "M0.5,0A0.5,0.5,0,1,1,-0.5,0A0.5,0.5,0,1,1,0.5,0";
  }
  draw(ctx, size, x, y, z) {
    return circle2(ctx, size / 2, x, y, z);
  }
  drawOffset(ctx, size, x, y, offset, z) {
    return circle2(ctx, size / 2 + offset, x, y, z);
  }
  drawToSvgPath(size, x, y, z) {
    const r = size / 2;
    return `M ${x - r}, ${y} a ${r},${r} 0 1,0 ${2 * r},0 a ${r},${r} 0 1,0 -${2 * r},0`;
  }
};
var circle_default2 = new CircleSymbol();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/builtin-symbol/cross
function cross(ctx, r, x, y, z) {
  return ctx.moveTo(-3 * r + x, -r + y, z), ctx.lineTo(-r + x, -r + y, z), ctx.lineTo(-r + x, -3 * r + y, z), ctx.lineTo(r + x, -3 * r + y, z), ctx.lineTo(r + x, -r + y, z), ctx.lineTo(3 * r + x, -r + y, z), ctx.lineTo(3 * r + x, r + y, z), ctx.lineTo(r + x, r + y, z), ctx.lineTo(r + x, 3 * r + y, z), ctx.lineTo(-r + x, 3 * r + y, z), ctx.lineTo(-r + x, r + y, z), ctx.lineTo(-3 * r + x, r + y, z), ctx.closePath(), true;
}
function crossOffset(ctx, r, x, y, offset, z) {
  return ctx.moveTo(-3 * r + x - offset, -r + y - offset, z), ctx.lineTo(-r + x - offset, -r + y - offset, z), ctx.lineTo(-r + x - offset, -3 * r + y - offset, z), ctx.lineTo(r + x + offset, -3 * r + y - offset, z), ctx.lineTo(r + x + offset, -r + y - offset, z), ctx.lineTo(3 * r + x + offset, -r + y - offset, z), ctx.lineTo(3 * r + x + offset, r + y + offset, z), ctx.lineTo(r + x + offset, r + y + offset, z), ctx.lineTo(r + x + offset, 3 * r + y + offset, z), ctx.lineTo(-r + x - offset, 3 * r + y + offset, z), ctx.lineTo(-r + x - offset, r + y + offset, z), ctx.lineTo(-3 * r + x - offset, r + y + offset, z), ctx.closePath(), true;
}
var CrossSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "cross", this.pathStr = "M-0.5,-0.2L-0.5,0.2L-0.2,0.2L-0.2,0.5L0.2,0.5L0.2,0.2L0.5,0.2L0.5,-0.2L0.2,-0.2L0.2,-0.5L-0.2,-0.5L-0.2,-0.2Z";
  }
  draw(ctx, size, x, y, z) {
    return cross(ctx, size / 6, x, y, z);
  }
  drawOffset(ctx, size, x, y, offset, z) {
    return crossOffset(ctx, size / 6, x, y, offset, z);
  }
};
var cross_default2 = new CrossSymbol();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/builtin-symbol/diamond
function diamond(ctx, r, x, y, z) {
  return ctx.moveTo(x, y - r, z), ctx.lineTo(r + x, y, z), ctx.lineTo(x, y + r, z), ctx.lineTo(x - r, y, z), ctx.closePath(), true;
}
var DiamondSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "diamond", this.pathStr = "M-0.5,0L0,-0.5L0.5,0L0,0.5Z";
  }
  draw(ctx, size, x, y, z) {
    return diamond(ctx, size / 2, x, y, z);
  }
  drawFitDir(ctx, size, x, y, z) {
    return diamond(ctx, size / 2, x, y, z);
  }
  drawOffset(ctx, size, x, y, offset, z) {
    return diamond(ctx, size / 2 + offset, x, y, z);
  }
};
var diamond_default = new DiamondSymbol();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/builtin-symbol/square
function square(ctx, r, x, y) {
  const wh = 2 * r;
  return ctx.rect(x - r, y - r, wh, wh), false;
}
var SquareSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "square", this.pathStr = "M-0.5,-0.5h1v1h-1Z";
  }
  draw(ctx, size, x, y) {
    return square(ctx, size / 2, x, y);
  }
  drawOffset(ctx, size, x, y, offset) {
    return square(ctx, size / 2 + offset, x, y);
  }
};
var square_default = new SquareSymbol();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/builtin-symbol/triangle-up
function trianglUp(ctx, r, x, y) {
  return ctx.moveTo(x + r, r + y), ctx.lineTo(x - r, r + y), ctx.lineTo(x, y - r), ctx.closePath(), true;
}
function trianglUpOffset(ctx, r, x, y, offset) {
  return ctx.moveTo(x + r + 2 * offset, r + y + offset), ctx.lineTo(x - r - 2 * offset, r + y + offset), ctx.lineTo(x, y - r - 2 * offset), ctx.closePath(), true;
}
var TriangleUpSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "triangleUp", this.pathStr = "M0.5,0.5 L-0.5,0.5 L0,-0.5 Z";
  }
  draw(ctx, size, x, y) {
    return trianglUp(ctx, size / 2, x, y);
  }
  drawOffset(ctx, size, x, y, offset) {
    return trianglUpOffset(ctx, size / 2, x, y, offset);
  }
};
var triangle_up_default = new TriangleUpSymbol();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/builtin-symbol/triangle
var TriangleSymbol = class extends TriangleUpSymbol {
  constructor() {
    super(...arguments), this.type = "triangle";
  }
};
var triangle_default = new TriangleSymbol();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/builtin-symbol/star
var kr = Math.sin(Math.PI / 10) / Math.sin(7 * Math.PI / 10);
var kx = Math.sin(tau / 10) * kr;
var ky = -Math.cos(tau / 10) * kr;
function star(ctx, r, transX, transY) {
  const x = kx * r, y = ky * r;
  ctx.moveTo(transX, -r + transY), ctx.lineTo(x + transX, y + transY);
  for (let i = 1; i < 5; ++i) {
    const a3 = tau * i / 5, c3 = Math.cos(a3), s2 = Math.sin(a3);
    ctx.lineTo(s2 * r + transX, -c3 * r + transY), ctx.lineTo(c3 * x - s2 * y + transX, s2 * x + c3 * y + transY);
  }
  return ctx.closePath(), true;
}
var StarSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "star", this.pathStr = "M0 -1L0.22451398828979266 -0.3090169943749474L0.9510565162951535 -0.30901699437494745L0.3632712640026804 0.1180339887498948L0.5877852522924732 0.8090169943749473L8.326672684688674e-17 0.3819660112501051L-0.587785252292473 0.8090169943749476L-0.3632712640026804 0.11803398874989487L-0.9510565162951536 -0.30901699437494723L-0.22451398828979274 -0.30901699437494734Z";
  }
  draw(ctx, size, transX, transY) {
    return star(ctx, size / 2, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return star(ctx, size / 2 + offset, transX, transY);
  }
};
var star_default = new StarSymbol();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/builtin-symbol/arrow
var sqrt3 = sqrt(3);
function arrow(ctx, r, transX, transY) {
  const triangleH = r, trangleBottomSide = triangleH / sqrt3, rectW = trangleBottomSide / 5, rectH = r;
  return ctx.moveTo(0 + transX, -triangleH + transY), ctx.lineTo(trangleBottomSide / 2 + transX, transY), ctx.lineTo(rectW / 2 + transX, transY), ctx.lineTo(rectW / 2 + transX, rectH + transY), ctx.lineTo(-rectW / 2 + transX, rectH + transY), ctx.lineTo(-rectW / 2 + transX, transY), ctx.lineTo(-trangleBottomSide / 2 + transX, transY), ctx.closePath(), true;
}
var ArrowSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "arrow", this.pathStr = "M-0.07142857142857142,0.5L0.07142857142857142,0.5L0.07142857142857142,-0.0625L0.2,-0.0625L0,-0.5L-0.2,-0.0625L-0.07142857142857142,-0.0625Z";
  }
  draw(ctx, size, transX, transY) {
    return arrow(ctx, size / 2, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return arrow(ctx, size / 2 + offset, transX, transY);
  }
};
var arrow_default = new ArrowSymbol();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/builtin-symbol/wedge
function wedge(ctx, r, transX, transY) {
  const h = 2 * r;
  return ctx.moveTo(transX, -r + transY), ctx.lineTo(h / 3 / 2 + transX, r + transY), ctx.lineTo(-h / 3 / 2 + transX, r + transY), ctx.closePath(), true;
}
var WedgeSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "wedge", this.pathStr = "M0,-0.5773502691896257L-0.125,0.28867513459481287L0.125,0.28867513459481287Z";
  }
  draw(ctx, size, transX, transY) {
    return wedge(ctx, size / 2, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return wedge(ctx, size / 2 + offset, transX, transY);
  }
};
var wedge_default = new WedgeSymbol();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/builtin-symbol/stroke
function stroke(ctx, r, transX, transY) {
  return ctx.moveTo(-r + transX, transY), ctx.lineTo(transX, r + transY), false;
}
var StrokeSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "stroke", this.pathStr = "";
  }
  draw(ctx, size, transX, transY) {
    return stroke(ctx, size / 2, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return stroke(ctx, size / 2 + offset, transX, transY);
  }
};
var stroke_default = new StrokeSymbol();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/builtin-symbol/wye
var c = -0.5;
var s = sqrt(3) / 2;
var k = 1 / sqrt(12);
var a = 3 * (k / 2 + 1);
function wye(ctx, r, transX, transY) {
  const x05 = r / 2, y05 = r * k, x14 = x05, y14 = r * k + r, x23 = -x14, y23 = y14;
  return ctx.moveTo(x05 + transX, y05 + transY), ctx.lineTo(x14 + transX, y14 + transY), ctx.lineTo(x23 + transX, y23 + transY), ctx.lineTo(c * x05 - s * y05 + transX, s * x05 + c * y05 + transY), ctx.lineTo(c * x14 - s * y14 + transX, s * x14 + c * y14 + transY), ctx.lineTo(c * x23 - s * y23 + transX, s * x23 + c * y23 + transY), ctx.lineTo(c * x05 + s * y05 + transX, c * y05 - s * x05 + transY), ctx.lineTo(c * x14 + s * y14 + transX, c * y14 - s * x14 + transY), ctx.lineTo(c * x23 + s * y23 + transX, c * y23 - s * x23 + transY), ctx.closePath(), false;
}
var WyeSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "wye", this.pathStr = "M0.25 0.14433756729740646L0.25 0.6443375672974064L-0.25 0.6443375672974064L-0.25 0.14433756729740643L-0.6830127018922193 -0.10566243270259357L-0.4330127018922193 -0.5386751345948129L0 -0.28867513459481287L0.4330127018922193 -0.5386751345948129L0.6830127018922193 -0.10566243270259357Z";
  }
  draw(ctx, size, transX, transY) {
    return wye(ctx, size / 2, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return wye(ctx, size / 2 + offset, transX, transY);
  }
};
var wye_default = new WyeSymbol();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/builtin-symbol/triangle-left
function trianglLeft(ctx, r, x, y) {
  return ctx.moveTo(-r + x, y), ctx.lineTo(r + x, r + y), ctx.lineTo(r + x, y - r), ctx.closePath(), true;
}
function trianglLeftOffset(ctx, r, x, y, offset) {
  return ctx.moveTo(-r + x - 2 * offset, y), ctx.lineTo(r + x + offset, r + y + 2 * offset), ctx.lineTo(r + x + offset, y - r - 2 * offset), ctx.closePath(), true;
}
var TriangleLeftSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "triangleLeft", this.pathStr = "M-0.5,0 L0.5,0.5 L0.5,-0.5 Z";
  }
  draw(ctx, size, x, y) {
    return trianglLeft(ctx, size / 2, x, y);
  }
  drawOffset(ctx, size, x, y, offset) {
    return trianglLeftOffset(ctx, size / 2, x, y, offset);
  }
};
var triangle_left_default = new TriangleLeftSymbol();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/builtin-symbol/triangle-right
function trianglRight(ctx, r, x, y) {
  return ctx.moveTo(x - r, r + y), ctx.lineTo(r + x, y), ctx.lineTo(x - r, y - r), ctx.closePath(), true;
}
function trianglRightOffset(ctx, r, x, y, offset) {
  return ctx.moveTo(x - r - offset, r + y + 2 * offset), ctx.lineTo(r + x + 2 * offset, y), ctx.lineTo(x - r - offset, y - r - 2 * offset), ctx.closePath(), true;
}
var TriangleRightSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "triangleRight", this.pathStr = "M-0.5,0.5 L0.5,0 L-0.5,-0.5 Z";
  }
  draw(ctx, size, x, y) {
    return trianglRight(ctx, size / 2, x, y);
  }
  drawOffset(ctx, size, x, y, offset) {
    return trianglRightOffset(ctx, size / 2, x, y, offset);
  }
};
var triangle_right_default = new TriangleRightSymbol();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/builtin-symbol/triangle-down
function trianglDown(ctx, r, x, y) {
  return ctx.moveTo(x - r, y - r), ctx.lineTo(x + r, y - r), ctx.lineTo(x, y + r), ctx.closePath(), true;
}
function trianglDownOffset(ctx, r, x, y, offset) {
  return ctx.moveTo(x - r - 2 * offset, y - r - offset), ctx.lineTo(x + r + 2 * offset, y - r - offset), ctx.lineTo(x, y + r + 2 * offset), ctx.closePath(), true;
}
var TriangleDownSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "triangleDown", this.pathStr = "M-0.5,-0.5 L0.5,-0.5 L0,0.5 Z";
  }
  draw(ctx, size, x, y) {
    return trianglDown(ctx, size / 2, x, y);
  }
  drawOffset(ctx, size, x, y, offset) {
    return trianglDownOffset(ctx, size / 2, x, y, offset);
  }
};
var triangle_down_default = new TriangleDownSymbol();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/builtin-symbol/thin-triangle
var sqrt32 = sqrt(3);
function thinTriangle(ctx, r, x, y) {
  const h = r * sqrt32;
  return ctx.moveTo(x, y + -h / 3 * 2), ctx.lineTo(r + x, y + h), ctx.lineTo(x - r, y + h), ctx.closePath(), true;
}
var ThinTriangleSymbol = class extends TriangleUpSymbol {
  constructor() {
    super(...arguments), this.type = "thinTriangle", this.pathStr = "M0,-0.5773502691896257L-0.5,0.28867513459481287L0.5,0.28867513459481287Z";
  }
  draw(ctx, size, x, y) {
    return thinTriangle(ctx, size / 2 / sqrt32, x, y);
  }
  drawOffset(ctx, size, x, y, offset) {
    return thinTriangle(ctx, size / 2 / sqrt32 + offset, x, y);
  }
};
var thin_triangle_default = new ThinTriangleSymbol();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/builtin-symbol/arrow2-left
function arrow2Left(ctx, r, transX, transY) {
  const r2 = 2 * r;
  return ctx.moveTo(r + transX, transY - r2), ctx.lineTo(transX - r, transY), ctx.lineTo(r + transX, r2 + transY), true;
}
var Arrow2LeftSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "arrow2Left", this.pathStr = "M 0.25 -0.5 L -0.25 0 l 0.25 0.5";
  }
  draw(ctx, size, transX, transY) {
    return arrow2Left(ctx, size / 4, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return arrow2Left(ctx, size / 4 + offset, transX, transY);
  }
};
var arrow2_left_default = new Arrow2LeftSymbol();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/builtin-symbol/arrow2-right
function arrow2Right(ctx, r, transX, transY) {
  const r2 = 2 * r;
  return ctx.moveTo(transX - r, transY - r2), ctx.lineTo(transX + r, transY), ctx.lineTo(transX - r, r2 + transY), true;
}
var Arrow2RightSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "arrow2Right", this.pathStr = "M -0.25 -0.5 l 0.25 0 l -0.25 0.5";
  }
  draw(ctx, size, transX, transY) {
    return arrow2Right(ctx, size / 4, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return arrow2Right(ctx, size / 4 + offset, transX, transY);
  }
};
var arrow2_right_default = new Arrow2RightSymbol();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/builtin-symbol/arrow2-up
function arrow2Up(ctx, r, transX, transY) {
  const r2 = 2 * r;
  return ctx.moveTo(transX - r2, transY + r), ctx.lineTo(transX, transY - r), ctx.lineTo(transX + r2, transY + r), true;
}
var Arrow2UpSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "arrow2Up", this.pathStr = "M -0.5 0.25 L 0 -0.25 l 0.5 0.25";
  }
  draw(ctx, size, transX, transY) {
    return arrow2Up(ctx, size / 4, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return arrow2Up(ctx, size / 4 + offset, transX, transY);
  }
};
var arrow2_up_default = new Arrow2UpSymbol();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/builtin-symbol/arrow2-down
function arrow2Down(ctx, r, transX, transY) {
  const r2 = 2 * r;
  return ctx.moveTo(transX - r2, transY - r), ctx.lineTo(transX, transY + r), ctx.lineTo(transX + r2, transY - r), true;
}
var Arrow2DownSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "arrow2Down", this.pathStr = "M -0.5 -0.25 L 0 0.25 l 0.5 -0.25";
  }
  draw(ctx, size, transX, transY) {
    return arrow2Down(ctx, size / 4, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return arrow2Down(ctx, size / 4 + offset, transX, transY);
  }
};
var arrow2_down_default = new Arrow2DownSymbol();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/builtin-symbol/line-v
function lineV(ctx, r, x, y, z) {
  return ctx.moveTo(x, y - r), ctx.lineTo(x, y + r), true;
}
var LineVSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "lineV", this.pathStr = "M0,-0.5L0,0.5";
  }
  draw(ctx, size, x, y, z) {
    return lineV(ctx, size / 2, x, y, z);
  }
  drawOffset(ctx, size, x, y, offset, z) {
    return lineV(ctx, size / 2 + offset, x, y, z);
  }
  drawToSvgPath(size, x, y, z) {
    const r = size / 2;
    return `M ${x}, ${y - r} L ${x},${y + r}`;
  }
};
var line_v_default = new LineVSymbol();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/builtin-symbol/line-h
function lineH(ctx, r, x, y, z) {
  return ctx.moveTo(x - r, y), ctx.lineTo(x + r, y), true;
}
var LineHSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "lineH", this.pathStr = "M-0.5,0L0.5,0";
  }
  draw(ctx, size, x, y, z) {
    return lineH(ctx, size / 2, x, y, z);
  }
  drawOffset(ctx, size, x, y, offset, z) {
    return lineH(ctx, size / 2 + offset, x, y, z);
  }
  drawToSvgPath(size, x, y, z) {
    const r = size / 2;
    return `M ${x - r}, ${y} L ${x + r},${y}`;
  }
};
var line_h_default = new LineHSymbol();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/builtin-symbol/close
function close(ctx, r, x, y, z) {
  return ctx.moveTo(x - r, y - r), ctx.lineTo(x + r, y + r), ctx.moveTo(x + r, y - r), ctx.lineTo(x - r, y + r), true;
}
var CloseSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "close", this.pathStr = "M-0.5,-0.5L0.5,0.5,M0.5,-0.5L-0.5,0.5";
  }
  draw(ctx, size, x, y, z) {
    return close(ctx, size / 2, x, y, z);
  }
  drawOffset(ctx, size, x, y, offset, z) {
    return close(ctx, size / 2 + offset, x, y, z);
  }
  drawToSvgPath(size, x, y, z) {
    const r = size / 2;
    return `M ${x - r}, ${y - r} L ${x + r},${y + r} M ${x + r}, ${y - r} L ${x - r},${y + r}`;
  }
};
var close_default = new CloseSymbol();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/builtin-symbol/rect
function rectSizeArray(ctx, size, x, y) {
  return ctx.rect(x - size[0] / 2, y - size[1] / 2, size[0], size[1]), false;
}
function rectSize(ctx, size, x, y) {
  const w = size, h = size / 2;
  return ctx.rect(x - w / 2, y - h / 2, w, h), false;
}
var RectSymbol = class extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "rect", this.pathStr = "M -0.5,0.25 L 0.5,0.25 L 0.5,-0.25,L -0.5,-0.25 Z";
  }
  draw(ctx, size, x, y) {
    return isNumber_default(size) ? rectSize(ctx, size, x, y) : rectSizeArray(ctx, size, x, y);
  }
  drawOffset(ctx, size, x, y, offset) {
    return isNumber_default(size) ? rectSize(ctx, size + 2 * offset, x, y) : rectSizeArray(ctx, [size[0] + 2 * offset, size[1] + 2 * offset], x, y);
  }
};
var rect_default = new RectSymbol();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/builtin-symbol/utils
var tempBounds2 = new AABBBounds();
var CustomSymbolClass = class {
  constructor(type, path, isSvg2 = false) {
    this.pathStr = "", this.type = type, isArray_default(path) ? this.svgCache = path : this.path = path, this.isSvg = isSvg2;
  }
  drawOffset(ctx, size, x, y, offset, z, cb) {
    return this.isSvg ? !!this.svgCache && (this.svgCache.forEach((item) => {
      ctx.beginPath(), renderCommandList(item.path.commandList, ctx, x, y, size, size), cb && cb(item.path, item.attribute);
    }), false) : (renderCommandList(this.path.commandList, ctx, x, y, size + offset, size + offset), false);
  }
  draw(ctx, size, x, y, z, cb) {
    return this.isSvg ? !!this.svgCache && (this.svgCache.forEach((item) => {
      ctx.beginPath(), renderCommandList(item.path.commandList, ctx, x, y, size, size), cb && cb(item.path, item.attribute);
    }), false) : (renderCommandList(this.path.commandList, ctx, x, y, size, size), false);
  }
  bounds(size, bounds) {
    if (this.isSvg) {
      if (!this.svgCache)
        return;
      return bounds.clear(), void this.svgCache.forEach(({ path }) => {
        tempBounds2.x1 = path.bounds.x1 * size, tempBounds2.y1 = path.bounds.y1 * size, tempBounds2.x2 = path.bounds.x2 * size, tempBounds2.y2 = path.bounds.y2 * size, bounds.union(tempBounds2);
      });
    }
    this.path.bounds && (bounds.x1 = this.path.bounds.x1 * size, bounds.y1 = this.path.bounds.y1 * size, bounds.x2 = this.path.bounds.x2 * size, bounds.y2 = this.path.bounds.y2 * size);
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/builtin-symbol
var builtinSymbols = [circle_default2, cross_default2, diamond_default, square_default, thin_triangle_default, triangle_default, star_default, arrow_default, wedge_default, stroke_default, wye_default, triangle_left_default, triangle_right_default, triangle_up_default, triangle_down_default, arrow2_left_default, arrow2_right_default, arrow2_up_default, arrow2_down_default, rect_default, line_v_default, line_h_default, close_default];
var builtinSymbolsMap = {};
builtinSymbols.forEach((symbol) => {
  builtinSymbolsMap[symbol.type] = symbol;
});
var builtInSymbolStrMap = {
  arrowLeft: "M 0.25 -0.5 L -0.25 0 l 0.5 0.5",
  arrowRight: "M -0.25 -0.5 l 0.5 0.5 l -0.5 0.5",
  rectRound: "M 0.3 -0.5 C 0.41 -0.5 0.5 -0.41 0.5 -0.3 C 0.5 -0.3 0.5 0.3 0.5 0.3 C 0.5 0.41 0.41 0.5 0.3 0.5 C 0.3 0.5 -0.3 0.5 -0.3 0.5 C -0.41 0.5 -0.5 0.41 -0.5 0.3 C -0.5 0.3 -0.5 -0.3 -0.5 -0.3 C -0.5 -0.41 -0.41 -0.5 -0.3 -0.5 C -0.3 -0.5 0.3 -0.5 0.3 -0.5 Z",
  roundLine: "M 1.2392 -0.258 L -1.3432 -0.258 C -1.4784 -0.258 -1.588 -0.1436 -1.588 -0.002 c 0 0.1416 0.1096 0.256 0.2448 0.256 l 2.5824 0 c 0.1352 0 0.2448 -0.1144 0.2448 -0.256 C 1.484 -0.1436 1.3744 -0.258 1.2392 -0.258 z"
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/symbol
var _tempBounds = new AABBBounds();
var SYMBOL_UPDATE_TAG_KEY = ["symbolType", "size", ...GRAPHIC_UPDATE_TAG_KEY];
var Symbol2 = class _Symbol extends Graphic {
  constructor(params2 = {
    symbolType: "circle"
  }) {
    super(params2), this.type = "symbol", this.numberType = SYMBOL_NUMBER_TYPE;
  }
  getParsedPath() {
    return this.shouldUpdateShape() && (this.doUpdateParsedPath(), this.clearUpdateShapeTag()), this._parsedPath;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const { size } = this.attribute;
    return isArray_default(size) ? 2 === size.length && size.every(this._validNumber) : this._validNumber(size);
  }
  doUpdateParsedPath() {
    const symbolTheme = getTheme(this).symbol;
    let { symbolType = symbolTheme.symbolType } = this.attribute, path = builtinSymbolsMap[symbolType];
    if (path)
      return this._parsedPath = path, path;
    if (path = _Symbol.userSymbolMap[symbolType], path)
      return this._parsedPath = path, path;
    symbolType = builtInSymbolStrMap[symbolType] || symbolType;
    if (true === isSvg(symbolType)) {
      const parser = new XMLParser(), { svg } = parser.parse(symbolType);
      if (!svg)
        return null;
      const path2 = isArray_default(svg.path) ? svg.path : [svg.path];
      _tempBounds.clear();
      const cacheList = [];
      path2.forEach((item) => {
        const cache2 = new CustomPath2D().fromString(item.d), attribute = {};
        SVG_PARSE_ATTRIBUTE_MAP_KEYS.forEach((k2) => {
          item[k2] && (attribute[SVG_PARSE_ATTRIBUTE_MAP[k2]] = item[k2]);
        }), cacheList.push({
          path: cache2,
          attribute
        }), _tempBounds.union(cache2.bounds);
      });
      const width2 = _tempBounds.width(), height2 = _tempBounds.height(), scale5 = 1 / max(width2, height2);
      return cacheList.forEach((cache2) => cache2.path.transform(0, 0, scale5, scale5)), this._parsedPath = new CustomSymbolClass(symbolType, cacheList, true), _Symbol.userSymbolMap[symbolType] = this._parsedPath, this._parsedPath;
    }
    const cache = new CustomPath2D().fromString(symbolType), width = cache.bounds.width(), height = cache.bounds.height(), scale4 = 1 / max(width, height);
    return cache.transform(0, 0, scale4, scale4), this._parsedPath = new CustomSymbolClass(symbolType, cache), _Symbol.userSymbolMap[symbolType] = this._parsedPath, this._parsedPath;
  }
  doUpdateAABBBounds(full) {
    const symbolTheme = getTheme(this).symbol;
    this._AABBBounds.clear();
    const attribute = this.attribute, bounds = application.graphicService.updateSymbolAABBBounds(attribute, getTheme(this).symbol, this._AABBBounds, full, this), { boundsPadding = symbolTheme.boundsPadding } = attribute, paddingArray = parsePadding(boundsPadding);
    return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
  }
  tryUpdateOBBBounds() {
    throw new Error("\u6682\u4E0D\u652F\u6301");
  }
  getDefaultAttribute(name) {
    return getTheme(this).symbol[name];
  }
  needUpdateTags(keys2) {
    return super.needUpdateTags(keys2, SYMBOL_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, SYMBOL_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    const symbolInstance = this.getParsedPath(), size = this.attribute.size, formattedSize = isArray_default(size) ? size : [size, size];
    return symbolInstance.path ? new CustomPath2D().fromCustomPath2D(symbolInstance.path, 0, 0, formattedSize[0], formattedSize[1]) : new CustomPath2D().fromString(symbolInstance.pathStr, 0, 0, formattedSize[0], formattedSize[1]);
  }
  clone() {
    return new _Symbol(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Symbol.NOWORK_ANIMATE_ATTR;
  }
};
Symbol2.userSymbolMap = {}, Symbol2.NOWORK_ANIMATE_ATTR = Object.assign({
  symbolType: 1
}, NOWORK_ANIMATE_ATTR);
function createSymbol(attributes) {
  return new Symbol2(attributes);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/line
var LINE_UPDATE_TAG_KEY = ["segments", "points", "curveType", ...GRAPHIC_UPDATE_TAG_KEY];
var Line = class _Line extends Graphic {
  constructor(params2 = {}) {
    super(params2), this.type = "line", this.numberType = LINE_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    if (this.pathProxy)
      return true;
    const { points, segments: segments2 } = this.attribute;
    return segments2 ? 0 !== segments2.length : !!points && !(points.length <= 1);
  }
  _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
    "points" === key && (nextAttributes.points = pointsInterpolation(lastStepVal, nextStepVal, ratio));
  }
  doUpdateAABBBounds() {
    const lineTheme = getTheme(this).line;
    this._AABBBounds.clear();
    const attribute = this.attribute, bounds = application.graphicService.updateLineAABBBounds(attribute, getTheme(this).line, this._AABBBounds, this), { boundsPadding = lineTheme.boundsPadding } = attribute, paddingArray = parsePadding(boundsPadding);
    return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
  }
  tryUpdateOBBBounds() {
    throw new Error("\u6682\u4E0D\u652F\u6301");
  }
  getDefaultAttribute(name) {
    return getTheme(this).line[name];
  }
  needUpdateTags(keys2) {
    return super.needUpdateTags(keys2, LINE_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, LINE_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    const attribute = this.attribute, path = new CustomPath2D(), segments2 = attribute.segments, parsePoints = (points) => {
      if (points && points.length) {
        let isFirst = true;
        points.forEach((point5) => {
          false !== point5.defined && (isFirst ? path.moveTo(point5.x, point5.y) : path.lineTo(point5.x, point5.y), isFirst = false);
        });
      }
    };
    return segments2 && segments2.length ? segments2.forEach((seg) => {
      parsePoints(seg.points);
    }) : attribute.points && parsePoints(attribute.points), path;
  }
  clone() {
    return new _Line(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Line.NOWORK_ANIMATE_ATTR;
  }
};
Line.NOWORK_ANIMATE_ATTR = Object.assign({
  segments: 1,
  curveType: 1
}, NOWORK_ANIMATE_ATTR);
function createLine(attributes) {
  return new Line(attributes);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/rect
var RECT_UPDATE_TAG_KEY = ["width", "x1", "y1", "height", "cornerRadius", ...GRAPHIC_UPDATE_TAG_KEY];
var Rect = class _Rect extends Graphic {
  constructor(params2) {
    super(params2), this.type = "rect", this.numberType = RECT_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    return true;
  }
  doUpdateAABBBounds() {
    const rectTheme = getTheme(this).rect;
    this._AABBBounds.clear();
    const attribute = this.attribute, bounds = application.graphicService.updateRectAABBBounds(attribute, getTheme(this).rect, this._AABBBounds, this), { boundsPadding = rectTheme.boundsPadding } = attribute, paddingArray = parsePadding(boundsPadding);
    return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
  }
  tryUpdateOBBBounds() {
    throw new Error("\u6682\u4E0D\u652F\u6301");
  }
  getDefaultAttribute(name) {
    return getTheme(this).rect[name];
  }
  needUpdateTags(keys2) {
    return super.needUpdateTags(keys2, RECT_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, RECT_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    const attribute = this.attribute, { x, y, width, height } = normalizeRectAttributes(attribute), path = new CustomPath2D();
    return path.moveTo(x, y), path.rect(x, y, width, height), path;
  }
  clone() {
    return new _Rect(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Rect.NOWORK_ANIMATE_ATTR;
  }
};
Rect.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createRect(attributes) {
  return new Rect(attributes);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/rect3d
var CUBE_VERTICES = [[0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0], [0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 1, 1]];
var Rect3d = class _Rect3d extends Rect {
  constructor(params2) {
    super(params2), this.type = "rect3d", this.numberType = RECT3D_NUMBER_TYPE;
  }
  findFace() {
    const faces = {
      polygons: [],
      vertices: [],
      edges: []
    }, rectTheme = getTheme(this).rect, { x1: x14, y1: y14, x, y, length: length2 = min(rectTheme.width, rectTheme.height) } = this.attribute;
    let { width, height } = this.attribute;
    width = null != width ? width : x14 - x, height = null != height ? height : y14 - y;
    for (let i = 0; i < CUBE_VERTICES.length; i++) {
      const v = CUBE_VERTICES[i];
      faces.vertices.push([v[0] * width, v[1] * height, v[2] * length2]);
    }
    return faces.polygons.push({
      polygon: [0, 1, 5, 4],
      normal: [0, -1, 0]
    }), faces.polygons.push({
      polygon: [2, 3, 7, 6],
      normal: [0, 1, 0]
    }), faces.polygons.push({
      polygon: [4, 7, 3, 0],
      normal: [-1, 0, 0]
    }), faces.polygons.push({
      polygon: [1, 2, 6, 5],
      normal: [1, 0, 0]
    }), faces.polygons.push({
      polygon: [0, 1, 2, 3],
      normal: [0, 0, -1]
    }), faces.polygons.push({
      polygon: [4, 5, 6, 7],
      normal: [0, 0, 1]
    }), faces.edges = [[0, 1], [1, 2], [2, 3], [3, 0], [4, 5], [5, 6], [6, 7], [7, 4], [0, 4], [3, 7], [1, 5], [2, 6]], faces;
  }
  getNoWorkAnimateAttr() {
    return _Rect3d.NOWORK_ANIMATE_ATTR;
  }
};
Rect3d.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/glyph
var Glyph = class _Glyph extends Graphic {
  constructor(params2) {
    super(params2), this.type = "glyph", this.numberType = GLYPH_NUMBER_TYPE, this.subGraphic = [], this._onInit && this._onInit(this), this.valid = this.isValid();
  }
  setSubGraphic(subGraphic) {
    this.detachSubGraphic(), this.subGraphic = subGraphic, subGraphic.forEach((g) => {
      g.glyphHost = this, Object.setPrototypeOf(g.attribute, this.attribute);
    }), this.valid = this.isValid(), this.addUpdateBoundTag();
  }
  detachSubGraphic() {
    this.subGraphic.forEach((g) => {
      g.glyphHost = null, Object.setPrototypeOf(g.attribute, {});
    });
  }
  getSubGraphic() {
    return this.subGraphic;
  }
  onInit(cb) {
    this._onInit = cb;
  }
  onUpdate(cb) {
    this._onUpdate = cb;
  }
  isValid() {
    return true;
  }
  setAttribute(key, value, forceUpdateTag, context) {
    super.setAttribute(key, value, forceUpdateTag, context), this.subGraphic.forEach((g) => {
      g.addUpdateShapeAndBoundsTag(), g.addUpdatePositionTag();
    });
  }
  setAttributes(params2, forceUpdateTag = false, context) {
    super.setAttributes(params2, forceUpdateTag, context), this.subGraphic.forEach((g) => {
      g.addUpdateShapeAndBoundsTag(), g.addUpdatePositionTag();
    });
  }
  translate(x, y) {
    return super.translate(x, y), this.subGraphic.forEach((g) => {
      g.addUpdatePositionTag(), g.addUpdateBoundTag();
    }), this;
  }
  translateTo(x, y) {
    return super.translateTo(x, y), this.subGraphic.forEach((g) => {
      g.addUpdatePositionTag(), g.addUpdateBoundTag();
    }), this;
  }
  scale(scaleX, scaleY, scaleCenter) {
    return super.scale(scaleX, scaleY, scaleCenter), this.subGraphic.forEach((g) => {
      g.addUpdatePositionTag(), g.addUpdateBoundTag();
    }), this;
  }
  scaleTo(scaleX, scaleY) {
    return super.scaleTo(scaleX, scaleY), this.subGraphic.forEach((g) => {
      g.addUpdatePositionTag(), g.addUpdateBoundTag();
    }), this;
  }
  rotate(angle2) {
    return super.rotate(angle2), this.subGraphic.forEach((g) => {
      g.addUpdatePositionTag(), g.addUpdateBoundTag();
    }), this;
  }
  rotateTo(angle2) {
    return super.rotate(angle2), this.subGraphic.forEach((g) => {
      g.addUpdatePositionTag(), g.addUpdateBoundTag();
    }), this;
  }
  doUpdateAABBBounds() {
    this._AABBBounds.clear();
    const bounds = application.graphicService.updateGlyphAABBBounds(this.attribute, getTheme(this).glyph, this._AABBBounds, this);
    return this.clearUpdateBoundTag(), bounds;
  }
  tryUpdateOBBBounds() {
    throw new Error("\u6682\u4E0D\u652F\u6301");
  }
  needUpdateTags(keys2) {
    return false;
  }
  needUpdateTag(key) {
    return false;
  }
  useStates(states, hasAnimation) {
    var _a;
    if (!states.length)
      return void this.clearStates(hasAnimation);
    if (!((null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.length) !== states.length || states.some((stateName, index) => this.currentStates[index] !== stateName)))
      return;
    this.stopStateAnimates();
    const stateAttrs = {}, subAttrs = this.subGraphic.map(() => ({}));
    states.forEach((stateName) => {
      var _a2;
      const attrs = this.glyphStateProxy ? this.glyphStateProxy(stateName, states) : this.glyphStates[stateName];
      attrs && (Object.assign(stateAttrs, attrs.attributes), (null === (_a2 = attrs.subAttributes) || void 0 === _a2 ? void 0 : _a2.length) && subAttrs.forEach((subAttrs2, index) => {
        Object.assign(subAttrs2, attrs.subAttributes[index]);
      }));
    }), this.subGraphic.forEach((graphic, index) => {
      graphic.updateNormalAttrs(subAttrs[index]), graphic.applyStateAttrs(subAttrs[index], states, hasAnimation);
    }), this.updateNormalAttrs(stateAttrs), this.currentStates = states, this.applyStateAttrs(stateAttrs, states, hasAnimation);
  }
  clearStates(hasAnimation) {
    this.stopStateAnimates(), this.hasState() && this.normalAttrs ? (this.currentStates = [], this.subGraphic.forEach((graphic) => {
      graphic.applyStateAttrs(graphic.normalAttrs, this.currentStates, hasAnimation, true), graphic.normalAttrs = null;
    }), this.applyStateAttrs(this.normalAttrs, this.currentStates, hasAnimation, true)) : this.currentStates = [], this.normalAttrs = null;
  }
  clone() {
    const glyph = new _Glyph(Object.assign({}, this.attribute));
    return glyph.setSubGraphic(this.subGraphic.map((g) => g.clone())), glyph;
  }
  getNoWorkAnimateAttr() {
    return _Glyph.NOWORK_ANIMATE_ATTR;
  }
};
Glyph.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/richtext/frame
var Frame = class {
  constructor(left2, top, width, height, ellipsis, wordBreak, verticalDirection, globalAlign, globalBaseline, layoutDirection, isWidthMax, isHeightMax, singleLine, icons) {
    this.left = left2, this.top = top, this.width = width, this.height = height, this.actualHeight = 0, this.bottom = top + height, this.right = left2 + width, this.ellipsis = ellipsis, this.wordBreak = wordBreak, this.verticalDirection = verticalDirection, this.lines = [], this.globalAlign = globalAlign, this.globalBaseline = globalBaseline, this.layoutDirection = layoutDirection, this.directionKey = DIRECTION_KEY[this.layoutDirection], this.isWidthMax = isWidthMax, this.isHeightMax = isHeightMax, this.singleLine = singleLine, icons ? (icons.clear(), this.icons = icons) : this.icons = /* @__PURE__ */ new Map();
  }
  draw(ctx, drawIcon) {
    const { width: actualWidth, height: actualHeight } = this.getActualSize(), width = this.isWidthMax ? Math.min(this.width, actualWidth) : this.width || actualWidth || 0;
    let height = this.isHeightMax ? Math.min(this.height, actualHeight) : this.height || actualHeight || 0;
    height = Math.min(height, actualHeight);
    let deltaY = 0;
    switch (this.globalBaseline) {
      case "top":
        deltaY = 0;
        break;
      case "middle":
        deltaY = -height / 2;
        break;
      case "bottom":
        deltaY = -height;
    }
    let deltaX = 0;
    "right" === this.globalAlign || "end" === this.globalAlign ? deltaX = -width : "center" === this.globalAlign && (deltaX = -width / 2);
    let frameHeight = this[this.directionKey.height];
    this.singleLine && (frameHeight = this.lines[0].height + 1);
    let lastLineTag = false;
    if ("middle" === this.verticalDirection)
      if (this.actualHeight >= frameHeight && 0 !== frameHeight)
        for (let i = 0; i < this.lines.length; i++) {
          const { top, height: height2 } = this.lines[i];
          if (top + height2 < this[this.directionKey.top] || top + height2 > this[this.directionKey.top] + frameHeight)
            return lastLineTag;
          let lastLine = false;
          this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight && (lastLine = true, lastLineTag = true), this.lines[i].draw(ctx, lastLine, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, this.ellipsis, drawIcon);
        }
      else {
        const detalHeight = Math.floor((frameHeight - this.actualHeight) / 2);
        "vertical" === this.layoutDirection ? deltaX += detalHeight : deltaY += detalHeight;
        for (let i = 0; i < this.lines.length; i++)
          this.lines[i].draw(ctx, false, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, this.ellipsis, drawIcon);
      }
    else if ("bottom" === this.verticalDirection && "vertical" !== this.layoutDirection)
      for (let i = 0; i < this.lines.length; i++) {
        const { top, height: height2 } = this.lines[i], y = frameHeight - this.lines[i].top - this.lines[i].height;
        if (0 === frameHeight)
          this.lines[i].draw(ctx, false, deltaX, y + deltaY, this.ellipsis, drawIcon);
        else {
          if (y + height2 > this[this.directionKey.top] + frameHeight || y < this[this.directionKey.top])
            return lastLineTag;
          {
            let lastLine = false;
            this.ellipsis && this.lines[i + 1] && y - this.lines[i + 1].height < this[this.directionKey.top] && (lastLine = true, lastLineTag = true), this.lines[i].draw(ctx, lastLine, deltaX, y + deltaY, this.ellipsis, drawIcon);
          }
        }
      }
    else {
      "bottom" === this.verticalDirection && "vertical" === this.layoutDirection && this.singleLine && this.isWidthMax && (deltaX += this.lines[0].height + 1);
      for (let i = 0; i < this.lines.length; i++) {
        "bottom" === this.verticalDirection && "vertical" === this.layoutDirection && (deltaX -= this.lines[i].height + this.lines[i].top);
        const { top, height: height2 } = this.lines[i];
        if (0 === frameHeight)
          this.lines[i].draw(ctx, false, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, this.ellipsis, drawIcon);
        else {
          if (top + height2 < this[this.directionKey.top] || top + height2 > this[this.directionKey.top] + frameHeight)
            return lastLineTag;
          {
            let lastLine = false;
            this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight && (lastLine = true, lastLineTag = true), this.lines[i].draw(ctx, lastLine, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, this.ellipsis, drawIcon);
          }
        }
      }
    }
    return lastLineTag;
  }
  getActualSize() {
    return this.ellipsis ? this.getActualSizeWidthEllipsis() : this.getRawActualSize();
  }
  getRawActualSize() {
    let width = 0, height = 0;
    for (let i = 0; i < this.lines.length; i++) {
      const line2 = this.lines[i];
      line2.actualWidth > width && (width = line2.actualWidth), height += line2.height;
    }
    return {
      width: "vertical" === this.layoutDirection ? height : width,
      height: "vertical" === this.layoutDirection ? width : height
    };
  }
  getActualSizeWidthEllipsis() {
    let widthBound = 0, heightBound = 0;
    const { width: actualWidth, height: actualHeight } = this.getRawActualSize();
    this.width;
    let height = this.height || actualHeight || 0;
    height = Math.min(height, actualHeight);
    let frameHeight = this[this.directionKey.height];
    if (this.singleLine && (frameHeight = this.lines[0].height + 1), "middle" === this.verticalDirection)
      if (this.actualHeight >= frameHeight && 0 !== frameHeight)
        for (let i = 0; i < this.lines.length; i++) {
          const { top, height: height2 } = this.lines[i];
          if (top + height2 < this[this.directionKey.top] || top + height2 > this[this.directionKey.top] + frameHeight)
            ;
          else if (this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight) {
            const ellipsis = true === this.ellipsis ? "..." : this.ellipsis || "", lineWidth = this.lines[i].getWidthWithEllips(ellipsis);
            lineWidth > widthBound && (widthBound = lineWidth), heightBound += this.lines[i].height;
          } else
            this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
        }
      else {
        Math.floor((frameHeight - this.actualHeight) / 2);
        for (let i = 0; i < this.lines.length; i++)
          this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
      }
    else if ("bottom" === this.verticalDirection)
      for (let i = 0; i < this.lines.length; i++) {
        const { top, height: height2 } = this.lines[i], y = frameHeight - this.lines[i].top - this.lines[i].height;
        if (0 === frameHeight)
          this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
        else if (y + height2 > this[this.directionKey.top] + frameHeight || y < this[this.directionKey.top])
          ;
        else {
          if (this.ellipsis && this.lines[i + 1] && y - this.lines[i + 1].height < this[this.directionKey.top]) {
            const ellipsis = true === this.ellipsis ? "..." : this.ellipsis || "", lineWidth = this.lines[i].getWidthWithEllips(ellipsis);
            lineWidth > widthBound && (widthBound = lineWidth), heightBound += this.lines[i].height;
          } else
            this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
        }
      }
    else
      for (let i = 0; i < this.lines.length; i++) {
        const { top, height: height2 } = this.lines[i];
        if (0 === frameHeight)
          this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
        else if (top + height2 < this[this.directionKey.top] || top + height2 > this[this.directionKey.top] + frameHeight)
          ;
        else {
          if (this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight) {
            const ellipsis = true === this.ellipsis ? "..." : this.ellipsis || "", lineWidth = this.lines[i].getWidthWithEllips(ellipsis);
            lineWidth > widthBound && (widthBound = lineWidth), heightBound += this.lines[i].height;
          } else
            this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
        }
      }
    return {
      width: "vertical" === this.layoutDirection ? heightBound : widthBound,
      height: "vertical" === this.layoutDirection ? widthBound : heightBound
    };
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/richtext/paragraph
var Paragraph = class {
  constructor(text2, newLine, character) {
    this.fontSize = character.fontSize || 16, this.textBaseline = character.textBaseline || "alphabetic";
    const lineHeight = calculateLineHeight(character.lineHeight, this.fontSize);
    this.lineHeight = "number" == typeof lineHeight ? lineHeight > this.fontSize ? lineHeight : this.fontSize : Math.floor(1.2 * this.fontSize), this.height = this.lineHeight;
    const { ascent, height, descent, width } = measureTextCanvas(text2, character);
    let halfDetaHeight = 0, deltaAscent = 0, deltaDescent = 0;
    this.height > height && (halfDetaHeight = (this.height - height) / 2, deltaAscent = Math.ceil(halfDetaHeight), deltaDescent = Math.floor(halfDetaHeight)), "top" === this.textBaseline ? (this.ascent = halfDetaHeight, this.descent = height - halfDetaHeight) : "bottom" === this.textBaseline ? (this.ascent = height - halfDetaHeight, this.descent = halfDetaHeight) : "middle" === this.textBaseline ? (this.ascent = this.height / 2, this.descent = this.height / 2) : (this.ascent = ascent + deltaAscent, this.descent = descent + deltaDescent), this.length = text2.length, this.width = width || 0, this.text = text2 || "", this.newLine = newLine || false, this.character = character, this.left = 0, this.top = 0, this.ellipsis = "normal", this.ellipsisWidth = 0, this.ellipsisOtherParagraphWidth = 0, "vertical" === character.direction && (this.direction = character.direction, this.widthOrigin = this.width, this.heightOrigin = this.height, this.width = this.heightOrigin, this.height = this.widthOrigin, this.lineHeight = this.height), this.ellipsisStr = "...";
  }
  updateWidth() {
    const { width } = measureTextCanvas(this.text, this.character);
    this.width = width, "vertical" === this.direction && (this.widthOrigin = this.width, this.width = this.heightOrigin, this.height = this.widthOrigin);
  }
  draw(ctx, baseline, deltaLeft, isLineFirst, textAlign) {
    let text2 = this.text, left2 = this.left + deltaLeft;
    baseline += this.top;
    let direction2 = this.direction;
    if (this.verticalEllipsis)
      text2 = this.ellipsisStr, direction2 = "vertical", baseline -= this.ellipsisWidth / 2;
    else {
      if ("hide" === this.ellipsis)
        return;
      if ("add" === this.ellipsis)
        text2 += this.ellipsisStr, "right" !== textAlign && "end" !== textAlign || (left2 -= this.ellipsisWidth);
      else if ("replace" === this.ellipsis) {
        const index = getStrByWithCanvas(text2, ("vertical" === direction2 ? this.height : this.width) - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text2.length - 1);
        if (text2 = text2.slice(0, index), text2 += this.ellipsisStr, "right" === textAlign || "end" === textAlign) {
          const { width } = measureTextCanvas(this.text.slice(index), this.character);
          "vertical" === direction2 || (left2 -= this.ellipsisWidth - width);
        }
      }
    }
    switch (this.character.script) {
      case "super":
        baseline -= this.ascent * (1 / 3);
        break;
      case "sub":
        baseline += this.descent / 2;
    }
    "vertical" === direction2 && (ctx.save(), ctx.rotateAbout(Math.PI / 2, left2, baseline), ctx.translate(-this.heightOrigin || -this.lineHeight / 2, -this.descent / 2), ctx.translate(left2, baseline), left2 = 0, baseline = 0), this.character.stroke && (applyStrokeStyle(ctx, this.character), ctx.strokeText(text2, left2, baseline)), applyFillStyle(ctx, this.character), this.character.fill && ctx.fillText(text2, left2, baseline), this.character.fill && ("boolean" == typeof this.character.lineThrough || "boolean" == typeof this.character.underline ? (this.character.underline && ctx.fillRect(left2, 1 + baseline, this.widthOrigin || this.width, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1), this.character.lineThrough && ctx.fillRect(left2, 1 + baseline - this.ascent / 2, this.widthOrigin || this.width, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1)) : "underline" === this.character.textDecoration ? ctx.fillRect(left2, 1 + baseline, this.widthOrigin || this.width, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1) : "line-through" === this.character.textDecoration && ctx.fillRect(left2, 1 + baseline - this.ascent / 2, this.widthOrigin || this.width, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1)), "vertical" === direction2 && ctx.restore();
  }
  getWidthWithEllips(direction2) {
    let text2 = this.text;
    const width = "vertical" === direction2 ? this.height : this.width;
    if ("hide" === this.ellipsis)
      return width;
    if ("add" === this.ellipsis)
      return width + this.ellipsisWidth;
    if ("replace" === this.ellipsis) {
      const index = getStrByWithCanvas(text2, width - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text2.length - 1);
      text2 = text2.slice(0, index), text2 += this.ellipsisStr;
      const { width: measureWidth } = measureTextCanvas(this.text.slice(index), this.character);
      return width + this.ellipsisWidth - measureWidth;
    }
    return width;
  }
};
function seperateParagraph(paragraph, index) {
  const text1 = paragraph.text.slice(0, index), text2 = paragraph.text.slice(index);
  return [new Paragraph(text1, paragraph.newLine, paragraph.character), new Paragraph(text2, true, paragraph.character)];
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/image
var IMAGE_UPDATE_TAG_KEY = ["width", "height", "image", ...GRAPHIC_UPDATE_TAG_KEY];
var Image = class _Image extends Graphic {
  constructor(params2) {
    super(params2), this.type = "image", this.numberType = IMAGE_NUMBER_TYPE, this.loadImage(this.attribute.image);
  }
  get width() {
    var _a;
    return null !== (_a = this.attribute.width) && void 0 !== _a ? _a : 0;
  }
  set width(width) {
    this.attribute.width === width && (this.attribute.width = width, this.addUpdateShapeAndBoundsTag());
  }
  get height() {
    var _a;
    return null !== (_a = this.attribute.height) && void 0 !== _a ? _a : 0;
  }
  set height(height) {
    this.attribute.height === height && (this.attribute.height = height, this.addUpdateShapeAndBoundsTag());
  }
  get repeatX() {
    var _a;
    return null !== (_a = this.attribute.repeatX) && void 0 !== _a ? _a : "no-repeat";
  }
  set repeatX(repeatX) {
    this.attribute.repeatX === repeatX && (this.attribute.repeatX = repeatX);
  }
  get repeatY() {
    var _a;
    return null !== (_a = this.attribute.repeatY) && void 0 !== _a ? _a : "no-repeat";
  }
  set repeatY(repeatY) {
    this.attribute.repeatY === repeatY && (this.attribute.repeatY = repeatY);
  }
  get image() {
    return this.attribute.image;
  }
  set image(image) {
    image !== this.attribute.image && (this.attribute.image = image, this.loadImage(this.attribute.image));
  }
  imageLoadSuccess(url, image, cb) {
    super.imageLoadSuccess(url, image, () => {
      this.successCallback && this.successCallback();
    });
  }
  imageLoadFail(url, cb) {
    super.imageLoadFail(url, () => {
      this.failCallback && this.failCallback();
    });
  }
  setAttributes(params2, forceUpdateTag, context) {
    return params2.image && this.loadImage(params2.image), super.setAttributes(params2, forceUpdateTag, context);
  }
  setAttribute(key, value, forceUpdateTag, context) {
    return "image" === key && this.loadImage(value), super.setAttribute(key, value, forceUpdateTag, context);
  }
  doUpdateAABBBounds() {
    const imageTheme = getTheme(this).image;
    this._AABBBounds.clear();
    const attribute = this.attribute, bounds = application.graphicService.updateImageAABBBounds(attribute, getTheme(this).image, this._AABBBounds, this), { boundsPadding = imageTheme.boundsPadding } = attribute, paddingArray = parsePadding(boundsPadding);
    return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
  }
  tryUpdateOBBBounds() {
    throw new Error("\u6682\u4E0D\u652F\u6301");
  }
  getDefaultAttribute(name) {
    return DefaultImageAttribute[name];
  }
  needUpdateTags(keys2) {
    return super.needUpdateTags(keys2, IMAGE_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, IMAGE_UPDATE_TAG_KEY);
  }
  clone() {
    return new _Image(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Image.NOWORK_ANIMATE_ATTR;
  }
};
Image.NOWORK_ANIMATE_ATTR = Object.assign({
  image: 1,
  repeatX: 1,
  repeatY: 1
}, NOWORK_ANIMATE_ATTR);
function createImage(attributes) {
  return new Image(attributes);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/richtext/icon
var RichTextIcon = class extends Image {
  constructor(params2) {
    if (super(params2), this._x = 0, this._y = 0, this._hovered = false, this._marginArray = [0, 0, 0, 0], "always" === params2.backgroundShowMode && (this._hovered = true), params2.margin) {
      const marginArray = parsePadding(params2.margin);
      this._marginArray = "number" == typeof marginArray ? [marginArray, marginArray, marginArray, marginArray] : marginArray;
    }
    this.onBeforeAttributeUpdate = (val, attributes, key) => {
      if (isArray_default(key) && -1 !== key.indexOf("margin") || "margin" === key)
        if (attributes.margin) {
          const marginArray = parsePadding(attributes.margin);
          this._marginArray = "number" == typeof marginArray ? [marginArray, marginArray, marginArray, marginArray] : marginArray;
        } else
          this._marginArray = [0, 0, 0, 0];
    };
  }
  get width() {
    var _a;
    return (null !== (_a = this.attribute.width) && void 0 !== _a ? _a : 0) + this._marginArray[1] + this._marginArray[3];
  }
  get height() {
    var _a;
    return (null !== (_a = this.attribute.height) && void 0 !== _a ? _a : 0) + this._marginArray[0] + this._marginArray[2];
  }
  tryUpdateAABBBounds() {
    if (!this.shouldUpdateAABBBounds())
      return this._AABBBounds;
    this.doUpdateAABBBounds();
    const { width = DefaultImageAttribute.width, height = DefaultImageAttribute.height } = this.attribute, { backgroundWidth = width, backgroundHeight = height } = this.attribute, expandX = (backgroundWidth - width) / 2, expandY = (backgroundHeight - height) / 2;
    return this._AABBBounds.expand([0, 2 * expandX, 2 * expandY, 0]), this._AABBBounds;
  }
  setHoverState(hovered) {
    "hover" === this.attribute.backgroundShowMode && this._hovered !== hovered && (this._hovered = hovered);
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/richtext/line
var Line2 = class {
  constructor(left2, width, baseline, ascent, descent, lineBuffer, direction2, isWidthMax) {
    this.left = left2, this.width = width, this.baseline = baseline, this.ascent = ascent, this.descent = descent, this.top = baseline - ascent, this.paragraphs = lineBuffer.map((p) => p), this.textAlign = (this.paragraphs[0] instanceof RichTextIcon ? this.paragraphs[0].attribute.textAlign : this.paragraphs[0].character.textAlign) || "left", this.direction = direction2, this.directionKey = DIRECTION_KEY[this.direction], this.actualWidth = 0;
    let maxHeight = 0;
    this.paragraphs.forEach((word, index) => {
      if (0 === index && word instanceof Paragraph) {
        const result2 = regFirstSpace.exec(word.text);
        0 !== (null == result2 ? void 0 : result2.index) && (word.text = word.text.slice(null == result2 ? void 0 : result2.index), word.updateWidth());
      }
      this.actualWidth += word[this.directionKey.width], maxHeight = Math.max(word[this.directionKey.height], maxHeight);
    }), this.height = maxHeight, this.blankWidth = isWidthMax ? 0 : this.width - this.actualWidth, this.calcOffset(width, isWidthMax);
  }
  calcOffset(width, isWidthMax) {
    const directionKey = this.directionKey, maxHeight = this.height;
    let x = this.left, spacing = 0;
    this.actualWidth < width && !isWidthMax && ("right" === this.textAlign || "end" === this.textAlign ? x = width - this.actualWidth : "center" === this.textAlign ? x = (width - this.actualWidth) / 2 : "justify" === this.textAlign && (this.paragraphs.length < 2 ? x = (width - this.actualWidth) / 2 : spacing = (width - this.actualWidth) / (this.paragraphs.length - 1))), this.paragraphs.map(function(paragraph) {
      paragraph instanceof RichTextIcon ? (paragraph["_" + directionKey.x] = x, x += paragraph[directionKey.width] + spacing, paragraph["_" + directionKey.y] = "top" === paragraph.attribute.textBaseline ? 0 : "bottom" === paragraph.attribute.textBaseline ? maxHeight - paragraph.height : (maxHeight - paragraph.height) / 2) : (paragraph[directionKey.left] = x, x += paragraph[directionKey.width] + spacing);
    });
  }
  draw(ctx, lastLine, x, y, drawEllipsis, drawIcon) {
    if (drawEllipsis && (lastLine || this.paragraphs.some((p) => p.overflow))) {
      let otherParagraphWidth = 0;
      for (let i = this.paragraphs.length - 1; i >= 0; i--) {
        const paragraph = this.paragraphs[i];
        if (paragraph.overflow)
          continue;
        if (paragraph instanceof RichTextIcon)
          break;
        if ("vertical" === this.direction && "vertical" !== paragraph.direction) {
          paragraph.verticalEllipsis = true;
          break;
        }
        const ellipsis = true === drawEllipsis ? "..." : drawEllipsis || "";
        paragraph.ellipsisStr = ellipsis;
        const { width } = measureTextCanvas(ellipsis, paragraph.character), ellipsisWidth = width || 0;
        if (ellipsisWidth <= this.blankWidth + otherParagraphWidth) {
          lastLine && (paragraph.ellipsis = "add");
          break;
        }
        if (ellipsisWidth <= this.blankWidth + otherParagraphWidth + paragraph.width) {
          paragraph.ellipsis = "replace", paragraph.ellipsisWidth = ellipsisWidth, paragraph.ellipsisOtherParagraphWidth = this.blankWidth + otherParagraphWidth;
          break;
        }
        paragraph.ellipsis = "hide", otherParagraphWidth += paragraph.width;
      }
    }
    this.paragraphs.map((paragraph, index) => {
      if (paragraph instanceof RichTextIcon)
        return paragraph.setAttributes({
          x: x + paragraph._x,
          y: y + paragraph._y
        }), void drawIcon(paragraph, ctx, x + paragraph._x, y + paragraph._y, this.ascent);
      paragraph.draw(ctx, y + this.ascent, x, 0 === index, this.textAlign);
    });
  }
  getWidthWithEllips(ellipsis) {
    let otherParagraphWidth = 0;
    for (let i = this.paragraphs.length - 1; i >= 0; i--) {
      const paragraph = this.paragraphs[i];
      if (paragraph instanceof RichTextIcon)
        break;
      const { width: width2 } = measureTextCanvas(ellipsis, paragraph.character), ellipsisWidth = width2 || 0;
      if (ellipsisWidth <= this.blankWidth + otherParagraphWidth) {
        paragraph.ellipsis = "add", paragraph.ellipsisWidth = ellipsisWidth;
        break;
      }
      if (ellipsisWidth <= this.blankWidth + otherParagraphWidth + paragraph.width) {
        paragraph.ellipsis = "replace", paragraph.ellipsisWidth = ellipsisWidth, paragraph.ellipsisOtherParagraphWidth = this.blankWidth + otherParagraphWidth;
        break;
      }
      paragraph.ellipsis = "hide", otherParagraphWidth += paragraph.width;
    }
    let width = 0;
    return this.paragraphs.map((paragraph, index) => {
      width += paragraph instanceof RichTextIcon ? paragraph.width : paragraph.getWidthWithEllips(this.direction);
    }), width;
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/richtext/wrapper
var Wrapper = class {
  constructor(frame) {
    this.frame = frame, this.width = this.frame.width, this.height = this.frame.height, this.lineWidth = 0, this.y = this.frame.top, this.maxAscent = 0, this.maxDescent = 0, this.maxAscentForBlank = 0, this.maxDescentForBlank = 0, this.lineBuffer = [], this.direction = frame.layoutDirection, this.directionKey = DIRECTION_KEY[this.direction];
  }
  store(paragraph) {
    if (paragraph instanceof RichTextIcon) {
      this.frame.icons.set(paragraph.richtextId, paragraph), this.lineBuffer.push(paragraph), this.lineWidth += paragraph[this.directionKey.width];
      let iconAscent = 0, iconDescent = 0;
      "top" === paragraph.attribute.textBaseline ? (iconAscent = 0, iconDescent = paragraph.height) : "bottom" === paragraph.attribute.textBaseline ? (iconAscent = paragraph.height, iconDescent = 0) : (iconAscent = paragraph.height / 2, iconDescent = paragraph.height / 2), this.maxAscent = Math.max(this.maxAscent, iconAscent), this.maxDescent = Math.max(this.maxDescent, iconDescent);
    } else
      this.lineBuffer.push(paragraph), 0 !== paragraph.text.length ? (this.lineWidth += paragraph[this.directionKey.width], this.maxAscent = Math.max(this.maxAscent, paragraph.ascent), this.maxDescent = Math.max(this.maxDescent, paragraph.descent)) : (this.maxAscentForBlank = Math.max(this.maxAscentForBlank, paragraph.ascent), this.maxDescentForBlank = Math.max(this.maxDescentForBlank, paragraph.descent));
  }
  send() {
    if (0 === this.lineBuffer.length)
      return;
    const maxAscent = 0 === this.maxAscent ? this.maxAscentForBlank : this.maxAscent, maxDescent = 0 === this.maxDescent ? this.maxDescentForBlank : this.maxDescent, line2 = new Line2(this.frame.left, this[this.directionKey.width], this.y + maxAscent, maxAscent, maxDescent, this.lineBuffer, this.direction, "horizontal" === this.direction ? this.frame.isWidthMax : this.frame.isHeightMax);
    this.frame.lines.push(line2), this.frame.actualHeight += line2.height, this.y += line2.height, this.lineBuffer.length = 0, this.lineWidth = this.maxAscent = this.maxDescent = this.maxAscentForBlank = this.maxDescentForBlank = 0;
  }
  deal(paragraph) {
    paragraph instanceof RichTextIcon ? "horizontal" === this.direction && 0 === this.width || "vertical" === this.direction && 0 === this.height || this.lineWidth + paragraph[this.directionKey.width] <= this[this.directionKey.width] ? this.store(paragraph) : 0 === this.lineBuffer.length ? (this.store(paragraph), this.send()) : (this.send(), this.deal(paragraph)) : "number" != typeof this.width || this.width < 0 || (paragraph.newLine && this.send(), 0 !== paragraph.text.length && ("horizontal" === this.direction && 0 === this.width || "vertical" === this.direction && 0 === this.height || this.lineWidth + paragraph[this.directionKey.width] <= this[this.directionKey.width] ? this.store(paragraph) : this.lineWidth === this[this.directionKey.width] ? (this.send(), this.deal(paragraph)) : this.cut(paragraph)));
  }
  cut(paragraph) {
    const availableWidth = this[this.directionKey.width] - this.lineWidth || 0, guessIndex = Math.ceil(availableWidth / paragraph[this.directionKey.width] * paragraph.length) || 0, index = getStrByWithCanvas(paragraph.text, availableWidth, paragraph.character, guessIndex, "break-word" === this.frame.wordBreak);
    if (0 !== index) {
      const [p1, p2] = seperateParagraph(paragraph, index);
      this.store(p1), this.deal(p2);
    } else
      0 !== this.lineBuffer.length && (this.send(), this.deal(paragraph));
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/richtext
var RICHTEXT_UPDATE_TAG_KEY = ["width", "height", "ellipsis", "wordBreak", "verticalDirection", "maxHeight", "maxWidth", "textAlign", "textBaseline", "textConfig", "layoutDirection", ...GRAPHIC_UPDATE_TAG_KEY];
var RichText = class _RichText extends Graphic {
  constructor(params2) {
    super(params2), this.type = "richtext", this._currentHoverIcon = null, this.numberType = RICHTEXT_NUMBER_TYPE;
  }
  get width() {
    var _a;
    return null !== (_a = this.attribute.width) && void 0 !== _a ? _a : DefaultRichTextAttribute.width;
  }
  set width(w) {
    this.attribute.width !== w && (this.attribute.width = w, this.addUpdateShapeAndBoundsTag());
  }
  get height() {
    var _a;
    return null !== (_a = this.attribute.height) && void 0 !== _a ? _a : DefaultRichTextAttribute.height;
  }
  set height(h) {
    this.attribute.height !== h && (this.attribute.height = h, this.addUpdateShapeAndBoundsTag());
  }
  get maxWidth() {
    return this.attribute.maxWidth;
  }
  set maxWidth(mw) {
    this.attribute.maxWidth !== mw && (this.attribute.maxWidth = mw, this.addUpdateShapeAndBoundsTag());
  }
  get maxHeight() {
    return this.attribute.maxHeight;
  }
  set maxHeight(mh) {
    this.attribute.maxHeight !== mh && (this.attribute.maxHeight = mh, this.addUpdateShapeAndBoundsTag());
  }
  get ellipsis() {
    var _a;
    return null !== (_a = this.attribute.ellipsis) && void 0 !== _a ? _a : DefaultRichTextAttribute.ellipsis;
  }
  set ellipsis(e) {
    this.attribute.ellipsis !== e && (this.attribute.ellipsis = e, this.addUpdateShapeAndBoundsTag());
  }
  get wordBreak() {
    var _a;
    return null !== (_a = this.attribute.wordBreak) && void 0 !== _a ? _a : DefaultRichTextAttribute.wordBreak;
  }
  set wordBreak(wb) {
    this.attribute.wordBreak !== wb && (this.attribute.wordBreak = wb, this.addUpdateShapeAndBoundsTag());
  }
  get verticalDirection() {
    var _a;
    return null !== (_a = this.attribute.verticalDirection) && void 0 !== _a ? _a : DefaultRichTextAttribute.verticalDirection;
  }
  set verticalDirection(vd) {
    this.attribute.verticalDirection !== vd && (this.attribute.verticalDirection = vd, this.addUpdateShapeAndBoundsTag());
  }
  get textAlign() {
    var _a;
    return null !== (_a = this.attribute.textAlign) && void 0 !== _a ? _a : DefaultRichTextAttribute.textAlign;
  }
  set textAlign(align) {
    this.attribute.textAlign !== align && (this.attribute.textAlign = align, this.addUpdateShapeAndBoundsTag());
  }
  get textBaseline() {
    var _a;
    return null !== (_a = this.attribute.textBaseline) && void 0 !== _a ? _a : DefaultRichTextAttribute.textBaseline;
  }
  set textBaseline(baseline) {
    this.attribute.textBaseline !== baseline && (this.attribute.textBaseline = baseline, this.addUpdateShapeAndBoundsTag());
  }
  get textConfig() {
    var _a;
    return null !== (_a = this.attribute.textConfig) && void 0 !== _a ? _a : DefaultRichTextAttribute.textConfig;
  }
  set textConfig(config2) {
    this.attribute.textConfig = config2, this.addUpdateShapeAndBoundsTag();
  }
  doUpdateAABBBounds() {
    const richTextTheme = getTheme(this).richtext;
    this._AABBBounds.clear();
    const attribute = this.attribute, bounds = application.graphicService.updateRichTextAABBBounds(attribute, getTheme(this).richtext, this._AABBBounds, this), { boundsPadding = richTextTheme.boundsPadding } = attribute, paddingArray = parsePadding(boundsPadding);
    return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
  }
  tryUpdateOBBBounds() {
    throw new Error("\u6682\u4E0D\u652F\u6301");
  }
  getDefaultAttribute(name) {
    return DefaultRichTextAttribute[name];
  }
  needUpdateTags(keys2) {
    return super.needUpdateTags(keys2, RICHTEXT_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, RICHTEXT_UPDATE_TAG_KEY);
  }
  getFrameCache() {
    return this.shouldUpdateShape() && (this.doUpdateFrameCache(), this.clearUpdateShapeTag()), this._frameCache;
  }
  combinedStyleToCharacter(config2) {
    const { fill, stroke: stroke2, fontSize, fontFamily, fontStyle, fontWeight, lineWidth, opacity, fillOpacity, strokeOpacity } = this.attribute;
    return Object.assign({
      fill,
      stroke: stroke2,
      fontSize,
      fontFamily,
      fontStyle,
      fontWeight,
      lineWidth,
      opacity,
      fillOpacity,
      strokeOpacity
    }, config2);
  }
  doUpdateFrameCache() {
    var _a;
    const { textConfig = [], maxWidth, maxHeight, width, height, ellipsis, wordBreak, verticalDirection, textAlign, textBaseline, layoutDirection, singleLine, disableAutoWrapLine } = this.attribute, paragraphs = [];
    for (let i = 0; i < textConfig.length; i++)
      if ("image" in textConfig[i]) {
        const config2 = this.combinedStyleToCharacter(textConfig[i]), iconCache = config2.id && this._frameCache && this._frameCache.icons && this._frameCache.icons.get(config2.id);
        if (iconCache)
          paragraphs.push(iconCache);
        else {
          const icon = new RichTextIcon(config2);
          icon.successCallback = () => {
            var _a2;
            this.addUpdateBoundTag(), null === (_a2 = this.stage) || void 0 === _a2 || _a2.renderNextFrame();
          }, icon.richtextId = config2.id, paragraphs.push(icon);
        }
      } else {
        const richTextConfig = this.combinedStyleToCharacter(textConfig[i]);
        if (isNumber_default(richTextConfig.text) && (richTextConfig.text = `${richTextConfig.text}`), richTextConfig.text && richTextConfig.text.includes("\n")) {
          const textParts = richTextConfig.text.split("\n");
          for (let j = 0; j < textParts.length; j++)
            paragraphs.push(new Paragraph(textParts[j], 0 !== j, richTextConfig));
        } else
          richTextConfig.text && paragraphs.push(new Paragraph(richTextConfig.text, false, richTextConfig));
      }
    const maxWidthFinite = "number" == typeof maxWidth && Number.isFinite(maxWidth) && maxWidth > 0, maxHeightFinite = "number" == typeof maxHeight && Number.isFinite(maxHeight) && maxHeight > 0, richTextWidthEnable = "number" == typeof width && Number.isFinite(width) && width > 0 && (!maxWidthFinite || width <= maxWidth), richTextHeightEnable = "number" == typeof height && Number.isFinite(height) && height > 0 && (!maxHeightFinite || height <= maxHeight), frame = new Frame(0, 0, (richTextWidthEnable ? width : maxWidthFinite ? maxWidth : 0) || 0, (richTextHeightEnable ? height : maxHeightFinite ? maxHeight : 0) || 0, ellipsis, wordBreak, verticalDirection, textAlign, textBaseline, layoutDirection || "horizontal", !richTextWidthEnable && maxWidthFinite, !richTextHeightEnable && maxHeightFinite, singleLine || false, null === (_a = this._frameCache) || void 0 === _a ? void 0 : _a.icons), wrapper = new Wrapper(frame);
    if (disableAutoWrapLine) {
      let lineCount = 0, skip = false;
      for (let i = 0; i < paragraphs.length; i++) {
        const p = paragraphs[i];
        skip ? (p.overflow = true, p.left = 1 / 0, p.top = 1 / 0, !p.newLine && frame.lines[frame.lines.length - 1].paragraphs.push(p)) : wrapper.deal(p), frame.lines.length !== lineCount && (lineCount = frame.lines.length, wrapper.lineBuffer.length = 0, p.overflow = true, p.left = 1e3, p.top = 1e3, frame.lines[frame.lines.length - 1].paragraphs.push(p), skip = true), p.newLine && (skip = false, wrapper.lineWidth = 0);
      }
    } else
      for (let i = 0; i < paragraphs.length; i++)
        wrapper.deal(paragraphs[i]);
    wrapper.send();
    if (!("horizontal" === frame.layoutDirection ? richTextWidthEnable : richTextHeightEnable)) {
      const frameSize = frame.getActualSizeWidthEllipsis();
      let offsetSize = "horizontal" === frame.layoutDirection ? frameSize.width : frameSize.height;
      ("horizontal" === frame.layoutDirection ? maxWidthFinite : maxHeightFinite) && (offsetSize = Math.min(offsetSize, "horizontal" === frame.layoutDirection ? maxWidth : maxHeight)), frame.lines.forEach(function(l) {
        l.calcOffset(offsetSize, false);
      });
    }
    this._frameCache = frame;
  }
  clone() {
    return new _RichText(Object.assign({}, this.attribute));
  }
  setStage(stage, layer) {
    super.setStage(stage, layer);
    this.getFrameCache().icons.forEach((icon) => {
      icon.setStage(stage, layer);
    });
  }
  bindIconEvent() {
    this.addEventListener("pointermove", (e) => {
      var _a, _b, _c, _d, _e;
      const pickedIcon = this.pickIcon(e.global);
      pickedIcon && pickedIcon === this._currentHoverIcon || (pickedIcon ? (null === (_a = this._currentHoverIcon) || void 0 === _a || _a.setHoverState(false), this._currentHoverIcon = pickedIcon, this._currentHoverIcon.setHoverState(true), null === (_b = this.stage) || void 0 === _b || _b.setCursor(pickedIcon.attribute.cursor), null === (_c = this.stage) || void 0 === _c || _c.renderNextFrame()) : !pickedIcon && this._currentHoverIcon && (this._currentHoverIcon.setHoverState(false), this._currentHoverIcon = null, null === (_d = this.stage) || void 0 === _d || _d.setCursor(), null === (_e = this.stage) || void 0 === _e || _e.renderNextFrame()));
    }), this.addEventListener("pointerleave", (e) => {
      var _a, _b;
      this._currentHoverIcon && (this._currentHoverIcon.setHoverState(false), this._currentHoverIcon = null, null === (_a = this.stage) || void 0 === _a || _a.setCursor(), null === (_b = this.stage) || void 0 === _b || _b.renderNextFrame());
    });
  }
  pickIcon(point5) {
    const frameCache = this.getFrameCache(), { e: x, f: y } = this.globalTransMatrix;
    let pickIcon;
    return frameCache.icons.forEach((icon) => {
      var _a, _b;
      icon.AABBBounds.containsPoint({
        x: point5.x - x,
        y: point5.y - y
      }) && (pickIcon = icon, pickIcon.globalX = (null !== (_a = pickIcon.attribute.x) && void 0 !== _a ? _a : 0) + x, pickIcon.globalY = (null !== (_b = pickIcon.attribute.y) && void 0 !== _b ? _b : 0) + y);
    }), pickIcon;
  }
  getNoWorkAnimateAttr() {
    return _RichText.NOWORK_ANIMATE_ATTR;
  }
};
RichText.NOWORK_ANIMATE_ATTR = Object.assign({
  ellipsis: 1,
  wordBreak: 1,
  verticalDirection: 1,
  textAlign: 1,
  textBaseline: 1,
  textConfig: 1,
  layoutDirection: 1
}, NOWORK_ANIMATE_ATTR);
function createRichText(attributes) {
  return new RichText(attributes);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/path
var PATH_UPDATE_TAG_KEY = ["path", "customPath", ...GRAPHIC_UPDATE_TAG_KEY];
var Path = class _Path extends Graphic {
  constructor(params2) {
    super(params2), this.type = "path", this.numberType = PATH_NUMBER_TYPE;
  }
  get pathShape() {
    return this.tryUpdateAABBBounds(), this.getParsedPathShape();
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const { path } = this.attribute;
    return null != path && "" !== path;
  }
  getParsedPathShape() {
    const pathTheme = getTheme(this).path;
    if (!this.valid)
      return pathTheme.path;
    const attribute = this.attribute;
    return attribute.path instanceof CustomPath2D ? attribute.path : (isNil_default(this.cache) && this.doUpdatePathShape(), this.cache instanceof CustomPath2D ? this.cache : pathTheme.path);
  }
  doUpdateAABBBounds() {
    const pathTheme = getTheme(this).path;
    this.doUpdatePathShape(), this._AABBBounds.clear();
    const attribute = this.attribute, bounds = application.graphicService.updatePathAABBBounds(attribute, getTheme(this).path, this._AABBBounds, this), { boundsPadding = pathTheme.boundsPadding } = attribute, paddingArray = parsePadding(boundsPadding);
    return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
  }
  doUpdatePathShape() {
    const attribute = this.attribute;
    isString_default(attribute.path, true) ? this.cache = new CustomPath2D().fromString(attribute.path) : attribute.customPath && (this.cache = new CustomPath2D(), attribute.customPath(this.cache, this));
  }
  tryUpdateOBBBounds() {
    throw new Error("\u6682\u4E0D\u652F\u6301");
  }
  getDefaultAttribute(name) {
    return getTheme(this).path[name];
  }
  needUpdateTags(keys2) {
    return super.needUpdateTags(keys2, PATH_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, PATH_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    return new CustomPath2D().fromCustomPath2D(this.getParsedPathShape(), 0, 0);
  }
  clone() {
    return new _Path(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Path.NOWORK_ANIMATE_ATTR;
  }
};
Path.NOWORK_ANIMATE_ATTR = Object.assign({
  path: 1,
  customPath: 1
}, NOWORK_ANIMATE_ATTR);
function createPath(attributes) {
  return new Path(attributes);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/area
var AREA_UPDATE_TAG_KEY = ["segments", "points", "curveType", ...GRAPHIC_UPDATE_TAG_KEY];
var Area = class _Area extends Graphic {
  constructor(params2) {
    super(params2), this.type = "area", this.numberType = AREA_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    if (this.pathProxy)
      return true;
    const { points, segments: segments2 } = this.attribute;
    return segments2 ? 0 !== segments2.length : !!points && 0 !== points.length;
  }
  doUpdateAABBBounds() {
    const areaTheme = getTheme(this).area;
    this._AABBBounds.clear();
    const attribute = this.attribute, bounds = application.graphicService.updateAreaAABBBounds(attribute, getTheme(this).area, this._AABBBounds, this), { boundsPadding = areaTheme.boundsPadding } = attribute, paddingArray = parsePadding(boundsPadding);
    return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
  }
  tryUpdateOBBBounds() {
    throw new Error("\u6682\u4E0D\u652F\u6301");
  }
  _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
    "points" === key && (nextAttributes.points = pointsInterpolation(lastStepVal, nextStepVal, ratio));
  }
  getDefaultAttribute(name) {
    return getTheme(this).area[name];
  }
  needUpdateTags(keys2) {
    return super.needUpdateTags(keys2, AREA_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, AREA_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    const path = new CustomPath2D(), attribute = this.attribute, segments2 = attribute.segments, parsePoints = (points) => {
      if (points && points.length) {
        let isFirst = true;
        const basePoints = [];
        if (points.forEach((point5) => {
          var _a, _b;
          false !== point5.defined && (isFirst ? path.moveTo(point5.x, point5.y) : path.lineTo(point5.x, point5.y), basePoints.push({
            x: null !== (_a = point5.x1) && void 0 !== _a ? _a : point5.x,
            y: null !== (_b = point5.y1) && void 0 !== _b ? _b : point5.y
          }), isFirst = false);
        }), basePoints.length) {
          for (let i = basePoints.length - 1; i >= 0; i--)
            path.lineTo(basePoints[i].x, basePoints[i].y);
          path.closePath();
        }
      }
    };
    return attribute.points ? parsePoints(attribute.points) : segments2 && segments2.length && segments2.forEach((seg) => {
      parsePoints(seg.points);
    }), path;
  }
  clone() {
    return new _Area(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Area.NOWORK_ANIMATE_ATTR;
  }
};
Area.NOWORK_ANIMATE_ATTR = Object.assign({
  segments: 1,
  curveType: 1
}, NOWORK_ANIMATE_ATTR);
function createArea(attributes) {
  return new Area(attributes);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/arc
var ARC_UPDATE_TAG_KEY = ["innerRadius", "outerRadius", "startAngle", "endAngle", "cornerRadius", "padAngle", "padRadius", "cap", ...GRAPHIC_UPDATE_TAG_KEY];
var Arc = class _Arc extends Graphic {
  constructor(params2) {
    super(params2), this.type = "arc", this.numberType = ARC_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const { startAngle, endAngle, outerRadius, innerRadius } = this.attribute;
    return this._validNumber(startAngle) && this._validNumber(endAngle) && this._validNumber(outerRadius) && this._validNumber(innerRadius);
  }
  getParsedCornerRadius() {
    const arcTheme = getTheme(this).arc, { cornerRadius = arcTheme.cornerRadius, innerPadding = arcTheme.innerPadding, outerPadding = arcTheme.outerPadding } = this.attribute;
    let { outerRadius = arcTheme.outerRadius, innerRadius = arcTheme.innerRadius } = this.attribute;
    if (outerRadius += outerPadding, innerRadius -= innerPadding, 0 === cornerRadius || "0%" === cornerRadius)
      return 0;
    const deltaRadius = Math.abs(outerRadius - innerRadius);
    return Math.min(isNumber_default(cornerRadius, true) ? cornerRadius : deltaRadius * parseFloat(cornerRadius) / 100, deltaRadius / 2);
  }
  getParsedAngle() {
    const arcTheme = getTheme(this).arc;
    let { startAngle = arcTheme.startAngle, endAngle = arcTheme.endAngle } = this.attribute;
    const { cap = arcTheme.cap } = this.attribute, sign3 = endAngle - startAngle >= 0 ? 1 : -1, deltaAngle = endAngle - startAngle;
    if (startAngle = clampAngleByRadian(startAngle), endAngle = startAngle + deltaAngle, cap && abs(deltaAngle) < pi2 - epsilon) {
      let startCap = 1, endCap = 1;
      cap.length && (startCap = Number(cap[0]), endCap = Number(cap[1]));
      let { outerRadius = arcTheme.outerRadius, innerRadius = arcTheme.innerRadius } = this.attribute;
      const { outerPadding = arcTheme.outerPadding, innerPadding = arcTheme.innerPadding } = this.attribute;
      outerRadius += outerPadding, innerRadius -= innerPadding;
      const capWidth = Math.abs(outerRadius - innerRadius) / 2, capAngle = capWidth / outerRadius;
      if (capWidth > epsilon && outerRadius > epsilon)
        return {
          startAngle: startAngle - sign3 * capAngle * startCap,
          endAngle: endAngle + sign3 * capAngle * endCap,
          sc: sign3 * capAngle * startCap,
          ec: sign3 * capAngle * endCap
        };
    }
    return {
      startAngle,
      endAngle
    };
  }
  getParsePadAngle(startAngle, endAngle) {
    const arcTheme = getTheme(this).arc, { innerPadding = arcTheme.innerPadding, outerPadding = arcTheme.outerPadding, padAngle = arcTheme.padAngle } = this.attribute;
    let { outerRadius = arcTheme.outerRadius, innerRadius = arcTheme.innerRadius } = this.attribute;
    outerRadius += outerPadding, innerRadius -= innerPadding;
    const { padRadius = sqrt(outerRadius * outerRadius + innerRadius * innerRadius) } = this.attribute, deltaAngle = abs(endAngle - startAngle);
    let outerStartAngle = startAngle, outerEndAngle = endAngle, innerStartAngle = startAngle, innerEndAngle = endAngle;
    const halfPadAngle = padAngle / 2;
    let innerDeltaAngle = deltaAngle, outerDeltaAngle = deltaAngle;
    if (halfPadAngle > epsilon && padRadius > epsilon) {
      const sign3 = endAngle > startAngle ? 1 : -1;
      let p0 = asin(Number(padRadius) / innerRadius * sin(halfPadAngle)), p1 = asin(Number(padRadius) / outerRadius * sin(halfPadAngle));
      return (innerDeltaAngle -= 2 * p0) > epsilon ? (p0 *= sign3, innerStartAngle += p0, innerEndAngle -= p0) : (innerDeltaAngle = 0, innerStartAngle = innerEndAngle = (startAngle + endAngle) / 2), (outerDeltaAngle -= 2 * p1) > epsilon ? (p1 *= sign3, outerStartAngle += p1, outerEndAngle -= p1) : (outerDeltaAngle = 0, outerStartAngle = outerEndAngle = (startAngle + endAngle) / 2), {
        outerStartAngle,
        outerEndAngle,
        innerStartAngle,
        innerEndAngle,
        innerDeltaAngle,
        outerDeltaAngle
      };
    }
    return {
      outerStartAngle,
      outerEndAngle,
      innerStartAngle,
      innerEndAngle,
      innerDeltaAngle,
      outerDeltaAngle
    };
  }
  doUpdateAABBBounds(full) {
    const arcTheme = getTheme(this).arc;
    this._AABBBounds.clear();
    const attribute = this.attribute, bounds = application.graphicService.updateArcAABBBounds(attribute, getTheme(this).arc, this._AABBBounds, full, this), { boundsPadding = arcTheme.boundsPadding } = attribute, paddingArray = parsePadding(boundsPadding);
    return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
  }
  tryUpdateOBBBounds() {
    throw new Error("\u6682\u4E0D\u652F\u6301");
  }
  needUpdateTags(keys2) {
    return super.needUpdateTags(keys2, ARC_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, ARC_UPDATE_TAG_KEY);
  }
  getDefaultAttribute(name) {
    return getTheme(this).arc[name];
  }
  toCustomPath() {
    const attribute = this.attribute, { startAngle, endAngle } = this.getParsedAngle();
    let innerRadius = attribute.innerRadius - (attribute.innerPadding || 0), outerRadius = attribute.outerRadius - (attribute.outerPadding || 0);
    const deltaAngle = abs(endAngle - startAngle), clockwise = endAngle > startAngle;
    if (outerRadius < innerRadius) {
      const temp3 = outerRadius;
      outerRadius = innerRadius, innerRadius = temp3;
    }
    const path = new CustomPath2D();
    if (outerRadius <= epsilon)
      path.moveTo(0, 0);
    else if (deltaAngle >= pi2 - epsilon)
      path.moveTo(0 + outerRadius * cos(startAngle), 0 + outerRadius * sin(startAngle)), path.arc(0, 0, outerRadius, startAngle, endAngle, !clockwise), innerRadius > epsilon && (path.moveTo(0 + innerRadius * cos(endAngle), 0 + innerRadius * sin(endAngle)), path.arc(0, 0, innerRadius, endAngle, startAngle, clockwise));
    else {
      const xors = outerRadius * cos(startAngle), yors = outerRadius * sin(startAngle), xire = innerRadius * cos(endAngle), yire = innerRadius * sin(endAngle);
      path.moveTo(0 + xors, 0 + yors), path.arc(0, 0, outerRadius, startAngle, endAngle, !clockwise), path.lineTo(0 + xire, 0 + yire), path.arc(0, 0, innerRadius, endAngle, startAngle, clockwise), path.closePath();
    }
    return path;
  }
  clone() {
    return new _Arc(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Arc.NOWORK_ANIMATE_ATTR;
  }
};
Arc.NOWORK_ANIMATE_ATTR = Object.assign({
  cap: 1
}, NOWORK_ANIMATE_ATTR);
function createArc(attributes) {
  return new Arc(attributes);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/arc3d
var Arc3d = class _Arc3d extends Arc {
  constructor(params2) {
    super(params2), this.type = "arc3d", this.numberType = ARC3D_NUMBER_TYPE;
  }
  doUpdateAABBBounds() {
    const polygonTheme = getTheme(this).arc;
    this._AABBBounds.clear();
    const attribute = this.attribute, bounds = application.graphicService.updateArc3dAABBBounds(attribute, getTheme(this).polygon, this._AABBBounds, this), { boundsPadding = polygonTheme.boundsPadding } = attribute, paddingArray = parsePadding(boundsPadding);
    return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), this._AABBBounds;
  }
  getNoWorkAnimateAttr() {
    return _Arc3d.NOWORK_ANIMATE_ATTR;
  }
};
Arc3d.NOWORK_ANIMATE_ATTR = Object.assign({
  cap: 1
}, NOWORK_ANIMATE_ATTR);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/polygon
var POLYGON_UPDATE_TAG_KEY = ["points", "cornerRadius", ...GRAPHIC_UPDATE_TAG_KEY];
var Polygon = class _Polygon extends Graphic {
  constructor(params2) {
    super(params2), this.type = "polygon", this.numberType = POLYGON_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const { points } = this.attribute;
    return points && points.length >= 2;
  }
  doUpdateAABBBounds() {
    const polygonTheme = getTheme(this).polygon;
    this._AABBBounds.clear();
    const attribute = this.attribute, bounds = application.graphicService.updatePolygonAABBBounds(attribute, getTheme(this).polygon, this._AABBBounds, this), { boundsPadding = polygonTheme.boundsPadding } = attribute, paddingArray = parsePadding(boundsPadding);
    return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), this._AABBBounds;
  }
  tryUpdateOBBBounds() {
    throw new Error("\u6682\u4E0D\u652F\u6301");
  }
  _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
    "points" === key && (nextAttributes.points = pointsInterpolation(lastStepVal, nextStepVal, ratio));
  }
  getDefaultAttribute(name) {
    return getTheme(this).polygon[name];
  }
  needUpdateTags(keys2) {
    return super.needUpdateTags(keys2, POLYGON_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, POLYGON_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    const points = this.attribute.points, path = new CustomPath2D();
    return points.forEach((point5, index) => {
      0 === index ? path.moveTo(point5.x, point5.y) : path.lineTo(point5.x, point5.y);
    }), path.closePath(), path;
  }
  clone() {
    return new _Polygon(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return _Polygon.NOWORK_ANIMATE_ATTR;
  }
};
Polygon.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createPolygon(attributes) {
  return new Polygon(attributes);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/pyramid3d
var Pyramid3d = class _Pyramid3d extends Polygon {
  constructor(params2) {
    super(params2), this.type = "pyramid3d", this.numberType = PYRAMID3D_NUMBER_TYPE;
  }
  doUpdateAABBBounds() {
    const polygonTheme = getTheme(this).polygon;
    this._AABBBounds.clear();
    const attribute = this.attribute, bounds = application.graphicService.updatePyramid3dAABBBounds(attribute, getTheme(this).polygon, this._AABBBounds, this), { boundsPadding = polygonTheme.boundsPadding } = attribute, paddingArray = parsePadding(boundsPadding);
    return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), this._AABBBounds;
  }
  findFace() {
    const { points } = this.attribute, kList = points.map((p, i) => {
      const p1 = 3 === i ? points[0] : points[i + 1], dx = p.x - p1.x;
      return 0 === dx ? 0 : (p.y - p1.y) / dx;
    }), pointsMap = points.map((p) => ({
      p,
      d: 0
    }));
    let find = false, maxD = 0;
    for (let i = 0; i < kList.length - 1; i++) {
      for (let j = i + 1; j < kList.length; j++) {
        if (kList[i] === kList[j]) {
          find = true;
          const d1 = PointService.distancePP(pointsMap[i].p, pointsMap[i + 1].p);
          pointsMap[i].d = d1, pointsMap[i + 1].d = d1, maxD = max(maxD, d1);
          const d2 = PointService.distancePP(pointsMap[j].p, pointsMap[j + 1].p);
          pointsMap[j].d = d2, pointsMap[j + 1].d = d2, maxD = max(maxD, d2);
        }
        if (find)
          break;
      }
      if (find)
        break;
    }
    for (let i = points.length - 1; i >= 0; i--) {
      const p = points[i];
      pointsMap.unshift({
        p,
        d: 0
      });
    }
    for (let i = 0; i < points.length; i++) {
      const delta = (maxD - pointsMap[i + points.length].d) / 2;
      pointsMap[i].d += delta, pointsMap[i + points.length].d += delta;
    }
    const faces = {
      polygons: [],
      vertices: [],
      edges: []
    };
    return pointsMap.forEach((p) => {
      faces.vertices.push([p.p.x, p.p.y, p.d]);
    }), faces.polygons.push({
      polygon: [0, 4, 5, 1],
      normal: [0, -1, 0]
    }), faces.polygons.push({
      polygon: [7, 6, 2, 3],
      normal: [0, 1, 0]
    }), faces.polygons.push({
      polygon: [0, 4, 7, 3],
      normal: [-1, 0, 0]
    }), faces.polygons.push({
      polygon: [1, 5, 6, 2],
      normal: [1, 0, 0]
    }), faces.polygons.push({
      polygon: [0, 1, 2, 3],
      normal: [0, 0, -1]
    }), faces.polygons.push({
      polygon: [4, 5, 6, 7],
      normal: [0, 0, 1]
    }), faces.edges = [[0, 1], [1, 2], [2, 3], [3, 0], [4, 5], [5, 6], [6, 7], [7, 4], [0, 4], [3, 7], [1, 5], [2, 6]], faces;
  }
  _isValid() {
    return super._isValid() && 4 === this.attribute.points.length;
  }
  getNoWorkAnimateAttr() {
    return _Pyramid3d.NOWORK_ANIMATE_ATTR;
  }
};
Pyramid3d.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/shadow-root
var ShadowRoot = class extends Group {
  constructor(graphic) {
    super({
      x: 0,
      y: 0
    }), this.type = "shadowroot", this.shadowHost = graphic;
  }
  addUpdateBoundTag() {
    super.addUpdateBoundTag(), this.shadowHost && this.shadowHost.addUpdateBoundTag();
  }
  addUpdateShapeAndBoundsTag() {
    super.addUpdateShapeAndBoundsTag(), this.shadowHost && this.shadowHost.addUpdateBoundTag();
  }
  tryUpdateGlobalTransMatrix(clearTag = true) {
    if (this.shouldUpdateGlobalMatrix()) {
      const m4 = this.transMatrix;
      this._globalTransMatrix ? this._globalTransMatrix.setValue(m4.a, m4.b, m4.c, m4.d, m4.e, m4.f) : this._globalTransMatrix = m4.clone(), this.doUpdateGlobalMatrix(), clearTag && this.clearUpdateGlobalPositionTag();
    }
    return this._globalTransMatrix;
  }
  doUpdateGlobalMatrix() {
    if (this.shadowHost) {
      const parentMatrix = this.shadowHost.globalTransMatrix;
      this._globalTransMatrix.multiply(parentMatrix.a, parentMatrix.b, parentMatrix.c, parentMatrix.d, parentMatrix.e, parentMatrix.f);
    }
  }
  tryUpdateGlobalAABBBounds() {
    return this._globalAABBBounds ? this._globalAABBBounds.setValue(this._AABBBounds.x1, this._AABBBounds.y1, this._AABBBounds.x2, this._AABBBounds.y2) : this._globalAABBBounds = this._AABBBounds.clone(), this.shadowHost && this._globalAABBBounds.transformWithMatrix(this.shadowHost.globalTransMatrix), this._globalAABBBounds;
  }
};
function createShadowRoot(graphic) {
  return new ShadowRoot(graphic);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/graphic-service/common-contribution
var DefaultOuterBorderBoundsContribution = class {
  updateBounds(attribute, theme2, aabbBounds, graphic) {
    const { outerBorder, shadowBlur = theme2.shadowBlur } = attribute;
    if (outerBorder) {
      const defaultOuterBorder = theme2.outerBorder, { distance: distance2 = defaultOuterBorder.distance, lineWidth = defaultOuterBorder.lineWidth } = outerBorder;
      aabbBounds.expand(distance2 + (shadowBlur + lineWidth) / 2);
    }
    return aabbBounds;
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/graphic-service/symbol-contribution
var DefaultSymbolOuterBorderBoundsContribution = class extends DefaultOuterBorderBoundsContribution {
  updateBounds(attribute, symbolTheme, aabbBounds, graphic) {
    const { outerBorder, shadowBlur = symbolTheme.shadowBlur, strokeBoundsBuffer = symbolTheme.strokeBoundsBuffer } = attribute;
    if (outerBorder) {
      const defaultOuterBorder = symbolTheme.outerBorder, { distance: distance2 = defaultOuterBorder.distance, lineWidth = defaultOuterBorder.lineWidth } = outerBorder;
      boundStroke(aabbBounds, distance2 + (shadowBlur + lineWidth) / 2, true, strokeBoundsBuffer);
    }
    return aabbBounds;
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/allocator/matrix-allocate
var MatrixAllocate = Symbol.for("MatrixAllocate");
var Mat4Allocate = Symbol.for("Mat4Allocate");
function createMat4() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
var DefaultMatrixAllocate = class {
  constructor() {
    this.pools = [];
  }
  allocate(a3, b, c3, d, e, f) {
    if (!this.pools.length)
      return new Matrix(a3, b, c3, d, e, f);
    const m4 = this.pools.pop();
    return m4.a = a3, m4.b = b, m4.c = c3, m4.d = d, m4.e = e, m4.f = f, m4;
  }
  allocateByObj(matrix) {
    if (!this.pools.length)
      return new Matrix(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
    const m4 = this.pools.pop();
    return m4.a = matrix.a, m4.b = matrix.b, m4.c = matrix.c, m4.d = matrix.d, m4.e = matrix.e, m4.f = matrix.f, m4;
  }
  free(d) {
    this.pools.push(d);
  }
  get length() {
    return this.pools.length;
  }
  release(...params2) {
    this.pools = [];
  }
};
var DefaultMat4Allocate = class _DefaultMat4Allocate {
  constructor() {
    this.pools = [];
  }
  static identity(out) {
    return out[0] = 1, out[1] = 0, out[2] = 0, out[3] = 0, out[4] = 0, out[5] = 1, out[6] = 0, out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 1, out[11] = 0, out[12] = 0, out[13] = 0, out[14] = 0, out[15] = 1, out;
  }
  allocate() {
    if (!this.pools.length)
      return createMat4();
    const m4 = this.pools.pop();
    return _DefaultMat4Allocate.identity(m4), m4;
  }
  allocateByObj(d) {
    let m4;
    m4 = this.pools.length ? this.pools.pop() : createMat4();
    for (let i = 0; i < m4.length; i++)
      m4[i] = d[i];
    return m4;
  }
  free(m4) {
    m4 && this.pools.push(m4);
  }
  get length() {
    return this.pools.length;
  }
  release(...params2) {
    this.pools = [];
  }
};
var matrixAllocate = new DefaultMatrixAllocate();
var mat4Allocate = new DefaultMat4Allocate();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/graphic-service/graphic-service
var __decorate7 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata5 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param3 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
function identity(out) {
  return out[0] = 1, out[1] = 0, out[2] = 0, out[3] = 0, out[4] = 0, out[5] = 1, out[6] = 0, out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 1, out[11] = 0, out[12] = 0, out[13] = 0, out[14] = 0, out[15] = 1, out;
}
function rotateX(out, a3, rad) {
  const s2 = Math.sin(rad), c3 = Math.cos(rad), a10 = a3[4], a11 = a3[5], a12 = a3[6], a13 = a3[7], a20 = a3[8], a21 = a3[9], a22 = a3[10], a23 = a3[11];
  return a3 !== out && (out[0] = a3[0], out[1] = a3[1], out[2] = a3[2], out[3] = a3[3], out[12] = a3[12], out[13] = a3[13], out[14] = a3[14], out[15] = a3[15]), out[4] = a10 * c3 + a20 * s2, out[5] = a11 * c3 + a21 * s2, out[6] = a12 * c3 + a22 * s2, out[7] = a13 * c3 + a23 * s2, out[8] = a20 * c3 - a10 * s2, out[9] = a21 * c3 - a11 * s2, out[10] = a22 * c3 - a12 * s2, out[11] = a23 * c3 - a13 * s2, out;
}
function rotateY(out, a3, rad) {
  const s2 = Math.sin(rad), c3 = Math.cos(rad), a00 = a3[0], a01 = a3[1], a02 = a3[2], a03 = a3[3], a20 = a3[8], a21 = a3[9], a22 = a3[10], a23 = a3[11];
  return a3 !== out && (out[4] = a3[4], out[5] = a3[5], out[6] = a3[6], out[7] = a3[7], out[12] = a3[12], out[13] = a3[13], out[14] = a3[14], out[15] = a3[15]), out[0] = a00 * c3 - a20 * s2, out[1] = a01 * c3 - a21 * s2, out[2] = a02 * c3 - a22 * s2, out[3] = a03 * c3 - a23 * s2, out[8] = a00 * s2 + a20 * c3, out[9] = a01 * s2 + a21 * c3, out[10] = a02 * s2 + a22 * c3, out[11] = a03 * s2 + a23 * c3, out;
}
function rotateZ(out, a3, rad) {
  const s2 = Math.sin(rad), c3 = Math.cos(rad), a00 = a3[0], a01 = a3[1], a02 = a3[2], a03 = a3[3], a10 = a3[4], a11 = a3[5], a12 = a3[6], a13 = a3[7];
  return a3 !== out && (out[8] = a3[8], out[9] = a3[9], out[10] = a3[10], out[11] = a3[11], out[12] = a3[12], out[13] = a3[13], out[14] = a3[14], out[15] = a3[15]), out[0] = a00 * c3 + a10 * s2, out[1] = a01 * c3 + a11 * s2, out[2] = a02 * c3 + a12 * s2, out[3] = a03 * c3 + a13 * s2, out[4] = a10 * c3 - a00 * s2, out[5] = a11 * c3 - a01 * s2, out[6] = a12 * c3 - a02 * s2, out[7] = a13 * c3 - a03 * s2, out;
}
function translate(out, a3, v) {
  const x = v[0], y = v[1], z = v[2];
  let a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;
  return a3 === out ? (out[12] = a3[0] * x + a3[4] * y + a3[8] * z + a3[12], out[13] = a3[1] * x + a3[5] * y + a3[9] * z + a3[13], out[14] = a3[2] * x + a3[6] * y + a3[10] * z + a3[14], out[15] = a3[3] * x + a3[7] * y + a3[11] * z + a3[15]) : (a00 = a3[0], a01 = a3[1], a02 = a3[2], a03 = a3[3], a10 = a3[4], a11 = a3[5], a12 = a3[6], a13 = a3[7], a20 = a3[8], a21 = a3[9], a22 = a3[10], a23 = a3[11], out[0] = a00, out[1] = a01, out[2] = a02, out[3] = a03, out[4] = a10, out[5] = a11, out[6] = a12, out[7] = a13, out[8] = a20, out[9] = a21, out[10] = a22, out[11] = a23, out[12] = a00 * x + a10 * y + a20 * z + a3[12], out[13] = a01 * x + a11 * y + a21 * z + a3[13], out[14] = a02 * x + a12 * y + a22 * z + a3[14], out[15] = a03 * x + a13 * y + a23 * z + a3[15]), out;
}
function mat3Tomat4(out, b) {
  out[0] = b.a, out[1] = b.b, out[2] = 0, out[3] = 0, out[4] = b.c, out[5] = b.d, out[6] = 0, out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 1, out[11] = 0, out[12] = b.e, out[13] = b.f, out[14] = 0, out[15] = 1;
}
function scale2(out, a3, v) {
  const x = v[0], y = v[1], z = v[2];
  return out[0] = a3[0] * x, out[1] = a3[1] * x, out[2] = a3[2] * x, out[3] = a3[3] * x, out[4] = a3[4] * y, out[5] = a3[5] * y, out[6] = a3[6] * y, out[7] = a3[7] * y, out[8] = a3[8] * z, out[9] = a3[9] * z, out[10] = a3[10] * z, out[11] = a3[11] * z, out[12] = a3[12], out[13] = a3[13], out[14] = a3[14], out[15] = a3[15], out;
}
function multiplyMat4Mat4(out, a3, b) {
  const a00 = a3[0], a01 = a3[1], a02 = a3[2], a03 = a3[3], a10 = a3[4], a11 = a3[5], a12 = a3[6], a13 = a3[7], a20 = a3[8], a21 = a3[9], a22 = a3[10], a23 = a3[11], a30 = a3[12], a31 = a3[13], a32 = a3[14], a33 = a3[15];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[4], b1 = b[5], b2 = b[6], b3 = b[7], out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[8], b1 = b[9], b2 = b[10], b3 = b[11], out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[12], b1 = b[13], b2 = b[14], b3 = b[15], out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, out;
}
function getModelMatrix(out, graphic, theme2) {
  var _a;
  const { x = theme2.x, y = theme2.y, z = theme2.z, dx = theme2.dx, dy = theme2.dy, dz = theme2.dz, scaleX = theme2.scaleX, scaleY = theme2.scaleY, scaleZ = theme2.scaleZ, alpha = theme2.alpha, beta = theme2.beta, angle: angle2 = theme2.angle, anchor3d = graphic.attribute.anchor, anchor } = graphic.attribute, _anchor = [0, 0, 0];
  if (anchor3d) {
    if ("string" == typeof anchor3d[0]) {
      const ratio = parseFloat(anchor3d[0]) / 100, bounds = graphic.AABBBounds;
      _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
    } else
      _anchor[0] = anchor3d[0];
    if ("string" == typeof anchor3d[1]) {
      const ratio = parseFloat(anchor3d[1]) / 100, bounds = graphic.AABBBounds;
      _anchor[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
    } else
      _anchor[1] = anchor3d[1];
    _anchor[2] = null !== (_a = anchor3d[2]) && void 0 !== _a ? _a : 0;
  }
  if (identity(out), translate(out, out, [x + dx, y + dy, z + dz]), translate(out, out, [_anchor[0], _anchor[1], _anchor[2]]), rotateX(out, out, beta), rotateY(out, out, alpha), translate(out, out, [-_anchor[0], -_anchor[1], _anchor[2]]), scale2(out, out, [scaleX, scaleY, scaleZ]), angle2) {
    const m4 = mat4Allocate.allocate(), _anchor2 = [0, 0];
    if (anchor) {
      if ("string" == typeof anchor3d[0]) {
        const ratio = parseFloat(anchor3d[0]) / 100, bounds = graphic.AABBBounds;
        _anchor2[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
      } else
        _anchor2[0] = anchor3d[0];
      if ("string" == typeof anchor3d[1]) {
        const ratio = parseFloat(anchor3d[1]) / 100, bounds = graphic.AABBBounds;
        _anchor2[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
      } else
        _anchor2[1] = anchor3d[1];
    }
    translate(m4, m4, [_anchor2[0], _anchor2[1], 0]), rotateZ(m4, m4, angle2), translate(m4, m4, [-_anchor2[0], -_anchor2[1], 0]), multiplyMat4Mat4(out, out, m4);
  }
}
function shouldUseMat4(graphic) {
  const { alpha, beta } = graphic.attribute;
  return alpha || beta;
}
var DefaultGraphicService = class {
  constructor(creator) {
    this.creator = creator, this.hooks = {
      onAttributeUpdate: new SyncHook(["graphic"]),
      onSetStage: new SyncHook(["graphic", "stage"]),
      onRemove: new SyncHook(["graphic"]),
      onRelease: new SyncHook(["graphic"]),
      onAddIncremental: new SyncHook(["graphic", "group", "stage"]),
      onClearIncremental: new SyncHook(["graphic", "group", "stage"]),
      beforeUpdateAABBBounds: new SyncHook(["graphic", "stage", "willUpdate", "aabbBounds"]),
      afterUpdateAABBBounds: new SyncHook(["graphic", "stage", "aabbBounds", "globalAABBBounds", "selfChange"])
    }, this.tempAABBBounds1 = new AABBBounds(), this.tempAABBBounds2 = new AABBBounds(), this._rectBoundsContribitions = [new DefaultOuterBorderBoundsContribution()], this._symbolBoundsContribitions = [new DefaultSymbolOuterBorderBoundsContribution()], this._imageBoundsContribitions = [new DefaultOuterBorderBoundsContribution()], this._circleBoundsContribitions = [new DefaultOuterBorderBoundsContribution()], this._arcBoundsContribitions = [new DefaultOuterBorderBoundsContribution()], this._pathBoundsContribitions = [new DefaultOuterBorderBoundsContribution()];
  }
  onAttributeUpdate(graphic) {
    this.hooks.onAttributeUpdate.taps.length && this.hooks.onAttributeUpdate.call(graphic);
  }
  onSetStage(graphic, stage) {
    this.hooks.onSetStage.taps.length && this.hooks.onSetStage.call(graphic, stage);
  }
  onRemove(graphic) {
    this.hooks.onRemove.taps.length && this.hooks.onRemove.call(graphic);
  }
  onRelease(graphic) {
    this.hooks.onRelease.taps.length && this.hooks.onRelease.call(graphic);
  }
  onAddIncremental(graphic, group, stage) {
    this.hooks.onAddIncremental.taps.length && this.hooks.onAddIncremental.call(graphic, group, stage);
  }
  onClearIncremental(group, stage) {
    this.hooks.onClearIncremental.taps.length && this.hooks.onClearIncremental.call(group, stage);
  }
  beforeUpdateAABBBounds(graphic, stage, willUpdate, bounds) {
    this.hooks.beforeUpdateAABBBounds.taps.length && this.hooks.beforeUpdateAABBBounds.call(graphic, stage, willUpdate, bounds);
  }
  afterUpdateAABBBounds(graphic, stage, bounds, params2, selfChange) {
    this.hooks.afterUpdateAABBBounds.taps.length && this.hooks.afterUpdateAABBBounds.call(graphic, stage, bounds, params2, selfChange);
  }
  updatePathProxyAABBBounds(aabbBounds, graphic) {
    const path = "function" == typeof graphic.pathProxy ? graphic.pathProxy(graphic.attribute) : graphic.pathProxy;
    if (!path)
      return false;
    const boundsContext = new BoundsContext(aabbBounds);
    return renderCommandList(path.commandList, boundsContext, 0, 0), true;
  }
  updateRectAABBBounds(attribute, rectTheme, aabbBounds, graphic) {
    if (!this._validCheck(attribute, rectTheme, aabbBounds, graphic))
      return aabbBounds;
    if (!this.updatePathProxyAABBBounds(aabbBounds, graphic)) {
      let { width, height } = attribute;
      const { x1: x14, y1: y14, x, y } = attribute;
      width = null != width ? width : x14 - x, height = null != height ? height : y14 - y, aabbBounds.set(0, 0, width || 0, height || 0);
    }
    const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
    return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this._rectBoundsContribitions.length && this._rectBoundsContribitions.forEach((c3) => {
      c3.updateBounds(attribute, rectTheme, tb1, graphic), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
    }), this.transformAABBBounds(attribute, aabbBounds, rectTheme, false, graphic), aabbBounds;
  }
  updateGroupAABBBounds(attribute, groupTheme, aabbBounds, graphic) {
    const originalAABBBounds = aabbBounds;
    aabbBounds = aabbBounds.clone();
    const { width, height, path, clip = groupTheme.clip } = attribute;
    path && path.length ? path.forEach((g) => {
      aabbBounds.union(g.AABBBounds);
    }) : null != width && null != height && aabbBounds.set(0, 0, Math.max(0, width), Math.max(0, height)), clip || graphic.forEachChildren((node) => {
      aabbBounds.union(node.AABBBounds);
    });
    const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
    return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this.transformAABBBounds(attribute, aabbBounds, groupTheme, false, graphic), originalAABBBounds.copy(aabbBounds), originalAABBBounds;
  }
  updateGlyphAABBBounds(attribute, theme2, aabbBounds, graphic) {
    return this._validCheck(attribute, theme2, aabbBounds, graphic) ? (graphic.getSubGraphic().forEach((node) => {
      aabbBounds.union(node.AABBBounds);
    }), aabbBounds) : aabbBounds;
  }
  updateHTMLTextAABBBounds(attribute, textTheme, aabbBounds, graphic) {
    const { textAlign, textBaseline } = attribute;
    if (null != attribute.forceBoundsHeight) {
      const h = isNumber_default(attribute.forceBoundsHeight) ? attribute.forceBoundsHeight : attribute.forceBoundsHeight(), dy = textLayoutOffsetY(textBaseline, h, h);
      aabbBounds.set(aabbBounds.x1, dy, aabbBounds.x2, dy + h);
    }
    if (null != attribute.forceBoundsWidth) {
      const w = isNumber_default(attribute.forceBoundsWidth) ? attribute.forceBoundsWidth : attribute.forceBoundsWidth(), dx = textDrawOffsetX(textAlign, w);
      aabbBounds.set(dx, aabbBounds.y1, dx + w, aabbBounds.y2);
    }
  }
  updateRichTextAABBBounds(attribute, richtextTheme, aabbBounds, graphic) {
    if (!this._validCheck(attribute, richtextTheme, aabbBounds, graphic))
      return aabbBounds;
    if (!graphic)
      return aabbBounds;
    const { width = richtextTheme.width, height = richtextTheme.height, maxWidth = richtextTheme.maxWidth, maxHeight = richtextTheme.maxHeight, textAlign = richtextTheme.textAlign, textBaseline = richtextTheme.textBaseline } = attribute;
    if (width > 0 && height > 0)
      aabbBounds.set(0, 0, width, height);
    else {
      const frameCache = graphic.getFrameCache(), { width: actualWidth, height: actualHeight } = frameCache.getActualSize();
      let contentWidth = width || actualWidth || 0, contentHeight = height || actualHeight || 0;
      contentHeight = "number" == typeof maxHeight && contentHeight > maxHeight ? maxHeight : contentHeight || 0, contentWidth = "number" == typeof maxWidth && contentWidth > maxWidth ? maxWidth : contentWidth || 0, aabbBounds.set(0, 0, contentWidth, contentHeight);
    }
    let deltaY = 0;
    switch (textBaseline) {
      case "top":
        deltaY = 0;
        break;
      case "middle":
        deltaY = -aabbBounds.height() / 2;
        break;
      case "bottom":
        deltaY = -aabbBounds.height();
    }
    let deltaX = 0;
    switch (textAlign) {
      case "left":
        deltaX = 0;
        break;
      case "center":
        deltaX = -aabbBounds.width() / 2;
        break;
      case "right":
        deltaX = -aabbBounds.width();
    }
    aabbBounds.translate(deltaX, deltaY);
    const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
    return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), null == attribute.forceBoundsHeight && null == attribute.forceBoundsWidth || this.updateHTMLTextAABBBounds(attribute, richtextTheme, aabbBounds), this.transformAABBBounds(attribute, aabbBounds, richtextTheme, false, graphic), aabbBounds;
  }
  updateTextAABBBounds(attribute, textTheme, aabbBounds, graphic) {
    if (!this._validCheck(attribute, textTheme, aabbBounds, graphic))
      return aabbBounds;
    if (!graphic)
      return aabbBounds;
    const { text: text2 = textTheme.text } = graphic.attribute;
    Array.isArray(text2) ? graphic.updateMultilineAABBBounds(text2) : graphic.updateSingallineAABBBounds(text2);
    const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
    tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
    const { scaleX = textTheme.scaleX, scaleY = textTheme.scaleY, shadowBlur = textTheme.shadowBlur, strokeBoundsBuffer = textTheme.strokeBoundsBuffer } = attribute;
    if (shadowBlur) {
      const shadowBlurHalfWidth = shadowBlur / Math.abs(scaleX + scaleY);
      boundStroke(tb1, shadowBlurHalfWidth, true, strokeBoundsBuffer), aabbBounds.union(tb1);
    }
    return this.combindShadowAABBBounds(aabbBounds, graphic), null == attribute.forceBoundsHeight && null == attribute.forceBoundsWidth || this.updateHTMLTextAABBBounds(attribute, textTheme, aabbBounds), transformBoundsWithMatrix(aabbBounds, aabbBounds, graphic.transMatrix), aabbBounds;
  }
  updatePathAABBBounds(attribute, pathTheme, aabbBounds, graphic) {
    if (!this._validCheck(attribute, pathTheme, aabbBounds, graphic))
      return aabbBounds;
    this.updatePathProxyAABBBounds(aabbBounds, graphic) || this.updatePathAABBBoundsImprecise(attribute, pathTheme, aabbBounds, graphic);
    const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
    tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this._pathBoundsContribitions.length && this._pathBoundsContribitions.forEach((c3) => {
      c3.updateBounds(attribute, pathTheme, tb1, graphic), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
    });
    const { lineJoin = pathTheme.lineJoin } = attribute;
    return this.transformAABBBounds(attribute, aabbBounds, pathTheme, "miter" === lineJoin, graphic), aabbBounds;
  }
  updatePathAABBBoundsImprecise(attribute, pathTheme, aabbBounds, graphic) {
    if (!graphic)
      return aabbBounds;
    const pathShape = graphic.getParsedPathShape();
    return aabbBounds.union(pathShape.getBounds()), aabbBounds;
  }
  updatePyramid3dAABBBounds(attribute, polygonTheme, aabbBounds, graphic) {
    if (!graphic)
      return aabbBounds;
    const stage = graphic.stage;
    if (!stage || !stage.camera)
      return aabbBounds;
    graphic.findFace().vertices.forEach((v) => {
      const x = v[0], y = v[1];
      aabbBounds.add(x, y);
    });
    const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
    return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this.transformAABBBounds(attribute, aabbBounds, polygonTheme, false, graphic), aabbBounds;
  }
  updateArc3dAABBBounds(attribute, arcTheme, aabbBounds, graphic) {
    if (!graphic)
      return aabbBounds;
    const stage = graphic.stage;
    if (!stage || !stage.camera)
      return aabbBounds;
    const { outerRadius = arcTheme.outerRadius, height = 0 } = attribute, r = outerRadius + height;
    aabbBounds.setValue(-r, -r, r, r);
    const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
    return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this.transformAABBBounds(attribute, aabbBounds, arcTheme, false, graphic), aabbBounds;
  }
  updatePolygonAABBBounds(attribute, polygonTheme, aabbBounds, graphic) {
    if (!this._validCheck(attribute, polygonTheme, aabbBounds, graphic))
      return aabbBounds;
    this.updatePathProxyAABBBounds(aabbBounds, graphic) || this.updatePolygonAABBBoundsImprecise(attribute, polygonTheme, aabbBounds, graphic);
    const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
    tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
    const { lineJoin = polygonTheme.lineJoin } = attribute;
    return this.transformAABBBounds(attribute, aabbBounds, polygonTheme, "miter" === lineJoin, graphic), aabbBounds;
  }
  updatePolygonAABBBoundsImprecise(attribute, polygonTheme, aabbBounds, graphic) {
    const { points = polygonTheme.points } = attribute;
    return points.forEach((p) => {
      aabbBounds.add(p.x, p.y);
    }), aabbBounds;
  }
  updateLineAABBBounds(attribute, lineTheme, aabbBounds, graphic) {
    if (!this._validCheck(attribute, lineTheme, aabbBounds, graphic))
      return aabbBounds;
    this.updatePathProxyAABBBounds(aabbBounds, graphic) || (attribute.segments ? this.updateLineAABBBoundsBySegments(attribute, lineTheme, aabbBounds, graphic) : this.updateLineAABBBoundsByPoints(attribute, lineTheme, aabbBounds, graphic));
    const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
    tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
    const { lineJoin = lineTheme.lineJoin } = attribute;
    return this.transformAABBBounds(attribute, aabbBounds, lineTheme, "miter" === lineJoin, graphic), aabbBounds;
  }
  updateLineAABBBoundsByPoints(attribute, lineTheme, aabbBounds, graphic) {
    const { points = lineTheme.points } = attribute, b = aabbBounds;
    return points.forEach((p) => {
      b.add(p.x, p.y);
    }), b;
  }
  updateLineAABBBoundsBySegments(attribute, lineTheme, aabbBounds, graphic) {
    const { segments: segments2 = lineTheme.segments } = attribute, b = aabbBounds;
    return segments2.forEach((s2) => {
      s2.points.forEach((p) => {
        b.add(p.x, p.y);
      });
    }), b;
  }
  updateAreaAABBBounds(attribute, areaTheme, aabbBounds, graphic) {
    if (!this._validCheck(attribute, areaTheme, aabbBounds, graphic))
      return aabbBounds;
    this.updatePathProxyAABBBounds(aabbBounds, graphic) || (attribute.segments ? this.updateAreaAABBBoundsBySegments(attribute, areaTheme, aabbBounds, graphic) : this.updateAreaAABBBoundsByPoints(attribute, areaTheme, aabbBounds, graphic));
    const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
    tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2);
    const { lineJoin = areaTheme.lineJoin } = attribute;
    return this.transformAABBBounds(attribute, aabbBounds, areaTheme, "miter" === lineJoin, graphic), aabbBounds;
  }
  updateAreaAABBBoundsByPoints(attribute, areaTheme, aabbBounds, graphic) {
    const { points = areaTheme.points } = attribute, b = aabbBounds;
    return points.forEach((p) => {
      var _a, _b;
      b.add(p.x, p.y), b.add(null !== (_a = p.x1) && void 0 !== _a ? _a : p.x, null !== (_b = p.y1) && void 0 !== _b ? _b : p.y);
    }), b;
  }
  updateAreaAABBBoundsBySegments(attribute, areaTheme, aabbBounds, graphic) {
    const { segments: segments2 = areaTheme.segments } = attribute, b = aabbBounds;
    return segments2.forEach((s2) => {
      s2.points.forEach((p) => {
        var _a, _b;
        b.add(p.x, p.y), b.add(null !== (_a = p.x1) && void 0 !== _a ? _a : p.x, null !== (_b = p.y1) && void 0 !== _b ? _b : p.y);
      });
    }), b;
  }
  updateCircleAABBBounds(attribute, circleTheme, aabbBounds, full, graphic) {
    if (!this._validCheck(attribute, circleTheme, aabbBounds, graphic))
      return aabbBounds;
    this.updatePathProxyAABBBounds(aabbBounds, graphic) || (full ? this.updateCircleAABBBoundsImprecise(attribute, circleTheme, aabbBounds, graphic) : this.updateCircleAABBBoundsAccurate(attribute, circleTheme, aabbBounds, graphic));
    const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
    return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this._circleBoundsContribitions.length && this._circleBoundsContribitions.forEach((c3) => {
      c3.updateBounds(attribute, circleTheme, tb1, graphic), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
    }), this.transformAABBBounds(attribute, aabbBounds, circleTheme, false, graphic), aabbBounds;
  }
  updateCircleAABBBoundsImprecise(attribute, circleTheme, aabbBounds, graphic) {
    const { radius = circleTheme.radius } = attribute;
    return aabbBounds.set(-radius, -radius, radius, radius), aabbBounds;
  }
  updateCircleAABBBoundsAccurate(attribute, circleTheme, aabbBounds, graphic) {
    const { startAngle = circleTheme.startAngle, endAngle = circleTheme.endAngle, radius = circleTheme.radius } = attribute;
    return endAngle - startAngle > pi2 - epsilon ? aabbBounds.set(-radius, -radius, radius, radius) : circleBounds(startAngle, endAngle, radius, aabbBounds), aabbBounds;
  }
  updateArcAABBBounds(attribute, arcTheme, aabbBounds, full, graphic) {
    if (!this._validCheck(attribute, arcTheme, aabbBounds, graphic))
      return aabbBounds;
    this.updatePathProxyAABBBounds(aabbBounds, graphic) || (full ? this.updateArcAABBBoundsImprecise(attribute, arcTheme, aabbBounds, graphic) : this.updateArcAABBBoundsAccurate(attribute, arcTheme, aabbBounds, graphic));
    const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
    tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this._arcBoundsContribitions.length && this._arcBoundsContribitions.forEach((c3) => {
      c3.updateBounds(attribute, arcTheme, tb1, graphic), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
    });
    const { lineJoin = arcTheme.lineJoin } = attribute;
    return this.transformAABBBounds(attribute, aabbBounds, arcTheme, "miter" === lineJoin, graphic), aabbBounds;
  }
  updateArcAABBBoundsImprecise(attribute, arcTheme, aabbBounds, graphic) {
    let { outerRadius = arcTheme.outerRadius, innerRadius = arcTheme.innerRadius } = attribute;
    const { outerPadding = arcTheme.outerPadding, innerPadding = arcTheme.innerPadding } = attribute;
    return outerRadius += outerPadding, innerRadius -= innerPadding, outerRadius < innerRadius && (outerRadius = innerRadius), aabbBounds.set(-outerRadius, -outerRadius, outerRadius, outerRadius), aabbBounds;
  }
  updateArcAABBBoundsAccurate(attribute, arcTheme, aabbBounds, graphic) {
    let { outerRadius = arcTheme.outerRadius, innerRadius = arcTheme.innerRadius } = attribute;
    const { outerPadding = arcTheme.outerPadding, innerPadding = arcTheme.innerPadding } = attribute;
    if (outerRadius += outerPadding, innerRadius -= innerPadding, outerRadius < innerRadius) {
      const temp3 = outerRadius;
      outerRadius = innerRadius, innerRadius = temp3;
    }
    let { endAngle = arcTheme.endAngle, startAngle = arcTheme.startAngle } = attribute;
    if (startAngle > endAngle) {
      const temp3 = startAngle;
      startAngle = endAngle, endAngle = temp3;
    }
    return outerRadius <= epsilon ? aabbBounds.set(0, 0, 0, 0) : Math.abs(endAngle - startAngle) > pi2 - epsilon ? aabbBounds.set(-outerRadius, -outerRadius, outerRadius, outerRadius) : (circleBounds(startAngle, endAngle, outerRadius, aabbBounds), circleBounds(startAngle, endAngle, innerRadius, aabbBounds)), aabbBounds;
  }
  updateSymbolAABBBounds(attribute, symbolTheme, aabbBounds, full, graphic) {
    if (!this._validCheck(attribute, symbolTheme, aabbBounds, graphic))
      return aabbBounds;
    this.updatePathProxyAABBBounds(aabbBounds, graphic) || (full ? this.updateSymbolAABBBoundsImprecise(attribute, symbolTheme, aabbBounds, graphic) : this.updateSymbolAABBBoundsAccurate(attribute, symbolTheme, aabbBounds, graphic));
    const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
    tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this._symbolBoundsContribitions.length && this._symbolBoundsContribitions.forEach((c3) => {
      c3.updateBounds(attribute, symbolTheme, tb1, graphic), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
    });
    const { lineJoin = symbolTheme.lineJoin } = attribute;
    return this.transformAABBBounds(attribute, aabbBounds, symbolTheme, "miter" === lineJoin, graphic), aabbBounds;
  }
  updateSymbolAABBBoundsImprecise(attribute, symbolTheme, aabbBounds, graphic) {
    const { size = symbolTheme.size } = attribute;
    if (isArray_default(size))
      aabbBounds.set(-size[0] / 2, -size[1] / 2, size[0] / 2, size[1] / 2);
    else {
      const halfWH = size / 2;
      aabbBounds.set(-halfWH, -halfWH, halfWH, halfWH);
    }
    return aabbBounds;
  }
  updateSymbolAABBBoundsAccurate(attribute, symbolTheme, aabbBounds, graphic) {
    if (!graphic)
      return aabbBounds;
    const { size = symbolTheme.size } = attribute;
    return graphic.getParsedPath().bounds(size, aabbBounds), aabbBounds;
  }
  updateImageAABBBounds(attribute, imageTheme, aabbBounds, graphic) {
    if (!this._validCheck(attribute, imageTheme, aabbBounds, graphic))
      return aabbBounds;
    if (!this.updatePathProxyAABBBounds(aabbBounds, graphic)) {
      const { width = imageTheme.width, height = imageTheme.height } = attribute;
      aabbBounds.set(0, 0, width, height);
    }
    const tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
    return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), this._imageBoundsContribitions.length && this._imageBoundsContribitions.forEach((c3) => {
      c3.updateBounds(attribute, imageTheme, tb1, graphic), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
    }), this.transformAABBBounds(attribute, aabbBounds, imageTheme, false, graphic), aabbBounds;
  }
  combindShadowAABBBounds(bounds, graphic) {
    if (graphic && graphic.shadowRoot) {
      const b = graphic.shadowRoot.AABBBounds;
      bounds.union(b);
    }
  }
  transformAABBBounds(attribute, aabbBounds, theme2, miter, graphic) {
    if (!aabbBounds.empty()) {
      const { scaleX = theme2.scaleX, scaleY = theme2.scaleY, stroke: stroke2 = theme2.stroke, shadowBlur = theme2.shadowBlur, lineWidth = theme2.lineWidth, pickStrokeBuffer = theme2.pickStrokeBuffer, strokeBoundsBuffer = theme2.strokeBoundsBuffer } = attribute, tb1 = this.tempAABBBounds1, tb2 = this.tempAABBBounds2;
      if (stroke2 && lineWidth) {
        const scaledHalfLineWidth = (lineWidth + pickStrokeBuffer) / Math.abs(scaleX + scaleY);
        boundStroke(tb1, scaledHalfLineWidth, miter, strokeBoundsBuffer), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
      }
      if (shadowBlur) {
        const { shadowOffsetX = theme2.shadowOffsetX, shadowOffsetY = theme2.shadowOffsetY } = attribute, shadowBlurWidth = shadowBlur / Math.abs(scaleX + scaleY) * 2;
        boundStroke(tb1, shadowBlurWidth, false, strokeBoundsBuffer + 1), tb1.translate(shadowOffsetX, shadowOffsetY), aabbBounds.union(tb1);
      }
    }
    if (this.combindShadowAABBBounds(aabbBounds, graphic), aabbBounds.empty())
      return;
    let updateMatrix = true;
    const m4 = graphic.transMatrix;
    graphic && graphic.isContainer && (updateMatrix = !(1 === m4.a && 0 === m4.b && 0 === m4.c && 1 === m4.d && 0 === m4.e && 0 === m4.f)), updateMatrix && transformBoundsWithMatrix(aabbBounds, aabbBounds, m4);
  }
  _validCheck(attribute, theme2, aabbBounds, graphic) {
    if (!graphic)
      return true;
    if (null != attribute.forceBoundsHeight || null != attribute.forceBoundsWidth)
      return true;
    if (!graphic.valid)
      return aabbBounds.clear(), false;
    const { visible = theme2.visible } = attribute;
    return !!visible || (aabbBounds.clear(), false);
  }
};
DefaultGraphicService = __decorate7([injectable(), __param3(0, inject(GraphicCreator)), __metadata5("design:paramtypes", [Object])], DefaultGraphicService);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/graphic-creator
var GraphicCreator2 = class {
  constructor() {
    this.store = /* @__PURE__ */ new Map();
  }
  RegisterGraphicCreator(name, cb) {
    this.store.set(name, cb), this[name] = cb;
  }
  CreateGraphic(name, params2) {
    const cb = this.store.get(name);
    return cb ? cb(params2) : null;
  }
};
var graphicCreator = new GraphicCreator2();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/bounds
var text;
var richText;
function getTextBounds(params2) {
  return text || (text = graphicCreator.CreateGraphic("text", {})), text.initAttributes(params2), text.AABBBounds;
}
function getRichTextBounds(params2) {
  return richText || (richText = graphicCreator.CreateGraphic("richtext", {})), richText.setAttributes(params2), richText.AABBBounds;
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/base-render
var result = {
  x: 0,
  y: 0,
  z: 0,
  lastModelMatrix: null
};
var BaseRender = class {
  init(contributions) {
    contributions && (this._renderContribitions = contributions.getContributions()), this._renderContribitions || (this._renderContribitions = []), this.builtinContributions && this.builtinContributions.forEach((item) => this._renderContribitions.push(item)), this._renderContribitions.length && (this._renderContribitions.sort((a3, b) => b.order - a3.order), this._beforeRenderContribitions = this._renderContribitions.filter((c3) => c3.time === BaseRenderContributionTime.beforeFillStroke), this._afterRenderContribitions = this._renderContribitions.filter((c3) => c3.time === BaseRenderContributionTime.afterFillStroke));
  }
  beforeRenderStep(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params2) {
    this._beforeRenderContribitions && this._beforeRenderContribitions.forEach((c3) => {
      if (c3.supportedAppName && graphic.stage && graphic.stage.params && graphic.stage.params.context && graphic.stage.params.context.appName) {
        if (!(Array.isArray(c3.supportedAppName) ? c3.supportedAppName : [c3.supportedAppName]).includes(graphic.stage.params.context.appName))
          return;
      }
      c3.drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params2);
    });
  }
  afterRenderStep(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params2) {
    this._afterRenderContribitions && this._afterRenderContribitions.forEach((c3) => {
      if (c3.supportedAppName && graphic.stage && graphic.stage.params && graphic.stage.params.context && graphic.stage.params.context.appName) {
        if (!(Array.isArray(c3.supportedAppName) ? c3.supportedAppName : [c3.supportedAppName]).includes(graphic.stage.params.context.appName))
          return;
      }
      c3.drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params2);
    });
  }
  valid(graphic, defaultAttribute, fillCb, strokeCb) {
    const { fill = defaultAttribute.fill, background, stroke: stroke2 = defaultAttribute.stroke, opacity = defaultAttribute.opacity, fillOpacity = defaultAttribute.fillOpacity, lineWidth = defaultAttribute.lineWidth, strokeOpacity = defaultAttribute.strokeOpacity, visible = defaultAttribute.visible } = graphic.attribute, fVisible = fillVisible(opacity, fillOpacity, fill), sVisible = strokeVisible(opacity, strokeOpacity), doFill = runFill(fill, background), doStroke = runStroke(stroke2, lineWidth);
    return !(!graphic.valid || !visible) && (!(!doFill && !doStroke) && (!!(fVisible || sVisible || fillCb || strokeCb || background) && {
      fVisible,
      sVisible,
      doFill,
      doStroke
    }));
  }
  transform(graphic, graphicAttribute, context, use3dMatrixIn3dMode = false) {
    const { x = graphicAttribute.x, y = graphicAttribute.y, z = graphicAttribute.z, scaleX = graphicAttribute.scaleX, scaleY = graphicAttribute.scaleY, angle: angle2 = graphicAttribute.angle, postMatrix } = graphic.attribute, lastModelMatrix = context.modelMatrix, camera = context.camera;
    result.x = x, result.y = y, result.z = z, result.lastModelMatrix = lastModelMatrix;
    const shouldTransform3d = camera && (use3dMatrixIn3dMode || shouldUseMat4(graphic)), onlyTranslate = shouldTransform3d ? graphic.transMatrix.onlyTranslate() && !postMatrix : 1 === scaleX && 1 === scaleY && 0 === angle2 && !postMatrix;
    if (shouldTransform3d) {
      const nextModelMatrix = mat4Allocate.allocate(), modelMatrix = mat4Allocate.allocate();
      getModelMatrix(modelMatrix, graphic, graphicAttribute), multiplyMat4Mat4(nextModelMatrix, lastModelMatrix || nextModelMatrix, modelMatrix), result.x = 0, result.y = 0, result.z = 0, context.modelMatrix = nextModelMatrix, context.setTransform(1, 0, 0, 1, 0, 0, true), mat4Allocate.free(modelMatrix);
    }
    if (onlyTranslate && !lastModelMatrix) {
      const point5 = graphic.getOffsetXY(graphicAttribute);
      result.x += point5.x, result.y += point5.y, result.z = z, context.setTransformForCurrent();
    } else if (shouldTransform3d)
      result.x = 0, result.y = 0, result.z = 0, context.setTransform(1, 0, 0, 1, 0, 0, true);
    else if (camera && context.project) {
      const point5 = graphic.getOffsetXY(graphicAttribute);
      result.x += point5.x, result.y += point5.y, this.transformWithoutTranslate(context, result.x, result.y, result.z, scaleX, scaleY, angle2);
    } else
      context.transformFromMatrix(graphic.transMatrix, true), result.x = 0, result.y = 0, result.z = 0;
    return result;
  }
  transformUseContext2d(graphic, graphicAttribute, z, context) {
    const camera = context.camera;
    if (this.camera = camera, camera) {
      const bounds = graphic.AABBBounds, width = bounds.x2 - bounds.x1, height = bounds.y2 - bounds.y1, p1 = context.project(0, 0, z), p2 = context.project(width, 0, z), p3 = context.project(width, height, z), _p1 = {
        x: 0,
        y: 0
      }, _p2 = {
        x: width,
        y: 0
      }, _p3 = {
        x: width,
        y: height
      };
      context.camera = null;
      const denom = 1 / (_p1.x * (_p3.y - _p2.y) - _p2.x * _p3.y + _p3.x * _p2.y + (_p2.x - _p3.x) * _p1.y), m11 = -(_p1.y * (p3.x - p2.x) - _p2.y * p3.x + _p3.y * p2.x + (_p2.y - _p3.y) * p1.x) * denom, m12 = (_p2.y * p3.y + _p1.y * (p2.y - p3.y) - _p3.y * p2.y + (_p3.y - _p2.y) * p1.y) * denom, m21 = (_p1.x * (p3.x - p2.x) - _p2.x * p3.x + _p3.x * p2.x + (_p2.x - _p3.x) * p1.x) * denom, m22 = -(_p2.x * p3.y + _p1.x * (p2.y - p3.y) - _p3.x * p2.y + (_p3.x - _p2.x) * p1.y) * denom, dx = (_p1.x * (_p3.y * p2.x - _p2.y * p3.x) + _p1.y * (_p2.x * p3.x - _p3.x * p2.x) + (_p3.x * _p2.y - _p2.x * _p3.y) * p1.x) * denom, dy = (_p1.x * (_p3.y * p2.y - _p2.y * p3.y) + _p1.y * (_p2.x * p3.y - _p3.x * p2.y) + (_p3.x * _p2.y - _p2.x * _p3.y) * p1.y) * denom;
      context.setTransform(m11, m12, m21, m22, dx, dy, true);
    }
  }
  restoreTransformUseContext2d(graphic, graphicAttribute, z, context) {
    this.camera && (context.camera = this.camera);
  }
  transformWithoutTranslate(context, x, y, z, scaleX, scaleY, angle2) {
    const p = context.project(x, y, z);
    context.translate(p.x, p.y, false), context.scale(scaleX, scaleY, false), context.rotate(angle2, false), context.translate(-p.x, -p.y, false), context.setTransformForCurrent();
  }
  _draw(graphic, defaultAttr, computed3dMatrix, drawContext, params2) {
    const { context } = drawContext;
    if (!context)
      return;
    const { renderable } = graphic.attribute;
    if (false === renderable)
      return;
    context.highPerformanceSave();
    const data = this.transform(graphic, defaultAttr, context, computed3dMatrix), { x, y, z, lastModelMatrix } = data;
    this.z = z, drawPathProxy(graphic, context, x, y, drawContext, params2) || (this.drawShape(graphic, context, x, y, drawContext, params2), this.z = 0, context.modelMatrix !== lastModelMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastModelMatrix), context.highPerformanceRestore();
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/color-utils
var parse = function() {
  const tokens = {
    linearGradient: /^(linear\-gradient)/i,
    radialGradient: /^(radial\-gradient)/i,
    conicGradient: /^(conic\-gradient)/i,
    sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|top (left|right)|bottom (left|right)|left|right|top|bottom)/i,
    extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
    positionKeywords: /^(left|center|right|top|bottom)/i,
    pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
    percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
    emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
    angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
    fromAngleValue: /^from\s*(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
    startCall: /^\(/,
    endCall: /^\)/,
    comma: /^,/,
    hexColor: /(^\#[0-9a-fA-F]+)/,
    literalColor: /^([a-zA-Z]+)/,
    rgbColor: /^(rgb\(\d{1,3},\s*\d{1,3},\s*\d{1,3}\))/i,
    rgbaColor: /^(rgba\(\d{1,3},\s*\d{1,3},\s*\d{1,3},\s*((\d\.\d+)|\d{1,3})\))/i,
    number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
  };
  let input = "";
  function error3(msg) {
    const err = new Error(input + ": " + msg);
    throw err.source = input, err;
  }
  function getAST() {
    const ast = matchListing(matchDefinition);
    return input.length > 0 && error3("Invalid input not EOF"), ast;
  }
  function matchDefinition() {
    return matchGradient("linear", tokens.linearGradient, matchLinearOrientation) || matchGradient("radial", tokens.radialGradient, matchListRadialOrientations) || matchGradient("conic", tokens.conicGradient, matchConicalOrientation);
  }
  function matchGradient(gradientType, pattern, orientationMatcher) {
    return function(pattern2, callback) {
      const captures = scan(pattern2);
      if (captures) {
        scan(tokens.startCall) || error3("Missing (");
        const result2 = callback(captures);
        return scan(tokens.endCall) || error3("Missing )"), result2;
      }
    }(pattern, function(captures) {
      const orientation = orientationMatcher();
      return orientation && (scan(tokens.comma) || error3("Missing comma before color stops")), {
        type: gradientType,
        orientation,
        colorStops: matchListing(matchColorStop)
      };
    });
  }
  function matchLinearOrientation() {
    return match("directional", tokens.sideOrCorner, 1) || match("angular", tokens.angleValue, 1);
  }
  function matchConicalOrientation() {
    return match("angular", tokens.fromAngleValue, 1);
  }
  function matchListRadialOrientations() {
    let radialOrientations, lookaheadCache, radialOrientation = matchRadialOrientation();
    return radialOrientation && (radialOrientations = [], radialOrientations.push(radialOrientation), lookaheadCache = input, scan(tokens.comma) && (radialOrientation = matchRadialOrientation(), radialOrientation ? radialOrientations.push(radialOrientation) : input = lookaheadCache)), radialOrientations;
  }
  function matchRadialOrientation() {
    let radialType = function() {
      const circle3 = match("shape", /^(circle)/i, 0);
      circle3 && (circle3.style = matchLength() || matchExtentKeyword());
      return circle3;
    }() || function() {
      const ellipse = match("shape", /^(ellipse)/i, 0);
      ellipse && (ellipse.style = matchDistance() || matchExtentKeyword());
      return ellipse;
    }();
    if (radialType)
      radialType.at = matchAtPosition();
    else {
      const extent2 = matchExtentKeyword();
      if (extent2) {
        radialType = extent2;
        const positionAt = matchAtPosition();
        positionAt && (radialType.at = positionAt);
      } else {
        const defaultPosition = matchPositioning();
        defaultPosition && (radialType = {
          type: "default-radial",
          at: defaultPosition
        });
      }
    }
    return radialType;
  }
  function matchExtentKeyword() {
    return match("extent-keyword", tokens.extentKeywords, 1);
  }
  function matchAtPosition() {
    if (match("position", /^at/, 0)) {
      const positioning = matchPositioning();
      return positioning || error3("Missing positioning value"), positioning;
    }
  }
  function matchPositioning() {
    const location = {
      x: matchDistance(),
      y: matchDistance()
    };
    if (location.x || location.y)
      return {
        type: "position",
        value: location
      };
  }
  function matchListing(matcher) {
    let captures = matcher();
    const result2 = [];
    if (captures)
      for (result2.push(captures); scan(tokens.comma); )
        captures = matcher(), captures ? result2.push(captures) : error3("One extra comma");
    return result2;
  }
  function matchColorStop() {
    const color = match("hex", tokens.hexColor, 1) || match("rgba", tokens.rgbaColor, 1) || match("rgb", tokens.rgbColor, 1) || match("literal", tokens.literalColor, 0);
    return color || error3("Expected color definition"), color.length = matchDistance(), color;
  }
  function matchDistance() {
    return match("%", tokens.percentageValue, 1) || match("position-keyword", tokens.positionKeywords, 1) || matchLength();
  }
  function matchLength() {
    return match("px", tokens.pixelValue, 1) || match("em", tokens.emValue, 1);
  }
  function match(type, pattern, captureIndex) {
    const captures = scan(pattern);
    if (captures)
      return {
        type,
        value: captures[captureIndex]
      };
  }
  function scan(regexp) {
    const blankCaptures = /^[\n\r\t\s]+/.exec(input);
    blankCaptures && consume(blankCaptures[0].length);
    const captures = regexp.exec(input);
    return captures && consume(captures[0].length), captures;
  }
  function consume(size) {
    input = input.substr(size);
  }
  return function(code) {
    return input = code.toString(), getAST();
  };
}();
var GradientParser = class _GradientParser {
  static IsGradient(c3) {
    return !("string" == typeof c3 && !c3.includes("gradient"));
  }
  static IsGradientStr(c3) {
    return "string" == typeof c3 && c3.includes("gradient");
  }
  static Parse(c3) {
    if (_GradientParser.IsGradientStr(c3))
      try {
        const datum = parse(c3)[0];
        if (datum) {
          if ("linear" === datum.type)
            return _GradientParser.ParseLinear(datum);
          if ("radial" === datum.type)
            return _GradientParser.ParseRadial(datum);
          if ("conic" === datum.type)
            return _GradientParser.ParseConic(datum);
        }
      } catch (err) {
        return c3;
      }
    return c3;
  }
  static ParseConic(datum) {
    const { orientation, colorStops = [] } = datum, halfPi4 = pi / 2, sa = parseFloat(orientation.value) / 180 * pi - halfPi4;
    return {
      gradient: "conical",
      x: 0.5,
      y: 0.5,
      startAngle: sa,
      endAngle: sa + pi2,
      stops: colorStops.map((item) => ({
        color: item.value,
        offset: parseFloat(item.length.value) / 100
      }))
    };
  }
  static ParseRadial(datum) {
    const { colorStops = [] } = datum;
    return {
      gradient: "radial",
      x0: 0.5,
      y0: 0.5,
      x1: 0.5,
      y1: 0.5,
      r0: 0,
      r1: 1,
      stops: colorStops.map((item) => ({
        color: item.value,
        offset: parseFloat(item.length.value) / 100
      }))
    };
  }
  static ParseLinear(datum) {
    const { orientation, colorStops = [] } = datum, halfPi4 = pi / 2;
    let angle2 = "angular" === orientation.type ? parseFloat(orientation.value) / 180 * pi : 0;
    for (; angle2 < 0; )
      angle2 += pi2;
    for (; angle2 > pi2; )
      angle2 -= pi2;
    let x05 = 0, y05 = 0, x14 = 0, y14 = 0;
    return angle2 < halfPi4 ? (x05 = 0, y05 = 1, x14 = Math.sin(angle2), y14 = Math.cos(angle2)) : angle2 < pi ? (x05 = 0, y05 = 0, x14 = Math.cos(angle2 - halfPi4), y14 = Math.sin(angle2 - halfPi4)) : angle2 < pi + halfPi4 ? (x05 = 1, y05 = 0, x14 = x05 - Math.sin(angle2 - pi), y14 = Math.cos(angle2 - pi)) : (x05 = 1, x14 = x05 - Math.cos(angle2 - halfPi4 - pi), y14 -= Math.sin(angle2 - halfPi4 - pi)), {
      gradient: "linear",
      x0: x05,
      y0: y05,
      x1: x14,
      y1: y14,
      stops: colorStops.map((item) => ({
        color: item.value,
        offset: parseFloat(item.length.value) / 100
      }))
    };
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/canvas-utils
function getScaledStroke(context, width, dpr) {
  let strokeWidth = width;
  const { a: a3, b, c: c3, d } = context.currentMatrix, scaleX = Math.sign(a3) * Math.sqrt(a3 * a3 + b * b), scaleY = Math.sign(d) * Math.sqrt(c3 * c3 + d * d);
  return scaleX + scaleY === 0 ? 0 : (strokeWidth = strokeWidth / Math.abs(scaleX + scaleY) * 2 * dpr, strokeWidth);
}
function createColor(context, c3, params2, offsetX, offsetY) {
  if (!c3 || true === c3)
    return "black";
  let result2, color;
  if (isArray_default(c3))
    for (let i = 0; i < c3.length && (color = c3[i], !color); i++)
      ;
  else
    color = c3;
  return color = GradientParser.Parse(color), "string" == typeof color ? color : ("linear" === color.gradient ? result2 = createLinearGradient(context, color, params2, offsetX, offsetY) : "conical" === color.gradient ? result2 = createConicGradient(context, color, params2, offsetX, offsetY) : "radial" === color.gradient && (result2 = createRadialGradient(context, color, params2, offsetX, offsetY)), result2 || "orange");
}
function createLinearGradient(context, color, params2, offsetX = 0, offsetY = 0) {
  var _a, _b, _c, _d;
  const bounds = params2.AABBBounds;
  if (!bounds)
    return;
  let w = bounds.x2 - bounds.x1, h = bounds.y2 - bounds.y1, x = bounds.x1 - offsetX, y = bounds.y1 - offsetY;
  if (params2.attribute) {
    const { scaleX = 1, scaleY = 1 } = params2.attribute;
    if (scaleX * scaleY == 0)
      return;
    w /= scaleX, h /= scaleY, x /= scaleX, y /= scaleY;
  }
  const canvasGradient = context.createLinearGradient(x + (null !== (_a = color.x0) && void 0 !== _a ? _a : 0) * w, y + (null !== (_b = color.y0) && void 0 !== _b ? _b : 0) * h, x + (null !== (_c = color.x1) && void 0 !== _c ? _c : 1) * w, y + (null !== (_d = color.y1) && void 0 !== _d ? _d : 0) * h);
  return color.stops.forEach((stop) => {
    canvasGradient.addColorStop(stop.offset, stop.color);
  }), canvasGradient;
}
function createRadialGradient(context, color, params2, offsetX = 0, offsetY = 0) {
  var _a, _b, _c, _d, _e, _f;
  const bounds = params2.AABBBounds;
  if (!bounds)
    return;
  let w = bounds.x2 - bounds.x1, h = bounds.y2 - bounds.y1, x = bounds.x1 - offsetX, y = bounds.y1 - offsetY;
  if (params2.attribute) {
    const { scaleX = 1, scaleY = 1 } = params2.attribute;
    if (scaleX * scaleY == 0)
      return;
    x /= scaleX, y /= scaleY, w /= scaleX, h /= scaleY;
  }
  const canvasGradient = context.createRadialGradient(x + (null !== (_a = color.x0) && void 0 !== _a ? _a : 0.5) * w, y + (null !== (_b = color.y0) && void 0 !== _b ? _b : 0.5) * h, Math.max(w, h) * (null !== (_c = color.r0) && void 0 !== _c ? _c : 0), x + (null !== (_d = color.x1) && void 0 !== _d ? _d : 0.5) * w, y + (null !== (_e = color.y1) && void 0 !== _e ? _e : 0.5) * h, Math.max(w, h) * (null !== (_f = color.r1) && void 0 !== _f ? _f : 0.5));
  return color.stops.forEach((stop) => {
    canvasGradient.addColorStop(stop.offset, stop.color);
  }), canvasGradient;
}
function createConicGradient(context, color, params2, offsetX = 0, offsetY = 0) {
  var _a, _b;
  const bounds = params2.AABBBounds;
  if (!bounds)
    return;
  let w = bounds.x2 - bounds.x1, h = bounds.y2 - bounds.y1, x = bounds.x1 - offsetX, y = bounds.y1 - offsetY;
  if (params2.attribute) {
    const { scaleX = 1, scaleY = 1 } = params2.attribute;
    if (scaleX * scaleY == 0)
      return;
    w /= scaleX, h /= scaleY, x /= scaleX, y /= scaleY;
  }
  const canvasGradient = context.createConicGradient(x + (null !== (_a = color.x) && void 0 !== _a ? _a : 0) * w, y + (null !== (_b = color.y) && void 0 !== _b ? _b : 0) * h, color.startAngle, color.endAngle);
  return color.stops.forEach((stop) => {
    canvasGradient.addColorStop(stop.offset, stop.color);
  }), canvasGradient.GetPattern(w + x, h + y, void 0);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/contributions/base-contribution-render
var __decorate8 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata6 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param4 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultBaseBackgroundRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.beforeFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    var _a;
    const { background, backgroundOpacity = null !== (_a = graphic.attribute.fillOpacity) && void 0 !== _a ? _a : graphicAttribute.backgroundOpacity, opacity = graphicAttribute.opacity, backgroundMode = graphicAttribute.backgroundMode, backgroundFit = graphicAttribute.backgroundFit } = graphic.attribute;
    if (background)
      if (graphic.backgroundImg && graphic.resources) {
        const res = graphic.resources.get(background);
        if ("success" !== res.state || !res.data)
          return;
        if (context.save(), graphic.parent && !graphic.transMatrix.onlyTranslate()) {
          const groupAttribute = getTheme(graphic.parent).group, { scrollX = groupAttribute.scrollX, scrollY = groupAttribute.scrollY } = graphic.parent.attribute;
          context.setTransformFromMatrix(graphic.parent.globalTransMatrix, true), context.translate(scrollX, scrollY);
        }
        context.clip();
        const b = graphic.AABBBounds;
        context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.globalAlpha = backgroundOpacity * opacity, this.doDrawImage(context, res.data, b, backgroundMode, backgroundFit), context.restore(), graphic.transMatrix.onlyTranslate() || context.setTransformForCurrent();
      } else
        context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.globalAlpha = backgroundOpacity * opacity, context.fillStyle = background, context.fill(), context.highPerformanceRestore();
  }
  doDrawImage(context, data, b, backgroundMode, backgroundFit) {
    if ("no-repeat" === backgroundMode)
      context.drawImage(data, b.x1, b.y1, b.width(), b.height());
    else {
      const targetW = b.width(), targetH = b.height();
      let w = targetW, h = targetH;
      if (backgroundFit && "repeat" !== backgroundMode && (data.width || data.height)) {
        const resW = data.width, resH = data.height;
        if ("repeat-x" === backgroundMode) {
          w = resW * (targetH / resH), h = targetH;
        } else if ("repeat-y" === backgroundMode) {
          h = resH * (targetW / resW), w = targetW;
        }
        const dpr2 = context.dpr, canvas = canvasAllocate.allocate({
          width: w,
          height: h,
          dpr: dpr2
        }), ctx = canvas.getContext("2d");
        ctx && (ctx.inuse = true, ctx.clearMatrix(), ctx.setTransformForCurrent(true), ctx.clearRect(0, 0, w, h), ctx.drawImage(data, 0, 0, w, h), data = canvas.nativeCanvas), canvasAllocate.free(canvas);
      }
      const dpr = context.dpr, pattern = context.createPattern(data, backgroundMode);
      pattern.setTransform && pattern.setTransform(new DOMMatrix([1 / dpr, 0, 0, 1 / dpr, 0, 0])), context.fillStyle = pattern, context.translate(b.x1, b.y1), context.fillRect(0, 0, targetW, targetH), context.translate(-b.x1, -b.y1);
    }
  }
};
var defaultBaseBackgroundRenderContribution = new DefaultBaseBackgroundRenderContribution();
var DefaultBaseInteractiveRenderContribution = class {
  constructor(subRenderContribitions) {
    this.subRenderContribitions = subRenderContribitions, this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    this._subRenderContribitions || (this._subRenderContribitions = this.subRenderContribitions.getContributions()), this._subRenderContribitions.forEach((c3) => {
      c3.render(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options);
    });
  }
};
DefaultBaseInteractiveRenderContribution = __decorate8([injectable(), __param4(0, inject(ContributionProvider)), __param4(0, named(InteractiveSubRenderContribution)), __metadata6("design:paramtypes", [Object])], DefaultBaseInteractiveRenderContribution);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/contributions/base-texture-contribution-render
var DefaultBaseTextureRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 10;
  }
  createCommonPattern(size, padding, color, targetContext, cb) {
    const r = (size - 2 * padding) / 2, dpr = targetContext.dpr, canvas = canvasAllocate.allocate({
      width: size,
      height: size,
      dpr
    }), ctx = canvas.getContext("2d");
    if (!ctx)
      return null;
    ctx.inuse = true, ctx.clearMatrix(), ctx.setTransformForCurrent(true), ctx.clearRect(0, 0, size, size), cb(r, ctx);
    const pattern = targetContext.createPattern(canvas.nativeCanvas, "repeat");
    return pattern.setTransform && pattern.setTransform(new DOMMatrix([1 / dpr, 0, 0, 1 / dpr, 0, 0])), canvasAllocate.free(canvas), pattern;
  }
  createCirclePattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      ctx.fillStyle = color, ctx.arc(r, r, r, 0, pi2), ctx.fill();
    });
  }
  createDiamondPattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      const x = size / 2, y = x;
      ctx.fillStyle = color, ctx.moveTo(x, y - r), ctx.lineTo(r + x, y), ctx.lineTo(x, y + r), ctx.lineTo(x - r, y), ctx.closePath(), ctx.fill();
    });
  }
  createRectPattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      const x = padding, y = x;
      ctx.fillStyle = color, ctx.fillRect(x, y, 2 * r, 2 * r);
    });
  }
  createVerticalLinePattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      const x = padding;
      ctx.fillStyle = color, ctx.fillRect(x, 0, 2 * r, size);
    });
  }
  createHorizontalLinePattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      const y = padding;
      ctx.fillStyle = color, ctx.fillRect(0, y, size, 2 * r);
    });
  }
  createBiasLRLinePattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      ctx.strokeStyle = color, ctx.lineWidth = r, ctx.moveTo(0, 0), ctx.lineTo(size, size);
      const dx = size / 2, dy = -dx;
      ctx.moveTo(dx, dy), ctx.lineTo(dx + size, dy + size), ctx.moveTo(-dx, -dy), ctx.lineTo(-dx + size, -dy + size), ctx.stroke();
    });
  }
  createBiasRLLinePattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      ctx.strokeStyle = color, ctx.lineWidth = r, ctx.moveTo(size, 0), ctx.lineTo(0, size);
      const dx = size / 2, dy = dx;
      ctx.moveTo(size + dx, dy), ctx.lineTo(dx, dy + size), ctx.moveTo(size - dx, -dy), ctx.lineTo(-dx, -dy + size), ctx.stroke();
    });
  }
  createGridPattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      const x = padding, y = x;
      ctx.fillStyle = color, ctx.fillRect(x, y, r, r), ctx.fillRect(x + r, y + r, r, r);
    });
  }
  initTextureMap(ctx, stage) {
    this.textureMap = /* @__PURE__ */ new Map();
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    this.textureMap || this.initTextureMap(context, graphic.stage);
    const { texture = graphicAttribute.texture, textureColor = graphicAttribute.textureColor, textureSize = graphicAttribute.textureSize, texturePadding = graphicAttribute.texturePadding } = graphic.attribute;
    texture && this.drawTexture(texture, graphic, context, x, y, graphicAttribute, textureColor, textureSize, texturePadding);
  }
  drawTexture(texture, graphic, context, x, y, graphicAttribute, textureColor, textureSize, texturePadding) {
    let pattern = this.textureMap.get(texture);
    if (!pattern)
      switch (texture) {
        case "circle":
          pattern = this.createCirclePattern(textureSize, texturePadding, textureColor, context);
          break;
        case "diamond":
          pattern = this.createDiamondPattern(textureSize, texturePadding, textureColor, context);
          break;
        case "rect":
          pattern = this.createRectPattern(textureSize, texturePadding, textureColor, context);
          break;
        case "vertical-line":
          pattern = this.createVerticalLinePattern(textureSize, texturePadding, textureColor, context);
          break;
        case "horizontal-line":
          pattern = this.createHorizontalLinePattern(textureSize, texturePadding, textureColor, context);
          break;
        case "bias-lr":
          pattern = this.createBiasLRLinePattern(textureSize, texturePadding, textureColor, context);
          break;
        case "bias-rl":
          pattern = this.createBiasRLLinePattern(textureSize, texturePadding, textureColor, context);
          break;
        case "grid":
          pattern = this.createGridPattern(textureSize, texturePadding, textureColor, context);
      }
    pattern && (context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.fillStyle = pattern, context.fill(), context.highPerformanceRestore());
  }
};
var defaultBaseTextureRenderContribution = new DefaultBaseTextureRenderContribution();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/contributions/arc-contribution-render
var DefaultArcRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb) {
    const { outerBorder, innerBorder } = arc.attribute, doOuterBorder = outerBorder && false !== outerBorder.visible, doInnerBorder = innerBorder && false !== innerBorder.visible;
    if (!doOuterBorder && !doInnerBorder)
      return;
    const { innerPadding = arcAttribute.innerPadding, outerPadding = arcAttribute.outerPadding, startAngle = arcAttribute.startAngle, endAngle = arcAttribute.endAngle, opacity = arcAttribute.opacity, x: originX = arcAttribute.x, y: originY = arcAttribute.y, scaleX = arcAttribute.scaleX, scaleY = arcAttribute.scaleY } = arc.attribute;
    let { innerRadius = arcAttribute.innerRadius, outerRadius = arcAttribute.outerRadius } = arc.attribute;
    outerRadius += outerPadding, innerRadius -= innerPadding;
    const doStrokeOuter = !(!outerBorder || !outerBorder.stroke), doStrokeInner = !(!innerBorder || !innerBorder.stroke);
    if (doOuterBorder) {
      const { distance: distance2 = arcAttribute.outerBorder.distance } = outerBorder, d = getScaledStroke(context, distance2, context.dpr), deltaAngle = distance2 / outerRadius;
      if (arc.setAttributes({
        outerRadius: outerRadius + d,
        innerRadius: innerRadius - d,
        startAngle: startAngle - deltaAngle,
        endAngle: endAngle + deltaAngle
      }), context.beginPath(), drawArcPath(arc, context, x, y, outerRadius + d, innerRadius - d), context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), strokeCb)
        strokeCb(context, outerBorder, arcAttribute.outerBorder);
      else if (doStrokeOuter) {
        const lastOpacity = arcAttribute.outerBorder.opacity;
        arcAttribute.outerBorder.opacity = opacity, context.setStrokeStyle(arc, outerBorder, (originX - x) / scaleX, (originY - y) / scaleY, arcAttribute.outerBorder), arcAttribute.outerBorder.opacity = lastOpacity, context.stroke();
      }
    }
    if (doInnerBorder) {
      const { distance: distance2 = arcAttribute.innerBorder.distance } = innerBorder, d = getScaledStroke(context, distance2, context.dpr), deltaAngle = distance2 / outerRadius;
      if (arc.setAttributes({
        outerRadius: outerRadius - d,
        innerRadius: innerRadius + d,
        startAngle: startAngle + deltaAngle,
        endAngle: endAngle - deltaAngle
      }), context.beginPath(), drawArcPath(arc, context, x, y, outerRadius - d, innerRadius + d), context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), strokeCb)
        strokeCb(context, innerBorder, arcAttribute.innerBorder);
      else if (doStrokeInner) {
        const lastOpacity = arcAttribute.innerBorder.opacity;
        arcAttribute.innerBorder.opacity = opacity, context.setStrokeStyle(arc, innerBorder, (originX - x) / scaleX, (originY - y) / scaleY, arcAttribute.innerBorder), arcAttribute.innerBorder.opacity = lastOpacity, context.stroke();
      }
    }
    arc.setAttributes({
      outerRadius,
      innerRadius,
      startAngle,
      endAngle
    });
  }
};
var defaultArcRenderContribution = new DefaultArcRenderContribution();
var defaultArcTextureRenderContribution = defaultBaseTextureRenderContribution;
var defaultArcBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/contributions/circle-contribution-render
var DefaultCircleRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(circle3, context, x, y, doFill, doStroke, fVisible, sVisible, circleAttribute, drawContext, fillCb, strokeCb) {
    const { outerBorder, innerBorder } = circle3.attribute, doOuterBorder = outerBorder && false !== outerBorder.visible, doInnerBorder = innerBorder && false !== innerBorder.visible;
    if (!doOuterBorder && !doInnerBorder)
      return;
    const { radius = circleAttribute.radius, startAngle = circleAttribute.startAngle, endAngle = circleAttribute.endAngle, opacity = circleAttribute.opacity, x: originX = circleAttribute.x, y: originY = circleAttribute.y, scaleX = circleAttribute.scaleX, scaleY = circleAttribute.scaleY } = circle3.attribute, doStrokeOuter = !(!outerBorder || !outerBorder.stroke), doStrokeInner = !(!innerBorder || !innerBorder.stroke);
    if (doOuterBorder) {
      const { distance: distance2 = circleAttribute.outerBorder.distance } = outerBorder, dw = getScaledStroke(context, distance2, context.dpr);
      if (context.beginPath(), context.arc(x, y, radius + dw, startAngle, endAngle), context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(circle3, circle3.attribute, circleAttribute), strokeCb)
        strokeCb(context, outerBorder, circleAttribute.outerBorder);
      else if (doStrokeOuter) {
        const lastOpacity = circleAttribute.outerBorder.opacity;
        circleAttribute.outerBorder.opacity = opacity, context.setStrokeStyle(circle3, outerBorder, (originX - x) / scaleX, (originY - y) / scaleY, circleAttribute.outerBorder), circleAttribute.outerBorder.opacity = lastOpacity, context.stroke();
      }
    }
    if (doInnerBorder) {
      const { distance: distance2 = circleAttribute.innerBorder.distance } = innerBorder, dw = getScaledStroke(context, distance2, context.dpr);
      if (context.beginPath(), context.arc(x, y, radius - dw, startAngle, endAngle), context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(circle3, circle3.attribute, circleAttribute), strokeCb)
        strokeCb(context, innerBorder, circleAttribute.innerBorder);
      else if (doStrokeInner) {
        const lastOpacity = circleAttribute.innerBorder.opacity;
        circleAttribute.innerBorder.opacity = opacity, context.setStrokeStyle(circle3, innerBorder, (originX - x) / scaleX, (originY - y) / scaleY, circleAttribute.innerBorder), circleAttribute.innerBorder.opacity = lastOpacity, context.stroke();
      }
    }
  }
};
var defaultCircleRenderContribution = new DefaultCircleRenderContribution();
var defaultCircleTextureRenderContribution = defaultBaseTextureRenderContribution;
var defaultCircleBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/contributions/group-contribution-render
var DefaultGroupBackgroundRenderContribution = class extends DefaultBaseBackgroundRenderContribution {
  constructor() {
    super(...arguments), this.time = BaseRenderContributionTime.beforeFillStroke;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb) {
    const { background, backgroundMode = graphicAttribute.backgroundMode, backgroundFit = graphicAttribute.backgroundFit } = graphic.attribute;
    if (background)
      if (graphic.backgroundImg && graphic.resources) {
        const res = graphic.resources.get(background);
        if ("success" !== res.state || !res.data)
          return;
        context.highPerformanceSave(), context.setTransformFromMatrix(graphic.parent.globalTransMatrix, true);
        const b = graphic.AABBBounds;
        this.doDrawImage(context, res.data, b, backgroundMode, backgroundFit), context.highPerformanceRestore(), context.setTransformForCurrent();
      } else
        context.highPerformanceSave(), context.fillStyle = background, context.fill(), context.highPerformanceRestore();
  }
};
var defaultGroupBackgroundRenderContribution = new DefaultGroupBackgroundRenderContribution();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/shape/rect
var halfPi3 = pi / 2;
function createRectPath(path, x, y, width, height, rectCornerRadius) {
  let cornerRadius;
  if (width < 0 && (x += width, width = -width), height < 0 && (y += height, height = -height), isNumber_default(rectCornerRadius, true))
    cornerRadius = [rectCornerRadius = abs(rectCornerRadius), rectCornerRadius, rectCornerRadius, rectCornerRadius];
  else if (Array.isArray(rectCornerRadius)) {
    const cornerRadiusArr = rectCornerRadius;
    let cr0, cr1;
    switch (cornerRadiusArr.length) {
      case 0:
        cornerRadius = [0, 0, 0, 0];
        break;
      case 1:
        cr0 = abs(cornerRadiusArr[0]), cornerRadius = [cr0, cr0, cr0, cr0];
        break;
      case 2:
      case 3:
        cr0 = abs(cornerRadiusArr[0]), cr1 = abs(cornerRadiusArr[1]), cornerRadius = [cr0, cr1, cr0, cr1];
        break;
      default:
        cornerRadius = cornerRadiusArr, cornerRadius[0] = abs(cornerRadius[0]), cornerRadius[1] = abs(cornerRadius[1]), cornerRadius[2] = abs(cornerRadius[2]), cornerRadius[3] = abs(cornerRadius[3]);
    }
  } else
    cornerRadius = [0, 0, 0, 0];
  if (width < 0 || cornerRadius[0] + cornerRadius[1] + cornerRadius[2] + cornerRadius[3] < 1e-12)
    return path.rect(x, y, width, height);
  const [leftTop, rightTop, rightBottom, leftBottom] = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]], maxCornerRadius = Math.min(width / 2, height / 2), _cornerRadius = [Math.min(maxCornerRadius, cornerRadius[0]), Math.min(maxCornerRadius, cornerRadius[1]), Math.min(maxCornerRadius, cornerRadius[2]), Math.min(maxCornerRadius, cornerRadius[3])], leftTopPoint1 = [leftTop[0] + _cornerRadius[0], leftTop[1]], leftTopPoint2 = [leftTop[0], leftTop[1] + _cornerRadius[0]], rightTopPoint1 = [rightTop[0] - _cornerRadius[1], rightTop[1]], rightTopPoint2 = [rightTop[0], rightTop[1] + _cornerRadius[1]], rightBottomPoint1 = [rightBottom[0] - _cornerRadius[2], rightBottom[1]], rightBottomPoint2 = [rightBottom[0], rightBottom[1] - _cornerRadius[2]], leftBottomPoint1 = [leftBottom[0] + _cornerRadius[3], leftBottom[1]], leftBottomPoint2 = [leftBottom[0], leftBottom[1] - _cornerRadius[3]];
  if (path.moveTo(leftTopPoint1[0], leftTopPoint1[1]), path.lineTo(rightTopPoint1[0], rightTopPoint1[1]), !arrayEqual(rightTopPoint1, rightTopPoint2)) {
    const centerX = rightTopPoint1[0], centerY = rightTopPoint1[1] + _cornerRadius[1];
    path.arc(centerX, centerY, _cornerRadius[1], -halfPi3, 0, false);
  }
  if (path.lineTo(rightBottomPoint2[0], rightBottomPoint2[1]), !arrayEqual(rightBottomPoint1, rightBottomPoint2)) {
    const centerX = rightBottomPoint2[0] - _cornerRadius[2], centerY = rightBottomPoint2[1];
    path.arc(centerX, centerY, _cornerRadius[2], 0, halfPi3, false);
  }
  if (path.lineTo(leftBottomPoint1[0], leftBottomPoint1[1]), !arrayEqual(leftBottomPoint1, leftBottomPoint2)) {
    const centerX = leftBottomPoint1[0], centerY = leftBottomPoint1[1] - _cornerRadius[3];
    path.arc(centerX, centerY, _cornerRadius[3], halfPi3, pi, false);
  }
  if (path.lineTo(leftTopPoint2[0], leftTopPoint2[1]), !arrayEqual(leftTopPoint1, leftTopPoint2)) {
    const centerX = leftTopPoint1[0], centerY = leftTopPoint1[1] + _cornerRadius[0];
    path.arc(centerX, centerY, _cornerRadius[0], pi, pi + halfPi3, false);
  }
  return path.closePath(), path;
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/contributions/rect-contribution-render
var __decorate9 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultRectRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb) {
    const { outerBorder, innerBorder } = rect.attribute, doOuterBorder = outerBorder && false !== outerBorder.visible, doInnerBorder = innerBorder && false !== innerBorder.visible;
    if (!doOuterBorder && !doInnerBorder)
      return;
    const { cornerRadius = rectAttribute.cornerRadius, opacity = rectAttribute.opacity, x: originX = rectAttribute.x, y: originY = rectAttribute.y, scaleX = rectAttribute.scaleX, scaleY = rectAttribute.scaleY, x1: x14, y1: y14 } = rect.attribute;
    let { width, height } = rect.attribute;
    width = (null != width ? width : x14 - x) || 0, height = (null != height ? height : y14 - y) || 0;
    const doStrokeOuter = !(!outerBorder || !outerBorder.stroke), doStrokeInner = !(!innerBorder || !innerBorder.stroke);
    if (doOuterBorder) {
      const { distance: distance2 = rectAttribute.outerBorder.distance } = outerBorder, d = getScaledStroke(context, distance2, context.dpr), nextX = x - d, nextY = y - d, dw = 2 * d;
      if (0 === cornerRadius || isArray_default(cornerRadius) && cornerRadius.every((num) => 0 === num) ? (context.beginPath(), context.rect(nextX, nextY, width + dw, height + dw)) : (context.beginPath(), createRectPath(context, nextX, nextY, width + dw, height + dw, cornerRadius)), context.setShadowBlendStyle && context.setShadowBlendStyle(rect, rect.attribute, rectAttribute), strokeCb)
        strokeCb(context, outerBorder, rectAttribute.outerBorder);
      else if (doStrokeOuter) {
        const lastOpacity = rectAttribute.outerBorder.opacity;
        rectAttribute.outerBorder.opacity = opacity, context.setStrokeStyle(rect, outerBorder, (originX - x) / scaleX, (originY - y) / scaleY, rectAttribute.outerBorder), rectAttribute.outerBorder.opacity = lastOpacity, context.stroke();
      }
    }
    if (doInnerBorder) {
      const { distance: distance2 = rectAttribute.innerBorder.distance } = innerBorder, d = getScaledStroke(context, distance2, context.dpr), nextX = x + d, nextY = y + d, dw = 2 * d;
      if (0 === cornerRadius || isArray_default(cornerRadius) && cornerRadius.every((num) => 0 === num) ? (context.beginPath(), context.rect(nextX, nextY, width - dw, height - dw)) : (context.beginPath(), createRectPath(context, nextX, nextY, width - dw, height - dw, cornerRadius)), context.setShadowBlendStyle && context.setShadowBlendStyle(rect, rect.attribute, rectAttribute), strokeCb)
        strokeCb(context, innerBorder, rectAttribute.innerBorder);
      else if (doStrokeInner) {
        const lastOpacity = rectAttribute.innerBorder.opacity;
        rectAttribute.innerBorder.opacity = opacity, context.setStrokeStyle(rect, innerBorder, (originX - x) / scaleX, (originY - y) / scaleY, rectAttribute.innerBorder), rectAttribute.innerBorder.opacity = lastOpacity, context.stroke();
      }
    }
  }
};
var SplitRectBeforeRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.beforeFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
    const { stroke: stroke2 = groupAttribute.stroke } = group.attribute;
    Array.isArray(stroke2) && stroke2.some((s2) => false === s2) && (doFillOrStroke.doStroke = false);
  }
};
SplitRectBeforeRenderContribution = __decorate9([injectable()], SplitRectBeforeRenderContribution);
var SplitRectAfterRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb) {
    const { x1: x14, y1: y14, x: originX = groupAttribute.x, y: originY = groupAttribute.y, stroke: stroke2 = groupAttribute.stroke } = rect.attribute;
    let { width, height } = rect.attribute;
    if (width = (null != width ? width : x14 - originX) || 0, height = (null != height ? height : y14 - originY) || 0, Array.isArray(stroke2) && stroke2.some((s2) => false === s2)) {
      if (context.setStrokeStyle(rect, rect.attribute, x, y, groupAttribute), context.beginPath(), context.moveTo(x, y), stroke2[0] ? context.lineTo(x + width, y) : context.moveTo(x + width, y), stroke2[1] ? context.lineTo(x + width, y + height) : context.moveTo(x + width, y + height), stroke2[2] ? context.lineTo(x, y + height) : context.moveTo(x, y + height), stroke2[3]) {
        const adjustY = stroke2[0] ? y - context.lineWidth / 2 : y;
        context.lineTo(x, adjustY);
      } else
        context.moveTo(x, y);
      context.stroke();
    }
  }
};
SplitRectAfterRenderContribution = __decorate9([injectable()], SplitRectAfterRenderContribution);
var defaultRectRenderContribution = new DefaultRectRenderContribution();
var defaultRectTextureRenderContribution = defaultBaseTextureRenderContribution;
var defaultRectBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/contributions/image-contribution-render
var DefaultImageBackgroundRenderContribution = class extends DefaultBaseBackgroundRenderContribution {
  constructor() {
    super(...arguments), this.time = BaseRenderContributionTime.beforeFillStroke;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb) {
    const { background, backgroundMode = graphicAttribute.backgroundMode, backgroundFit = graphicAttribute.backgroundFit } = graphic.attribute;
    if (background)
      if (graphic.backgroundImg) {
        const res = graphic.resources.get(background);
        if ("success" !== res.state || !res.data)
          return;
        if (context.save(), graphic.parent && !graphic.transMatrix.onlyTranslate()) {
          const groupAttribute = getTheme(graphic.parent).group, { scrollX = groupAttribute.scrollX, scrollY = groupAttribute.scrollY } = graphic.parent.attribute;
          context.setTransformFromMatrix(graphic.parent.globalTransMatrix, true), context.translate(scrollX, scrollY);
        }
        const b = graphic.AABBBounds;
        this.doDrawImage(context, res.data, b, backgroundMode, backgroundFit), context.restore(), graphic.transMatrix.onlyTranslate() || context.setTransformForCurrent();
      } else if (isObject_default(background)) {
        const { stroke: stroke2, fill, lineWidth = 1, cornerRadius = 0, expandX = 0, expandY = 0 } = background;
        if (!stroke2 && !fill)
          return;
        context.beginPath();
        const { x: x3, y: y3, width, height } = getActualPosition(graphic);
        cornerRadius ? createRectPath(context, x3 - expandX, y3 - expandY, width + 2 * expandX, height + 2 * expandY, cornerRadius) : context.rect(x3 - expandX, y3 - expandY, width + 2 * expandX, height + 2 * expandY), context.globalAlpha = 1, fill && (context.fillStyle = fill, context.fill()), stroke2 && lineWidth > 0 && (context.lineWidth = lineWidth, context.strokeStyle = stroke2, context.stroke());
      } else {
        context.beginPath();
        const b = graphic.AABBBounds;
        context.rect(x, y, b.width(), b.height()), context.fillStyle = background, context.globalAlpha = 1, context.fill();
      }
  }
};
function getActualPosition(graphic) {
  const boundsPadding = parsePadding(graphic.attribute.boundsPadding), bounds = graphic.AABBBounds;
  let x = bounds.x1, y = bounds.y1, width = bounds.width(), height = bounds.height();
  return isNumber_default(boundsPadding) ? (x += boundsPadding, y += boundsPadding, width -= 2 * boundsPadding, height -= 2 * boundsPadding) : (x += boundsPadding[3], y += boundsPadding[0], width -= boundsPadding[1] + boundsPadding[3], height -= boundsPadding[0] + boundsPadding[2]), {
    x,
    y,
    width,
    height
  };
}
var DefaultImageRenderContribution = class extends DefaultRectRenderContribution {
  constructor() {
    super(...arguments), this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb) {
    return super.drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb);
  }
};
var defaultImageRenderContribution = new DefaultImageRenderContribution();
var defaultImageBackgroundRenderContribution = new DefaultImageBackgroundRenderContribution();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/contributions/symbol-contribution-render
var DefaultSymbolRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = true, this.order = 0;
  }
  drawShape(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, drawContext, fillCb, strokeCb) {
    const parsedPath = symbol.getParsedPath();
    if (!parsedPath)
      return;
    const { outerBorder, innerBorder } = symbol.attribute, doOuterBorder = outerBorder && false !== outerBorder.visible, doInnerBorder = innerBorder && false !== innerBorder.visible;
    if (!doOuterBorder && !doInnerBorder)
      return;
    const { size = symbolAttribute.size, opacity = symbolAttribute.opacity, x: originX = symbolAttribute.x, y: originY = symbolAttribute.y, scaleX = symbolAttribute.scaleX, scaleY = symbolAttribute.scaleY } = symbol.attribute, doStrokeOuter = !(!outerBorder || !outerBorder.stroke), doStrokeInner = !(!innerBorder || !innerBorder.stroke);
    if (doOuterBorder) {
      const { distance: distance2 = symbolAttribute.outerBorder.distance } = outerBorder, d = getScaledStroke(context, distance2, context.dpr);
      if (context.beginPath(), false === parsedPath.drawOffset(context, size, x, y, d) && context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(symbol, symbol.attribute, symbolAttribute), strokeCb)
        strokeCb(context, outerBorder, symbolAttribute.outerBorder);
      else if (doStrokeOuter) {
        const lastOpacity = symbolAttribute.outerBorder.opacity;
        symbolAttribute.outerBorder.opacity = opacity, context.setStrokeStyle(symbol, outerBorder, (originX - x) / scaleX, (originY - y) / scaleY, symbolAttribute.outerBorder), symbolAttribute.outerBorder.opacity = lastOpacity, context.stroke();
      }
    }
    if (doInnerBorder) {
      const { distance: distance2 = symbolAttribute.innerBorder.distance } = innerBorder, d = getScaledStroke(context, distance2, context.dpr);
      if (context.beginPath(), false === parsedPath.drawOffset(context, size, x, y, -d) && context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(symbol, symbol.attribute, symbolAttribute), strokeCb)
        strokeCb(context, innerBorder, symbolAttribute.innerBorder);
      else if (doStrokeInner) {
        const lastOpacity = symbolAttribute.innerBorder.opacity;
        symbolAttribute.innerBorder.opacity = opacity, context.setStrokeStyle(symbol, innerBorder, (originX - x) / scaleX, (originY - y) / scaleY, symbolAttribute.innerBorder), symbolAttribute.innerBorder.opacity = lastOpacity, context.stroke();
      }
    }
  }
};
var defaultSymbolRenderContribution = new DefaultSymbolRenderContribution();
var defaultSymbolTextureRenderContribution = defaultBaseTextureRenderContribution;
var defaultSymbolBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/contributions/area-texture-contribution-render
var DefaultAreaTextureRenderContribution = class extends DefaultBaseTextureRenderContribution {
  constructor() {
    super(...arguments), this.time = BaseRenderContributionTime.afterFillStroke;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    var _a, _b, _c, _d;
    this.textureMap || this.initTextureMap(context, graphic.stage);
    const { attribute = graphic.attribute } = options || {}, { texture = null !== (_a = graphic.attribute.texture) && void 0 !== _a ? _a : getAttributeFromDefaultAttrList(graphicAttribute, "texture"), textureColor = null !== (_b = graphic.attribute.textureColor) && void 0 !== _b ? _b : getAttributeFromDefaultAttrList(graphicAttribute, "textureColor"), textureSize = null !== (_c = graphic.attribute.textureSize) && void 0 !== _c ? _c : getAttributeFromDefaultAttrList(graphicAttribute, "textureSize"), texturePadding = null !== (_d = graphic.attribute.texturePadding) && void 0 !== _d ? _d : getAttributeFromDefaultAttrList(graphicAttribute, "texturePadding") } = attribute;
    texture && this.drawTexture(texture, graphic, context, x, y, graphicAttribute, textureColor, textureSize, texturePadding);
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/arc-render
var __decorate10 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata7 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param5 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasArcRender = class extends BaseRender {
  constructor(arcRenderContribitions) {
    super(), this.arcRenderContribitions = arcRenderContribitions, this.numberType = ARC_NUMBER_TYPE, this.builtinContributions = [defaultArcRenderContribution, defaultArcBackgroundRenderContribution, defaultArcTextureRenderContribution], this.init(arcRenderContribitions);
  }
  drawArcTailCapPath(arc, context, cx, cy, outerRadius, innerRadius, _sa, _ea) {
    const capAngle = _ea - _sa, data = arc.getParsedAngle(), startAngle = data.startAngle;
    let endAngle = data.endAngle;
    endAngle = _ea;
    const deltaAngle = abs(endAngle - startAngle), clockwise = endAngle > startAngle;
    let collapsedToLine = false;
    if (outerRadius < innerRadius) {
      const temp3 = outerRadius;
      outerRadius = innerRadius, innerRadius = temp3;
    }
    const cornerRadius = arc.getParsedCornerRadius(), { outerDeltaAngle, innerDeltaAngle, outerStartAngle, outerEndAngle, innerEndAngle, innerStartAngle } = arc.getParsePadAngle(startAngle, endAngle), outerCornerRadiusStart = cornerRadius, outerCornerRadiusEnd = cornerRadius, innerCornerRadiusEnd = cornerRadius, innerCornerRadiusStart = cornerRadius, maxOuterCornerRadius = Math.max(outerCornerRadiusEnd, outerCornerRadiusStart), maxInnerCornerRadius = Math.max(innerCornerRadiusEnd, innerCornerRadiusStart);
    let limitedOcr = maxOuterCornerRadius, limitedIcr = maxInnerCornerRadius;
    const xors = outerRadius * cos(outerStartAngle), yors = outerRadius * sin(outerStartAngle), xire = innerRadius * cos(innerEndAngle), yire = innerRadius * sin(innerEndAngle);
    let xore, yore, xirs, yirs;
    if ((maxInnerCornerRadius > epsilon || maxOuterCornerRadius > epsilon) && (xore = outerRadius * cos(outerEndAngle), yore = outerRadius * sin(outerEndAngle), xirs = innerRadius * cos(innerStartAngle), yirs = innerRadius * sin(innerStartAngle), deltaAngle < pi)) {
      const oc = intersect(xors, yors, xirs, yirs, xore, yore, xire, yire);
      if (oc) {
        const ax = xors - oc[0], ay = yors - oc[1], bx = xore - oc[0], by = yore - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
        limitedIcr = min(maxInnerCornerRadius, (innerRadius - lc) / (kc - 1)), limitedOcr = min(maxOuterCornerRadius, (outerRadius - lc) / (kc + 1));
      }
    }
    if (limitedOcr > epsilon) {
      const cornerRadiusStart = min(outerCornerRadiusStart, limitedOcr), cornerRadiusEnd = min(outerCornerRadiusEnd, limitedOcr), t0 = cornerTangents(xirs, yirs, xors, yors, outerRadius, cornerRadiusStart, Number(clockwise)), t1 = cornerTangents(xore, yore, xire, yire, outerRadius, cornerRadiusEnd, Number(clockwise));
      if (limitedOcr < maxOuterCornerRadius && cornerRadiusStart === cornerRadiusEnd)
        context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), context.arc(cx + t0.cx, cy + t0.cy, limitedOcr, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !clockwise);
      else {
        const a1 = endAngle - capAngle - 0.03, a22 = atan2(t1.y11, t1.x11);
        context.arc(cx, cy, outerRadius, a1, a22, !clockwise), cornerRadiusEnd > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusEnd, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !clockwise);
      }
    } else
      context.moveTo(cx + xors, cy + yors);
    if (!(innerRadius > epsilon) || innerDeltaAngle < 1e-3)
      context.lineTo(cx + xire, cy + yire), collapsedToLine = true;
    else if (limitedIcr > epsilon) {
      const cornerRadiusStart = min(innerCornerRadiusStart, limitedIcr), cornerRadiusEnd = min(innerCornerRadiusEnd, limitedIcr), t0 = cornerTangents(xire, yire, xore, yore, innerRadius, -cornerRadiusEnd, Number(clockwise)), t1 = cornerTangents(xors, yors, xirs, yirs, innerRadius, -cornerRadiusStart, Number(clockwise));
      if (context.lineTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), limitedIcr < maxInnerCornerRadius && cornerRadiusStart === cornerRadiusEnd) {
        const arcEndAngle = atan2(t1.y01, t1.x01);
        context.arc(cx + t0.cx, cy + t0.cy, limitedIcr, atan2(t0.y01, t0.x01), arcEndAngle, !clockwise);
      } else {
        cornerRadiusEnd > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusEnd, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !clockwise);
        const a1 = atan2(t0.cy + t0.y11, t0.cx + t0.x11), a22 = endAngle - capAngle - 0.03;
        context.arc(cx, cy, innerRadius, a1, a22, clockwise);
      }
    } else
      context.lineTo(cx + innerRadius * cos(innerStartAngle), cy + innerRadius * sin(innerStartAngle));
    return collapsedToLine;
  }
  drawShape(arc, context, x, y, drawContext, params2, fillCb, strokeCb) {
    const arcAttribute = getTheme(arc, null == params2 ? void 0 : params2.theme).arc, { fill = arcAttribute.fill, stroke: stroke2 = arcAttribute.stroke, x: originX = arcAttribute.x, y: originY = arcAttribute.y } = arc.attribute, data = this.valid(arc, arcAttribute, fillCb, strokeCb);
    if (!data)
      return;
    const { fVisible, sVisible, doFill, doStroke } = data, { outerPadding = arcAttribute.outerPadding, innerPadding = arcAttribute.innerPadding, cap = arcAttribute.cap, forceShowCap = arcAttribute.forceShowCap } = arc.attribute;
    let { outerRadius = arcAttribute.outerRadius, innerRadius = arcAttribute.innerRadius } = arc.attribute;
    outerRadius += outerPadding, innerRadius -= innerPadding;
    let conicalOffset = 0;
    const tempChangeConicalColor = (isBoolean_default(cap) && cap || cap[0]) && "conical" === fill.gradient;
    if (tempChangeConicalColor) {
      const { sc, startAngle, endAngle } = arc.getParsedAngle();
      abs(endAngle - startAngle) < pi2 - epsilon && (conicalOffset = sc || 0, fill.startAngle -= conicalOffset, fill.endAngle -= conicalOffset);
    }
    let beforeRenderContribitionsRuned = false;
    const { isFullStroke, stroke: arrayStroke } = parseStroke(stroke2);
    if ((doFill || isFullStroke) && (context.beginPath(), drawArcPath(arc, context, x, y, outerRadius, innerRadius), beforeRenderContribitionsRuned = true, context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), this.beforeRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb), doFill && (fillCb ? fillCb(context, arc.attribute, arcAttribute) : fVisible && (context.setCommonStyle(arc, arc.attribute, originX - x, originY - y, arcAttribute), context.fill())), doStroke && isFullStroke && (strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, originX - x, originY - y, arcAttribute), context.stroke()))), !isFullStroke && doStroke) {
      context.beginPath();
      drawArcPath(arc, context, x, y, outerRadius, innerRadius, arrayStroke);
      beforeRenderContribitionsRuned || this.beforeRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb), strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), context.stroke());
    }
    if ((isBoolean_default(cap) && cap || cap[1]) && forceShowCap) {
      const { startAngle: sa, endAngle: ea } = arc.getParsedAngle();
      if (abs(ea - sa) >= pi2 - epsilon) {
        context.beginPath();
        const capAngle = Math.abs(outerRadius - innerRadius) / 2 / outerRadius, { endAngle = arcAttribute.endAngle, fill: fill2 = arcAttribute.fill } = arc.attribute, startAngle = endAngle;
        if (this.drawArcTailCapPath(arc, context, x, y, outerRadius, innerRadius, startAngle, startAngle + capAngle), beforeRenderContribitionsRuned || this.beforeRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb), doFill) {
          const color = fill2;
          if ("conical" === color.gradient) {
            const lastColor = getConicGradientAt(0, 0, endAngle, color);
            fillCb || fillVisible && (context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute), context.fillStyle = lastColor, context.fill());
          }
        }
        doStroke && (strokeCb || sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), context.stroke()));
      }
    }
    this.afterRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb), tempChangeConicalColor && (fill.startAngle += conicalOffset, fill.endAngle += conicalOffset);
  }
  draw(arc, renderService, drawContext, params2) {
    const arcAttribute = getTheme(arc, null == params2 ? void 0 : params2.theme).arc;
    this._draw(arc, arcAttribute, false, drawContext, params2);
  }
};
DefaultCanvasArcRender = __decorate10([injectable(), __param5(0, inject(ContributionProvider)), __param5(0, named(ArcRenderContribution)), __metadata7("design:paramtypes", [Object])], DefaultCanvasArcRender);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/circle-render
var __decorate11 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata8 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param6 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasCircleRender = class extends BaseRender {
  constructor(circleRenderContribitions) {
    super(), this.circleRenderContribitions = circleRenderContribitions, this.numberType = CIRCLE_NUMBER_TYPE, this.builtinContributions = [defaultCircleRenderContribution, defaultCircleBackgroundRenderContribution, defaultCircleTextureRenderContribution], this.init(circleRenderContribitions);
  }
  drawShape(circle3, context, x, y, drawContext, params2, fillCb, strokeCb) {
    const circleAttribute = getTheme(circle3, null == params2 ? void 0 : params2.theme).circle, { radius = circleAttribute.radius, startAngle = circleAttribute.startAngle, endAngle = circleAttribute.endAngle, x: originX = circleAttribute.x, y: originY = circleAttribute.y } = circle3.attribute, data = this.valid(circle3, circleAttribute, fillCb, strokeCb);
    if (!data)
      return;
    const { fVisible, sVisible, doFill, doStroke } = data;
    context.beginPath(), context.arc(x, y, radius, startAngle, endAngle), context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(circle3, circle3.attribute, circleAttribute), this.beforeRenderStep(circle3, context, x, y, doFill, doStroke, fVisible, sVisible, circleAttribute, drawContext, fillCb, strokeCb), doFill && (fillCb ? fillCb(context, circle3.attribute, circleAttribute) : fVisible && (context.setCommonStyle(circle3, circle3.attribute, originX - x, originY - y, circleAttribute), context.fill())), doStroke && (strokeCb ? strokeCb(context, circle3.attribute, circleAttribute) : sVisible && (context.setStrokeStyle(circle3, circle3.attribute, originX - x, originY - y, circleAttribute), context.stroke())), this.afterRenderStep(circle3, context, x, y, doFill, doStroke, fVisible, sVisible, circleAttribute, drawContext, fillCb, strokeCb);
  }
  draw(circle3, renderService, drawContext, params2) {
    const circleAttribute = getTheme(circle3, null == params2 ? void 0 : params2.theme).circle;
    this._draw(circle3, circleAttribute, false, drawContext, params2);
  }
};
DefaultCanvasCircleRender = __decorate11([injectable(), __param6(0, inject(ContributionProvider)), __param6(0, named(CircleRenderContribution)), __metadata8("design:paramtypes", [Object])], DefaultCanvasCircleRender);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/render-utils
function drawSegItem(ctx, curve, endPercent, params2) {
  if (!curve.p1)
    return;
  const { offsetX = 0, offsetY = 0, offsetZ = 0 } = params2 || {};
  if (1 === endPercent)
    curve.p2 && curve.p3 ? ctx.bezierCurveTo(offsetX + curve.p1.x, offsetY + curve.p1.y, offsetX + curve.p2.x, offsetY + curve.p2.y, offsetX + curve.p3.x, offsetY + curve.p3.y, offsetZ) : ctx.lineTo(offsetX + curve.p1.x, offsetY + curve.p1.y, offsetZ);
  else if (curve.p2 && curve.p3) {
    const [curve1] = divideCubic(curve, endPercent);
    ctx.bezierCurveTo(offsetX + curve1.p1.x, offsetY + curve1.p1.y, offsetX + curve1.p2.x, offsetY + curve1.p2.y, offsetX + curve1.p3.x, offsetY + curve1.p3.y, offsetZ);
  } else {
    const p = curve.getPointAt(endPercent);
    ctx.lineTo(offsetX + p.x, offsetY + p.y, offsetZ);
  }
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/render-curve
function drawSegments(path, segPath, percent, clipRangeByDimension, params2) {
  var _a;
  const { offsetX = 0, offsetY = 0, offsetZ = 0, mode = "none", drawConnect = false, zeroX = 0, zeroY = 0 } = params2 || {};
  if (drawConnect && "none" === mode)
    return;
  if (!segPath)
    return;
  let needMoveTo = true;
  const { curves } = segPath;
  if (percent >= 1) {
    if (drawConnect) {
      let lastCurve2, defined02 = true;
      curves.forEach((curve, i) => {
        var _a2;
        let p0 = curve.p0;
        if (curve.originP1 !== curve.originP2) {
          if (lastCurve2 && lastCurve2.originP1 === lastCurve2.originP2 && (p0 = lastCurve2.p0), curve.defined)
            defined02 || (path.lineTo(p0.x + offsetX, p0.y + offsetY, offsetZ), defined02 = !defined02);
          else {
            const { originP1, originP2 } = curve;
            let validP;
            if (originP1 && false !== originP1.defined ? validP = p0 : originP1 && false !== originP2.defined && (validP = null !== (_a2 = curve.p3) && void 0 !== _a2 ? _a2 : curve.p1), defined02) {
              defined02 = !defined02;
              const x = validP ? validP.x : curve.p0.x, y = validP ? validP.y : curve.p0.y;
              path.moveTo(x + offsetX, y + offsetY, offsetZ);
            } else
              validP && (defined02 = !defined02, path.lineTo(validP.x + offsetX, validP.y + offsetY, offsetZ));
          }
          lastCurve2 = curve;
        } else
          lastCurve2 = curve;
      });
    } else
      curves.forEach((curve) => {
        curve.defined ? (needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), drawSegItem(path, curve, 1, params2), needMoveTo = false) : needMoveTo = true;
      });
    return;
  }
  if (percent <= 0)
    return;
  let direction2;
  "x" === clipRangeByDimension ? direction2 = Direction.ROW : "y" === clipRangeByDimension ? direction2 = Direction.COLUMN : "auto" === clipRangeByDimension && (direction2 = segPath.direction);
  const totalDrawLength = percent * segPath.tryUpdateLength(direction2);
  let drawedLengthUntilLast = 0, defined0 = true, lastCurve = null;
  for (let i = 0, n = curves.length; i < n; i++) {
    const curve = curves[i], curCurveLength = curve.getLength(direction2), _p = (totalDrawLength - drawedLengthUntilLast) / curCurveLength;
    if (drawedLengthUntilLast += curCurveLength, _p < 0)
      break;
    if (drawConnect) {
      let p0 = curve.p0;
      if (curve.originP1 === curve.originP2) {
        lastCurve = curve;
        continue;
      }
      if (lastCurve && lastCurve.originP1 === lastCurve.originP2 && (p0 = lastCurve.p0), curve.defined)
        defined0 || (path.lineTo(p0.x + offsetX, p0.y + offsetY, offsetZ), defined0 = !defined0);
      else {
        const { originP1, originP2 } = curve;
        let validP;
        if (originP1 && false !== originP1.defined ? validP = p0 : originP1 && false !== originP2.defined && (validP = null !== (_a = curve.p3) && void 0 !== _a ? _a : curve.p1), defined0) {
          defined0 = !defined0;
          const x = validP ? validP.x : curve.p0.x, y = validP ? validP.y : curve.p0.y;
          path.moveTo(x + offsetX, y + offsetY, offsetZ);
        } else
          validP && (defined0 = !defined0, path.lineTo(validP.x + offsetX, validP.y + offsetY, offsetZ));
      }
      lastCurve = curve;
    } else {
      if (!curve.defined) {
        needMoveTo = true;
        continue;
      }
      needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), drawSegItem(path, curve, min(_p, 1), params2), needMoveTo = false;
    }
  }
}
function drawIncrementalSegments(path, lastSeg, segments2, params2) {
  const { offsetX = 0, offsetY = 0 } = params2 || {}, startP = lastSeg ? lastSeg.points[lastSeg.points.length - 1] : segments2.points[0];
  path.moveTo(startP.x + offsetX, startP.y + offsetY), segments2.points.forEach((p) => {
    false !== p.defined ? path.lineTo(p.x + offsetX, p.y + offsetY) : path.moveTo(p.x + offsetX, p.y + offsetY);
  });
}
function drawIncrementalAreaSegments(path, lastSeg, segments2, params2) {
  const { offsetX = 0, offsetY = 0 } = params2 || {}, { points } = segments2, definedPointsList = [];
  let lastIdx = 0;
  for (let i = 0; i < points.length; i++)
    false === points[i].defined && (lastIdx + 1 !== i && definedPointsList.slice(lastIdx, i), lastIdx = i);
  definedPointsList.length, definedPointsList.push(points), definedPointsList.forEach((points2, i) => {
    var _a, _b, _c, _d;
    const startP = lastSeg && 0 === i ? lastSeg.points[lastSeg.points.length - 1] : points2[0];
    path.moveTo(startP.x + offsetX, startP.y + offsetY), points2.forEach((p) => {
      false !== p.defined ? path.lineTo(p.x + offsetX, p.y + offsetY) : path.moveTo(p.x + offsetX, p.y + offsetY);
    });
    for (let i2 = points2.length - 1; i2 >= 0; i2--) {
      const p = points2[i2];
      path.lineTo(null !== (_a = p.x1) && void 0 !== _a ? _a : p.x, null !== (_b = p.y1) && void 0 !== _b ? _b : p.y);
    }
    path.lineTo(null !== (_c = startP.x1) && void 0 !== _c ? _c : startP.x, null !== (_d = startP.y1) && void 0 !== _d ? _d : startP.y), path.closePath();
  });
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/line-render
var __decorate12 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultCanvasLineRender = class extends BaseRender {
  constructor() {
    super(...arguments), this.numberType = LINE_NUMBER_TYPE;
  }
  draw(line2, renderService, drawContext, params2) {
    const lineAttribute = getTheme(line2, null == params2 ? void 0 : params2.theme).line;
    this._draw(line2, lineAttribute, false, drawContext, params2);
  }
  drawSegmentItem(context, cache, fill, stroke2, fillOpacity, strokeOpacity, attribute, defaultAttribute, clipRange, clipRangeByDimension, offsetX, offsetY, line2, fillCb, strokeCb) {
    var _a, _b, _c, _d, _e;
    if (!cache)
      return;
    context.beginPath();
    const z = null !== (_a = this.z) && void 0 !== _a ? _a : 0;
    drawSegments(context.camera ? context : context.nativeContext, cache, clipRange, clipRangeByDimension, {
      offsetX,
      offsetY,
      offsetZ: z
    }), line2.cache && !isArray_default(line2.cache) && line2.cache.curves.every((c3) => c3.defined) && line2.attribute.curveType && line2.attribute.curveType.includes("Closed") && context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(line2, attribute, defaultAttribute);
    const { x: originX = 0, x: originY = 0 } = attribute;
    false !== fill && (fillCb ? fillCb(context, attribute, defaultAttribute) : fillOpacity && (context.setCommonStyle(line2, attribute, originX - offsetX, originY - offsetY, defaultAttribute), context.fill())), false !== stroke2 && (strokeCb ? strokeCb(context, attribute, defaultAttribute) : strokeOpacity && (context.setStrokeStyle(line2, attribute, originX - offsetX, originY - offsetY, defaultAttribute), context.stroke()));
    let { connectedType, connectedX, connectedY, connectedStyle } = attribute;
    if (isArray_default(defaultAttribute) ? (connectedType = null !== (_b = null != connectedType ? connectedType : defaultAttribute[0].connectedType) && void 0 !== _b ? _b : defaultAttribute[1].connectedType, connectedX = null !== (_c = null != connectedX ? connectedX : defaultAttribute[0].connectedX) && void 0 !== _c ? _c : defaultAttribute[1].connectedX, connectedY = null !== (_d = null != connectedY ? connectedY : defaultAttribute[0].connectedY) && void 0 !== _d ? _d : defaultAttribute[1].connectedY, connectedStyle = null !== (_e = null != connectedStyle ? connectedStyle : defaultAttribute[0].connectedStyle) && void 0 !== _e ? _e : defaultAttribute[1].connectedStyle) : (connectedType = null != connectedType ? connectedType : defaultAttribute.connectedType, connectedX = null != connectedX ? connectedX : defaultAttribute.connectedX, connectedY = null != connectedY ? connectedY : defaultAttribute.connectedY, connectedStyle = null != connectedStyle ? connectedStyle : defaultAttribute.connectedStyle), "connect" !== connectedType && "zero" !== connectedType && (connectedType = "none"), "none" !== connectedType) {
      context.beginPath(), drawSegments(context.camera ? context : context.nativeContext, cache, clipRange, clipRangeByDimension, {
        offsetX,
        offsetY,
        offsetZ: z,
        drawConnect: true,
        mode: connectedType,
        zeroX: connectedX,
        zeroY: connectedY
      });
      const da = [];
      isArray_default(defaultAttribute) ? defaultAttribute.forEach((i) => da.push(i)) : da.push(defaultAttribute), da.push(attribute), false !== fill && (fillCb ? fillCb(context, attribute, defaultAttribute) : fillOpacity && (context.setCommonStyle(line2, connectedStyle, originX - offsetX, originY - offsetY, da), context.fill())), false !== stroke2 && (strokeCb ? strokeCb(context, attribute, defaultAttribute) : strokeOpacity && (context.setStrokeStyle(line2, connectedStyle, originX - offsetX, originY - offsetY, da), context.stroke()));
    }
    return false;
  }
  drawLinearLineHighPerformance(line2, context, fill, stroke2, fillOpacity, strokeOpacity, offsetX, offsetY, lineAttribute, drawContext, params2, fillCb, strokeCb) {
    var _a;
    context.beginPath();
    const z = null !== (_a = this.z) && void 0 !== _a ? _a : 0, { points } = line2.attribute, startP = points[0];
    context.moveTo(startP.x + offsetX, startP.y + offsetY, z);
    for (let i = 1; i < points.length; i++) {
      const p = points[i];
      context.lineTo(p.x + offsetX, p.y + offsetY, z);
    }
    context.setShadowBlendStyle && context.setShadowBlendStyle(line2, line2.attribute, lineAttribute);
    const { x: originX = 0, x: originY = 0 } = line2.attribute;
    false !== fill && (fillCb ? fillCb(context, line2.attribute, lineAttribute) : fillOpacity && (context.setCommonStyle(line2, line2.attribute, originX - offsetX, originY - offsetY, lineAttribute), context.fill())), false !== stroke2 && (strokeCb ? strokeCb(context, line2.attribute, lineAttribute) : strokeOpacity && (context.setStrokeStyle(line2, line2.attribute, originX - offsetX, originY - offsetY, lineAttribute), context.stroke()));
  }
  drawShape(line2, context, x, y, drawContext, params2, fillCb, strokeCb) {
    const lineAttribute = getTheme(line2, null == params2 ? void 0 : params2.theme).line, { fill = lineAttribute.fill, stroke: stroke2 = lineAttribute.stroke, fillOpacity = lineAttribute.fillOpacity, strokeOpacity = lineAttribute.strokeOpacity, segments: segments2, points, closePath } = line2.attribute;
    if (!this.valid(line2, lineAttribute, fillCb, strokeCb))
      return;
    let { curveType = lineAttribute.curveType } = line2.attribute;
    closePath && "linear" === curveType && (curveType = "linearClosed");
    const { clipRange = lineAttribute.clipRange, clipRangeByDimension = lineAttribute.clipRangeByDimension } = line2.attribute;
    if (1 === clipRange && !segments2 && !points.some((p) => false === p.defined) && "linear" === curveType)
      return this.drawLinearLineHighPerformance(line2, context, !!fill, !!stroke2, fillOpacity, strokeOpacity, x, y, lineAttribute, drawContext, params2, fillCb, strokeCb);
    if (line2.shouldUpdateShape()) {
      const { points: points2, segments: segments3 } = line2.attribute, _points = points2;
      if (segments3 && segments3.length) {
        let startPoint, lastSeg;
        if (line2.cache = segments3.map((seg, index) => {
          if (seg.points.length <= 1 && 0 === index)
            return seg.points[0] && (lastSeg = {
              endX: seg.points[0].x,
              endY: seg.points[0].y,
              curves: [{
                defined: false !== seg.points[0].defined
              }]
            }), null;
          1 === index ? startPoint = {
            x: lastSeg.endX,
            y: lastSeg.endY,
            defined: lastSeg.curves[lastSeg.curves.length - 1].defined
          } : index > 1 && (startPoint.x = lastSeg.endX, startPoint.y = lastSeg.endY, startPoint.defined = lastSeg.curves[lastSeg.curves.length - 1].defined);
          const data = calcLineCache(seg.points, curveType, {
            startPoint
          });
          return lastSeg = data, data;
        }).filter((item) => !!item), "linearClosed" === curveType) {
          let startP;
          for (let i = 0; i < line2.cache.length; i++) {
            const cacheItem = line2.cache[i];
            for (let i2 = 0; i2 < cacheItem.curves.length; i2++)
              if (cacheItem.curves[i2].defined) {
                startP = cacheItem.curves[i2].p0;
                break;
              }
            if (startP)
              break;
          }
          line2.cache[line2.cache.length - 1] && line2.cache[line2.cache.length - 1].lineTo(startP.x, startP.y, true);
        }
      } else {
        if (!points2 || !points2.length)
          return line2.cache = null, void line2.clearUpdateShapeTag();
        line2.cache = calcLineCache(_points, curveType);
      }
      line2.clearUpdateShapeTag();
    }
    if (Array.isArray(line2.cache)) {
      const segments3 = line2.attribute.segments.filter((item) => item.points.length);
      if (1 === segments3[0].points.length && segments3.shift(), 1 === clipRange) {
        let skip = false;
        line2.cache.forEach((cache, index) => {
          skip || (skip = this.drawSegmentItem(context, cache, !!fill, !!stroke2, fillOpacity, strokeOpacity, segments3[index], [lineAttribute, line2.attribute], clipRange, clipRangeByDimension, x, y, line2, fillCb, strokeCb));
        });
      } else {
        const totalLength = line2.cache.reduce((l, c3) => l + c3.getLength(), 0), totalDrawLength = clipRange * totalLength;
        let drawedLengthUntilLast = 0, skip = false;
        line2.cache.forEach((cache, index) => {
          if (skip)
            return;
          const curSegLength = cache.getLength(), _cr = (totalDrawLength - drawedLengthUntilLast) / curSegLength;
          drawedLengthUntilLast += curSegLength, _cr > 0 && (skip = this.drawSegmentItem(context, cache, !!fill, !!stroke2, fillOpacity, strokeOpacity, segments3[index], [lineAttribute, line2.attribute], min(_cr, 1), clipRangeByDimension, x, y, line2, fillCb, strokeCb));
        });
      }
    } else
      this.drawSegmentItem(context, line2.cache, !!fill, !!stroke2, fillOpacity, strokeOpacity, line2.attribute, lineAttribute, clipRange, clipRangeByDimension, x, y, line2, fillCb, strokeCb);
  }
};
DefaultCanvasLineRender = __decorate12([injectable()], DefaultCanvasLineRender);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/render-area
function drawAreaSegments(path, segPath, percent, params2) {
  var _a;
  const { drawConnect = false, mode = "none" } = params2 || {};
  if (drawConnect && "none" === mode)
    return;
  const { top, bottom } = segPath;
  if (top.curves.length !== bottom.curves.length)
    return;
  if (percent >= 1) {
    const topList2 = [], bottomList2 = [];
    let lastDefined2 = true;
    if (drawConnect) {
      let lastCurve, lastBottomCurve2, defined02 = true;
      const n = top.curves.length;
      top.curves.forEach((curve, i) => {
        const bototmCurve = bottom.curves[n - i - 1];
        let currentTopCurve = curve, currentBottomCurve = bototmCurve;
        if (curve.originP1 === curve.originP2)
          return lastCurve = curve, void (lastBottomCurve2 = bototmCurve);
        if (lastCurve && lastCurve.originP1 === lastCurve.originP2 && (currentTopCurve = lastCurve, currentBottomCurve = lastBottomCurve2), curve.defined)
          defined02 || (topList2.push(currentTopCurve), bottomList2.push(currentBottomCurve), drawAreaConnectBlock(path, topList2, bottomList2, params2), topList2.length = 0, bottomList2.length = 0, defined02 = !defined02);
        else {
          const { originP1, originP2 } = curve;
          let validTopCurve, validBottomCurve;
          originP1 && false !== originP1.defined ? (validTopCurve = currentTopCurve, validBottomCurve = currentBottomCurve) : originP1 && false !== originP2.defined && (validTopCurve = curve, validBottomCurve = bototmCurve), defined02 ? (defined02 = !defined02, topList2.push(validTopCurve || curve), bottomList2.push(validBottomCurve || bototmCurve)) : validTopCurve && (defined02 = !defined02, topList2.push(validTopCurve || curve), bottomList2.push(validBottomCurve || bototmCurve), drawAreaConnectBlock(path, topList2, bottomList2, params2), topList2.length = 0, bottomList2.length = 0);
        }
        lastCurve = curve;
      }), drawAreaConnectBlock(path, topList2, bottomList2, params2);
    } else {
      for (let i = 0, n = top.curves.length; i < n; i++) {
        const topCurve = top.curves[i];
        lastDefined2 !== topCurve.defined ? (lastDefined2 ? (drawAreaBlock(path, topList2, bottomList2, params2), topList2.length = 0, bottomList2.length = 0) : (topList2.push(topCurve), bottomList2.push(bottom.curves[n - i - 1])), lastDefined2 = !lastDefined2) : lastDefined2 && (topList2.push(topCurve), bottomList2.push(bottom.curves[n - i - 1]));
      }
      drawAreaBlock(path, topList2, bottomList2, params2);
    }
    return;
  }
  if (percent <= 0)
    return;
  let { direction: direction2 } = params2 || {};
  const { curves: topCurves } = top, endP = null !== (_a = topCurves[topCurves.length - 1].p3) && void 0 !== _a ? _a : topCurves[topCurves.length - 1].p1, xTotalLength = abs(endP.x - topCurves[0].p0.x), yTotalLength = abs(endP.y - topCurves[0].p0.y);
  direction2 = null != direction2 ? direction2 : xTotalLength > yTotalLength ? Direction.ROW : Direction.COLUMN, Number.isFinite(xTotalLength) || (direction2 = Direction.COLUMN), Number.isFinite(yTotalLength) || (direction2 = Direction.ROW);
  const totalDrawLength = percent * (direction2 === Direction.ROW ? xTotalLength : yTotalLength);
  let drawedLengthUntilLast = 0, lastDefined = true;
  const topList = [], bottomList = [];
  let lastTopCurve, lastBottomCurve, defined0 = true;
  for (let i = 0, n = top.curves.length; i < n; i++) {
    const topCurve = top.curves[i], curCurveLength = topCurve.getLength(direction2), percent2 = (totalDrawLength - drawedLengthUntilLast) / curCurveLength;
    if (percent2 < 0)
      break;
    if (drawedLengthUntilLast += curCurveLength, drawConnect) {
      const bototmCurve = bottom.curves[n - i - 1];
      let currentTopCurve = topCurve, currentBottomCurve = bototmCurve;
      if (topCurve.originP1 === topCurve.originP2) {
        lastTopCurve = topCurve, lastBottomCurve = bototmCurve;
        continue;
      }
      if (lastTopCurve && lastTopCurve.originP1 === lastTopCurve.originP2 && (currentTopCurve = lastTopCurve, currentBottomCurve = lastBottomCurve), topCurve.defined)
        defined0 || (topList.push(currentTopCurve), bottomList.push(currentBottomCurve), drawAreaConnectBlock(path, topList, bottomList, params2), topList.length = 0, bottomList.length = 0, defined0 = !defined0);
      else {
        const { originP1, originP2 } = topCurve;
        let validTopCurve, validBottomCurve;
        originP1 && false !== originP1.defined ? (validTopCurve = currentTopCurve, validBottomCurve = currentBottomCurve) : originP1 && false !== originP2.defined && (validTopCurve = topCurve, validBottomCurve = bototmCurve), defined0 ? (defined0 = !defined0, topList.push(validTopCurve || topCurve), bottomList.push(validBottomCurve || bototmCurve)) : validTopCurve && (defined0 = !defined0, topList.push(validTopCurve || topCurve), bottomList.push(validBottomCurve || bototmCurve), drawAreaConnectBlock(path, topList, bottomList, params2), topList.length = 0, bottomList.length = 0);
      }
      lastTopCurve = topCurve;
    } else {
      let tc = null, bc = null;
      lastDefined !== topCurve.defined ? (lastDefined ? (drawAreaBlock(path, topList, bottomList, params2), topList.length = 0, bottomList.length = 0) : (tc = topCurve, bc = bottom.curves[n - i - 1]), lastDefined = !lastDefined) : lastDefined && (tc = topCurve, bc = bottom.curves[n - i - 1]), tc && bc && (percent2 < 1 && (tc = tc.p2 && tc.p3 ? divideCubic(tc, percent2)[0] : divideLinear(tc, percent2)[0], bc = bc.p2 && bc.p3 ? divideCubic(bc, 1 - percent2)[1] : divideLinear(bc, 1 - percent2)[1]), tc.defined = lastDefined, bc.defined = lastDefined, topList.push(tc), bottomList.push(bc)), tc = null, bc = null;
    }
  }
  drawConnect ? drawAreaConnectBlock(path, topList, bottomList, params2) : drawAreaBlock(path, topList, bottomList, params2);
}
function drawAreaConnectBlock(path, topList, bottomList, params2) {
  if (topList.length < 2)
    return;
  const { offsetX = 0, offsetY = 0, offsetZ = 0, mode } = params2 || {};
  let curve = topList[0];
  path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), curve = topList[topList.length - 1];
  let end = curve.p3 || curve.p1;
  path.lineTo(end.x + offsetX, end.y + offsetY, offsetZ), curve = bottomList[bottomList.length - 1], path.lineTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), curve = bottomList[0], end = curve.p3 || curve.p1, path.lineTo(end.x + offsetX, end.y + offsetY, offsetZ), path.closePath();
}
function drawAreaBlock(path, topList, bottomList, params2) {
  const { offsetX = 0, offsetY = 0, offsetZ = 0 } = params2 || {};
  let needMoveTo = true;
  topList.forEach((curve) => {
    curve.defined ? (needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), drawSegItem(path, curve, 1, params2), needMoveTo = false) : needMoveTo = true;
  }), needMoveTo = true;
  for (let i = bottomList.length - 1; i >= 0; i--) {
    const curve = bottomList[i];
    curve.defined ? (needMoveTo && path.lineTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), drawSegItem(path, curve, 1, params2), needMoveTo = false) : needMoveTo = true;
  }
  path.closePath();
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/contributions/area-contribution-render
var defaultAreaTextureRenderContribution = new DefaultAreaTextureRenderContribution();
var defaultAreaBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/area-render
var __decorate13 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata9 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param7 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
function calcLineCache2(points, curveType, params2) {
  switch (curveType) {
    case "linear":
    default:
      return genLinearSegments(points, params2);
    case "basis":
      return genBasisSegments(points, params2);
    case "monotoneX":
      return genMonotoneXSegments(points, params2);
    case "monotoneY":
      return genMonotoneYSegments(points, params2);
    case "step":
      return genStepSegments(points, 0.5, params2);
    case "stepBefore":
      return genStepSegments(points, 0, params2);
    case "stepAfter":
      return genStepSegments(points, 1, params2);
    case "linearClosed":
      return genLinearClosedSegments(points, params2);
  }
}
var DefaultCanvasAreaRender = class extends BaseRender {
  constructor(areaRenderContribitions) {
    super(), this.areaRenderContribitions = areaRenderContribitions, this.numberType = AREA_NUMBER_TYPE, this.builtinContributions = [defaultAreaTextureRenderContribution, defaultAreaBackgroundRenderContribution], this.init(areaRenderContribitions);
  }
  drawLinearAreaHighPerformance(area2, context, fill, stroke2, fillOpacity, strokeOpacity, offsetX, offsetY, areaAttribute, drawContext, params2, fillCb, strokeCb) {
    var _a, _b, _c, _d, _e;
    const { points } = area2.attribute;
    if (points.length < 2)
      return;
    context.beginPath();
    const z = null !== (_a = this.z) && void 0 !== _a ? _a : 0, startP = points[0];
    context.moveTo(startP.x + offsetX, startP.y + offsetY, z);
    for (let i = 1; i < points.length; i++) {
      const p = points[i];
      context.lineTo(p.x + offsetX, p.y + offsetY, z);
    }
    for (let i = points.length - 1; i >= 0; i--) {
      const p = points[i];
      context.lineTo((null !== (_b = p.x1) && void 0 !== _b ? _b : p.x) + offsetX, (null !== (_c = p.y1) && void 0 !== _c ? _c : p.y) + offsetY, z);
    }
    context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(area2, area2.attribute, areaAttribute), this.beforeRenderStep(area2, context, offsetX, offsetY, !!fillOpacity, false, fill, false, areaAttribute, drawContext, fillCb, null, {
      attribute: area2.attribute
    });
    const { x: originX = 0, x: originY = 0 } = area2.attribute;
    if (false !== fill && (fillCb ? fillCb(context, area2.attribute, areaAttribute) : fillOpacity && (context.setCommonStyle(area2, area2.attribute, originX - offsetX, originY - offsetY, areaAttribute), context.fill())), this.afterRenderStep(area2, context, offsetX, offsetY, !!fillOpacity, false, fill, false, areaAttribute, drawContext, fillCb, null, {
      attribute: area2.attribute
    }), stroke2) {
      const { stroke: stroke3 = areaAttribute && areaAttribute.stroke } = area2.attribute;
      if (isArray_default(stroke3) && (stroke3[0] || stroke3[2]) && false === stroke3[1]) {
        if (context.beginPath(), stroke3[0]) {
          context.moveTo(startP.x + offsetX, startP.y + offsetY, z);
          for (let i = 1; i < points.length; i++) {
            const p = points[i];
            context.lineTo(p.x + offsetX, p.y + offsetY, z);
          }
        } else if (stroke3[2]) {
          const endP = points[points.length - 1];
          context.moveTo(endP.x + offsetX, endP.y + offsetY, z);
          for (let i = points.length - 2; i >= 0; i--) {
            const p = points[i];
            context.lineTo((null !== (_d = p.x1) && void 0 !== _d ? _d : p.x) + offsetX, (null !== (_e = p.y1) && void 0 !== _e ? _e : p.y) + offsetY, z);
          }
        }
      }
      strokeCb ? strokeCb(context, area2.attribute, areaAttribute) : (context.setStrokeStyle(area2, area2.attribute, originX - offsetX, originY - offsetY, areaAttribute), context.stroke());
    }
  }
  drawShape(area2, context, x, y, drawContext, params2, fillCb, strokeCb) {
    var _a, _b, _c, _d, _e, _f;
    const areaAttribute = getTheme(area2, null == params2 ? void 0 : params2.theme).area, { fill = areaAttribute.fill, stroke: stroke2 = areaAttribute.stroke, fillOpacity = areaAttribute.fillOpacity, z = areaAttribute.z, strokeOpacity = areaAttribute.strokeOpacity } = area2.attribute, data = this.valid(area2, areaAttribute, fillCb, strokeCb);
    if (!data)
      return;
    const { doFill, doStroke } = data, { clipRange = areaAttribute.clipRange, closePath, points, segments: segments2 } = area2.attribute;
    let { curveType = areaAttribute.curveType } = area2.attribute;
    if (closePath && "linear" === curveType && (curveType = "linearClosed"), 1 === clipRange && !segments2 && !points.some((p) => false === p.defined) && "linear" === curveType)
      return this.drawLinearAreaHighPerformance(area2, context, !!fill, doStroke, fillOpacity, strokeOpacity, x, y, areaAttribute, drawContext, params2, fillCb, strokeCb);
    if (area2.shouldUpdateShape()) {
      if (segments2 && segments2.length) {
        let startPoint, lastTopSeg;
        const topCaches = segments2.map((seg, index) => {
          if (seg.points.length <= 1 && 0 === index)
            return seg.points[0] && (lastTopSeg = {
              endX: seg.points[0].x,
              endY: seg.points[0].y
            }), null;
          1 === index ? startPoint = {
            x: lastTopSeg.endX,
            y: lastTopSeg.endY
          } : index > 1 && (startPoint.x = lastTopSeg.endX, startPoint.y = lastTopSeg.endY);
          const data2 = calcLineCache2(seg.points, curveType, {
            startPoint
          });
          return lastTopSeg = data2, data2;
        }).filter((item) => !!item);
        let lastBottomSeg;
        const bottomCaches = [];
        for (let i = segments2.length - 1; i >= 0; i--) {
          const points2 = segments2[i].points, bottomPoints = [];
          for (let i2 = points2.length - 1; i2 >= 0; i2--)
            bottomPoints.push({
              x: null !== (_a = points2[i2].x1) && void 0 !== _a ? _a : points2[i2].x,
              y: null !== (_b = points2[i2].y1) && void 0 !== _b ? _b : points2[i2].y
            });
          if (0 !== i) {
            const lastSegmentPoints = segments2[i - 1].points, endPoint = lastSegmentPoints[lastSegmentPoints.length - 1];
            endPoint && bottomPoints.push({
              x: null !== (_c = endPoint.x1) && void 0 !== _c ? _c : endPoint.x,
              y: null !== (_d = endPoint.y1) && void 0 !== _d ? _d : endPoint.y
            });
          }
          bottomPoints.length > 1 && (lastBottomSeg = calcLineCache2(bottomPoints, "stepBefore" === curveType ? "stepAfter" : "stepAfter" === curveType ? "stepBefore" : curveType), bottomCaches.unshift(lastBottomSeg));
        }
        area2.cacheArea = bottomCaches.map((item, index) => ({
          top: topCaches[index],
          bottom: item
        }));
      } else {
        if (!points || !points.length)
          return area2.cacheArea = null, void area2.clearUpdateShapeTag();
        {
          const topPoints = points, bottomPoints = [];
          for (let i = points.length - 1; i >= 0; i--)
            bottomPoints.push({
              x: null !== (_e = points[i].x1) && void 0 !== _e ? _e : points[i].x,
              y: null !== (_f = points[i].y1) && void 0 !== _f ? _f : points[i].y
            });
          const topCache = calcLineCache2(topPoints, curveType), bottomCache = calcLineCache2(bottomPoints, "stepBefore" === curveType ? "stepAfter" : "stepAfter" === curveType ? "stepBefore" : curveType);
          area2.cacheArea = {
            top: topCache,
            bottom: bottomCache
          };
        }
      }
      area2.clearUpdateShapeTag();
    }
    if (Array.isArray(area2.cacheArea)) {
      const segments3 = area2.attribute.segments.filter((item) => item.points.length);
      if (1 === segments3[0].points.length && segments3.shift(), 1 === clipRange) {
        let skip = false;
        area2.cacheArea.forEach((cache, index) => {
          skip || (skip = this.drawSegmentItem(context, cache, doFill, fillOpacity, doStroke, strokeOpacity, segments3[index], [areaAttribute, area2.attribute], clipRange, x, y, z, area2, drawContext, fillCb, strokeCb));
        });
      } else {
        const totalLength = area2.cacheArea.reduce((l, c3) => l + c3.top.getLength(), 0), totalDrawLength = clipRange * totalLength;
        let drawedLengthUntilLast = 0, skip = false;
        area2.cacheArea.forEach((cache, index) => {
          if (skip)
            return;
          const curSegLength = cache.top.getLength(), _cr = (totalDrawLength - drawedLengthUntilLast) / curSegLength;
          drawedLengthUntilLast += curSegLength, _cr > 0 && (skip = this.drawSegmentItem(context, cache, doFill, fillOpacity, doStroke, strokeOpacity, segments3[index], [areaAttribute, area2.attribute], min(_cr, 1), x, y, z, area2, drawContext, fillCb, strokeCb));
        });
      }
    } else
      this.drawSegmentItem(context, area2.cacheArea, doFill, fillOpacity, doStroke, strokeOpacity, area2.attribute, areaAttribute, clipRange, x, y, z, area2, drawContext, fillCb, strokeCb);
  }
  draw(area2, renderService, drawContext, params2) {
    const areaAttribute = getTheme(area2, null == params2 ? void 0 : params2.theme).area;
    this._draw(area2, areaAttribute, false, drawContext, params2);
  }
  drawSegmentItem(context, cache, fill, fillOpacity, stroke2, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area2, drawContext, fillCb, strokeCb) {
    let ret = false;
    return ret = ret || this._drawSegmentItem(context, cache, fill, fillOpacity, stroke2, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area2, drawContext, false, fillCb, strokeCb), ret = ret || this._drawSegmentItem(context, cache, fill, fillOpacity, stroke2, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area2, drawContext, true, fillCb, strokeCb), ret;
  }
  _drawSegmentItem(context, cache, fill, fillOpacity, stroke2, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area2, drawContext, connect, fillCb, strokeCb) {
    var _a, _b, _c, _d;
    if (!(cache && cache.top && cache.bottom && cache.top.curves && cache.top.curves.length && cache.bottom.curves && cache.bottom.curves.length))
      return;
    let { connectedType, connectedX, connectedY, connectedStyle } = attribute;
    const da = [];
    if (connect && (isArray_default(defaultAttribute) ? (connectedType = null !== (_a = null != connectedType ? connectedType : defaultAttribute[0].connectedType) && void 0 !== _a ? _a : defaultAttribute[1].connectedType, connectedX = null !== (_b = null != connectedX ? connectedX : defaultAttribute[0].connectedX) && void 0 !== _b ? _b : defaultAttribute[1].connectedX, connectedY = null !== (_c = null != connectedY ? connectedY : defaultAttribute[0].connectedY) && void 0 !== _c ? _c : defaultAttribute[1].connectedY, connectedStyle = null !== (_d = null != connectedStyle ? connectedStyle : defaultAttribute[0].connectedStyle) && void 0 !== _d ? _d : defaultAttribute[1].connectedStyle) : (connectedType = null != connectedType ? connectedType : defaultAttribute.connectedType, connectedX = null != connectedX ? connectedX : defaultAttribute.connectedX, connectedY = null != connectedY ? connectedY : defaultAttribute.connectedY, connectedStyle = null != connectedStyle ? connectedStyle : defaultAttribute.connectedStyle), "connect" !== connectedType && "zero" !== connectedType && (connectedType = "none"), isArray_default(defaultAttribute) ? defaultAttribute.forEach((i) => da.push(i)) : da.push(defaultAttribute), da.push(attribute)), connect && "none" === connectedType)
      return false;
    context.beginPath();
    const { points, segments: segments2 } = area2.attribute;
    let endP, startP, direction2 = Direction.ROW;
    if (segments2) {
      const endSeg = segments2[segments2.length - 1];
      startP = segments2[0].points[0], endP = endSeg.points[endSeg.points.length - 1];
    } else
      startP = points[0], endP = points[points.length - 1];
    const xTotalLength = abs(endP.x - startP.x), yTotalLength = abs(endP.y - startP.y);
    direction2 = Number.isFinite(xTotalLength + yTotalLength) ? xTotalLength > yTotalLength ? Direction.ROW : Direction.COLUMN : Direction.ROW, drawAreaSegments(context.camera ? context : context.nativeContext, cache, clipRange, {
      offsetX,
      offsetY,
      offsetZ,
      direction: direction2,
      drawConnect: connect,
      mode: connectedType,
      zeroX: connectedX,
      zeroY: connectedY
    }), this.beforeRenderStep(area2, context, offsetX, offsetY, !!fillOpacity, false, fill, false, defaultAttribute, drawContext, fillCb, null, {
      attribute
    }), context.setShadowBlendStyle && context.setShadowBlendStyle(area2, attribute, defaultAttribute);
    const { x: originX = 0, x: originY = 0 } = attribute;
    if (false !== fill && (fillCb ? fillCb(context, attribute, defaultAttribute) : fillOpacity && (context.setCommonStyle(area2, connect ? connectedStyle : attribute, originX - offsetX, originY - offsetY, connect ? da : defaultAttribute), context.fill())), this.afterRenderStep(area2, context, offsetX, offsetY, !!fillOpacity, false, fill, false, defaultAttribute, drawContext, fillCb, null, {
      attribute
    }), false !== stroke2)
      if (strokeCb)
        strokeCb(context, attribute, defaultAttribute);
      else {
        const { stroke: stroke3 = defaultAttribute && defaultAttribute[1] && defaultAttribute[1].stroke } = attribute;
        isArray_default(stroke3) && (stroke3[0] || stroke3[2]) && false === stroke3[1] && (context.beginPath(), drawSegments(context.camera ? context : context.nativeContext, stroke3[0] ? cache.top : cache.bottom, clipRange, direction2 === Direction.ROW ? "x" : "y", {
          offsetX,
          offsetY,
          offsetZ,
          drawConnect: connect,
          mode: connectedType,
          zeroX: connectedX,
          zeroY: connectedY
        })), context.setStrokeStyle(area2, connect ? connectedStyle : attribute, originX - offsetX, originY - offsetY, connect ? da : defaultAttribute), context.stroke();
      }
    return false;
  }
};
DefaultCanvasAreaRender = __decorate13([injectable(), __param7(0, inject(ContributionProvider)), __param7(0, named(AreaRenderContribution)), __metadata9("design:paramtypes", [Object])], DefaultCanvasAreaRender);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/contributions/path-contribution-render
var defaultPathTextureRenderContribution = defaultBaseTextureRenderContribution;
var defaultPathBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/path-render
var __decorate14 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata10 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param8 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasPathRender = class extends BaseRender {
  constructor(pathRenderContribitions) {
    super(), this.pathRenderContribitions = pathRenderContribitions, this.numberType = PATH_NUMBER_TYPE, this.builtinContributions = [defaultPathBackgroundRenderContribution, defaultPathTextureRenderContribution], this.init(pathRenderContribitions);
  }
  drawShape(path, context, x, y, drawContext, params2, fillCb, strokeCb) {
    var _a, _b, _c;
    const pathAttribute = null !== (_a = this.tempTheme) && void 0 !== _a ? _a : getTheme(path, null == params2 ? void 0 : params2.theme).path, { x: originX = pathAttribute.x, y: originY = pathAttribute.y } = path.attribute, z = null !== (_b = this.z) && void 0 !== _b ? _b : 0, data = this.valid(path, pathAttribute, fillCb, strokeCb);
    if (!data)
      return;
    const { fVisible, sVisible, doFill, doStroke } = data;
    if (context.beginPath(), path.pathShape)
      renderCommandList(path.pathShape.commandList, context, x, y, 1, 1, z);
    else {
      const path2D = null !== (_c = path.attribute.path) && void 0 !== _c ? _c : pathAttribute.path;
      renderCommandList(path2D.commandList, context, x, y, 1, 1, z);
    }
    context.setShadowBlendStyle && context.setShadowBlendStyle(path, path.attribute, pathAttribute), this.beforeRenderStep(path, context, x, y, doFill, doStroke, fVisible, sVisible, pathAttribute, drawContext, fillCb, strokeCb), doStroke && (strokeCb ? strokeCb(context, path.attribute, pathAttribute) : sVisible && (context.setStrokeStyle(path, path.attribute, originX - x, originY - y, pathAttribute), context.stroke())), doFill && (fillCb ? fillCb(context, path.attribute, pathAttribute) : fVisible && (context.setCommonStyle(path, path.attribute, originX - x, originY - y, pathAttribute), context.fill())), this.afterRenderStep(path, context, x, y, doFill, doStroke, fVisible, sVisible, pathAttribute, drawContext, fillCb, strokeCb);
  }
  draw(path, renderService, drawContext, params2) {
    const pathAttribute = getTheme(path, null == params2 ? void 0 : params2.theme).path;
    this.tempTheme = pathAttribute, this._draw(path, pathAttribute, false, drawContext, params2), this.tempTheme = null;
  }
};
DefaultCanvasPathRender = __decorate14([injectable(), __param8(0, inject(ContributionProvider)), __param8(0, named(PathRenderContribution)), __metadata10("design:paramtypes", [Object])], DefaultCanvasPathRender);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/rect-render
var __decorate15 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata11 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param9 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasRectRender = class extends BaseRender {
  constructor(rectRenderContribitions) {
    super(), this.rectRenderContribitions = rectRenderContribitions, this.type = "rect", this.numberType = RECT_NUMBER_TYPE, this.builtinContributions = [defaultRectRenderContribution, defaultRectBackgroundRenderContribution, defaultRectTextureRenderContribution], this.init(rectRenderContribitions);
  }
  drawShape(rect, context, x, y, drawContext, params2, fillCb, strokeCb) {
    var _a;
    const rectAttribute = null !== (_a = this.tempTheme) && void 0 !== _a ? _a : getTheme(rect, null == params2 ? void 0 : params2.theme).rect, { fill = rectAttribute.fill, background, stroke: stroke2 = rectAttribute.stroke, cornerRadius = rectAttribute.cornerRadius, opacity = rectAttribute.opacity, fillOpacity = rectAttribute.fillOpacity, lineWidth = rectAttribute.lineWidth, strokeOpacity = rectAttribute.strokeOpacity, visible = rectAttribute.visible, x1: x14, y1: y14, x: originX = rectAttribute.x, y: originY = rectAttribute.y } = rect.attribute;
    let { width, height } = rect.attribute;
    width = (null != width ? width : x14 - originX) || 0, height = (null != height ? height : y14 - originY) || 0;
    const fVisible = rectFillVisible(opacity, fillOpacity, width, height, fill), sVisible = rectStrokeVisible(opacity, strokeOpacity, width, height), doFill = runFill(fill, background), doStroke = runStroke(stroke2, lineWidth);
    if (!rect.valid || !visible)
      return;
    if (!doFill && !doStroke)
      return;
    if (!(fVisible || sVisible || fillCb || strokeCb || background))
      return;
    0 === cornerRadius || isArray_default(cornerRadius) && cornerRadius.every((num) => 0 === num) ? (context.beginPath(), context.rect(x, y, width, height)) : (context.beginPath(), createRectPath(context, x, y, width, height, cornerRadius));
    const doFillOrStroke = {
      doFill,
      doStroke
    };
    context.setShadowBlendStyle && context.setShadowBlendStyle(rect, rect.attribute, rectAttribute), this.beforeRenderStep(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb, doFillOrStroke), doFillOrStroke.doFill && (fillCb ? fillCb(context, rect.attribute, rectAttribute) : fVisible && (context.setCommonStyle(rect, rect.attribute, originX - x, originY - y, rectAttribute), context.fill())), doFillOrStroke.doStroke && (strokeCb ? strokeCb(context, rect.attribute, rectAttribute) : sVisible && (context.setStrokeStyle(rect, rect.attribute, originX - x, originY - y, rectAttribute), context.stroke())), this.afterRenderStep(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb);
  }
  draw(rect, renderService, drawContext, params2) {
    const rectAttribute = getTheme(rect, null == params2 ? void 0 : params2.theme).rect;
    this.tempTheme = rectAttribute, this._draw(rect, rectAttribute, false, drawContext, params2), this.tempTheme = null;
  }
};
DefaultCanvasRectRender = __decorate15([injectable(), __param9(0, inject(ContributionProvider)), __param9(0, named(RectRenderContribution)), __metadata11("design:paramtypes", [Object])], DefaultCanvasRectRender);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/symbol-render
var __decorate16 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata12 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param10 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasSymbolRender = class extends BaseRender {
  constructor(symbolRenderContribitions) {
    super(), this.symbolRenderContribitions = symbolRenderContribitions, this.numberType = SYMBOL_NUMBER_TYPE, this.builtinContributions = [defaultSymbolRenderContribution, defaultSymbolBackgroundRenderContribution, defaultSymbolTextureRenderContribution], this.init(symbolRenderContribitions);
  }
  drawShape(symbol, context, x, y, drawContext, params2, fillCb, strokeCb) {
    var _a;
    const symbolAttribute = getTheme(symbol, null == params2 ? void 0 : params2.theme).symbol, { size = symbolAttribute.size, x: originX = symbolAttribute.x, y: originY = symbolAttribute.y, scaleX = symbolAttribute.scaleX, scaleY = symbolAttribute.scaleY } = symbol.attribute, data = this.valid(symbol, symbolAttribute, fillCb, strokeCb);
    if (!data)
      return;
    const { fVisible, sVisible, doFill, doStroke } = data, parsedPath = symbol.getParsedPath();
    if (!parsedPath)
      return;
    const { keepDirIn3d = symbolAttribute.keepDirIn3d } = symbol.attribute, z = null !== (_a = this.z) && void 0 !== _a ? _a : 0;
    if (context.beginPath(), keepDirIn3d && context.camera && context.project) {
      const p = context.project(x, y, z), camera = context.camera;
      context.camera = null, false === parsedPath.draw(context, isArray_default(size) ? [size[0] * scaleX, size[1] * scaleY] : size * scaleX, p.x, p.y, void 0, (p2, a3) => {
        var _a2, _b, _c;
        if (symbol._parsedPath.svgCache) {
          const obj = Object.assign({}, a3);
          obj.fill = null !== (_a2 = a3.fill) && void 0 !== _a2 ? _a2 : symbol.attribute.fill, obj.opacity = null !== (_b = a3.fill) && void 0 !== _b ? _b : symbol.attribute.opacity, obj.fillOpacity = symbol.attribute.fillOpacity, obj.stroke = null !== (_c = a3.stroke) && void 0 !== _c ? _c : symbol.attribute.stroke, a3 = obj;
        }
        a3.fill && (fillCb ? fillCb(context, symbol.attribute, symbolAttribute) : (context.setCommonStyle(symbol, a3, originX - x, originY - y, symbolAttribute), context.fill())), a3.stroke && (strokeCb ? strokeCb(context, symbol.attribute, symbolAttribute) : (context.setStrokeStyle(symbol, a3, (originX - x) / scaleX, (originY - y) / scaleY, symbolAttribute), context.stroke()));
      }) && context.closePath(), context.camera = camera;
    } else
      false === parsedPath.draw(context, size, x, y, z, (p, a3) => {
        var _a2, _b, _c;
        if (symbol._parsedPath.svgCache) {
          const obj = Object.assign({}, a3);
          obj.fill = null !== (_a2 = a3.fill) && void 0 !== _a2 ? _a2 : symbol.attribute.fill, obj.opacity = null !== (_b = a3.opacity) && void 0 !== _b ? _b : symbol.attribute.opacity, obj.fillOpacity = symbol.attribute.fillOpacity, obj.stroke = null !== (_c = a3.stroke) && void 0 !== _c ? _c : symbol.attribute.stroke, a3 = obj;
        }
        a3.fill && (fillCb ? fillCb(context, symbol.attribute, symbolAttribute) : (context.setCommonStyle(symbol, a3, originX - x, originY - y, symbolAttribute), context.fill())), a3.stroke && (strokeCb ? strokeCb(context, symbol.attribute, symbolAttribute) : (context.setStrokeStyle(symbol, a3, (originX - x) / scaleX, (originY - y) / scaleY, symbolAttribute), context.stroke()));
      }) && context.closePath();
    context.setShadowBlendStyle && context.setShadowBlendStyle(symbol, symbol.attribute, symbolAttribute), this.beforeRenderStep(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, drawContext, fillCb, strokeCb), doFill && !parsedPath.isSvg && (fillCb ? fillCb(context, symbol.attribute, symbolAttribute) : fVisible && (context.setCommonStyle(symbol, symbol.attribute, originX - x, originY - y, symbolAttribute), context.fill())), doStroke && !parsedPath.isSvg && (strokeCb ? strokeCb(context, symbol.attribute, symbolAttribute) : sVisible && (context.setStrokeStyle(symbol, symbol.attribute, (originX - x) / scaleX, (originY - y) / scaleY, symbolAttribute), context.stroke())), this.afterRenderStep(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, drawContext, fillCb, strokeCb);
  }
  draw(symbol, renderService, drawContext, params2) {
    const symbolAttribute = getTheme(symbol, null == params2 ? void 0 : params2.theme).symbol;
    this._draw(symbol, symbolAttribute, false, drawContext, params2);
  }
};
DefaultCanvasSymbolRender = __decorate16([injectable(), __param10(0, inject(ContributionProvider)), __param10(0, named(SymbolRenderContribution)), __metadata12("design:paramtypes", [Object])], DefaultCanvasSymbolRender);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/allocator/bounds-allocate
var BoundsAllocate = Symbol.for("BoundsAllocate");
var DefaultBoundsAllocate = class {
  constructor() {
    this.pools = [];
    for (let i = 0; i < 10; i++)
      this.pools.push(new AABBBounds());
  }
  allocate(x14, y14, x23, y23) {
    if (!this.pools.length)
      return new AABBBounds().setValue(x14, y14, x23, y23);
    const b = this.pools.pop();
    return b.x1 = x14, b.y1 = y14, b.x2 = x23, b.y2 = y23, b;
  }
  allocateByObj(b) {
    if (!this.pools.length)
      return new AABBBounds(b);
    const _b = this.pools.pop();
    return _b.x1 = b.x1, _b.y1 = b.y1, _b.x2 = b.x2, _b.y2 = b.y2, _b;
  }
  free(b) {
    this.pools.push(b);
  }
  get length() {
    return this.pools.length;
  }
  release(...params2) {
    this.pools = [];
  }
};
var boundsAllocate = new DefaultBoundsAllocate();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/contributions/text-contribution-render
var DefaultTextBackgroundRenderContribution = class extends DefaultBaseBackgroundRenderContribution {
  constructor() {
    super(...arguments), this.time = BaseRenderContributionTime.beforeFillStroke;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb) {
    var _a, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const { backgroundMode = graphicAttribute.backgroundMode, backgroundFit = graphicAttribute.backgroundFit } = graphic.attribute;
    let matrix, { background } = graphic.attribute;
    if (!background)
      return;
    const restore = () => {
      "richtext" === graphic.type && (context.restore(), context.save(), matrix && context.setTransformFromMatrix(matrix, true, 1));
    };
    let b;
    "richtext" === graphic.type && (matrix = context.currentMatrix.clone(), context.restore(), context.save(), context.setTransformForCurrent());
    const shouldReCalBounds = isObject_default(background) && background.background, onlyTranslate = graphic.transMatrix.onlyTranslate();
    if (shouldReCalBounds) {
      const _b = graphic.AABBBounds, x3 = (null !== (_a = background.x) && void 0 !== _a ? _a : _b.x1) + (null !== (_c = background.dx) && void 0 !== _c ? _c : 0), y3 = (null !== (_d = background.y) && void 0 !== _d ? _d : _b.y1) + (null !== (_e = background.dy) && void 0 !== _e ? _e : 0), w = null !== (_f = background.width) && void 0 !== _f ? _f : _b.width(), h = null !== (_g = background.height) && void 0 !== _g ? _g : _b.height();
      if (b = boundsAllocate.allocate(x3, y3, x3 + w, y3 + h), background = background.background, !onlyTranslate) {
        const w2 = b.width(), h2 = b.height();
        b.set((null !== (_h = background.x) && void 0 !== _h ? _h : 0) + (null !== (_j = background.dx) && void 0 !== _j ? _j : 0), (null !== (_k = background.y) && void 0 !== _k ? _k : 0) + (null !== (_l = background.dy) && void 0 !== _l ? _l : 0), w2, h2);
      }
    } else
      b = graphic.AABBBounds, onlyTranslate || (b = getTextBounds(Object.assign(Object.assign({}, graphic.attribute), {
        angle: 0,
        scaleX: 1,
        scaleY: 1,
        x: 0,
        y: 0,
        dx: 0,
        dy: 0
      })).clone());
    if (graphic.backgroundImg && graphic.resources) {
      const res = graphic.resources.get(background);
      if ("success" !== res.state || !res.data)
        return void restore();
      context.highPerformanceSave(), onlyTranslate && context.setTransformFromMatrix(graphic.parent.globalTransMatrix, true), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), this.doDrawImage(context, res.data, b, backgroundMode, backgroundFit), context.highPerformanceRestore(), context.setTransformForCurrent();
    } else {
      const { backgroundCornerRadius } = graphic.attribute;
      context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.fillStyle = background, backgroundCornerRadius ? (createRectPath(context, b.x1, b.y1, b.width(), b.height(), backgroundCornerRadius), context.fill()) : context.fillRect(b.x1, b.y1, b.width(), b.height()), context.highPerformanceRestore();
    }
    shouldReCalBounds && boundsAllocate.free(b), restore();
  }
};
var defaultTextBackgroundRenderContribution = new DefaultTextBackgroundRenderContribution();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/text-render
var __decorate17 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata13 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param11 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasTextRender = class extends BaseRender {
  constructor(textRenderContribitions) {
    super(), this.textRenderContribitions = textRenderContribitions, this.numberType = TEXT_NUMBER_TYPE, this.builtinContributions = [defaultTextBackgroundRenderContribution], this.init(textRenderContribitions);
  }
  drawShape(text2, context, x, y, drawContext, params2, fillCb, strokeCb) {
    var _a, _b, _c;
    const textAttribute2 = getTheme(text2, null == params2 ? void 0 : params2.theme).text, { text: str, underline = textAttribute2.underline, lineThrough = textAttribute2.lineThrough, keepDirIn3d = textAttribute2.keepDirIn3d, direction: direction2 = textAttribute2.direction, whiteSpace = textAttribute2.whiteSpace, fontSize = textAttribute2.fontSize, verticalMode = textAttribute2.verticalMode, x: originX = textAttribute2.x, y: originY = textAttribute2.y } = text2.attribute;
    let { textAlign = textAttribute2.textAlign, textBaseline = textAttribute2.textBaseline } = text2.attribute;
    if (!verticalMode && "vertical" === direction2) {
      const t = textAlign;
      textAlign = null !== (_a = text2.getBaselineMapAlign()[textBaseline]) && void 0 !== _a ? _a : "left", textBaseline = null !== (_b = text2.getAlignMapBaseline()[t]) && void 0 !== _b ? _b : "top";
    }
    const lineHeight = null !== (_c = calculateLineHeight(text2.attribute.lineHeight, fontSize)) && void 0 !== _c ? _c : fontSize, data = this.valid(text2, textAttribute2, fillCb, strokeCb);
    if (!data)
      return;
    const { fVisible, sVisible, doFill, doStroke } = data, transform3dMatrixToContextMatrix = !keepDirIn3d, z = this.z || 0;
    context.beginPath(), context.setShadowBlendStyle && context.setShadowBlendStyle(text2, text2.attribute, textAttribute2), this.beforeRenderStep(text2, context, x, y, doFill, doStroke, fVisible, sVisible, textAttribute2, drawContext, fillCb, strokeCb), transform3dMatrixToContextMatrix && this.transformUseContext2d(text2, textAttribute2, z, context);
    const drawText = (t, offsetX, offsetY, direction3) => {
      let _x = x + offsetX;
      const _y = y + offsetY;
      if (direction3) {
        context.highPerformanceSave(), _x += fontSize;
        const matrix = matrixAllocate.allocate(1, 0, 0, 1, 0, 0);
        matrix.rotateByCenter(Math.PI / 2, _x, _y), context.transformFromMatrix(matrix, true), matrixAllocate.free(matrix);
      }
      doStroke && (strokeCb ? strokeCb(context, text2.attribute, textAttribute2) : sVisible && (context.setStrokeStyle(text2, text2.attribute, originX - x, originY - y, textAttribute2), context.strokeText(t, _x, _y, z))), doFill && (fillCb ? fillCb(context, text2.attribute, textAttribute2) : fVisible && (context.setCommonStyle(text2, text2.attribute, originX - x, originY - y, textAttribute2), context.fillText(t, _x, _y, z), this.drawUnderLine(underline, lineThrough, text2, _x, _y, z, textAttribute2, context))), direction3 && (context.highPerformanceRestore(), context.setTransformForCurrent());
    };
    if (text2.isMultiLine)
      if (context.setTextStyleWithoutAlignBaseline(text2.attribute, textAttribute2, z), "horizontal" === direction2) {
        const { multilineLayout } = text2;
        if (!multilineLayout)
          return void context.highPerformanceRestore();
        const { xOffset, yOffset } = multilineLayout.bbox;
        doStroke && (strokeCb ? strokeCb(context, text2.attribute, textAttribute2) : sVisible && (context.setStrokeStyle(text2, text2.attribute, originX - x, originY - y, textAttribute2), multilineLayout.lines.forEach((line2) => {
          context.strokeText(line2.str, (line2.leftOffset || 0) + xOffset + x, (line2.topOffset || 0) + yOffset + y, z);
        }))), doFill && (fillCb ? fillCb(context, text2.attribute, textAttribute2) : fVisible && (context.setCommonStyle(text2, text2.attribute, originX - x, originY - y, textAttribute2), multilineLayout.lines.forEach((line2) => {
          context.fillText(line2.str, (line2.leftOffset || 0) + xOffset + x, (line2.topOffset || 0) + yOffset + y, z), this.drawMultiUnderLine(underline, lineThrough, text2, (line2.leftOffset || 0) + xOffset + x, (line2.topOffset || 0) + yOffset + y - textDrawOffsetY("bottom", fontSize) - 0.05 * fontSize, z, line2.width, textAttribute2, context);
        })));
      } else {
        text2.tryUpdateAABBBounds();
        const cache = text2.cache, { verticalList } = cache;
        context.textAlign = "left", context.textBaseline = "top";
        const totalHeight = lineHeight * verticalList.length;
        let totalW = 0;
        verticalList.forEach((verticalData) => {
          const _w = verticalData.reduce((a3, b) => a3 + (b.width || 0), 0);
          totalW = max(_w, totalW);
        });
        let offsetY = 0, offsetX = 0;
        "bottom" === textBaseline ? offsetX = -totalHeight : "middle" === textBaseline && (offsetX = -totalHeight / 2), "center" === textAlign ? offsetY -= totalW / 2 : "right" === textAlign && (offsetY -= totalW), verticalList.forEach((verticalData, i) => {
          const currentW = verticalData.reduce((a3, b) => a3 + (b.width || 0), 0), dw = totalW - currentW;
          let currentOffsetY = offsetY;
          "center" === textAlign ? currentOffsetY += dw / 2 : "right" === textAlign && (currentOffsetY += dw), verticalData.forEach((item) => {
            const { text: text3, width, direction: direction3 } = item;
            drawText(text3, totalHeight - (i + 1) * lineHeight + offsetX, currentOffsetY, direction3), currentOffsetY += width;
          });
        });
      }
    else if ("horizontal" === direction2) {
      context.setTextStyle(text2.attribute, textAttribute2, z);
      const t = text2.clipedText;
      let dy = 0;
      lineHeight !== fontSize && ("top" === textBaseline ? dy = (lineHeight - fontSize) / 2 : "middle" === textBaseline || "bottom" === textBaseline && (dy = -(lineHeight - fontSize) / 2)), drawText(t, 0, dy, 0);
    } else {
      text2.tryUpdateAABBBounds();
      const cache = text2.cache;
      if (cache) {
        context.setTextStyleWithoutAlignBaseline(text2.attribute, textAttribute2, z);
        const { verticalList } = cache;
        let offsetY = 0;
        const totalW = verticalList[0].reduce((a3, b) => a3 + (b.width || 0), 0);
        let offsetX = 0;
        "bottom" === textBaseline ? offsetX = -lineHeight : "middle" === textBaseline && (offsetX = -lineHeight / 2), "center" === textAlign ? offsetY -= totalW / 2 : "right" === textAlign && (offsetY -= totalW), context.textAlign = "left", context.textBaseline = "top", verticalList[0].forEach((item) => {
          const { text: text3, width, direction: direction3 } = item;
          drawText(text3, offsetX, offsetY, direction3), offsetY += width;
        });
      }
    }
    transform3dMatrixToContextMatrix && this.restoreTransformUseContext2d(text2, textAttribute2, z, context), this.afterRenderStep(text2, context, x, y, doFill, doStroke, fVisible, sVisible, textAttribute2, drawContext, fillCb, strokeCb);
  }
  draw(text2, renderService, drawContext, params2) {
    const textAttribute2 = getTheme(text2, null == params2 ? void 0 : params2.theme).text, { keepDirIn3d = textAttribute2.keepDirIn3d } = text2.attribute, computed3dMatrix = !keepDirIn3d;
    this._draw(text2, textAttribute2, computed3dMatrix, drawContext, params2);
  }
  drawUnderLine(underline, lineThrough, text2, x, y, z, textAttribute2, context) {
    if (lineThrough + underline <= 0)
      return;
    const { textAlign = textAttribute2.textAlign, textBaseline = textAttribute2.textBaseline, fontSize = textAttribute2.fontSize, fill = textAttribute2.fill, opacity = textAttribute2.opacity, underlineOffset = textAttribute2.underlineOffset, underlineDash = textAttribute2.underlineDash, fillOpacity = textAttribute2.fillOpacity } = text2.attribute, w = text2.clipedWidth, offsetX = textDrawOffsetX(textAlign, w), offsetY = textLayoutOffsetY(textBaseline, fontSize, fontSize), attribute = {
      lineWidth: 0,
      stroke: fill,
      opacity,
      strokeOpacity: fillOpacity
    };
    if (underline) {
      attribute.lineWidth = underline, context.setStrokeStyle(text2, attribute, x, y, textAttribute2), underlineDash && context.setLineDash(underlineDash), context.beginPath();
      const dy = y + offsetY + fontSize + underlineOffset;
      context.moveTo(x + offsetX, dy, z), context.lineTo(x + offsetX + w, dy, z), context.stroke();
    }
    if (lineThrough) {
      attribute.lineWidth = lineThrough, context.setStrokeStyle(text2, attribute, x, y, textAttribute2), context.beginPath();
      const dy = y + offsetY + fontSize / 2;
      context.moveTo(x + offsetX, dy, z), context.lineTo(x + offsetX + w, dy, z), context.stroke();
    }
  }
  drawMultiUnderLine(underline, lineThrough, text2, x, y, z, w, textAttribute2, context) {
    if (lineThrough + underline <= 0)
      return;
    const { fontSize = textAttribute2.fontSize, fill = textAttribute2.fill, opacity = textAttribute2.opacity, underlineOffset = textAttribute2.underlineOffset, underlineDash = textAttribute2.underlineDash, fillOpacity = textAttribute2.fillOpacity } = text2.attribute, offsetY = textLayoutOffsetY("alphabetic", fontSize, fontSize), attribute = {
      lineWidth: 0,
      stroke: fill,
      opacity,
      strokeOpacity: fillOpacity
    };
    let deltaY = -3;
    if (underline) {
      attribute.lineWidth = underline, context.setStrokeStyle(text2, attribute, x, y, textAttribute2), underlineDash && context.setLineDash(underlineDash), context.beginPath();
      const dy = y + offsetY + fontSize + deltaY + underlineOffset;
      context.moveTo(x + 0, dy, z), context.lineTo(x + 0 + w, dy, z), context.stroke();
    }
    if (deltaY = -1, lineThrough) {
      attribute.lineWidth = lineThrough, context.setStrokeStyle(text2, attribute, x, y, textAttribute2), context.beginPath();
      const dy = y + offsetY + fontSize / 2 + deltaY;
      context.moveTo(x + 0, dy, z), context.lineTo(x + 0 + w, dy, z), context.stroke();
    }
  }
};
DefaultCanvasTextRender = __decorate17([injectable(), __param11(0, inject(ContributionProvider)), __param11(0, named(TextRenderContribution)), __metadata13("design:paramtypes", [Object])], DefaultCanvasTextRender);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/graphic-render
var __decorate18 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var AbstractGraphicRender = class {
};
AbstractGraphicRender = __decorate18([injectable()], AbstractGraphicRender);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/polygon
function drawPolygon(path, points, x, y) {
  path.moveTo(points[0].x + x, points[0].y + y);
  for (let i = 1; i < points.length; i++)
    path.lineTo(points[i].x + x, points[i].y + y);
}
function drawRoundedPolygon(path, points, x, y, cornerRadius, closePath = true) {
  var _a;
  if (points.length < 3)
    return void drawPolygon(path, points, x, y);
  let startI = 0, endI = points.length - 1;
  closePath || (startI += 1, endI -= 1, path.moveTo(points[0].x + x, points[0].y + y));
  for (let i = startI; i <= endI; i++) {
    const p1 = points[0 === i ? endI : (i - 1) % points.length], angularPoint = points[i % points.length], p2 = points[(i + 1) % points.length], dx1 = angularPoint.x - p1.x, dy1 = angularPoint.y - p1.y, dx2 = angularPoint.x - p2.x, dy2 = angularPoint.y - p2.y, angle2 = (Math.atan2(dy1, dx1) - Math.atan2(dy2, dx2)) / 2, tan2 = Math.abs(Math.tan(angle2));
    let radius = Array.isArray(cornerRadius) ? null !== (_a = cornerRadius[i % points.length]) && void 0 !== _a ? _a : 0 : cornerRadius, segment = radius / tan2;
    const length1 = getLength(dx1, dy1), length2 = getLength(dx2, dy2), length3 = Math.min(length1, length2);
    segment > length3 && (segment = length3, radius = length3 * tan2);
    const p1Cross = getProportionPoint(angularPoint, segment, length1, dx1, dy1), p2Cross = getProportionPoint(angularPoint, segment, length2, dx2, dy2), dx = 2 * angularPoint.x - p1Cross.x - p2Cross.x, dy = 2 * angularPoint.y - p1Cross.y - p2Cross.y, L = getLength(dx, dy), circlePoint = getProportionPoint(angularPoint, getLength(segment, radius), L, dx, dy);
    let startAngle = Math.atan2(p1Cross.y - circlePoint.y, p1Cross.x - circlePoint.x);
    const endAngle = Math.atan2(p2Cross.y - circlePoint.y, p2Cross.x - circlePoint.x);
    let sweepAngle = endAngle - startAngle;
    sweepAngle < 0 && (startAngle = endAngle, sweepAngle = -sweepAngle), sweepAngle > Math.PI && (sweepAngle -= Math.PI), 0 === i ? path.moveTo(p1Cross.x + x, p1Cross.y + y) : path.lineTo(p1Cross.x + x, p1Cross.y + y), sweepAngle && path.arcTo(angularPoint.x + x, angularPoint.y + y, p2Cross.x + x, p2Cross.y + y, radius), path.lineTo(p2Cross.x + x, p2Cross.y + y);
  }
  closePath || path.lineTo(points[endI + 1].x + x, points[endI + 1].y + y);
}
function getLength(dx, dy) {
  return Math.sqrt(dx * dx + dy * dy);
}
function getProportionPoint(point5, segment, length2, dx, dy) {
  const factor = segment / length2;
  return {
    x: point5.x - dx * factor,
    y: point5.y - dy * factor
  };
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/contributions/polygon-contribution-render
var defaultPolygonTextureRenderContribution = defaultBaseTextureRenderContribution;
var defaultPolygonBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/polygon-render
var __decorate19 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata14 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param12 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasPolygonRender = class extends BaseRender {
  constructor(polygonRenderContribitions) {
    super(), this.polygonRenderContribitions = polygonRenderContribitions, this.numberType = POLYGON_NUMBER_TYPE, this.builtinContributions = [defaultPolygonBackgroundRenderContribution, defaultPolygonTextureRenderContribution], this.init(polygonRenderContribitions);
  }
  drawShape(polygon, context, x, y, drawContext, params2, fillCb, strokeCb) {
    const polygonAttribute = getTheme(polygon, null == params2 ? void 0 : params2.theme).polygon, { points = polygonAttribute.points, cornerRadius = polygonAttribute.cornerRadius, x: originX = polygonAttribute.x, y: originY = polygonAttribute.y, closePath = polygonAttribute.closePath } = polygon.attribute, data = this.valid(polygon, polygonAttribute, fillCb, strokeCb);
    if (!data)
      return;
    const { fVisible, sVisible, doFill, doStroke } = data;
    context.beginPath(), cornerRadius <= 0 || isArray_default(cornerRadius) && cornerRadius.every((num) => 0 === num) ? drawPolygon(context.camera ? context : context.nativeContext, points, x, y) : drawRoundedPolygon(context.camera ? context : context.nativeContext, points, x, y, cornerRadius, closePath), closePath && context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(polygon, polygon.attribute, polygonAttribute), this.beforeRenderStep(polygon, context, x, y, doFill, doStroke, fVisible, sVisible, polygonAttribute, drawContext, fillCb, strokeCb), doFill && (fillCb ? fillCb(context, polygon.attribute, polygonAttribute) : fVisible && (context.setCommonStyle(polygon, polygon.attribute, originX - x, originY - y, polygonAttribute), context.fill())), doStroke && (strokeCb ? strokeCb(context, polygon.attribute, polygonAttribute) : sVisible && (context.setStrokeStyle(polygon, polygon.attribute, originX - x, originY - y, polygonAttribute), context.stroke())), this.afterRenderStep(polygon, context, x, y, doFill, doStroke, fVisible, sVisible, polygonAttribute, drawContext, fillCb, strokeCb);
  }
  draw(polygon, renderService, drawContext, params2) {
    const polygonAttribute = getTheme(polygon, null == params2 ? void 0 : params2.theme).polygon;
    this._draw(polygon, polygonAttribute, false, drawContext, params2);
  }
};
DefaultCanvasPolygonRender = __decorate19([injectable(), __param12(0, inject(ContributionProvider)), __param12(0, named(PolygonRenderContribution)), __metadata14("design:paramtypes", [Object])], DefaultCanvasPolygonRender);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/image-render
var __decorate20 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata15 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param13 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var repeatStr = ["", "repeat-x", "repeat-y", "repeat"];
var DefaultCanvasImageRender = class extends BaseRender {
  constructor(imageRenderContribitions) {
    super(), this.imageRenderContribitions = imageRenderContribitions, this.numberType = IMAGE_NUMBER_TYPE, this.builtinContributions = [defaultImageRenderContribution, defaultImageBackgroundRenderContribution], this.init(imageRenderContribitions);
  }
  drawShape(image, context, x, y, drawContext, params2, fillCb, strokeCb) {
    const imageAttribute = getTheme(image).image, { width = imageAttribute.width, height = imageAttribute.height, repeatX = imageAttribute.repeatX, repeatY = imageAttribute.repeatY, x: originX = imageAttribute.x, y: originY = imageAttribute.y, cornerRadius = imageAttribute.cornerRadius, image: url } = image.attribute, data = this.valid(image, imageAttribute, fillCb);
    if (!data)
      return;
    const { fVisible, sVisible, doFill, doStroke } = data;
    if (context.setShadowBlendStyle && context.setShadowBlendStyle(image, imageAttribute), this.beforeRenderStep(image, context, x, y, doFill, false, fVisible, false, imageAttribute, drawContext, fillCb), doFill) {
      if (fillCb)
        fillCb(context, image.attribute, imageAttribute);
      else if (fVisible) {
        if (!url || !image.resources)
          return;
        const res = image.resources.get(url);
        if ("success" !== res.state)
          return;
        let needRestore = false;
        0 === cornerRadius || isArray_default(cornerRadius) && cornerRadius.every((num) => 0 === num) || (context.beginPath(), createRectPath(context, x, y, width, height, cornerRadius), context.save(), context.clip(), needRestore = true), context.setCommonStyle(image, image.attribute, x, y, imageAttribute);
        let repeat = 0;
        if ("repeat" === repeatX && (repeat |= 1), "repeat" === repeatY && (repeat |= 2), repeat) {
          const pattern = context.createPattern(res.data, repeatStr[repeat]);
          context.fillStyle = pattern, context.translate(x, y, true), context.fillRect(0, 0, width, height), context.translate(-x, -y, true);
        } else
          context.drawImage(res.data, x, y, width, height);
        needRestore && context.restore();
      }
    }
    doStroke && (strokeCb ? strokeCb(context, image.attribute, imageAttribute) : sVisible && (context.setStrokeStyle(image, image.attribute, originX - x, originY - y, imageAttribute), context.stroke())), this.afterRenderStep(image, context, x, y, doFill, false, fVisible, false, imageAttribute, drawContext, fillCb);
  }
  draw(image, renderService, drawContext) {
    const { image: url } = image.attribute;
    if (!url || !image.resources)
      return;
    const res = image.resources.get(url);
    if ("loading" === res.state && isString_default(url))
      return void ResourceLoader.improveImageLoading(url);
    if ("success" !== res.state)
      return;
    const { context } = renderService.drawParams;
    if (!context)
      return;
    const imageAttribute = getTheme(image).image;
    this._draw(image, imageAttribute, false, drawContext);
  }
};
DefaultCanvasImageRender = __decorate20([injectable(), __param13(0, inject(ContributionProvider)), __param13(0, named(ImageRenderContribution)), __metadata15("design:paramtypes", [Object])], DefaultCanvasImageRender);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/symbol
var IncrementalDrawContribution = Symbol.for("IncrementalDrawContribution");
var ArcRender = Symbol.for("ArcRender");
var Arc3dRender = Symbol.for("Arc3dRender");
var AreaRender = Symbol.for("AreaRender");
var CircleRender = Symbol.for("CircleRender");
var GraphicRender = Symbol.for("GraphicRender");
var GroupRender = Symbol.for("GroupRender");
var LineRender = Symbol.for("LineRender");
var PathRender = Symbol.for("PathRender");
var PolygonRender = Symbol.for("PolygonRender");
var RectRender = Symbol.for("RectRender");
var Rect3DRender = Symbol.for("Rect3DRender");
var SymbolRender = Symbol.for("SymbolRender");
var TextRender = Symbol.for("TextRender");
var RichTextRender = Symbol.for("RichTextRender");
var Pyramid3dRender = Symbol.for("Pyramid3dRender");
var GlyphRender = Symbol.for("GlyphRender");
var ImageRender = Symbol.for("ImageRender");
var RenderSelector = Symbol.for("RenderSelector");
var DrawContribution = Symbol.for("DrawContribution");

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/draw-interceptor
var __decorate21 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata16 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var DrawItemInterceptor = Symbol.for("DrawItemInterceptor");
var tempDirtyBounds = new AABBBounds();
var ShadowRootDrawItemInterceptorContribution = class {
  constructor() {
    this.order = 1;
  }
  afterDrawItem(graphic, renderService, drawContext, drawContribution, params2) {
    return (graphic.attribute.shadowRootIdx > 0 || !graphic.attribute.shadowRootIdx) && this.drawItem(graphic, renderService, drawContext, drawContribution, params2), false;
  }
  beforeDrawItem(graphic, renderService, drawContext, drawContribution, params2) {
    return graphic.attribute.shadowRootIdx < 0 && this.drawItem(graphic, renderService, drawContext, drawContribution, params2), false;
  }
  drawItem(graphic, renderService, drawContext, drawContribution, params2) {
    if (!graphic.shadowRoot)
      return false;
    const { context } = drawContext;
    if (context.highPerformanceSave(), context.transformFromMatrix(graphic.transMatrix, true), drawContribution.dirtyBounds && drawContribution.backupDirtyBounds) {
      tempDirtyBounds.copy(drawContribution.dirtyBounds);
      const m4 = graphic.globalTransMatrix.getInverse();
      drawContribution.dirtyBounds.copy(drawContribution.backupDirtyBounds).transformWithMatrix(m4);
    }
    return drawContribution.renderGroup(graphic.shadowRoot, drawContext, graphic.parent.globalTransMatrix), context.highPerformanceRestore(), drawContribution.dirtyBounds && drawContribution.backupDirtyBounds && drawContribution.dirtyBounds.copy(tempDirtyBounds), true;
  }
};
var DebugDrawItemInterceptorContribution = class {
  constructor() {
    this.order = 1;
  }
  afterDrawItem(graphic, renderService, drawContext, drawContribution, params2) {
    return graphic.attribute._debug_bounds && this.drawItem(graphic, renderService, drawContext, drawContribution, params2), false;
  }
  drawItem(graphic, renderService, drawContext, drawContribution, params2) {
    if (!graphic.attribute._debug_bounds)
      return false;
    const { context } = drawContext;
    context.highPerformanceSave(), graphic.parent && context.setTransformFromMatrix(graphic.parent.globalTransMatrix, true), graphic.glyphHost && graphic.glyphHost.parent && context.setTransformFromMatrix(graphic.glyphHost.parent.globalTransMatrix, true);
    const b = graphic.AABBBounds;
    return true !== graphic.attribute._debug_bounds && graphic.attribute._debug_bounds(context, graphic), context.strokeRect(b.x1, b.y1, b.width(), b.height()), context.highPerformanceRestore(), true;
  }
};
var CommonDrawItemInterceptorContribution = class {
  constructor() {
    this.order = 1, this.interceptors = [new ShadowRootDrawItemInterceptorContribution(), new Canvas3DDrawItemInterceptor(), new InteractiveDrawItemInterceptorContribution(), new DebugDrawItemInterceptorContribution()];
  }
  afterDrawItem(graphic, renderService, drawContext, drawContribution, params2) {
    for (let i = 0; i < this.interceptors.length; i++)
      if (this.interceptors[i].afterDrawItem && this.interceptors[i].afterDrawItem(graphic, renderService, drawContext, drawContribution, params2))
        return true;
    return false;
  }
  beforeDrawItem(graphic, renderService, drawContext, drawContribution, params2) {
    if ((!graphic.in3dMode || drawContext.in3dInterceptor) && !graphic.shadowRoot && !(graphic.baseGraphic || graphic.attribute.globalZIndex || graphic.interactiveGraphic))
      return false;
    for (let i = 0; i < this.interceptors.length; i++)
      if (this.interceptors[i].beforeDrawItem && this.interceptors[i].beforeDrawItem(graphic, renderService, drawContext, drawContribution, params2))
        return true;
    return false;
  }
};
CommonDrawItemInterceptorContribution = __decorate21([injectable(), __metadata16("design:paramtypes", [])], CommonDrawItemInterceptorContribution);
var InteractiveDrawItemInterceptorContribution = class {
  constructor() {
    this.order = 1;
  }
  beforeDrawItem(graphic, renderService, drawContext, drawContribution, params2) {
    return !this.processing && (graphic.baseGraphic ? this.beforeDrawInteractive(graphic, renderService, drawContext, drawContribution, params2) : this.beforeSetInteractive(graphic, renderService, drawContext, drawContribution, params2));
  }
  beforeSetInteractive(graphic, renderService, drawContext, drawContribution, params2) {
    let interactiveGraphic = graphic.interactiveGraphic;
    if (graphic.attribute.globalZIndex) {
      interactiveGraphic || (interactiveGraphic = graphic.clone(), graphic.interactiveGraphic = interactiveGraphic, interactiveGraphic.baseGraphic = graphic), interactiveGraphic.setAttributes({
        globalZIndex: 0,
        zIndex: graphic.attribute.globalZIndex
      }, false, {
        skipUpdateCallback: true
      }), drawContext.stage.tryInitInteractiveLayer();
      const interactiveLayer = drawContext.stage.getLayer("_builtin_interactive");
      if (interactiveLayer) {
        this.getShadowRoot(interactiveLayer).add(interactiveGraphic);
      }
      return true;
    }
    if (interactiveGraphic) {
      drawContext.stage.tryInitInteractiveLayer();
      const interactiveLayer = drawContext.stage.getLayer("_builtin_interactive");
      if (interactiveLayer) {
        this.getShadowRoot(interactiveLayer).removeChild(interactiveGraphic);
      }
      graphic.interactiveGraphic = null, interactiveGraphic.baseGraphic = null;
    }
    return false;
  }
  beforeDrawInteractive(graphic, renderService, drawContext, drawContribution, params2) {
    const baseGraphic = graphic.baseGraphic;
    if (!baseGraphic.stage) {
      const interactiveLayer = drawContext.stage.getLayer("_builtin_interactive");
      if (interactiveLayer) {
        this.getShadowRoot(interactiveLayer).removeChild(graphic);
      }
      return true;
    }
    if (baseGraphic) {
      this.processing = true;
      const { context } = drawContext;
      return context.highPerformanceSave(), context.setTransformFromMatrix(baseGraphic.parent.globalTransMatrix, true), baseGraphic.isContainer ? drawContribution.renderGroup(baseGraphic, drawContext, baseGraphic.parent.globalTransMatrix) : drawContribution.renderItem(baseGraphic, drawContext), context.highPerformanceRestore(), this.processing = false, true;
    }
    return false;
  }
  getShadowRoot(interactiveLayer) {
    var _a;
    let group = interactiveLayer.getElementById("_interactive_group");
    return group || (group = graphicCreator.CreateGraphic("group", {}), group.id = "_interactive_group", interactiveLayer.add(group)), null !== (_a = group.shadowRoot) && void 0 !== _a ? _a : group.attachShadow();
  }
};
var Canvas3DDrawItemInterceptor = class {
  constructor() {
    this.order = 1;
  }
  beforeDrawItem(graphic, renderService, drawContext, drawContribution, params2) {
    if (!graphic.in3dMode || drawContext.in3dInterceptor)
      return false;
    drawContext.in3dInterceptor = true;
    const { context, stage } = renderService.drawParams;
    context.canvas;
    context.save(), this.initCanvasCtx(context), context.camera = stage.camera;
    const m4 = context.currentMatrix;
    m4.a /= context.dpr, m4.b /= context.dpr, m4.c /= context.dpr, m4.d /= context.dpr, m4.e /= context.dpr, m4.f /= context.dpr;
    const matrix = mat4Allocate.allocate();
    mat3Tomat4(matrix, m4);
    const lastModelMatrix = context.modelMatrix;
    if (lastModelMatrix) {
      if (matrix) {
        const m5 = mat4Allocate.allocate();
        context.modelMatrix = multiplyMat4Mat4(m5, lastModelMatrix, matrix);
      }
    } else
      context.modelMatrix = matrix;
    if (context.setTransform(1, 0, 0, 1, 0, 0, true), graphic.isContainer) {
      let isPie = false, is3d = false;
      if (graphic.forEachChildren((c3) => (isPie = c3.numberType === ARC3D_NUMBER_TYPE, !isPie)), graphic.forEachChildren((c3) => (is3d = !!c3.findFace, !is3d)), isPie) {
        const children = graphic.getChildren(), sortedChildren = [...children];
        sortedChildren.sort((a3, b) => {
          var _a, _b, _c, _d;
          let angle1 = ((null !== (_a = a3.attribute.startAngle) && void 0 !== _a ? _a : 0) + (null !== (_b = a3.attribute.endAngle) && void 0 !== _b ? _b : 0)) / 2, angle2 = ((null !== (_c = b.attribute.startAngle) && void 0 !== _c ? _c : 0) + (null !== (_d = b.attribute.endAngle) && void 0 !== _d ? _d : 0)) / 2;
          for (; angle1 < 0; )
            angle1 += pi2;
          for (; angle2 < 0; )
            angle2 += pi2;
          return angle2 - angle1;
        }), sortedChildren.forEach((c3) => {
          c3._next = null, c3._prev = null;
        }), graphic.removeAllChild(), graphic.update(), sortedChildren.forEach((c3) => {
          graphic.appendChild(c3);
        });
        const m5 = graphic.parent.globalTransMatrix;
        drawContext.hack_pieFace = "outside", drawContribution.renderGroup(graphic, drawContext, m5), drawContext.hack_pieFace = "inside", drawContribution.renderGroup(graphic, drawContext, m5), drawContext.hack_pieFace = "top", drawContribution.renderGroup(graphic, drawContext, m5), graphic.removeAllChild(), children.forEach((c3) => {
          c3._next = null, c3._prev = null;
        }), children.forEach((c3) => {
          graphic.appendChild(c3);
        });
      } else if (is3d) {
        const children = graphic.getChildren(), zChildren = children.map((g) => ({
          ave_z: g.findFace().vertices.map((v) => {
            var _a;
            return context.view(v[0], v[1], null !== (_a = v[2] + g.attribute.z) && void 0 !== _a ? _a : 0)[2];
          }).reduce((a3, b) => a3 + b, 0),
          g
        }));
        zChildren.sort((a3, b) => b.ave_z - a3.ave_z), graphic.removeAllChild(), zChildren.forEach((i) => {
          i.g._next = null, i.g._prev = null;
        }), graphic.update(), zChildren.forEach((i) => {
          graphic.add(i.g);
        }), drawContribution.renderGroup(graphic, drawContext, graphic.parent.globalTransMatrix, true), graphic.removeAllChild(), children.forEach((g) => {
          g._next = null, g._prev = null;
        }), graphic.update(), children.forEach((g) => {
          graphic.add(g);
        });
      } else
        drawContribution.renderGroup(graphic, drawContext, graphic.parent.globalTransMatrix);
    } else
      drawContribution.renderItem(graphic, drawContext);
    return context.camera = null, context.restore(), context.modelMatrix !== lastModelMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastModelMatrix, drawContext.in3dInterceptor = false, true;
  }
  initCanvasCtx(context) {
    context.setTransformForCurrent();
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/render-service
var __decorate22 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata17 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param14 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var RenderService = Symbol.for("RenderService");
var BeforeRenderConstribution = Symbol.for("BeforeRenderConstribution");
var DefaultRenderService = class {
  constructor(drawContribution) {
    this.drawContribution = drawContribution;
  }
  prepare(updateBounds) {
    updateBounds && this.renderTreeRoots.forEach((g) => {
      this._prepare(g, updateBounds);
    });
  }
  _prepare(g, updateBounds) {
    g.forEachChildren((g2) => {
      this._prepare(g2, updateBounds);
    }), g.update({
      bounds: updateBounds,
      trans: true
    });
  }
  prepareRenderList() {
  }
  beforeDraw(params2) {
  }
  draw(params2) {
    this.drawContribution.draw(this, Object.assign({}, this.drawParams));
  }
  afterDraw(params2) {
    this.drawContribution.afterDraw && this.drawContribution.afterDraw(this, Object.assign({}, this.drawParams));
  }
  render(groups2, params2) {
    this.renderTreeRoots = groups2, this.drawParams = params2;
    const updateBounds = params2.updateBounds;
    this.prepare(updateBounds), this.prepareRenderList(), this.beforeDraw(params2), this.draw(params2), this.afterDraw(params2), this.drawParams = null;
  }
};
DefaultRenderService = __decorate22([injectable(), __param14(0, inject(DrawContribution)), __metadata17("design:paramtypes", [Object])], DefaultRenderService);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/render-modules
var render_modules_default = new ContainerModule((bind) => {
  bind(RenderService).to(DefaultRenderService);
});

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/picker/constants
var GraphicPicker = Symbol.for("GraphicPicker");
var PickerService = Symbol.for("PickerService");
var BoundsPicker = Symbol.for("BoundsPicker");
var GlobalPickerService = Symbol.for("GlobalPickerService");

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/picker/pick-interceptor
var __decorate23 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var PickItemInterceptor = Symbol.for("PickItemInterceptor");
var ShadowRootPickItemInterceptorContribution = class {
  constructor() {
    this.order = 1;
  }
  afterPickItem(graphic, pickerService, point5, pickParams, params2) {
    return graphic.attribute.shadowRootIdx > 0 || !graphic.attribute.shadowRootIdx ? this._pickItem(graphic, pickerService, point5, pickParams, params2) : null;
  }
  beforePickItem(graphic, pickerService, point5, pickParams, params2) {
    return graphic.attribute.shadowRootIdx < 0 ? this._pickItem(graphic, pickerService, point5, pickParams, params2) : null;
  }
  _pickItem(graphic, pickerService, point5, pickParams, params2) {
    if (!graphic.shadowRoot)
      return null;
    const { parentMatrix } = params2 || {};
    if (!parentMatrix)
      return null;
    const context = pickerService.pickContext;
    context.highPerformanceSave();
    const g = graphic.shadowRoot, currentGroupMatrix = matrixAllocate.allocateByObj(parentMatrix), newPoint = new Point(currentGroupMatrix.a * point5.x + currentGroupMatrix.c * point5.y + currentGroupMatrix.e, currentGroupMatrix.b * point5.x + currentGroupMatrix.d * point5.y + currentGroupMatrix.f), result2 = pickerService.pickGroup(g, newPoint, currentGroupMatrix, pickParams);
    return context.highPerformanceRestore(), result2;
  }
};
ShadowRootPickItemInterceptorContribution = __decorate23([injectable()], ShadowRootPickItemInterceptorContribution);
var InteractivePickItemInterceptorContribution = class {
  constructor() {
    this.order = 1;
  }
  beforePickItem(graphic, pickerService, point5, pickParams, params2) {
    const originGraphic = graphic.baseGraphic;
    if (originGraphic && originGraphic.parent) {
      const newPoint = new Point(point5.x, point5.y), context = pickerService.pickContext;
      context.highPerformanceSave();
      const parentMatrix = originGraphic.parent.globalTransMatrix;
      parentMatrix.transformPoint(newPoint, newPoint);
      const result2 = originGraphic.isContainer ? pickerService.pickGroup(originGraphic, newPoint.clone(), parentMatrix, pickParams) : pickerService.pickItem(originGraphic, newPoint.clone(), parentMatrix, pickParams);
      return context.highPerformanceRestore(), result2;
    }
    return null;
  }
};
InteractivePickItemInterceptorContribution = __decorate23([injectable()], InteractivePickItemInterceptorContribution);
var Canvas3DPickItemInterceptor = class {
  constructor() {
    this.order = 1;
  }
  beforePickItem(graphic, pickerService, point5, pickParams, params2) {
    if (!graphic.in3dMode || pickParams.in3dInterceptor)
      return null;
    const context = pickerService.pickContext, stage = graphic.stage;
    if (!context || !stage)
      return null;
    if (pickParams.in3dInterceptor = true, context.save(), this.initCanvasCtx(context), context.camera = stage.camera, graphic.isContainer) {
      let result2, isPie = false, is3d = false;
      if (graphic.forEachChildren((c3) => (isPie = c3.numberType === ARC3D_NUMBER_TYPE, !isPie)), graphic.forEachChildren((c3) => (is3d = !!c3.findFace, !is3d)), isPie) {
        const children = graphic.getChildren(), sortedChildren = [...children];
        sortedChildren.sort((a3, b) => {
          var _a, _b, _c, _d;
          let angle1 = (null !== (_b = null !== (_a = a3.attribute.startAngle) && void 0 !== _a ? _a : 0 + a3.attribute.endAngle) && void 0 !== _b ? _b : 0) / 2, angle2 = (null !== (_d = null !== (_c = b.attribute.startAngle) && void 0 !== _c ? _c : 0 + b.attribute.endAngle) && void 0 !== _d ? _d : 0) / 2;
          for (; angle1 < 0; )
            angle1 += pi2;
          for (; angle2 < 0; )
            angle2 += pi2;
          return angle2 - angle1;
        }), sortedChildren.forEach((c3) => {
          c3._next = null, c3._prev = null;
        }), graphic.removeAllChild(), graphic.update(), sortedChildren.forEach((c3) => {
          graphic.appendChild(c3);
        }), pickParams.hack_pieFace = "outside", result2 = pickerService.pickGroup(graphic, point5, params2.parentMatrix, pickParams), result2.graphic || (pickParams.hack_pieFace = "inside", result2 = pickerService.pickGroup(graphic, point5, params2.parentMatrix, pickParams)), result2.graphic || (pickParams.hack_pieFace = "top", result2 = pickerService.pickGroup(graphic, point5, params2.parentMatrix, pickParams)), graphic.removeAllChild(), children.forEach((c3) => {
          c3._next = null, c3._prev = null;
        }), children.forEach((c3) => {
          graphic.appendChild(c3);
        });
      } else if (is3d) {
        const children = graphic.getChildren(), zChildren = children.map((g) => ({
          ave_z: g.findFace().vertices.map((v) => {
            var _a;
            return context.view(v[0], v[1], null !== (_a = v[2] + g.attribute.z) && void 0 !== _a ? _a : 0)[2];
          }).reduce((a3, b) => a3 + b, 0),
          g
        }));
        zChildren.sort((a3, b) => b.ave_z - a3.ave_z), graphic.removeAllChild(), zChildren.forEach((i) => {
          i.g._next = null, i.g._prev = null;
        }), graphic.update(), zChildren.forEach((i) => {
          graphic.add(i.g);
        }), result2 = pickerService.pickGroup(graphic, point5, params2.parentMatrix, pickParams), graphic.removeAllChild(), children.forEach((g) => {
          g._next = null, g._prev = null;
        }), graphic.update(), children.forEach((g) => {
          graphic.add(g);
        });
      } else
        result2 = pickerService.pickGroup(graphic, point5, params2.parentMatrix, pickParams);
      return context.camera = null, pickParams.in3dInterceptor = false, context.restore(), result2;
    }
    return context.restore(), null;
  }
  initCanvasCtx(context) {
    context.setTransformForCurrent();
  }
};
Canvas3DPickItemInterceptor = __decorate23([injectable()], Canvas3DPickItemInterceptor);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/picker/pick-modules
var pick_modules_default = new ContainerModule((bind, unbind, isBound) => {
  isBound(PickerService) || (bind(GlobalPickerService).toSelf(), bind(PickerService).toService(GlobalPickerService)), bind(Canvas3DPickItemInterceptor).toSelf().inSingletonScope(), bind(PickItemInterceptor).toService(Canvas3DPickItemInterceptor), bind(ShadowRootPickItemInterceptorContribution).toSelf().inSingletonScope(), bind(PickItemInterceptor).toService(ShadowRootPickItemInterceptorContribution), bind(InteractivePickItemInterceptorContribution).toSelf().inSingletonScope(), bind(PickItemInterceptor).toService(InteractivePickItemInterceptorContribution), bindContributionProvider(bind, PickItemInterceptor);
});

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/graphic/graphic-service/graphic-module
var graphic_module_default = new ContainerModule((bind) => {
  bind(GraphicService).to(DefaultGraphicService).inSingletonScope(), bind(GraphicCreator).toConstantValue(graphicCreator);
});

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/plugins/constants
var AutoEnablePlugins = Symbol.for("AutoEnablePlugins");
var PluginService = Symbol.for("PluginService");

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/plugins/plugin-service
var __decorate24 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata18 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param15 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultPluginService = class {
  constructor(autoEnablePlugins) {
    this.autoEnablePlugins = autoEnablePlugins, this.onStartupFinishedPlugin = [], this.onRegisterPlugin = [], this.actived = false;
  }
  active(stage, params2) {
    this.stage = stage, this.actived = true;
    const { pluginList } = params2;
    pluginList && container.isBound(AutoEnablePlugins) && this.autoEnablePlugins.getContributions().forEach((p) => {
      pluginList.includes(p.name) && this.register(p);
    });
  }
  findPluginsByName(name) {
    const arr = [];
    return this.onStartupFinishedPlugin.forEach((plugin) => {
      plugin.name === name && arr.push(plugin);
    }), this.onRegisterPlugin.forEach((plugin) => {
      plugin.name === name && arr.push(plugin);
    }), arr;
  }
  register(plugin) {
    "onStartupFinished" === plugin.activeEvent ? this.onStartupFinishedPlugin.push(plugin) : "onRegister" === plugin.activeEvent && (this.onRegisterPlugin.push(plugin), plugin.activate(this));
  }
  unRegister(plugin) {
    "onStartupFinished" === plugin.activeEvent ? this.onStartupFinishedPlugin.splice(this.onStartupFinishedPlugin.indexOf(plugin), 1) : "onRegister" === plugin.activeEvent && this.onRegisterPlugin.splice(this.onStartupFinishedPlugin.indexOf(plugin), 1), plugin.deactivate(this);
  }
  release(...params2) {
    this.onStartupFinishedPlugin.forEach((plugin) => {
      plugin.deactivate(this);
    }), this.onStartupFinishedPlugin = [], this.onRegisterPlugin.forEach((plugin) => {
      plugin.deactivate(this);
    }), this.onRegisterPlugin = [];
  }
};
DefaultPluginService = __decorate24([injectable(), __param15(0, inject(ContributionProvider)), __param15(0, named(AutoEnablePlugins)), __metadata18("design:paramtypes", [Object])], DefaultPluginService);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/plugins/plugin-modules
var plugin_modules_default = new ContainerModule((bind) => {
  bind(PluginService).to(DefaultPluginService), bindContributionProviderNoSingletonScope(bind, AutoEnablePlugins);
});

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/core/contributions/env/modules
var modules_default = new ContainerModule((bind) => {
  bindContributionProvider(bind, EnvContribution);
});

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/core/contributions/textMeasure/modules
var modules_default2 = new ContainerModule((bind) => {
  bind(TextMeasureContribution).to(DefaultTextMeasureContribution).inSingletonScope(), bindContributionProvider(bind, TextMeasureContribution);
});

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/core/contributions/layerHandler/canvas2d-contribution
var __decorate25 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata19 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var CanvasLayerHandlerContribution = class {
  constructor() {
    this.type = "static", this.offscreen = false, this.global = application.global;
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  init(layer, window2, params2) {
    if (this.layer = layer, this.window = window2, params2.main)
      this.main = true, this.context = window2.getContext(), this.canvas = this.context.getCanvas();
    else {
      let nativeCanvas;
      this.main = false, params2.canvasId && (nativeCanvas = this.global.getElementById(params2.canvasId)), nativeCanvas || (nativeCanvas = this.global.createCanvas({
        width: window2.width,
        height: window2.height
      })), nativeCanvas.style && (nativeCanvas.style["pointer-events"] = "none");
      const windowCanvas = window2.getContext().getCanvas().nativeCanvas, canvas = wrapCanvas({
        nativeCanvas,
        width: window2.width,
        height: window2.height,
        dpr: window2.dpr,
        id: params2.canvasId,
        canvasControled: true,
        container: window2.getContainer(),
        x: windowCanvas.offsetLeft,
        y: windowCanvas.offsetTop
      });
      canvas.applyPosition(), this.canvas = canvas, this.context = canvas.getContext();
    }
  }
  resize(w, h) {
    this.canvas.resize(w, h);
  }
  resizeView(w, h) {
  }
  render(group, params2, userParams) {
    var _a;
    if (!this.main) {
      const windowCanvas = this.window.getContext().getCanvas().nativeCanvas;
      !windowCanvas || this.canvas.x === windowCanvas.offsetLeft && this.canvas.y === windowCanvas.offsetTop || (this.canvas.x = windowCanvas.offsetLeft, this.canvas.y = windowCanvas.offsetTop, this.canvas.applyPosition());
    }
    params2.renderService.render(group, Object.assign(Object.assign({
      context: this.context,
      clear: null !== (_a = params2.background) && void 0 !== _a ? _a : "#ffffff"
    }, params2), userParams));
  }
  merge(layerHandlers) {
    layerHandlers.forEach((l) => {
      const canvas = l.getContext().canvas.nativeCanvas;
      this.context.drawImage(canvas, 0, 0);
    });
  }
  prepare(dirtyBounds, params2) {
  }
  drawTo(target, group, params2) {
    var _a;
    const context = target.getContext();
    params2.renderService.render(group, Object.assign(Object.assign({
      context
    }, params2), {
      clear: params2.clear ? null !== (_a = params2.background) && void 0 !== _a ? _a : "#fff" : void 0
    }));
  }
  getContext() {
    return this.context;
  }
  release() {
    this.canvas.release();
  }
};
CanvasLayerHandlerContribution = __decorate25([injectable(), __metadata19("design:paramtypes", [])], CanvasLayerHandlerContribution);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/core/contributions/layerHandler/empty-contribution
var __decorate26 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata20 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var EmptyLayerHandlerContribution = class {
  constructor() {
    this.offscreen = false, this.type = "virtual", this.global = application.global;
  }
  setDpr(dpr) {
  }
  init(layer, window2, params2) {
    if (this.layer = layer, this.window = window2, params2.main)
      throw new Error("virtual layer\u4E0D\u80FD\u4F5C\u4E3Amain layer");
    this.main = false, this.canvas = null, this.context = null;
  }
  resize(w, h) {
  }
  resizeView(w, h) {
  }
  render(group, params2, userParams) {
    this.mainHandler.render(group, params2, Object.assign(Object.assign({}, userParams), {
      clear: false
    }));
  }
  merge(layerHandlers) {
  }
  prepare(dirtyBounds, params2) {
  }
  drawTo(target, group, params2) {
    var _a;
    const context = target.getContext();
    params2.renderService.render(group, Object.assign(Object.assign({
      context
    }, params2), {
      clear: params2.clear ? null !== (_a = params2.background) && void 0 !== _a ? _a : "#fff" : void 0
    }));
  }
  getContext() {
    return null;
  }
  release() {
  }
};
EmptyLayerHandlerContribution = __decorate26([injectable(), __metadata20("design:paramtypes", [])], EmptyLayerHandlerContribution);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/core/contributions/layerHandler/offscreen2d-contribution
var __decorate27 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata21 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var OffscreenLayerHandlerContribution = class {
  constructor() {
    this.offscreen = true, this.type = "dynamic", this.global = application.global;
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  init(layer, window2, params2) {
    this.layer = layer;
    const nativeCanvas = this.global.createOffscreenCanvas({
      width: params2.width,
      height: params2.height,
      dpr: window2.dpr
    }), canvas = wrapCanvas({
      nativeCanvas,
      width: params2.width,
      height: params2.height,
      dpr: window2.dpr,
      canvasControled: true
    });
    this.canvas = canvas, this.context = canvas.getContext();
  }
  resize(w, h) {
    this.canvas.resize(w, h);
  }
  resizeView(w, h) {
    this.canvas.resize(w, h);
  }
  render(group, params2) {
    var _a;
    params2.renderService.render(group, Object.assign(Object.assign({
      context: this.context,
      viewBox: params2.stage.window.getViewBox(),
      transMatrix: params2.stage.window.getViewBoxTransform()
    }, params2), {
      clear: null !== (_a = params2.background) && void 0 !== _a ? _a : "#ffffff"
    }));
  }
  prepare(dirtyBounds, params2) {
  }
  release() {
    this.canvas.release();
  }
  getContext() {
    return this.context;
  }
  drawTo(target, group, params2) {
    const context = target.getContext(), targetDpr = target.dpr, { viewBox } = params2, x = viewBox.x1, y = viewBox.y1, width = viewBox.width(), height = viewBox.height();
    context.nativeContext.save(), context.nativeContext.setTransform(targetDpr, 0, 0, targetDpr, 0, 0), params2.clear && context.clearRect(x, y, width, height), context.drawImage(this.canvas.nativeCanvas, 0, 0, this.canvas.width, this.canvas.height, x, y, width, height), context.nativeContext.restore();
  }
  merge(layerHandlers) {
  }
};
OffscreenLayerHandlerContribution = __decorate27([injectable(), __metadata21("design:paramtypes", [])], OffscreenLayerHandlerContribution);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/core/contributions/layerHandler/modules
var modules_default3 = new ContainerModule((bind) => {
  bind(CanvasLayerHandlerContribution).toSelf(), bind(OffscreenLayerHandlerContribution).toSelf(), bind(EmptyLayerHandlerContribution).toSelf(), bind(StaticLayerHandlerContribution).toService(CanvasLayerHandlerContribution), bind(DynamicLayerHandlerContribution).toService(OffscreenLayerHandlerContribution), bind(VirtualLayerHandlerContribution).toService(EmptyLayerHandlerContribution);
});

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/core/contributions/modules
function load(container2) {
  container2.load(modules_default), container2.load(modules_default2), container2.load(modules_default3);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/sort
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function foreach(graphic, defaultZIndex, cb, reverse = false, sort3d = false) {
  const childMap = {}, zIdxArray = [];
  let needSort = false;
  if (sort3d)
    needSort = true;
  else {
    let lastZIndex;
    graphic.forEachChildren((item, i) => {
      const { zIndex = defaultZIndex } = item.attribute;
      if (0 === i)
        lastZIndex = zIndex;
      else if (lastZIndex !== zIndex)
        return needSort = true, true;
      return false;
    }, reverse);
  }
  if (needSort) {
    graphic.forEachChildren((item) => {
      const { zIndex = defaultZIndex } = item.attribute;
      childMap[zIndex] ? childMap[zIndex].push(item) : (childMap[zIndex] = [item], zIdxArray.push(zIndex));
    }, reverse), zIdxArray.sort((a3, b) => reverse ? b - a3 : a3 - b);
    let skip = false;
    for (let i = 0; i < zIdxArray.length && !skip; i++) {
      const idx = zIdxArray[i], children = childMap[idx];
      sort3d && children.sort((a3, b) => {
        var _a, _b;
        return (reverse ? -1 : 1) * ((null !== (_a = b.attribute.z) && void 0 !== _a ? _a : 0) - (null !== (_b = a3.attribute.z) && void 0 !== _b ? _b : 0));
      });
      for (let i2 = 0; i2 < children.length; i2++)
        if (cb(children[i2], i2)) {
          skip = true;
          break;
        }
    }
  } else
    graphic.forEachChildren(cb, reverse);
}
function foreachAsync(graphic, defaultZIndex, cb, reverse = false) {
  return __awaiter3(this, void 0, void 0, function* () {
    yield graphic.forEachChildrenAsync(cb, reverse);
  });
}
function findNextGraphic(graphic, id2, defaultZIndex, reverse = false) {
  const childMap = {}, zIdxArray = [];
  let needSort = false;
  graphic.forEachChildren((item, i) => {
    const { zIndex = defaultZIndex } = item.attribute;
    if (0 === i)
      ;
    else if (void 0 !== zIndex)
      return needSort = true, true;
    return false;
  }, reverse);
  let result2 = null, next = false;
  if (needSort) {
    graphic.forEachChildren((item) => {
      const { zIndex = defaultZIndex } = item.attribute;
      childMap[zIndex] ? childMap[zIndex].push(item) : (childMap[zIndex] = [item], zIdxArray.push(zIndex));
    }, reverse), zIdxArray.sort((a3, b) => reverse ? b - a3 : a3 - b);
    let skip = false;
    for (let i = 0; i < zIdxArray.length && !skip; i++) {
      const idx = zIdxArray[i], children = childMap[idx];
      for (let i2 = 0; i2 < children.length; i2++) {
        if (next) {
          skip = true, result2 = children[i2];
          break;
        }
        children[i2]._uid !== id2 || (next = true);
      }
    }
  } else
    graphic.forEachChildren((item) => next ? (result2 = item, true) : (item._uid === id2 && (next = true), false), reverse);
  return result2;
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/draw-contribution
var __decorate28 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata22 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param16 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultDrawContribution = class {
  constructor(contributions, drawItemInterceptorContributions) {
    this.contributions = contributions, this.drawItemInterceptorContributions = drawItemInterceptorContributions, this.currentRenderMap = /* @__PURE__ */ new Map(), this.defaultRenderMap = /* @__PURE__ */ new Map(), this.styleRenderMap = /* @__PURE__ */ new Map(), this.dirtyBounds = new Bounds(), this.backupDirtyBounds = new Bounds(), this.global = application.global, this.layerService = application.layerService, this.init();
  }
  init() {
    this.contributions.forEach((item) => {
      if (item.style) {
        const map4 = this.styleRenderMap.get(item.style) || /* @__PURE__ */ new Map();
        map4.set(item.numberType, item), this.styleRenderMap.set(item.style, map4);
      } else
        this.defaultRenderMap.set(item.numberType, item);
    }), this.InterceptorContributions = this.drawItemInterceptorContributions.getContributions().sort((a3, b) => a3.order - b.order);
  }
  prepareForDraw(renderService, drawContext) {
    drawContext.updateBounds ? this.useDirtyBounds = true : this.useDirtyBounds = !drawContext.stage.params.optimize.disableCheckGraphicWidthOutRange;
  }
  draw(renderService, drawContext) {
    this.prepareForDraw(renderService, drawContext), drawContext.drawContribution = this, this.currentRenderMap = this.styleRenderMap.get(drawContext.renderStyle) || this.defaultRenderMap, this.currentRenderService = renderService;
    const { context, stage, viewBox, transMatrix } = drawContext;
    if (!context)
      return;
    const dirtyBounds = this.dirtyBounds.setValue(0, 0, viewBox.width(), viewBox.height());
    if (stage.dirtyBounds && !stage.dirtyBounds.empty()) {
      const b = getRectIntersect(dirtyBounds, stage.dirtyBounds, false);
      dirtyBounds.x1 = Math.floor(b.x1), dirtyBounds.y1 = Math.floor(b.y1), dirtyBounds.x2 = Math.ceil(b.x2), dirtyBounds.y2 = Math.ceil(b.y2);
    }
    const d = context.dpr % 1;
    (d || 0.5 !== d) && (dirtyBounds.x1 = Math.floor(dirtyBounds.x1 * context.dpr) / context.dpr, dirtyBounds.y1 = Math.floor(dirtyBounds.y1 * context.dpr) / context.dpr, dirtyBounds.x2 = Math.ceil(dirtyBounds.x2 * context.dpr) / context.dpr, dirtyBounds.y2 = Math.ceil(dirtyBounds.y2 * context.dpr) / context.dpr), this.backupDirtyBounds.copy(dirtyBounds), context.inuse = true, context.setClearMatrix(transMatrix.a, transMatrix.b, transMatrix.c, transMatrix.d, transMatrix.e, transMatrix.f), context.clearMatrix(), context.setTransformForCurrent(true), context.translate(viewBox.x1, viewBox.y1, true), context.beginPath(), context.rect(dirtyBounds.x1, dirtyBounds.y1, dirtyBounds.width(), dirtyBounds.height()), context.clip(), stage.camera && (this.dirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0), this.backupDirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0)), this.clearScreen(renderService, context, drawContext), context.save(), renderService.renderTreeRoots.sort((a3, b) => {
      var _a, _b;
      return (null !== (_a = a3.attribute.zIndex) && void 0 !== _a ? _a : DefaultAttribute.zIndex) - (null !== (_b = b.attribute.zIndex) && void 0 !== _b ? _b : DefaultAttribute.zIndex);
    }).forEach((group) => {
      group.isContainer ? this.renderGroup(group, drawContext, matrixAllocate.allocate(1, 0, 0, 1, 0, 0)) : this.renderItem(group, drawContext);
    }), context.restore(), context.setClearMatrix(1, 0, 0, 1, 0, 0), context.inuse = false, context.draw();
  }
  doRegister() {
    throw new Error("\u6682\u4E0D\u652F\u6301");
  }
  _findNextGraphic(group) {
    let parent = group.parent, id2 = group._uid;
    for (; parent; ) {
      const g = findNextGraphic(parent, id2, DefaultAttribute.zIndex);
      if (g)
        return g;
      id2 = parent._uid, parent = parent.parent;
    }
    return null;
  }
  renderGroup(group, drawContext, parentMatrix, skipSort) {
    if (drawContext.break || false === group.attribute.visibleAll)
      return;
    if (group.incremental && (null == drawContext.startAtId || drawContext.startAtId === group._uid))
      return drawContext.break = true, void this._increaseRender(group, drawContext);
    if (this.useDirtyBounds && !isRectIntersect(group.AABBBounds, this.dirtyBounds, false))
      return;
    let tempBounds3, nextM = parentMatrix;
    if (this.useDirtyBounds) {
      tempBounds3 = boundsAllocate.allocateByObj(this.dirtyBounds);
      const gm = group.transMatrix;
      nextM = matrixAllocate.allocateByObj(parentMatrix).multiply(gm.a, gm.b, gm.c, gm.d, gm.e, gm.f), this.dirtyBounds.copy(this.backupDirtyBounds).transformWithMatrix(nextM.getInverse());
    }
    this.renderItem(group, drawContext, {
      drawingCb: () => {
        var _a;
        skipSort ? group.forEachChildren((item) => {
          drawContext.break || (item.isContainer ? this.renderGroup(item, drawContext, nextM) : this.renderItem(item, drawContext));
        }) : foreach(group, DefaultAttribute.zIndex, (item) => {
          drawContext.break || (item.isContainer ? this.renderGroup(item, drawContext, nextM) : this.renderItem(item, drawContext));
        }, false, !!(null === (_a = drawContext.context) || void 0 === _a ? void 0 : _a.camera));
      }
    }), this.useDirtyBounds && (this.dirtyBounds.copy(tempBounds3), boundsAllocate.free(tempBounds3), matrixAllocate.free(nextM));
  }
  _increaseRender(group, drawContext) {
    const { layer, stage } = drawContext, { subLayers } = layer;
    let incrementalLayer = subLayers.get(group._uid);
    incrementalLayer || (incrementalLayer = {
      layer: this.layerService.createLayer(stage),
      zIndex: subLayers.size,
      group
    }, subLayers.set(group._uid, incrementalLayer));
    const incrementalContext = incrementalLayer.layer.getNativeHandler().getContext(), idc = incrementalLayer.drawContribution || container.get(IncrementalDrawContribution);
    idc.dirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0), idc.backupDirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0), idc.draw(this.currentRenderService, Object.assign(Object.assign({}, drawContext), {
      drawContribution: idc,
      clear: "transparent",
      layer: incrementalLayer.layer,
      context: incrementalContext,
      startAtId: group._uid,
      break: false
    })), incrementalLayer.drawContribution = idc;
    const nextGraphic = this._findNextGraphic(group);
    if (nextGraphic)
      if (nextGraphic.isContainer && nextGraphic.incremental)
        this._increaseRender(nextGraphic, drawContext);
      else {
        let afterLayer = subLayers.get(nextGraphic._uid);
        afterLayer || (afterLayer = {
          layer: this.layerService.createLayer(stage),
          zIndex: subLayers.size
        }, subLayers.set(nextGraphic._uid, afterLayer));
        const afterContext = afterLayer.layer.getNativeHandler().getContext();
        this.draw(this.currentRenderService, Object.assign(Object.assign({}, drawContext), {
          drawContribution: idc,
          clear: "transparent",
          layer: afterLayer.layer,
          context: afterContext,
          startAtId: nextGraphic._uid,
          break: false
        }));
      }
  }
  getRenderContribution(graphic) {
    let renderer;
    return renderer || (renderer = this.selectRenderByNumberType(graphic.numberType, graphic)), renderer || (renderer = this.selectRenderByType(graphic.type)), renderer;
  }
  renderItem(graphic, drawContext, params2) {
    if (this.InterceptorContributions.length)
      for (let i = 0; i < this.InterceptorContributions.length; i++) {
        const drawContribution = this.InterceptorContributions[i];
        if (drawContribution.beforeDrawItem && drawContribution.beforeDrawItem(graphic, this.currentRenderService, drawContext, this, params2))
          return;
      }
    const renderer = this.getRenderContribution(graphic);
    if (!renderer)
      return;
    let tempBounds3, retrans = false;
    if (graphic.parent) {
      const { scrollX = 0, scrollY = 0 } = graphic.parent.attribute;
      if (retrans = !(!scrollX && !scrollY), retrans) {
        tempBounds3 = this.dirtyBounds.clone();
        const m4 = graphic.globalTransMatrix.getInverse();
        this.dirtyBounds.copy(this.backupDirtyBounds).transformWithMatrix(m4), this.dirtyBounds.translate(-scrollX, -scrollY);
      }
    }
    if (this.useDirtyBounds && !graphic.isContainer && !isRectIntersect(graphic.AABBBounds, this.dirtyBounds, false))
      return void (retrans && this.dirtyBounds.copy(tempBounds3));
    const skipDraw = null != drawContext.startAtId && graphic._uid !== drawContext.startAtId;
    if (graphic._uid === drawContext.startAtId && (drawContext.startAtId = null), params2 && (params2.skipDraw = skipDraw), skipDraw ? graphic.isContainer && renderer.draw(graphic, this.currentRenderService, drawContext, params2) : renderer.draw(graphic, this.currentRenderService, drawContext, params2), retrans && this.dirtyBounds.copy(tempBounds3), this.InterceptorContributions.length)
      for (let i = 0; i < this.InterceptorContributions.length; i++) {
        const drawContribution = this.InterceptorContributions[i];
        if (drawContribution.afterDrawItem && drawContribution.afterDrawItem(graphic, this.currentRenderService, drawContext, this))
          return;
      }
  }
  selectRenderByType(type) {
    return Logger.getInstance().warn("\u672A\u77E5\u9519\u8BEF\uFF0C\u4E0D\u5E94\u8BE5\u8D70\u5230\u8FD9\u91CC"), null;
  }
  selectRenderByNumberType(type, graphic) {
    let data;
    if (graphic.attribute.renderStyle) {
      const currentRenderMap = this.styleRenderMap.get(graphic.attribute.renderStyle);
      data = currentRenderMap && currentRenderMap.get(type);
    }
    return data || this.currentRenderMap.get(type) || this.defaultRenderMap.get(type);
  }
  clearScreen(renderService, context, drawContext) {
    var _a, _b;
    const { clear, viewBox } = drawContext, width = viewBox.width(), height = viewBox.height();
    if (clear) {
      context.clearRect(0, 0, width, height);
      const stage = null === (_a = renderService.drawParams) || void 0 === _a ? void 0 : _a.stage;
      if (stage && (context.globalAlpha = null !== (_b = stage.attribute.opacity) && void 0 !== _b ? _b : 1), stage && stage.backgroundImg && stage.resources) {
        const res = stage.resources.get(clear);
        res && "success" === res.state && res.data && context.drawImage(res.data, 0, 0, width, height);
      } else
        context.fillStyle = createColor(context, clear, {
          AABBBounds: {
            x1: 0,
            y1: 0,
            x2: 0 + width,
            y2: 0 + height
          }
        }, 0, 0), context.fillRect(0, 0, width, height);
    }
  }
  afterDraw(renderService, drawParams) {
  }
};
DefaultDrawContribution = __decorate28([injectable(), __param16(0, multiInject(GraphicRender)), __param16(1, inject(ContributionProvider)), __param16(1, named(DrawItemInterceptor)), __metadata22("design:paramtypes", [Array, Object])], DefaultDrawContribution);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/group-render
var __decorate29 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata23 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param17 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasGroupRender = class {
  constructor(groupRenderContribitions) {
    this.groupRenderContribitions = groupRenderContribitions, this.numberType = GROUP_NUMBER_TYPE;
  }
  drawShape(group, context, x, y, drawContext, params2, fillCb, strokeCb) {
    const groupAttribute = getTheme(group, null == params2 ? void 0 : params2.theme).group, { fill = groupAttribute.fill, background, stroke: stroke2 = groupAttribute.stroke, opacity = groupAttribute.opacity, width = groupAttribute.width, height = groupAttribute.height, clip = groupAttribute.clip, fillOpacity = groupAttribute.fillOpacity, strokeOpacity = groupAttribute.strokeOpacity, cornerRadius = groupAttribute.cornerRadius, path = groupAttribute.path, lineWidth = groupAttribute.lineWidth, visible = groupAttribute.visible } = group.attribute, fVisible = rectFillVisible(opacity, fillOpacity, width, height, fill), sVisible = rectStrokeVisible(opacity, strokeOpacity, width, height), doFill = runFill(fill, background), doStroke = runStroke(stroke2, lineWidth);
    if (!group.valid || !visible)
      return;
    if (!clip) {
      if (!doFill && !doStroke)
        return;
      if (!(fVisible || sVisible || fillCb || strokeCb || background))
        return;
    }
    if (path && path.length && drawContext.drawContribution) {
      const disableFill = context.disableFill, disableStroke = context.disableStroke, disableBeginPath = context.disableBeginPath;
      context.disableFill = true, context.disableStroke = true, context.disableBeginPath = true, path.forEach((g) => {
        drawContext.drawContribution.getRenderContribution(g).draw(g, drawContext.renderService, drawContext, params2);
      }), context.disableFill = disableFill, context.disableStroke = disableStroke, context.disableBeginPath = disableBeginPath;
    } else
      0 === cornerRadius || isArray_default(cornerRadius) && cornerRadius.every((num) => 0 === num) ? (context.beginPath(), context.rect(x, y, width, height)) : (context.beginPath(), createRectPath(context, x, y, width, height, cornerRadius));
    this._groupRenderContribitions || (this._groupRenderContribitions = this.groupRenderContribitions.getContributions() || [], this._groupRenderContribitions.push(defaultGroupBackgroundRenderContribution));
    const doFillOrStroke = {
      doFill,
      doStroke
    };
    this._groupRenderContribitions.forEach((c3) => {
      c3.time === BaseRenderContributionTime.beforeFillStroke && c3.drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb, doFillOrStroke);
    }), clip && context.clip(), context.setShadowBlendStyle && context.setShadowBlendStyle(group, group.attribute, groupAttribute), doFillOrStroke.doFill && (fillCb ? fillCb(context, group.attribute, groupAttribute) : fVisible && (context.setCommonStyle(group, group.attribute, x, y, groupAttribute), context.fill())), doFillOrStroke.doStroke && (strokeCb ? strokeCb(context, group.attribute, groupAttribute) : sVisible && (context.setStrokeStyle(group, group.attribute, x, y, groupAttribute), context.stroke())), this._groupRenderContribitions.forEach((c3) => {
      c3.time === BaseRenderContributionTime.afterFillStroke && c3.drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb);
    });
  }
  draw(group, renderService, drawContext, params2) {
    const { context } = drawContext;
    if (!context)
      return;
    const { clip, baseOpacity = 1 } = group.attribute;
    clip ? context.save() : context.highPerformanceSave(), context.baseGlobalAlpha *= baseOpacity;
    const groupAttribute = getTheme(group, null == params2 ? void 0 : params2.theme).group, lastModelMatrix = context.modelMatrix;
    if (context.camera) {
      const nextModelMatrix = mat4Allocate.allocate(), modelMatrix = mat4Allocate.allocate();
      getModelMatrix(modelMatrix, group, groupAttribute), multiplyMat4Mat4(nextModelMatrix, lastModelMatrix || nextModelMatrix, modelMatrix), context.modelMatrix = nextModelMatrix, mat4Allocate.free(modelMatrix), context.setTransform(1, 0, 0, 1, 0, 0, true);
    } else
      context.transformFromMatrix(group.transMatrix, true);
    context.beginPath(), params2.skipDraw ? this.drawShape(group, context, 0, 0, drawContext, params2, () => false, () => false) : this.drawShape(group, context, 0, 0, drawContext);
    const { scrollX = groupAttribute.scrollX, scrollY = groupAttribute.scrollY } = group.attribute;
    let p;
    (scrollX || scrollY) && context.translate(scrollX, scrollY), params2 && params2.drawingCb && (p = params2.drawingCb()), context.modelMatrix !== lastModelMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastModelMatrix, context.baseGlobalAlpha /= baseOpacity, p && p.then ? p.then(() => {
      clip ? context.restore() : context.highPerformanceRestore();
    }) : clip ? context.restore() : context.highPerformanceRestore();
  }
};
DefaultCanvasGroupRender = __decorate29([injectable(), __param17(0, inject(ContributionProvider)), __param17(0, named(GroupRenderContribution)), __metadata23("design:paramtypes", [Object])], DefaultCanvasGroupRender);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/incremental-line-render
var __decorate30 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultIncrementalCanvasLineRender = class extends DefaultCanvasLineRender {
  constructor() {
    super(...arguments), this.numberType = LINE_NUMBER_TYPE;
  }
  drawShape(line2, context, x, y, drawContext, params2, fillCb, strokeCb) {
    if (line2.incremental && drawContext.multiGraphicOptions) {
      const { startAtIdx, length: length2 } = drawContext.multiGraphicOptions, { segments: segments2 = [] } = line2.attribute;
      if (startAtIdx > segments2.length)
        return;
      const lineAttribute = getTheme(line2).line, { fill = lineAttribute.fill, stroke: stroke2 = lineAttribute.stroke, opacity = lineAttribute.opacity, fillOpacity = lineAttribute.fillOpacity, strokeOpacity = lineAttribute.strokeOpacity, lineWidth = lineAttribute.lineWidth, visible = lineAttribute.visible } = line2.attribute, fVisible = fillVisible(opacity, fillOpacity, fill), sVisible = strokeVisible(opacity, strokeOpacity), doFill = runFill(fill), doStroke = runStroke(stroke2, lineWidth);
      if (!line2.valid || !visible)
        return;
      if (!doFill && !doStroke)
        return;
      if (!(fVisible || sVisible || fillCb || strokeCb))
        return;
      const { context: context2 } = drawContext;
      for (let i = startAtIdx; i < startAtIdx + length2; i++)
        this.drawIncreaseSegment(line2, context2, segments2[i - 1], segments2[i], line2.attribute.segments[i], [lineAttribute, line2.attribute], x, y);
    } else
      super.drawShape(line2, context, x, y, drawContext, params2, fillCb, strokeCb);
  }
  drawIncreaseSegment(line2, context, lastSeg, seg, attribute, defaultAttribute, offsetX, offsetY) {
    seg && (context.beginPath(), drawIncrementalSegments(context.nativeContext, lastSeg, seg, {
      offsetX,
      offsetY
    }), context.setShadowBlendStyle && context.setShadowBlendStyle(line2, attribute, defaultAttribute), context.setStrokeStyle(line2, attribute, offsetX, offsetY, defaultAttribute), context.stroke());
  }
};
DefaultIncrementalCanvasLineRender = __decorate30([injectable()], DefaultIncrementalCanvasLineRender);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/incremental-area-render
var __decorate31 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultIncrementalCanvasAreaRender = class extends DefaultCanvasAreaRender {
  constructor() {
    super(...arguments), this.numberType = AREA_NUMBER_TYPE;
  }
  drawShape(area2, context, x, y, drawContext, params2, fillCb) {
    if (area2.incremental && drawContext.multiGraphicOptions) {
      const { startAtIdx, length: length2 } = drawContext.multiGraphicOptions, { segments: segments2 = [] } = area2.attribute;
      if (startAtIdx > segments2.length)
        return;
      const areaAttribute = getTheme(area2).area, { fill = areaAttribute.fill, fillOpacity = areaAttribute.fillOpacity, opacity = areaAttribute.opacity, visible = areaAttribute.visible } = area2.attribute, fVisible = fillVisible(opacity, fillOpacity, fill), doFill = runFill(fill);
      if (!area2.valid || !visible)
        return;
      if (!doFill)
        return;
      if (!fVisible && !fillCb)
        return;
      for (let i = startAtIdx; i < startAtIdx + length2; i++)
        this.drawIncreaseSegment(area2, context, segments2[i - 1], segments2[i], area2.attribute.segments[i], [areaAttribute, area2.attribute], x, y);
    } else
      super.drawShape(area2, context, x, y, drawContext, params2, fillCb);
  }
  drawIncreaseSegment(area2, context, lastSeg, seg, attribute, defaultAttribute, offsetX, offsetY) {
    seg && (context.beginPath(), drawIncrementalAreaSegments(context.camera ? context : context.nativeContext, lastSeg, seg, {
      offsetX,
      offsetY
    }), context.setShadowBlendStyle && context.setShadowBlendStyle(area2, attribute, defaultAttribute), context.setCommonStyle(area2, attribute, offsetX, offsetY, defaultAttribute), context.fill());
  }
};
DefaultIncrementalCanvasAreaRender = __decorate31([injectable()], DefaultIncrementalCanvasAreaRender);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/incremental-draw-contribution
var STATUS2;
var __decorate32 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata24 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param18 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
!function(STATUS3) {
  STATUS3[STATUS3.NORMAL = 0] = "NORMAL", STATUS3[STATUS3.STOP = 1] = "STOP";
}(STATUS2 || (STATUS2 = {}));
var DefaultIncrementalDrawContribution = class extends DefaultDrawContribution {
  constructor(contributions, lineRender, areaRender, drawItemInterceptorContributions) {
    super(contributions, drawItemInterceptorContributions), this.contributions = contributions, this.lineRender = lineRender, this.areaRender = areaRender, this.drawItemInterceptorContributions = drawItemInterceptorContributions, this.rendering = false, this.currFrameStartAt = 0, this.currentIdx = 0, this.status = STATUS2.NORMAL, this.checkingForDrawPromise = null, this.hooks = {
      completeDraw: new SyncHook([])
    }, this.defaultRenderMap.set(this.lineRender.numberType, this.lineRender), this.defaultRenderMap.set(this.areaRender.numberType, this.areaRender);
  }
  draw(renderService, drawContext) {
    return __awaiter4(this, void 0, void 0, function* () {
      if (this.checkingForDrawPromise)
        return;
      this.lastRenderService = renderService, this.lastDrawContext = drawContext, this.checkingForDrawPromise = this.checkForDraw(drawContext);
      const skipDraw = yield this.checkingForDrawPromise;
      if (this.checkingForDrawPromise = null, skipDraw)
        return;
      this.currentRenderService = renderService;
      const { context, viewBox } = drawContext;
      context && (context.inuse = true, context.clearMatrix(), context.setTransformForCurrent(true), context.save(), drawContext.restartIncremental && this.clearScreen(this.currentRenderService, context, drawContext), context.translate(viewBox.x1, viewBox.y1, true), context.save(), renderService.renderTreeRoots.sort((a3, b) => {
        var _a, _b;
        return (null !== (_a = a3.attribute.zIndex) && void 0 !== _a ? _a : DefaultAttribute.zIndex) - (null !== (_b = b.attribute.zIndex) && void 0 !== _b ? _b : DefaultAttribute.zIndex);
      }).forEach((group) => {
        this.renderGroup(group, drawContext);
      }), this.hooks.completeDraw.tap("top-draw", () => {
        context.restore(), context.restore(), context.draw(), context.inuse = false, this.rendering = false;
      }));
    });
  }
  _increaseRender(group, drawContext) {
    return __awaiter4(this, void 0, void 0, function* () {
      this.rendering = true, yield this._renderIncrementalGroup(group, drawContext);
    });
  }
  _renderIncrementalGroup(group, drawContext) {
    return __awaiter4(this, void 0, void 0, function* () {
      this.count = group.count, yield new Promise((resolve) => {
        this.renderItem(group, drawContext, {
          drawingCb: () => __awaiter4(this, void 0, void 0, function* () {
            if (2 !== group.count)
              yield foreachAsync(group, DefaultAttribute.zIndex, (item, i) => {
                if (this.status === STATUS2.STOP)
                  return true;
                if (item.isContainer)
                  return false;
                if (i < this.currentIdx)
                  return false;
                const frameTail = this.currFrameStartAt + group.incremental;
                return i < frameTail && (this.currentIdx = i + 1, this.renderItem(item, drawContext)), i === frameTail - 1 && (this.currFrameStartAt = this.currentIdx, this.waitToNextFrame());
              }), resolve(false);
            else {
              const graphic = group.getChildAt(0);
              if (graphic.incremental && graphic.attribute.segments)
                for (graphic.incrementalAt || (graphic.incrementalAt = 0); graphic.incrementalAt < graphic.attribute.segments.length; )
                  drawContext.multiGraphicOptions = {
                    startAtIdx: graphic.incrementalAt,
                    length: graphic.incremental
                  }, this.renderItem(graphic, drawContext), graphic.incrementalAt += graphic.incremental, yield this.waitToNextFrame();
              else
                this.renderItem(graphic, drawContext);
              resolve(false);
            }
          })
        });
      }), this.hooks.completeDraw.call();
    });
  }
  waitToNextFrame() {
    return __awaiter4(this, void 0, void 0, function* () {
      return new Promise((resolve) => {
        this.global.getRequestAnimationFrame()(() => {
          resolve(false);
        });
      });
    });
  }
  checkForDraw(drawContext) {
    return __awaiter4(this, void 0, void 0, function* () {
      let skip = this.rendering;
      return drawContext.restartIncremental && (skip = false, yield this.forceStop(), this.resetToInit()), skip;
    });
  }
  forceStop() {
    return __awaiter4(this, void 0, void 0, function* () {
      this.rendering && (this.status = STATUS2.STOP, yield new Promise((resolve) => {
        this.hooks.completeDraw.tap("stopCb", () => {
          this.status = STATUS2.NORMAL, this.hooks.completeDraw.taps = this.hooks.completeDraw.taps.filter((item) => "stopCb" !== item.name), resolve(false);
        });
      }));
    });
  }
  resetToInit() {
    this.currFrameStartAt = 0, this.currentIdx = 0;
  }
  renderGroup(group, drawContext) {
    return __awaiter4(this, void 0, void 0, function* () {
      if (!drawContext.break && false !== group.attribute.visibleAll)
        return group.incremental && drawContext.startAtId === group._uid ? (yield this._increaseRender(group, drawContext), void (drawContext.break = true)) : void (yield new Promise((resolve) => {
          this.renderItem(group, drawContext, {
            drawingCb: () => __awaiter4(this, void 0, void 0, function* () {
              yield foreachAsync(group, DefaultAttribute.zIndex, (item) => __awaiter4(this, void 0, void 0, function* () {
                drawContext.break || item.isContainer && (yield this.renderGroup(item, drawContext));
              })), resolve(false);
            })
          });
        }));
    });
  }
};
DefaultIncrementalDrawContribution = __decorate32([injectable(), __param18(0, multiInject(GraphicRender)), __param18(1, inject(DefaultIncrementalCanvasLineRender)), __param18(2, inject(DefaultIncrementalCanvasAreaRender)), __param18(3, inject(ContributionProvider)), __param18(3, named(DrawItemInterceptor)), __metadata24("design:paramtypes", [Array, Object, Object, Object])], DefaultIncrementalDrawContribution);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/module
var module_default = new ContainerModule((bind) => {
  bind(DefaultBaseBackgroundRenderContribution).toSelf().inSingletonScope(), bind(DefaultBaseTextureRenderContribution).toSelf().inSingletonScope(), bind(DrawContribution).to(DefaultDrawContribution), bind(IncrementalDrawContribution).to(DefaultIncrementalDrawContribution), bind(GroupRender).to(DefaultCanvasGroupRender).inSingletonScope(), bind(GraphicRender).toService(GroupRender), bindContributionProvider(bind, GroupRenderContribution), bind(DefaultBaseInteractiveRenderContribution).toSelf().inSingletonScope(), bindContributionProvider(bind, InteractiveSubRenderContribution), bindContributionProvider(bind, GraphicRender), bind(CommonDrawItemInterceptorContribution).toSelf().inSingletonScope(), bind(DrawItemInterceptor).toService(CommonDrawItemInterceptorContribution), bindContributionProvider(bind, DrawItemInterceptor);
});

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/modules
function load2(container2) {
  container2.load(module_default);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/modules
function preLoadAllModule() {
  preLoadAllModule.__loaded || (preLoadAllModule.__loaded = true, container.load(core_modules_default), container.load(graphic_module_default), container.load(render_modules_default), container.load(pick_modules_default), container.load(plugin_modules_default), load(container), load2(container));
}
preLoadAllModule.__loaded = false, preLoadAllModule();
var vglobal = container.get(VGlobal);
application.global = vglobal;
var graphicUtil = container.get(GraphicUtil);
application.graphicUtil = graphicUtil;
var transformUtil = container.get(TransformUtil);
application.transformUtil = transformUtil;
var graphicService = container.get(GraphicService);
application.graphicService = graphicService;
var layerService = container.get(LayerService);
application.layerService = layerService;

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/plugins/builtin-plugin/auto-render-plugin
var AutoRenderPlugin = class {
  constructor() {
    this.name = "AutoRenderPlugin", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid;
  }
  activate(context) {
    this.pluginService = context, application.graphicService.hooks.onAttributeUpdate.tap(this.key, (graphic) => {
      graphic.glyphHost && (graphic = graphic.glyphHost), graphic.stage === context.stage && null != graphic.stage && graphic.stage.renderNextFrame();
    }), application.graphicService.hooks.onSetStage.tap(this.key, (graphic) => {
      graphic.glyphHost && (graphic = graphic.glyphHost), graphic.stage === context.stage && null != graphic.stage && graphic.stage.renderNextFrame();
    });
  }
  deactivate(context) {
    application.graphicService.hooks.onAttributeUpdate.taps = application.graphicService.hooks.onAttributeUpdate.taps.filter((item) => item.name !== this.key), application.graphicService.hooks.onSetStage.taps = application.graphicService.hooks.onSetStage.taps.filter((item) => item.name !== this.key);
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/plugins/builtin-plugin/3dview-transform-plugin
var ViewTransform3dPlugin = class {
  constructor() {
    this.name = "ViewTransform3dPlugin", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid, this.onMouseDown = (e) => {
      this.option3d || (this.option3d = this.pluginService.stage.option3d), this.option3d && (this.mousedown = true, this.pageX = e.page.x, this.pageY = e.page.y);
    }, this.onMouseUp = (e) => {
      this.option3d || (this.option3d = this.pluginService.stage.option3d), this.option3d && (this.mousedown = false);
    }, this.onMouseMove = (e) => {
      var _a, _b;
      const stage = this.pluginService.stage;
      if (this.option3d || (this.option3d = stage.option3d), this.option3d && this.mousedown)
        if (this.pageX && this.pageY) {
          const deltaX = e.page.x - this.pageX, deltaY = e.page.y - this.pageY;
          this.pageX = e.page.x, this.pageY = e.page.y;
          const angle1 = deltaX / 100, angle2 = deltaY / 100;
          this.option3d.alpha = (null !== (_a = this.option3d.alpha) && void 0 !== _a ? _a : 0) + angle1, this.option3d.beta = (null !== (_b = this.option3d.beta) && void 0 !== _b ? _b : 0) + angle2, stage.set3dOptions(this.option3d), stage.renderNextFrame();
        } else
          this.pageX = e.page.x, this.pageY = e.page.y;
    };
  }
  activate(context) {
    this.pluginService = context;
    const stage = context.stage;
    this.option3d = stage.option3d, stage.addEventListener("mousedown", this.onMouseDown), stage.addEventListener("mouseup", this.onMouseUp), stage.addEventListener("mousemove", this.onMouseMove);
  }
  deactivate(context) {
    const stage = context.stage;
    stage.removeEventListener("mousedown", this.onMouseDown), stage.removeEventListener("mouseup", this.onMouseUp), stage.removeEventListener("mousemove", this.onMouseMove);
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/plugins/builtin-plugin/incremental-auto-render-plugin
var IncrementalAutoRenderPlugin = class {
  constructor() {
    this.name = "IncrementalAutoRenderPlugin", this.activeEvent = "onRegister", this.nextFrameRenderGroupSet = /* @__PURE__ */ new Set(), this.willNextFrameRender = false, this.nextUserParams = {}, this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid;
  }
  activate(context) {
    this.pluginService = context, application.graphicService.hooks.onAddIncremental.tap(this.key, (graphic, group, stage) => {
      graphic.glyphHost && (graphic = graphic.glyphHost), graphic.stage === context.stage && null != graphic.stage && (this.nextUserParams.startAtId = group._uid, this.renderNextFrame(group));
    }), application.graphicService.hooks.onClearIncremental.tap(this.key, (group, stage) => {
      group.stage === context.stage && null != group.stage && (this.nextUserParams.startAtId = group._uid, this.nextUserParams.restartIncremental = true, this.renderNextFrame(group));
    });
  }
  deactivate(context) {
    application.graphicService.hooks.onAddIncremental.taps = application.graphicService.hooks.onAddIncremental.taps.filter((item) => item.name !== this.key), application.graphicService.hooks.onClearIncremental.taps = application.graphicService.hooks.onClearIncremental.taps.filter((item) => item.name !== this.key);
  }
  renderNextFrame(group) {
    this.nextFrameRenderGroupSet.add(group), this.willNextFrameRender || (this.willNextFrameRender = true, application.global.getRequestAnimationFrame()(() => {
      this._doRenderInThisFrame(), this.willNextFrameRender = false;
    }));
  }
  _doRenderInThisFrame() {
    const stage = this.pluginService.stage;
    this.nextFrameRenderGroupSet.size && (this.nextFrameRenderGroupSet.forEach((group) => {
      const layer = group.layer;
      if (!layer || !group.layer.subLayers)
        return;
      const subLayer = group.layer.subLayers.get(group._uid);
      subLayer && subLayer.drawContribution && subLayer.drawContribution.draw(stage.renderService, Object.assign({
        stage,
        layer,
        viewBox: stage.window.getViewBox(),
        transMatrix: stage.window.getViewBoxTransform(),
        clear: "transparent",
        renderService: stage.renderService,
        updateBounds: false,
        startAtId: group._uid,
        context: subLayer.layer.getNativeHandler().getContext()
      }, this.nextUserParams));
    }), this.nextUserParams = {}, this.nextFrameRenderGroupSet.clear());
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/plugins/builtin-plugin/html-attribute-plugin
var HtmlAttributePlugin = class {
  constructor() {
    this.name = "HtmlAttributePlugin", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid, this.htmlMap = {}, this.renderId = 0;
  }
  activate(context) {
    this.pluginService = context, context.stage.hooks.afterRender.tap(this.key, (stage) => {
      stage && stage === this.pluginService.stage && this.drawHTML(context.stage.renderService);
    });
  }
  deactivate(context) {
    context.stage.hooks.afterRender.taps = context.stage.hooks.afterRender.taps.filter((item) => item.name !== this.key), application.graphicService.hooks.onRemove.unTap(this.key), application.graphicService.hooks.onRelease.unTap(this.key), this.release();
  }
  getWrapContainer(stage, userContainer, domParams) {
    let nativeContainer;
    return nativeContainer = userContainer ? "string" == typeof userContainer ? application.global.getElementById(userContainer) : userContainer : stage.window.getContainer(), {
      wrapContainer: application.global.createDom(Object.assign({
        tagName: "div",
        parent: nativeContainer
      }, domParams)),
      nativeContainer
    };
  }
  parseDefaultStyleFromGraphic(graphic) {
    const attrs = "text" === graphic.type && graphic.attribute ? graphic.attribute : getTheme(graphic).text;
    return textAttributesToStyle(attrs);
  }
  getTransformOfText(graphic) {
    const textTheme = getTheme(graphic).text, { textAlign = textTheme.textAlign, textBaseline = textTheme.textBaseline } = graphic.attribute, cssAttrs = graphic.globalTransMatrix.toTransformAttrs(), { rotateDeg, scaleX, scaleY } = cssAttrs, translateMap = {
      left: "0",
      start: "0",
      end: "-100%",
      center: "-50%",
      right: "-100%",
      top: "0",
      middle: "-50%",
      bottom: "-100%",
      alphabetic: "-79%"
    }, originMap = {
      left: "0",
      start: "0",
      end: "100%",
      center: "50%",
      right: "100%",
      top: "0",
      middle: "50%",
      bottom: "100%",
      alphabetic: "79%"
    };
    return {
      textAlign,
      transform: `translate(${translateMap[textAlign]},${translateMap[textBaseline]}) rotate(${rotateDeg}deg) scaleX(${scaleX}) scaleY(${scaleY})`,
      transformOrigin: `${originMap[textAlign]} ${originMap[textBaseline]}`
    };
  }
  updateStyleOfWrapContainer(graphic, stage, wrapContainer, nativeContainer, options) {
    const { pointerEvents } = options;
    let calculateStyle = this.parseDefaultStyleFromGraphic(graphic);
    calculateStyle.display = false !== graphic.attribute.visible ? "block" : "none", calculateStyle.pointerEvents = true === pointerEvents ? "all" : pointerEvents || "none", wrapContainer.style.position || (wrapContainer.style.position = "absolute", nativeContainer.style.position = "relative");
    let left2 = 0, top = 0;
    const b = graphic.globalAABBBounds;
    let anchorType = options.anchorType;
    if (isNil_default(anchorType) && (anchorType = "text" === graphic.type ? "position" : "boundsLeftTop"), "boundsLeftTop" === anchorType && (anchorType = "top-left"), "position" === anchorType || b.empty()) {
      const matrix = graphic.globalTransMatrix;
      left2 = matrix.e, top = matrix.f;
    } else {
      const anchor = calculateAnchorOfBounds(b, anchorType);
      left2 = anchor.x, top = anchor.y;
    }
    const containerTL = application.global.getElementTopLeft(nativeContainer, false), windowTL = stage.window.getTopLeft(false), offsetX = left2 + windowTL.left - containerTL.left, offsetTop = top + windowTL.top - containerTL.top;
    if (calculateStyle.left = `${offsetX}px`, calculateStyle.top = `${offsetTop}px`, "text" === graphic.type && "position" === anchorType && (calculateStyle = Object.assign(Object.assign({}, calculateStyle), this.getTransformOfText(graphic))), isFunction_default(options.style)) {
      const userStyle = options.style({
        top: offsetTop,
        left: offsetX,
        width: b.width(),
        height: b.height()
      }, graphic, wrapContainer);
      userStyle && (calculateStyle = Object.assign(Object.assign({}, calculateStyle), userStyle));
    } else
      isObject_default(options.style) ? calculateStyle = Object.assign(Object.assign({}, calculateStyle), options.style) : isString_default(options.style) && options.style && (calculateStyle = Object.assign(Object.assign({}, calculateStyle), styleStringToObject(options.style)));
    application.global.updateDom(wrapContainer, {
      width: options.width,
      height: options.width,
      style: calculateStyle
    });
  }
  clearCacheContainer() {
    this.htmlMap && Object.keys(this.htmlMap).forEach((key) => {
      this.htmlMap[key] && this.htmlMap[key].renderId !== this.renderId && this.removeElement(key);
    }), this.renderId += 1;
  }
  drawHTML(renderService) {
    "browser" === application.global.env && (renderService.renderTreeRoots.sort((a3, b) => {
      var _a, _b;
      return (null !== (_a = a3.attribute.zIndex) && void 0 !== _a ? _a : DefaultAttribute.zIndex) - (null !== (_b = b.attribute.zIndex) && void 0 !== _b ? _b : DefaultAttribute.zIndex);
    }).forEach((group) => {
      this.renderGroupHTML(group);
    }), this.clearCacheContainer());
  }
  renderGroupHTML(group) {
    this.renderGraphicHTML(group), group.forEachChildren((g) => {
      g.isContainer ? this.renderGroupHTML(g) : this.renderGraphicHTML(g);
    });
  }
  removeElement(id2) {
    if (!this.htmlMap || !this.htmlMap[id2])
      return;
    const { wrapContainer } = this.htmlMap[id2];
    wrapContainer && application.global.removeDom(wrapContainer), this.htmlMap[id2] = null;
  }
  renderGraphicHTML(graphic) {
    var _a;
    const { html } = graphic.attribute;
    if (!html)
      return;
    const stage = graphic.stage;
    if (!stage)
      return;
    const { dom, container: container2 } = html;
    if (!dom)
      return;
    const id2 = isNil_default(html.id) ? `${null !== (_a = graphic.id) && void 0 !== _a ? _a : graphic._uid}_react` : html.id;
    if (this.htmlMap && this.htmlMap[id2] && container2 && container2 !== this.htmlMap[id2].container && this.removeElement(id2), this.htmlMap && this.htmlMap[id2])
      "string" == typeof dom ? this.htmlMap[id2].wrapContainer.innerHTML = dom : dom !== this.htmlMap[id2].wrapContainer.firstChild && (this.htmlMap[id2].wrapContainer.removeChild(this.htmlMap[id2].wrapContainer.firstChild), this.htmlMap[id2].wrapContainer.appendChild(dom));
    else {
      const { wrapContainer: wrapContainer2, nativeContainer: nativeContainer2 } = this.getWrapContainer(stage, container2);
      wrapContainer2 && ("string" == typeof dom ? wrapContainer2.innerHTML = dom : wrapContainer2.appendChild(dom), this.htmlMap || (this.htmlMap = {}), this.htmlMap[id2] = {
        wrapContainer: wrapContainer2,
        nativeContainer: nativeContainer2,
        container: container2,
        renderId: this.renderId
      });
    }
    if (!this.htmlMap || !this.htmlMap[id2])
      return;
    const { wrapContainer, nativeContainer } = this.htmlMap[id2];
    this.updateStyleOfWrapContainer(graphic, stage, wrapContainer, nativeContainer, html), this.htmlMap[id2].renderId = this.renderId;
  }
  release() {
    "browser" === application.global.env && this.removeAllDom(this.pluginService.stage.defaultLayer);
  }
  removeAllDom(g) {
    this.htmlMap && (Object.keys(this.htmlMap).forEach((key) => {
      this.removeElement(key);
    }), this.htmlMap = null);
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/plugins/builtin-plugin/dirty-bounds-plugin
var globalBounds = new AABBBounds();
var DirtyBoundsPlugin = class {
  constructor() {
    this.name = "DirtyBoundsPlugin", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid;
  }
  activate(context) {
    this.pluginService = context, context.stage.hooks.afterRender.tap(this.key, (stage) => {
      stage && stage === this.pluginService.stage && stage.dirtyBounds.clear();
    }), application.graphicService.hooks.beforeUpdateAABBBounds.tap(this.key, (graphic, stage, willUpdate, bounds) => {
      graphic.glyphHost && (graphic = graphic.glyphHost), stage && stage === this.pluginService.stage && stage.renderCount && (graphic.isContainer && !graphic.shouldSelfChangeUpdateAABBBounds() || willUpdate && (globalBounds.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), stage.dirty(globalBounds, graphic.parent && graphic.parent.globalTransMatrix)));
    }), application.graphicService.hooks.afterUpdateAABBBounds.tap(this.key, (graphic, stage, bounds, params2, selfChange) => {
      stage && stage === this.pluginService.stage && stage.renderCount && (graphic.isContainer && !selfChange || stage.dirty(params2.globalAABBBounds));
    }), application.graphicService.hooks.onRemove.tap(this.key, (graphic) => {
      const stage = graphic.stage;
      stage && stage === this.pluginService.stage && stage.renderCount && stage && stage.dirty(graphic.globalAABBBounds);
    });
  }
  deactivate(context) {
    application.graphicService.hooks.beforeUpdateAABBBounds.taps = application.graphicService.hooks.beforeUpdateAABBBounds.taps.filter((item) => item.name !== this.key), application.graphicService.hooks.afterUpdateAABBBounds.taps = application.graphicService.hooks.afterUpdateAABBBounds.taps.filter((item) => item.name !== this.key), context.stage.hooks.afterRender.taps = context.stage.hooks.afterRender.taps.filter((item) => item.name !== this.key), application.graphicService.hooks.onRemove.taps = application.graphicService.hooks.onRemove.taps.filter((item) => item.name !== this.key);
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/plugins/builtin-plugin/flex-layout-plugin
var _tempBounds2 = new AABBBounds();
var FlexLayoutPlugin = class {
  constructor() {
    this.name = "FlexLayoutPlugin", this.activeEvent = "onRegister", this.id = Generator.GenAutoIncrementId(), this.key = this.name + this.id, this.tempBounds = new AABBBounds();
  }
  pauseLayout(p) {
    this.pause = p;
  }
  tryLayoutChildren(graphic) {
    graphic.firstChild && this.tryLayout(graphic.firstChild);
  }
  tryLayout(graphic, force = true) {
    if (this.pause)
      return;
    const p = graphic.parent;
    if (!(force || p && graphic.needUpdateLayout()))
      return;
    const theme2 = getTheme(p).group, { display = theme2.display } = p.attribute;
    if ("flex" !== display)
      return;
    const { flexDirection = theme2.flexDirection, flexWrap = theme2.flexWrap, alignItems = theme2.alignItems, clip = theme2.clip } = p.attribute, { alignContent = null != alignItems ? alignItems : theme2.alignContent } = p.attribute;
    let { width, height, justifyContent = theme2.justifyContent } = p.attribute;
    const children = p.getChildren();
    if (null == width || null == height) {
      let childrenWidth = 0, childrenHeight = 0, boundsLegal = 0;
      if (children.forEach((child) => {
        const bounds = this.getAABBBounds(child);
        bounds.empty() || ("column" === flexDirection || "column-reverse" === flexDirection ? (childrenHeight += bounds.height(), childrenWidth = Math.max(childrenWidth, bounds.width())) : (childrenWidth += bounds.width(), childrenHeight = Math.max(childrenHeight, bounds.height())), boundsLegal += bounds.x1, boundsLegal += bounds.y1, boundsLegal += bounds.x2, boundsLegal += bounds.y2);
      }), !isFinite(boundsLegal))
        return;
      width = childrenWidth, height = childrenHeight;
    }
    null == p.attribute.width ? p.attribute.width = width : width = p.attribute.width, null == p.attribute.height ? p.attribute.height = height : height = p.attribute.height, this.tempBounds.copy(p._AABBBounds);
    const result2 = {
      main: {
        len: width,
        field: "x"
      },
      cross: {
        len: height,
        field: "y"
      }
    }, main = result2.main, cross2 = result2.cross;
    "column" !== flexDirection && "column-reverse" !== flexDirection || (main.len = height, cross2.len = width, main.field = "y", cross2.field = "x"), "row-reverse" !== flexDirection && "column-reverse" !== flexDirection || ("flex-start" === justifyContent ? justifyContent = "flex-end" : "flex-end" === justifyContent ? justifyContent = "flex-start" : children.reverse());
    let mainLen = 0, crossLen = 0;
    const mianLenArray = [];
    children.forEach((c3) => {
      const b2 = this.getAABBBounds(c3);
      if (b2.empty())
        return;
      const ml = "x" === main.field ? b2.width() : b2.height(), cl = "x" === cross2.field ? b2.width() : b2.height();
      mianLenArray.push({
        mainLen: ml,
        crossLen: cl
      }), mainLen += ml, crossLen = Math.max(crossLen, cl);
    });
    const mainList = [];
    if (mainLen > main.len && "wrap" === flexWrap) {
      let tempMainL = 0, tempCrossL = 0;
      mianLenArray.forEach(({ mainLen: mainLen2, crossLen: crossLen2 }, i) => {
        tempMainL + mainLen2 > main.len ? 0 === tempMainL ? (mainList.push({
          idx: i,
          mainLen: tempMainL + mainLen2,
          crossLen: crossLen2
        }), tempMainL = 0, tempCrossL = 0) : (mainList.push({
          idx: i - 1,
          mainLen: tempMainL,
          crossLen: tempCrossL
        }), tempMainL = mainLen2, tempCrossL = crossLen2) : (tempMainL += mainLen2, tempCrossL = Math.max(tempCrossL, crossLen2));
      }), mainList.push({
        idx: mianLenArray.length - 1,
        mainLen: tempMainL,
        crossLen: tempCrossL
      });
    } else
      mainList.push({
        idx: mianLenArray.length - 1,
        mainLen,
        crossLen
      });
    let lastIdx = 0;
    if (mainList.forEach((s2) => {
      this.layoutMain(p, children, justifyContent, main, mianLenArray, lastIdx, s2), lastIdx = s2.idx + 1;
    }), crossLen = mainList.reduce((a3, b2) => a3 + b2.crossLen, 0), 1 === mainList.length) {
      const anchorPosMap = {
        "flex-start": 0,
        "flex-end": cross2.len,
        center: cross2.len / 2
      };
      this.layoutCross(children, alignItems, cross2, anchorPosMap, mianLenArray, mainList[0], 0);
    } else if ("flex-start" === alignContent) {
      lastIdx = 0;
      let anchorPos = 0;
      mainList.forEach((s2, i) => {
        const anchorPosMap = {
          "flex-start": anchorPos,
          "flex-end": anchorPos + s2.crossLen,
          center: anchorPos + s2.crossLen / 2
        };
        this.layoutCross(children, "flex-start", cross2, anchorPosMap, mianLenArray, mainList[i], lastIdx), lastIdx = s2.idx + 1, anchorPos += s2.crossLen;
      });
    } else if ("center" === alignContent) {
      lastIdx = 0;
      let anchorPos = Math.max(0, (cross2.len - crossLen) / 2);
      mainList.forEach((s2, i) => {
        const anchorPosMap = {
          "flex-start": anchorPos,
          "flex-end": anchorPos + s2.crossLen,
          center: anchorPos + s2.crossLen / 2
        };
        this.layoutCross(children, "center", cross2, anchorPosMap, mianLenArray, mainList[i], lastIdx), lastIdx = s2.idx + 1, anchorPos += s2.crossLen;
      });
    } else if ("space-around" === alignContent) {
      lastIdx = 0;
      const padding = Math.max(0, (cross2.len - crossLen) / mainList.length / 2);
      let anchorPos = padding;
      mainList.forEach((s2, i) => {
        const anchorPosMap = {
          "flex-start": anchorPos,
          "flex-end": anchorPos + s2.crossLen,
          center: anchorPos + s2.crossLen / 2
        };
        this.layoutCross(children, "flex-start", cross2, anchorPosMap, mianLenArray, mainList[i], lastIdx), lastIdx = s2.idx + 1, anchorPos += s2.crossLen + 2 * padding;
      });
    } else if ("space-between" === alignContent) {
      lastIdx = 0;
      const padding = Math.max(0, (cross2.len - crossLen) / (2 * mainList.length - 2));
      let anchorPos = 0;
      mainList.forEach((s2, i) => {
        const anchorPosMap = {
          "flex-start": anchorPos,
          "flex-end": anchorPos + s2.crossLen,
          center: anchorPos + s2.crossLen / 2
        };
        this.layoutCross(children, "flex-start", cross2, anchorPosMap, mianLenArray, mainList[i], lastIdx), lastIdx = s2.idx + 1, anchorPos += s2.crossLen + 2 * padding;
      });
    }
    children.forEach((child, idx) => {
      child.addUpdateBoundTag(), child.addUpdatePositionTag(), child.clearUpdateLayoutTag();
    }), p.addUpdateLayoutTag();
    const b = this.getAABBBounds(p);
    clip || this.tempBounds.equals(b) || this.tryLayout(p, false);
  }
  getAABBBounds(graphic) {
    this.skipBoundsTrigger = true;
    const b = graphic.AABBBounds;
    return this.skipBoundsTrigger = false, b;
  }
  updateChildPos(posBaseLeftTop, lastP, lastBP) {
    return posBaseLeftTop + (null != lastP ? lastP : 0) - lastBP;
  }
  layoutMain(p, children, justifyContent, main, mianLenArray, lastIdx, currSeg) {
    if ("flex-start" === justifyContent) {
      let pos = 0;
      for (let i = lastIdx; i <= currSeg.idx; i++) {
        const posBaseLeftTop = pos + getPadding(children[i], main.field), b = this.getAABBBounds(children[i]);
        !b.empty() && (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`])), pos += mianLenArray[i].mainLen;
      }
    } else if ("flex-end" === justifyContent) {
      let pos = main.len;
      for (let i = currSeg.idx; i >= lastIdx; i--) {
        pos -= mianLenArray[i].mainLen;
        const posBaseLeftTop = pos + getPadding(children[i], main.field), b = this.getAABBBounds(children[i]);
        !b.empty() && (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`]));
      }
    } else if ("space-around" === justifyContent)
      if (currSeg.mainLen >= main.len) {
        let pos = 0;
        for (let i = lastIdx; i <= currSeg.idx; i++) {
          const posBaseLeftTop = pos + getPadding(children[i], main.field), b = this.getAABBBounds(children[i]);
          !b.empty() && (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`])), pos += mianLenArray[i].mainLen;
        }
      } else {
        const size = currSeg.idx - lastIdx + 1, padding = (main.len - currSeg.mainLen) / size / 2;
        let pos = padding;
        for (let i = lastIdx; i <= currSeg.idx; i++) {
          const posBaseLeftTop = pos + getPadding(children[i], main.field), b = this.getAABBBounds(children[i]);
          !b.empty() && (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`])), pos += mianLenArray[i].mainLen + 2 * padding;
        }
      }
    else if ("space-between" === justifyContent)
      if (currSeg.mainLen >= main.len) {
        let pos = 0;
        for (let i = lastIdx; i <= currSeg.idx; i++) {
          const posBaseLeftTop = pos + getPadding(children[i], main.field), b = this.getAABBBounds(children[i]);
          !b.empty() && (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`])), pos += mianLenArray[i].mainLen;
        }
      } else {
        const size = currSeg.idx - lastIdx + 1, padding = (main.len - currSeg.mainLen) / (2 * size - 2);
        let pos = 0;
        for (let i = lastIdx; i <= currSeg.idx; i++) {
          const posBaseLeftTop = pos + getPadding(children[i], main.field), b = this.getAABBBounds(children[i]);
          !b.empty() && (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`])), pos += mianLenArray[i].mainLen + 2 * padding;
        }
      }
    else if ("center" === justifyContent) {
      let pos = (main.len - currSeg.mainLen) / 2;
      for (let i = lastIdx; i <= currSeg.idx; i++) {
        const posBaseLeftTop = pos + getPadding(children[i], main.field), b = this.getAABBBounds(children[i]);
        !b.empty() && (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`])), pos += mianLenArray[i].mainLen;
      }
    }
  }
  layoutCross(children, alignItem, cross2, anchorPosMap, lenArray, currSeg, lastIdx) {
    var _a;
    for (let i = lastIdx; i <= currSeg.idx; i++) {
      const child = children[i];
      let { alignSelf } = child.attribute;
      alignSelf && "auto" !== alignSelf || (alignSelf = alignItem);
      const b = this.getAABBBounds(child), anchorPos = null !== (_a = anchorPosMap[alignSelf]) && void 0 !== _a ? _a : anchorPosMap["flex-start"];
      "flex-end" === alignSelf ? !b.empty() && (child.attribute[cross2.field] = this.updateChildPos(anchorPos - lenArray[i].crossLen + getPadding(child, cross2.field), child.attribute[cross2.field], b[`${cross2.field}1`])) : "center" === alignSelf ? !b.empty() && (child.attribute[cross2.field] = this.updateChildPos(anchorPos - lenArray[i].crossLen / 2 + getPadding(child, cross2.field), child.attribute[cross2.field], b[`${cross2.field}1`])) : !b.empty() && (child.attribute[cross2.field] = this.updateChildPos(anchorPos + getPadding(child, cross2.field), child.attribute[cross2.field], b[`${cross2.field}1`]));
    }
  }
  activate(context) {
    this.pluginService = context, application.graphicService.hooks.onAttributeUpdate.tap(this.key, (graphic) => {
      graphic.glyphHost && (graphic = graphic.glyphHost), graphic.stage && graphic.stage === this.pluginService.stage && this.tryLayout(graphic, false);
    }), application.graphicService.hooks.beforeUpdateAABBBounds.tap(this.key, (graphic, stage, willUpdate, bounds) => {
      graphic.glyphHost && (graphic = graphic.glyphHost), stage && stage === this.pluginService.stage && graphic.isContainer && !this.skipBoundsTrigger && _tempBounds2.copy(bounds);
    }), application.graphicService.hooks.afterUpdateAABBBounds.tap(this.key, (graphic, stage, bounds, params2, selfChange) => {
      stage && stage === this.pluginService.stage && graphic.isContainer && !this.skipBoundsTrigger && (_tempBounds2.equals(bounds) || this.tryLayout(graphic, false));
    }), application.graphicService.hooks.onSetStage.tap(this.key, (graphic) => {
      graphic.glyphHost && (graphic = graphic.glyphHost), this.tryLayout(graphic, false);
    });
  }
  deactivate(context) {
    application.graphicService.hooks.onAttributeUpdate.taps = application.graphicService.hooks.onAttributeUpdate.taps.filter((item) => item.name !== this.key), application.graphicService.hooks.beforeUpdateAABBBounds.taps = application.graphicService.hooks.beforeUpdateAABBBounds.taps.filter((item) => item.name !== this.key), application.graphicService.hooks.afterUpdateAABBBounds.taps = application.graphicService.hooks.afterUpdateAABBBounds.taps.filter((item) => item.name !== this.key), application.graphicService.hooks.onSetStage.taps = application.graphicService.hooks.onSetStage.taps.filter((item) => item.name !== this.key);
  }
};
function getPadding(graphic, field3) {
  return 0;
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/animate/default-ticker
var defaultTicker = new DefaultTicker();
defaultTicker.addTimeline(defaultTimeline);
defaultTicker.setFPS(60);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/core/light
var DirectionalLight = class {
  constructor(dir, color, ambient = 0.8) {
    this.dir = dir, this.color = color, this.colorRgb = ColorStore.Get(color, ColorType.Color1), this.ambient = ambient;
    const length2 = sqrt(dir[0] * dir[0] + dir[1] * dir[1] + dir[2] * dir[2]);
    this.formatedDir = [dir[0] / length2, dir[1] / length2, dir[2] / length2];
  }
  computeColor(normal, color) {
    const lightDir = this.formatedDir, brightness = min(max((normal[0] * lightDir[0] + normal[1] * lightDir[1] + normal[2] * lightDir[2]) * (1 - this.ambient / 2), 0) + this.ambient, 1);
    let colorArray;
    colorArray = isString_default(color) ? ColorStore.Get(color, ColorType.Color1) : color;
    const lightColorArray = this.colorRgb;
    return `rgb(${lightColorArray[0] * colorArray[0] * brightness}, ${lightColorArray[1] * colorArray[1] * brightness}, ${lightColorArray[2] * colorArray[2] * brightness})`;
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/matrix
function lookAt(out, eye, center2, up) {
  let x05, x14, x23, y05, y14, y23, z0, z1, z2, len;
  const eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2], centerx = center2[0], centery = center2[1], centerz = center2[2];
  return Math.abs(eyex - centerx) < epsilon && Math.abs(eyey - centery) < epsilon && Math.abs(eyez - centerz) < epsilon ? DefaultMat4Allocate.identity(out) : (z0 = eyex - centerx, z1 = eyey - centery, z2 = eyez - centerz, len = 1 / Math.hypot(z0, z1, z2), z0 *= len, z1 *= len, z2 *= len, x05 = upy * z2 - upz * z1, x14 = upz * z0 - upx * z2, x23 = upx * z1 - upy * z0, len = Math.hypot(x05, x14, x23), len ? (len = 1 / len, x05 *= len, x14 *= len, x23 *= len) : (x05 = 0, x14 = 0, x23 = 0), y05 = z1 * x23 - z2 * x14, y14 = z2 * x05 - z0 * x23, y23 = z0 * x14 - z1 * x05, len = Math.hypot(y05, y14, y23), len ? (len = 1 / len, y05 *= len, y14 *= len, y23 *= len) : (y05 = 0, y14 = 0, y23 = 0), out[0] = x05, out[1] = y05, out[2] = z0, out[3] = 0, out[4] = x14, out[5] = y14, out[6] = z1, out[7] = 0, out[8] = x23, out[9] = y23, out[10] = z2, out[11] = 0, out[12] = -(x05 * eyex + x14 * eyey + x23 * eyez), out[13] = -(y05 * eyex + y14 * eyey + y23 * eyez), out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez), out[15] = 1, out);
}
function ortho(out, left2, right2, bottom, top, near, far) {
  const lr = 1 / (left2 - right2), bt = 1 / (bottom - top), nf = 1 / (near - far);
  return out[0] = -2 * lr, out[1] = 0, out[2] = 0, out[3] = 0, out[4] = 0, out[5] = -2 * bt, out[6] = 0, out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 2 * nf, out[11] = 0, out[12] = (left2 + right2) * lr, out[13] = (top + bottom) * bt, out[14] = (far + near) * nf, out[15] = 1, out;
}
function multiply(out, a3, b) {
  const a00 = a3[0], a01 = a3[1], a02 = a3[2], a03 = a3[3], a10 = a3[4], a11 = a3[5], a12 = a3[6], a13 = a3[7], a20 = a3[8], a21 = a3[9], a22 = a3[10], a23 = a3[11], a30 = a3[12], a31 = a3[13], a32 = a3[14], a33 = a3[15];
  let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[4], b1 = b[5], b2 = b[6], b3 = b[7], out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[8], b1 = b[9], b2 = b[10], b3 = b[11], out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[12], b1 = b[13], b2 = b[14], b3 = b[15], out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, out;
}
function transformMat4(out, a3, m4) {
  const x = a3[0], y = a3[1], z = a3[2];
  let w = m4[3] * x + m4[7] * y + m4[11] * z + m4[15];
  return w = w || 1, out[0] = (m4[0] * x + m4[4] * y + m4[8] * z + m4[12]) / w, out[1] = (m4[1] * x + m4[5] * y + m4[9] * z + m4[13]) / w, out[2] = (m4[2] * x + m4[6] * y + m4[10] * z + m4[14]) / w, out;
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/core/camera
var OrthoCamera = class {
  set params(params2) {
    this._params = Object.assign({}, params2), this._projectionMatrixCached = this.forceGetProjectionMatrix(), this._viewMatrixCached = this.forceGetViewMatrix();
  }
  get params() {
    return Object.assign({}, this._params);
  }
  constructor(params2) {
    this.params = params2;
  }
  getViewMatrix() {
    return this._viewMatrixCached || (this._viewMatrixCached = mat4Allocate.allocate()), this._viewMatrixCached;
  }
  forceGetViewMatrix() {
    this._viewMatrixCached || (this._viewMatrixCached = mat4Allocate.allocate());
    const { pos, center: center2, up } = this.params.viewParams;
    return lookAt(this._viewMatrixCached, pos, center2, up), this._vp || (this._vp = mat4Allocate.allocate()), this._vp = multiply(this._vp, this.getProjectionMatrix(), this.getViewMatrix()), this._viewMatrixCached;
  }
  getProjectionMatrix() {
    return this._projectionMatrixCached || (this._projectionMatrixCached = mat4Allocate.allocate()), this._projectionMatrixCached;
  }
  forceGetProjectionMatrix() {
    this._projectionMatrixCached || (this._projectionMatrixCached = mat4Allocate.allocate());
    const { left: left2, top, right: right2, bottom } = this._params;
    return ortho(this._projectionMatrixCached, left2, right2, bottom, top, 0, -2e6), this._vp || (this._vp = mat4Allocate.allocate()), this._vp = multiply(this._vp, this.getProjectionMatrix(), this.getViewMatrix()), this._projectionMatrixCached;
  }
  getField() {
    const { fieldRatio = 0.8, fieldDepth, left: left2, right: right2 } = this._params;
    return (null != fieldDepth ? fieldDepth : right2 - left2) * fieldRatio;
  }
  getProjectionScale(z) {
    const field3 = this.getField();
    return field3 / (field3 + z);
  }
  view(x, y, z) {
    const outP2 = [0, 0, 0];
    return transformMat4(outP2, [x, y, z], this._viewMatrixCached), outP2;
  }
  vp(x, y, z) {
    const outP2 = [0, 0, 0], { pos } = this._params.viewParams;
    transformMat4(outP2, [x, y, z], this._viewMatrixCached), x = outP2[0], y = outP2[1], z = outP2[2];
    const sizeProjection = this.getProjectionScale(z);
    return {
      x: x * sizeProjection + pos[0],
      y: y * sizeProjection + pos[1]
    };
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/env-check
var _isBrowserEnv;
function initIsBrowserEnv() {
  if (null == _isBrowserEnv)
    try {
      const canvas = document.createElement("canvas"), ctx = canvas.getContext("2d");
      _isBrowserEnv = !!(window && canvas.getBoundingClientRect && requestAnimationFrame && window.devicePixelRatio && ctx && ctx.isPointInPath && ctx.isPointInStroke), _isBrowserEnv && (_isBrowserEnv = !!document.createElement);
    } catch (err) {
      _isBrowserEnv = false;
    }
}
function isBrowserEnv() {
  initIsBrowserEnv();
  const env = application.global && application.global.env;
  return env ? "browser" === env : _isBrowserEnv;
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/plugins/builtin-plugin/react-attribute-plugin
var ReactAttributePlugin = class extends HtmlAttributePlugin {
  constructor() {
    super(...arguments), this.name = "ReactAttributePlugin", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid, this.htmlMap = {};
  }
  removeElement(id2) {
    if (!this.htmlMap || !this.htmlMap[id2])
      return;
    const { root, wrapContainer } = this.htmlMap[id2];
    if (root) {
      application.global.getRequestAnimationFrame()(() => {
        root.unmount();
      });
    }
    wrapContainer && application.global.removeDom(wrapContainer), this.htmlMap[id2] = null;
  }
  renderGraphicHTML(graphic) {
    var _a;
    const { react } = graphic.attribute;
    if (!react)
      return;
    const stage = graphic.stage;
    if (!stage)
      return;
    const ReactDOM = stage.params.ReactDOM, { element, container: container2 } = react;
    if (!(element && ReactDOM && ReactDOM.createRoot))
      return;
    const id2 = isNil_default(react.id) ? `${null !== (_a = graphic.id) && void 0 !== _a ? _a : graphic._uid}_react` : react.id;
    if (this.htmlMap && this.htmlMap[id2] && container2 && container2 !== this.htmlMap[id2].container && this.removeElement(id2), this.htmlMap && this.htmlMap[id2])
      this.htmlMap[id2].root.render(element);
    else {
      const { wrapContainer: wrapContainer2, nativeContainer: nativeContainer2 } = this.getWrapContainer(stage, container2);
      if (wrapContainer2) {
        const root = ReactDOM.createRoot(wrapContainer2);
        root.render(element), this.htmlMap || (this.htmlMap = {}), this.htmlMap[id2] = {
          root,
          wrapContainer: wrapContainer2,
          nativeContainer: nativeContainer2,
          container: container2,
          renderId: this.renderId
        };
      }
    }
    if (!this.htmlMap || !this.htmlMap[id2])
      return;
    const { wrapContainer, nativeContainer } = this.htmlMap[id2];
    this.updateStyleOfWrapContainer(graphic, stage, wrapContainer, nativeContainer, react), this.htmlMap[id2].renderId = this.renderId;
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/core/stage
var DefaultConfig = {
  WIDTH: 500,
  HEIGHT: 500,
  X: 0,
  Y: 0,
  BACKGROUND: "white"
};
var Stage = class extends Group {
  set viewBox(b) {
    this.window.setViewBox(b);
  }
  get viewBox() {
    return this.window.getViewBox();
  }
  get x() {
    return this.window.getViewBox().x1;
  }
  set x(x) {
    const b = this.window.getViewBox();
    b.translate(x - b.x1, 0), this.window.setViewBox(b);
  }
  get y() {
    return this.window.getViewBox().y1;
  }
  set y(y) {
    const b = this.window.getViewBox();
    b.translate(0, y - b.y1), this.window.setViewBox(b);
  }
  get width() {
    return this.window.width;
  }
  set width(w) {
    this.resize(w, this.height);
  }
  get viewWidth() {
    return this.window.getViewBox().width();
  }
  set viewWidth(w) {
    this.resizeView(w, this.viewHeight);
  }
  get viewHeight() {
    return this.window.getViewBox().height();
  }
  set viewHeight(h) {
    this.resizeView(this.viewWidth, h);
  }
  get height() {
    return this.window.height;
  }
  set height(h) {
    this.resize(this.width, h);
  }
  get dpr() {
    return this.window.dpr;
  }
  set dpr(r) {
    this.setDpr(r);
  }
  get background() {
    var _a;
    return null !== (_a = this._background) && void 0 !== _a ? _a : DefaultConfig.BACKGROUND;
  }
  set background(b) {
    this._background = b;
  }
  get defaultLayer() {
    return this.at(0);
  }
  get eventSystem() {
    return this._eventSystem;
  }
  constructor(params2 = {}) {
    var _a;
    super({}), this._onVisibleChange = (visible) => {
      if (!(this._skipRender < 0))
        if (visible) {
          if (this.dirtyBounds) {
            const b = this.window.getViewBox();
            this.dirtyBounds.setValue(b.x1, b.y1, b.width(), b.height());
          }
          this._skipRender > 1 && this.renderNextFrame(), this._skipRender = 0;
        } else
          this._skipRender = 1;
    }, this.beforeRender = (stage) => {
      this._beforeRender && this._beforeRender(stage);
    }, this.afterRender = (stage) => {
      this.renderCount++, this._afterRender && this._afterRender(stage), this._afterNextRenderCbs && this._afterNextRenderCbs.forEach((cb) => cb(stage)), this._afterNextRenderCbs = null;
    }, this.params = params2, this.theme = new Theme(), this.hooks = {
      beforeRender: new SyncHook(["stage"]),
      afterRender: new SyncHook(["stage"])
    }, this.global = application.global, !this.global.env && isBrowserEnv() && this.global.setEnv("browser"), this.window = container.get(VWindow), this.renderService = container.get(RenderService), this.pluginService = container.get(PluginService), this.layerService = container.get(LayerService), this.pluginService.active(this, params2), this.window.create({
      width: params2.width,
      height: params2.height,
      viewBox: params2.viewBox,
      container: params2.container,
      dpr: params2.dpr || this.global.devicePixelRatio,
      canvasControled: false !== params2.canvasControled,
      title: params2.title || "",
      canvas: params2.canvas
    }), this.state = "normal", this.renderCount = 0, this.tryInitEventSystem(), this._background = null !== (_a = params2.background) && void 0 !== _a ? _a : DefaultConfig.BACKGROUND, this.appendChild(this.layerService.createLayer(this, {
      main: true
    })), this.nextFrameRenderLayerSet = /* @__PURE__ */ new Set(), this.willNextFrameRender = false, this.stage = this, this.renderStyle = params2.renderStyle, params2.autoRender && this.enableAutoRender(), false === params2.disableDirtyBounds && this.enableDirtyBounds(), params2.enableHtmlAttribute && this.enableHtmlAttribute(params2.enableHtmlAttribute), params2.ReactDOM && this.enableReactAttribute(params2.ReactDOM), params2.enableLayout && this.enableLayout(), this.hooks.beforeRender.tap("constructor", this.beforeRender), this.hooks.afterRender.tap("constructor", this.afterRender), this._beforeRender = params2.beforeRender, this._afterRender = params2.afterRender, this.ticker = params2.ticker || defaultTicker, this.supportInteractiveLayer = false !== params2.interactiveLayer, this.timeline = new DefaultTimeline(), this.ticker.addTimeline(this.timeline), this.timeline.pause(), params2.optimize || (params2.optimize = {}), this.optmize(params2.optimize), params2.background && isString_default(this._background) && this._background.includes("/") && this.setAttributes({
      background: this._background
    });
  }
  pauseRender() {
    this._skipRender = -1;
  }
  resumeRender() {
    this._skipRender = 0;
  }
  tryInitEventSystem() {
    this.global.supportEvent && !this._eventSystem && (this._eventSystem = new EventSystem(Object.assign({
      targetElement: this.window,
      resolution: this.window.dpr || this.global.devicePixelRatio,
      rootNode: this,
      global: this.global,
      supportsPointerEvents: this.params.supportsPointerEvents,
      supportsTouchEvents: this.params.supportsTouchEvents
    }, this.params.event)));
  }
  preventRender(prevent2) {
    prevent2 ? this._skipRender = -1 / 0 : false !== this.params.optimize.skipRenderWithOutRange ? this._skipRender = this.window.isVisible() ? 0 : 1 : this._skipRender = 0;
  }
  optmize(params2) {
    this.optmizeRender(params2.skipRenderWithOutRange), this.params.optimize = params2;
  }
  optmizeRender(skipRenderWithOutRange = false) {
    skipRenderWithOutRange && (this._skipRender = this._skipRender < 0 ? this._skipRender : this.window.isVisible() ? 0 : 1, this.window.onVisibleChange(this._onVisibleChange));
  }
  getTimeline() {
    return this.timeline;
  }
  get3dOptions(options) {
    const { center: center2 = {
      x: this.width / 2,
      y: this.height / 2,
      z: 0,
      dx: 0,
      dy: 0,
      dz: 0
    }, light = {}, alpha = 0, beta = 0, camera, fieldRatio = 1, fieldDepth } = options;
    return Object.assign(Object.assign({}, options), {
      center: center2,
      light,
      alpha,
      beta,
      camera,
      fieldRatio,
      fieldDepth
    });
  }
  set3dOptions(options) {
    var _a, _b, _d, _e, _f, _g;
    this.option3d = options;
    const options3d = this.get3dOptions(options), { light, center: center2, camera, alpha, beta, fieldRatio, fieldDepth } = options3d, { dir = [1, 1, -1], color = "white", ambient } = light, centerX = (null !== (_a = center2.x) && void 0 !== _a ? _a : this.width / 2) + (null !== (_b = center2.dx) && void 0 !== _b ? _b : 0), centerY = (null !== (_d = center2.y) && void 0 !== _d ? _d : this.height / 2) + (null !== (_e = center2.dy) && void 0 !== _e ? _e : 0), centerVec3 = [centerX, centerY, (null !== (_f = center2.z) && void 0 !== _f ? _f : 0) + (null !== (_g = center2.dz) && void 0 !== _g ? _g : 0)];
    let cameraX = 0, cameraY = 0, cameraZ = 0;
    camera || (cameraX = Math.sin(alpha) + centerX, cameraY = Math.sin(beta) + centerY, cameraZ = Math.cos(alpha) * Math.cos(beta) * 1), this.light = new DirectionalLight(dir, color, ambient);
    const cameraParams = {
      left: 0,
      right: this.width,
      top: 0,
      bottom: this.height,
      fieldRatio,
      fieldDepth,
      viewParams: {
        pos: [cameraX, cameraY, cameraZ],
        center: centerVec3,
        up: [0, 1, 0]
      }
    };
    this.camera ? this.camera.params = cameraParams : this.camera = new OrthoCamera(cameraParams), options.enableView3dTransform && this.enableView3dTransform();
  }
  setBeforeRender(cb) {
    this._beforeRender = cb;
  }
  setAfterRender(cb) {
    this._afterRender = cb;
  }
  afterNextRender(cb) {
    this._afterNextRenderCbs || (this._afterNextRenderCbs = []), this._afterNextRenderCbs.push(cb);
  }
  enableView3dTransform() {
    this.view3dTranform || (this.view3dTranform = true, this.pluginService.register(new ViewTransform3dPlugin()));
  }
  disableView3dTranform() {
    this.view3dTranform && (this.view3dTranform = false, this.pluginService.findPluginsByName("ViewTransform3dPlugin").forEach((plugin) => {
      this.pluginService.unRegister(plugin);
    }));
  }
  enableAutoRender() {
    this.autoRender || (this.autoRender = true, this.pluginService.register(new AutoRenderPlugin()));
  }
  disableAutoRender() {
    this.autoRender && (this.autoRender = false, this.pluginService.findPluginsByName("AutoRenderPlugin").forEach((plugin) => {
      this.pluginService.unRegister(plugin);
    }));
  }
  enableIncrementalAutoRender() {
    this.increaseAutoRender || (this.increaseAutoRender = true, this.pluginService.register(new IncrementalAutoRenderPlugin()));
  }
  disableIncrementalAutoRender() {
    this.increaseAutoRender && (this.increaseAutoRender = false, this.pluginService.findPluginsByName("IncrementalAutoRenderPlugin").forEach((plugin) => {
      this.pluginService.unRegister(plugin);
    }));
  }
  enableDirtyBounds() {
    if (this.dirtyBounds)
      return;
    this.dirtyBounds = new Bounds();
    let plugin = this.pluginService.findPluginsByName("DirtyBoundsPlugin")[0];
    plugin ? plugin.activate(this.pluginService) : (plugin = new DirtyBoundsPlugin(), this.pluginService.register(plugin));
  }
  disableDirtyBounds() {
    this.dirtyBounds && (this.dirtyBounds = null, this.pluginService.findPluginsByName("DirtyBoundsPlugin").forEach((plugin) => {
      this.pluginService.unRegister(plugin);
    }));
  }
  enableLayout() {
    this._enableLayout || (this._enableLayout = true, this.pluginService.register(new FlexLayoutPlugin()));
  }
  disableLayout() {
    this._enableLayout && (this._enableLayout = false, this.pluginService.findPluginsByName("FlexLayoutPlugin").forEach((plugin) => {
      this.pluginService.unRegister(plugin);
    }));
  }
  enableHtmlAttribute(container2) {
    this.htmlAttribute || (this.htmlAttribute = container2, this.pluginService.register(new HtmlAttributePlugin()));
  }
  disableHtmlAttribute() {
    this.htmlAttribute && (this.htmlAttribute = false, this.pluginService.findPluginsByName("HtmlAttributePlugin").forEach((plugin) => {
      this.pluginService.unRegister(plugin);
    }));
  }
  enableReactAttribute(container2) {
    this.reactAttribute || (this.reactAttribute = container2, this.pluginService.register(new ReactAttributePlugin()));
  }
  disableReactAttribute() {
    this.reactAttribute && (this.reactAttribute = false, this.pluginService.findPluginsByName("ReactAttributePlugin").forEach((plugin) => {
      this.pluginService.unRegister(plugin);
    }));
  }
  getPluginsByName(name) {
    return this.pluginService.findPluginsByName(name);
  }
  tryUpdateAABBBounds() {
    const viewBox = this.window.getViewBox();
    return this._AABBBounds.setValue(viewBox.x1, viewBox.y1, viewBox.x2, viewBox.y2), this._AABBBounds;
  }
  combineLayer(ILayer1, ILayer2) {
    throw new Error("\u6682\u4E0D\u652F\u6301");
  }
  createLayer(canvasId, layerMode) {
    const layer = this.layerService.createLayer(this, {
      main: false,
      layerMode,
      canvasId
    });
    return this.appendChild(layer), layer;
  }
  sortLayer(cb) {
    const children = this.children;
    children.sort(cb), this.removeAllChild(), children.forEach((c3) => {
      this.appendChild(c3);
    });
  }
  removeLayer(ILayerId) {
    return this.removeChild(this.findChildByUid(ILayerId));
  }
  tryInitInteractiveLayer() {
    this.supportInteractiveLayer && !this.interactiveLayer && (this.interactiveLayer = this.createLayer(), this.interactiveLayer.name = "_builtin_interactive", this.interactiveLayer.attribute.pickable = false, this.nextFrameRenderLayerSet.add(this.interactiveLayer));
  }
  clearViewBox(color) {
    this.window.clearViewBox(color);
  }
  render(layers, params2) {
    this.ticker.start(), this.timeline.resume();
    const state = this.state;
    this.state = "rendering", this.layerService.prepareStageLayer(this), this._skipRender || (this.lastRenderparams = params2, this.hooks.beforeRender.call(this), this._skipRender || (this.renderLayerList(this.children), this.combineLayersToWindow(), this.nextFrameRenderLayerSet.clear()), this.hooks.afterRender.call(this)), this.state = state, this._skipRender && this._skipRender++;
  }
  combineLayersToWindow() {
    if ("harmony" === this.global.env) {
      const ctx = this.window.getContext().nativeContext;
      this.forEachChildren((layer, i) => {
        if (i > 0) {
          const image = layer.getNativeHandler().getContext().canvas.nativeCanvas.nativeCanvas._c.transferToImageBitmap();
          ctx.transferFromImageBitmap(image);
        }
      });
    }
  }
  renderNextFrame(layers, force) {
    this.nextFrameRenderLayerSet.size !== this.childrenCount && (layers || this).forEach((layer) => {
      this.nextFrameRenderLayerSet.add(layer);
    }), this.willNextFrameRender || (this.willNextFrameRender = true, this.global.getRequestAnimationFrame()(() => {
      this._doRenderInThisFrame(), this.willNextFrameRender = false;
    }));
  }
  _doRenderInThisFrame() {
    this.timeline.resume(), this.ticker.start();
    const state = this.state;
    this.state = "rendering", this.layerService.prepareStageLayer(this), this.nextFrameRenderLayerSet.size && !this._skipRender && (this.hooks.beforeRender.call(this), this._skipRender || (this.renderLayerList(Array.from(this.nextFrameRenderLayerSet.values()), this.lastRenderparams || {}), this.combineLayersToWindow(), this.nextFrameRenderLayerSet.clear()), this.hooks.afterRender.call(this)), this.state = state, this._skipRender && this._skipRender++;
  }
  renderLayerList(layerList, params2) {
    const list = [];
    for (let i = 0; i < layerList.length; i++) {
      let l = layerList[i];
      "virtual" === l.layerMode && (l = l.getNativeHandler().mainHandler.layer), list.includes(l) || list.push(l);
    }
    list.forEach((layer) => {
      layer.renderCount > this.renderCount || (layer.renderCount = this.renderCount + 1, layer.render({
        renderService: this.renderService,
        background: layer === this.defaultLayer ? this.background : void 0,
        updateBounds: !(!this.dirtyBounds || this.dirtyBounds.empty()),
        viewBox: this.window.getViewBox(),
        transMatrix: this.window.getViewBoxTransform()
      }, Object.assign({
        renderStyle: this.renderStyle
      }, params2)));
    }), this.interactiveLayer && !layerList.includes(this.interactiveLayer) && this.interactiveLayer.render({
      renderService: this.renderService,
      updateBounds: !(!this.dirtyBounds || this.dirtyBounds.empty()),
      viewBox: this.window.getViewBox(),
      transMatrix: this.window.getViewBoxTransform()
    }, Object.assign({
      renderStyle: this.renderStyle
    }, params2));
  }
  resizeWindow(w, h, rerender = true) {
    this.window.resize(w, h), rerender && this.render();
  }
  resize(w, h, rerender = true) {
    this.window.hasSubView() || this.viewBox.setValue(this.viewBox.x1, this.viewBox.y1, this.viewBox.x1 + w, this.viewBox.y1 + h), this.window.resize(w, h), this.forEachChildren((c3) => {
      c3.resize(w, h);
    }), this.camera && this.option3d && this.set3dOptions(this.option3d), rerender && this.render();
  }
  resizeView(w, h, rerender = true) {
    this.viewBox.setValue(this.viewBox.x1, this.viewBox.y1, this.viewBox.x1 + w, this.viewBox.y1 + h), this.forEachChildren((c3) => {
      c3.resizeView(w, h);
    }), this.camera && (this.camera.params = Object.assign(Object.assign({}, this.camera.params), {
      right: this.width,
      bottom: this.height
    })), rerender && this.render();
  }
  setViewBox(x, y, w, h, rerender) {
    let isRerender = true;
    "object" == typeof x ? (this.viewBox.setValue(x.x1, x.y1, x.x2, x.y2), false === y && (isRerender = false)) : (this.viewBox.setValue(x, y, x + w, y + h), false === rerender && (isRerender = false)), this.forEachChildren((c3) => {
      c3.resizeView(this.viewBox.width(), this.viewBox.height());
    }), isRerender && this.render();
  }
  setDpr(dpr, rerender = true) {
    this.forEachChildren((c3) => {
      c3.setDpr(dpr);
    }), rerender && this.render();
  }
  setOrigin(x, y) {
    throw new Error("\u6682\u4E0D\u652F\u6301");
  }
  export(type) {
    throw new Error("\u6682\u4E0D\u652F\u6301");
  }
  pick(x, y) {
    this.pickerService || (this.pickerService = container.get(PickerService));
    const result2 = this.pickerService.pick(this.children, new Point(x, y), {
      bounds: this.AABBBounds
    });
    return !(!(null == result2 ? void 0 : result2.graphic) && !(null == result2 ? void 0 : result2.group)) && result2;
  }
  startAnimate(t) {
    throw new Error("\u6682\u4E0D\u652F\u6301");
  }
  setToFrame(t) {
    throw new Error("\u6682\u4E0D\u652F\u6301");
  }
  release() {
    super.release(), this.hooks.beforeRender.unTap("constructor", this.beforeRender), this.hooks.afterRender.unTap("constructor", this.afterRender), this.eventSystem && this.eventSystem.release(), this.layerService.releaseStage(this), this.pluginService.release(), this.forEach((layer) => {
      layer.release();
    }), this.interactiveLayer && this.interactiveLayer.release(), this.window.release(), this.ticker.remTimeline(this.timeline), this.renderService.renderTreeRoots = [];
  }
  setStage(stage) {
  }
  dirty(b, matrix) {
    matrix && b.transformWithMatrix(matrix), this.dirtyBounds.empty() && this.dirtyBounds.setValue(b.x1, b.y1, b.x2, b.y2), this.dirtyBounds.union(b);
  }
  getLayer(name) {
    return this.children.filter((layer) => layer.name === name)[0];
  }
  renderTo(window2) {
    this.forEachChildren((layer, i) => {
      layer.drawTo(window2, {
        renderService: this.renderService,
        viewBox: window2.getViewBox(),
        transMatrix: window2.getViewBoxTransform(),
        background: layer === this.defaultLayer ? this.background : void 0,
        clear: 0 === i,
        updateBounds: !(!this.dirtyBounds || this.dirtyBounds.empty())
      });
    });
  }
  renderToNewWindow(fullImage = true, viewBox) {
    const window2 = container.get(VWindow), x14 = viewBox ? -viewBox.x1 : 0, y14 = viewBox ? -viewBox.y1 : 0, x23 = viewBox ? viewBox.x2 : this.viewWidth, y23 = viewBox ? viewBox.y2 : this.viewHeight, width = viewBox ? viewBox.width() : this.viewWidth, height = viewBox ? viewBox.height() : this.viewHeight;
    return window2.create({
      viewBox: {
        x1: x14,
        y1: y14,
        x2: x23,
        y2: y23
      },
      width,
      height,
      dpr: this.window.dpr,
      canvasControled: true,
      offscreen: true,
      title: ""
    }), this.renderTo(window2), window2;
  }
  toCanvas(fullImage = true, viewBox) {
    const c3 = this.renderToNewWindow(fullImage, viewBox).getNativeHandler();
    return c3.nativeCanvas ? c3.nativeCanvas : null;
  }
  setCursor(mode) {
    this._cursor = mode, this.eventSystem.setCursor(mode, "ignore");
  }
  getCursor() {
    return this._cursor;
  }
  eventPointTransform(e) {
    const point5 = this.global.mapToCanvasPoint(e, this.window.getContext().canvas.nativeCanvas);
    return this.stage.window.pointTransform(point5.x, point5.y);
  }
  pauseTriggerEvent() {
    this._eventSystem && this._eventSystem.pauseTriggerEvent();
  }
  resumeTriggerEvent() {
    this._eventSystem && this._eventSystem.resumeTriggerEvent();
  }
};

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/create
function createStage(params2) {
  return new Stage(params2);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/interface/graphic/bounds
var params;
!function(params2) {
  params2[params2.W = 1] = "W", params2[params2.H = 2] = "H", params2[params2.WH = 3] = "WH";
}(params || (params = {}));

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/canvas/empty-context
var __decorate33 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata25 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var initMatrix = new Matrix(1, 0, 0, 1, 0, 0);
var globalPoint = {
  x: 0,
  y: 0
};
var EmptyContext2d = class {
  get nativeContext() {
    return this.path;
  }
  constructor(canvas, dpr) {
    this.matrix = new Matrix(1, 0, 0, 1, 0, 0), this.stack = [], this.dpr = dpr, this.applyedMatrix = new Matrix(1, 0, 0, 1, 0, 0), this.path = new CustomPath2D(), this._clearMatrix = new Matrix(1, 0, 0, 1, 0, 0);
  }
  getCanvas() {
    throw new Error("\u4E0D\u652F\u6301getCanvas");
  }
  getContext() {
    throw new Error("\u4E0D\u652F\u6301getContext");
  }
  setTransformForCurrent(force = false) {
    !force && this.applyedMatrix.equalToMatrix(this.matrix) || (this.applyedMatrix = this.cloneMatrix(this.matrix));
  }
  get currentMatrix() {
    return this.matrix;
  }
  cloneMatrix(m4) {
    return matrixAllocate.allocateByObj(m4);
  }
  clear() {
    this.save(), this.resetTransform(), this.restore();
  }
  restore() {
    this.stack.length > 0 && (matrixAllocate.free(this.matrix), this.matrix = this.stack.pop(), this.setTransformForCurrent());
  }
  highPerformanceRestore() {
    this.stack.length > 0 && (matrixAllocate.free(this.matrix), this.matrix = this.stack.pop());
  }
  rotate(rad, setTransform = true) {
    this.matrix.rotate(rad), setTransform && this.setTransformForCurrent();
  }
  save() {
    const matrix = this.cloneMatrix(this.matrix);
    this.stack.push(matrix);
  }
  highPerformanceSave() {
    const matrix = this.cloneMatrix(this.matrix);
    this.stack.push(matrix);
  }
  scale(sx, sy, setTransform = true) {
    this.matrix.scale(sx, sy), setTransform && this.setTransformForCurrent();
  }
  setScale(sx, sy, setTransform = true) {
    this.matrix.setScale(sx, sy), setTransform && this.setTransformForCurrent();
  }
  scalePoint(sx, sy, px, py, setTransform = true) {
    this.translate(px, py, false), this.scale(sx, sy, false), this.translate(-px, -py, false), setTransform && this.setTransformForCurrent();
  }
  setTransform(a3, b, c3, d, e, f, setTransform = true, dpr = this.dpr) {
    this.matrix.setValue(dpr * a3, dpr * b, dpr * c3, dpr * d, dpr * e, dpr * f), setTransform && this.setTransformForCurrent();
  }
  setTransformFromMatrix(matrix, setTransform = true, dpr = this.dpr) {
    this.matrix.setValue(matrix.a * dpr, matrix.b * dpr, matrix.c * dpr, matrix.d * dpr, matrix.e * dpr, matrix.f * dpr), setTransform && this.setTransformForCurrent();
  }
  resetTransform(setTransform = true, dpr = this.dpr) {
    this.setTransform(dpr, 0, 0, dpr, 0, 0), setTransform && this.setTransformForCurrent();
  }
  transform(a3, b, c3, d, e, f, setTransform = true) {
    this.matrix.multiply(a3, b, c3, d, e, f), setTransform && this.setTransformForCurrent();
  }
  transformFromMatrix(matrix, setTransform) {
    this.matrix.multiply(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f), setTransform && this.setTransformForCurrent();
  }
  translate(x, y, setTransform = true) {
    this.matrix.translate(x, y), setTransform && this.setTransformForCurrent();
  }
  rotateDegrees(deg, setTransform = true) {
    const rad = deg * Math.PI / 180;
    this.rotate(rad, setTransform);
  }
  rotateAbout(rad, x, y, setTransform = true) {
    this.translate(x, y, false), this.rotate(rad, false), this.translate(-x, -y, false), setTransform && this.setTransformForCurrent();
  }
  rotateDegreesAbout(deg, x, y, setTransform = true) {
    this.translate(x, y, false), this.rotateDegrees(deg, false), this.translate(-x, -y, false), setTransform && this.setTransformForCurrent();
  }
  beginPath() {
    this.path.clear();
  }
  clip(path, fillRule) {
  }
  arc(x, y, radius, startAngle, endAngle, anticlockwise) {
    this.path.arc(x, y, radius, startAngle, endAngle, anticlockwise);
  }
  arcTo(x14, y14, x23, y23, radiusX) {
    this.path.arcTo(x14, y14, x23, y23, radiusX);
  }
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
    this.path.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
  }
  closePath() {
    this.path.closePath();
  }
  ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
  }
  lineTo(x, y) {
    this.path.lineTo(x, y);
  }
  moveTo(x, y) {
    this.path.moveTo(x, y);
  }
  quadraticCurveTo(cpx, cpy, x, y) {
    this.path.quadraticCurveTo(cpx, cpy, x, y);
  }
  rect(x, y, w, h) {
    this.path.rect(x, y, w, h);
  }
  createImageData(imageDataOrSw, sh) {
    return null;
  }
  createLinearGradient(x05, y05, x14, y14) {
    throw new Error("\u4E0D\u652F\u6301createLinearGradient");
  }
  createPattern(image, repetition) {
    throw new Error("\u4E0D\u652F\u6301createPattern");
  }
  createRadialGradient(x05, y05, r0, x14, y14, r1) {
    throw new Error("\u4E0D\u652F\u6301createRadialGradient");
  }
  createConicGradient(x, y, startAngle, endAngle) {
    return null;
  }
  fill(path, fillRule) {
  }
  fillRect(x, y, width, height) {
    this.path.rect(x, y, width, height);
  }
  clearRect(x, y, w, h) {
  }
  fillText(text2, x, y) {
  }
  getImageData(sx, sy, sw, sh) {
    return null;
  }
  getLineDash() {
    return [];
  }
  isPointInPath(x, y) {
    return this.matrix.transformPoint({
      x,
      y
    }, globalPoint), contain(this.path.commandList, globalPoint.x, globalPoint.y);
  }
  isPointInStroke(x, y) {
    if (!this.lineWidth)
      return false;
    this.matrix.transformPoint({
      x,
      y
    }, globalPoint);
    const lineWidth = getScaledStroke(this, this.lineWidth, this.dpr);
    return containStroke(this.path.commandList, lineWidth, globalPoint.x, globalPoint.y);
  }
  measureText(text2) {
    throw new Error("\u4E0D\u652F\u6301measureText");
  }
  putImageData(imagedata, dx, dy) {
    throw new Error("\u4E0D\u652F\u6301measureText");
  }
  setLineDash(segments2) {
  }
  stroke(path) {
  }
  strokeRect(x, y, width, height) {
    this.path.rect(x, y, width, height);
  }
  strokeText(text2, x, y) {
  }
  drawImage() {
  }
  setCommonStyle(params2, attribute, offsetX, offsetY, defaultParams) {
  }
  _setCommonStyle(params2, offsetX, offsetY, defaultParams) {
  }
  setStrokeStyle(params2, attribute, offsetX, offsetY, defaultParams) {
  }
  _setStrokeStyle(params2, offsetX, offsetY, defaultParams) {
  }
  setTextStyleWithoutAlignBaseline(params2, defaultParams) {
  }
  setTextStyle(params2, defaultParams) {
  }
  draw() {
  }
  clearMatrix(setTransform = true, dpr = this.dpr) {
    this.setTransformFromMatrix(initMatrix, setTransform, dpr);
  }
  setClearMatrix(a3, b, c3, d, e, f) {
    this._clearMatrix.setValue(a3, b, c3, d, e, f);
  }
  onlyTranslate(dpr = this.dpr) {
    return this.matrix.a === dpr && 0 === this.matrix.b && 0 === this.matrix.c && this.matrix.d === dpr;
  }
  release(...params2) {
    this.stack.forEach((m4) => matrixAllocate.free(m4)), this.stack.length = 0;
  }
};
EmptyContext2d = __decorate33([injectable(), __metadata25("design:paramtypes", [Object, Number])], EmptyContext2d);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/canvas/contributions/base-canvas
var __decorate34 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata26 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var DefaultConfig2 = {
  WIDTH: 500,
  HEIGHT: 500,
  DPR: 1
};
var BaseCanvas = class {
  get displayWidth() {
    return this._pixelWidth / this._dpr;
  }
  get displayHeight() {
    return this._pixelHeight / this._dpr;
  }
  get id() {
    return this._id;
  }
  get x() {
    return this._x;
  }
  set x(_x) {
    this._x = _x;
  }
  get y() {
    return this._y;
  }
  set y(_y) {
    this._y = _y;
  }
  get nativeCanvas() {
    return this._nativeCanvas;
  }
  get width() {
    return this._pixelWidth;
  }
  set width(width) {
    this._pixelWidth = width, this._displayWidth = width / (this._dpr || 1);
  }
  get height() {
    return this._pixelHeight;
  }
  set height(height) {
    this._pixelHeight = height, this._displayHeight = height / (this._dpr || 1);
  }
  getContext(str) {
    return this._context;
  }
  get visiable() {
    return this._visiable;
  }
  set visiable(visiable) {
    this._visiable = visiable, visiable ? this.show() : this.hide();
  }
  get dpr() {
    return this._dpr;
  }
  set dpr(dpr) {
    this._dpr = dpr, this.resize(this._displayWidth, this._displayHeight);
  }
  constructor(params2) {
    var _a;
    const { nativeCanvas, width = DefaultConfig2.WIDTH, height = DefaultConfig2.HEIGHT, dpr = DefaultConfig2.DPR, x, y, id: id2, canvasControled = true } = params2;
    this._x = null != x ? x : 0, this._y = null != y ? y : 0, this._pixelWidth = width * dpr, this._pixelHeight = height * dpr, this._visiable = false !== params2.visiable, this.controled = canvasControled, this._displayWidth = width, this._displayHeight = height, this._dpr = dpr, this._nativeCanvas = nativeCanvas, this._id = null !== (_a = nativeCanvas.id) && void 0 !== _a ? _a : id2, id2 && (nativeCanvas.id = id2), this.init(params2);
  }
  getNativeCanvas() {
    return this._nativeCanvas;
  }
  hide() {
  }
  show() {
  }
  applyPosition() {
  }
  resetStyle(params2) {
  }
  resize(width, height) {
  }
  toDataURL(mimeType, quality) {
    return "";
  }
  readPixels(x, y, w, h) {
    return this._context.getImageData(x, y, w, h);
  }
  convertToBlob(options) {
    throw new Error("\u6682\u672A\u5B9E\u73B0");
  }
  transferToImageBitmap() {
    throw new Error("\u6682\u672A\u5B9E\u73B0");
  }
  release(...params2) {
    this.controled && this._nativeCanvas.parentElement && this._nativeCanvas.parentElement.removeChild(this._nativeCanvas);
  }
};
BaseCanvas.env = "browser", BaseCanvas = __decorate34([injectable(), __metadata26("design:paramtypes", [Object])], BaseCanvas);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/core/contributions/env/base-contribution
var __decorate35 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var BaseEnvContribution = class {
  configure(service, ...p) {
    service.env === this.type && service.setActiveEnvContribution(this);
  }
  getNativeAABBBounds(dom) {
    return new AABBBounds();
  }
  removeDom(dom) {
    return false;
  }
  createDom(params2) {
    return null;
  }
  updateDom(dom, params2) {
    return false;
  }
  getDynamicCanvasCount() {
    return 999;
  }
  getStaticCanvasCount() {
    return 999;
  }
  getElementById(str) {
    return document.getElementById(str);
  }
  getRootElement() {
    return document.body;
  }
  loadJson(url) {
    const jsonPromise = fetch(url).then((data) => data.json());
    return jsonPromise.then((json) => ({
      data: json,
      state: "success"
    })).catch(() => ({
      data: null,
      state: "fail"
    })), jsonPromise;
  }
  loadArrayBuffer(url) {
    return fetch(url).then((data) => data.arrayBuffer()).then((arrayBuffer) => ({
      data: arrayBuffer,
      loadState: "success"
    })).catch(() => ({
      data: null,
      loadState: "fail"
    }));
  }
  loadBlob(url) {
    return fetch(url).then((data) => data.blob()).then((blob) => ({
      data: blob,
      loadState: "success"
    })).catch(() => ({
      data: null,
      loadState: "fail"
    }));
  }
  getElementTop(dom, baseWindow) {
    return 0;
  }
  getElementLeft(dom, baseWindow) {
    return 0;
  }
  getElementTopLeft(dom, baseWindow) {
    return {
      top: 0,
      left: 0
    };
  }
};
BaseEnvContribution = __decorate35([injectable()], BaseEnvContribution);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/core/contributions/window/base-contribution
var __decorate36 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata27 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var BaseWindowHandlerContribution = class {
  constructor() {
    this._uid = Generator.GenAutoIncrementId(), this.viewBox = new AABBBounds(), this.modelMatrix = new Matrix(1, 0, 0, 1, 0, 0);
  }
  onChange(cb) {
    this._onChangeCb = cb;
  }
  configure(window2, global) {
    global.env === this.type && window2.setWindowHandler(this);
  }
  release(...params2) {
    this.releaseWindow();
  }
  isVisible(bbox) {
    return true;
  }
  onVisibleChange(cb) {
  }
  getTopLeft(baseWindow) {
    return {
      top: 0,
      left: 0
    };
  }
  setViewBox(vb) {
    this.viewBox.setValue(vb.x1, vb.y1, vb.x2, vb.y2);
  }
  getViewBox() {
    return this.viewBox;
  }
  setViewBoxTransform(a3, b, c3, d, e, f) {
    this.modelMatrix.setValue(a3, b, c3, d, e, f);
  }
  getViewBoxTransform() {
    return this.modelMatrix;
  }
};
BaseWindowHandlerContribution = __decorate36([injectable(), __metadata27("design:paramtypes", [])], BaseWindowHandlerContribution);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/picker/picker-service
var __decorate37 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata28 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param19 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultPickService = class {
  constructor(pickItemInterceptorContributions) {
    this.pickItemInterceptorContributions = pickItemInterceptorContributions, this.type = "default", this.global = application.global;
  }
  _init() {
    this.InterceptorContributions = this.pickItemInterceptorContributions.getContributions().sort((a3, b) => a3.order - b.order);
  }
  pick(graphics, point5, params2) {
    let result2 = {
      graphic: null,
      group: null
    };
    params2.pickerService = this;
    const w = params2.bounds.width(), h = params2.bounds.height();
    if (!new AABBBounds().setValue(0, 0, w, h).containsPoint(point5))
      return result2;
    this.pickContext && (this.pickContext.inuse = true), params2.pickContext = this.pickContext, this.pickContext && this.pickContext.clearMatrix(true, 1);
    const parentMatrix = new Matrix(1, 0, 0, 1, 0, 0);
    let group;
    for (let i = graphics.length - 1; i >= 0 && (result2 = graphics[i].isContainer ? this.pickGroup(graphics[i], point5, parentMatrix, params2) : this.pickItem(graphics[i], point5, parentMatrix, params2), !result2.graphic); i--)
      group || (group = result2.group);
    if (result2.graphic || (result2.group = group), this.pickContext && (this.pickContext.inuse = false), result2.graphic) {
      let g = result2.graphic;
      for (; g.parent; )
        g = g.parent;
      g.shadowHost && (result2.params = {
        shadowTarget: result2.graphic
      }, result2.graphic = g.shadowHost);
    }
    return result2;
  }
  containsPoint(graphic, point5, params2) {
    var _a;
    return !!(null === (_a = this.pickItem(graphic, point5, null, null != params2 ? params2 : {
      pickContext: this.pickContext,
      pickerService: this
    })) || void 0 === _a ? void 0 : _a.graphic);
  }
  pickGroup(group, point5, parentMatrix, params2) {
    let result2 = {
      group: null,
      graphic: null
    };
    if (false === group.attribute.visibleAll)
      return result2;
    const context = params2.pickContext, lastMatrix = context.modelMatrix;
    if (context.camera) {
      const m4 = group.transMatrix, matrix = mat4Allocate.allocate();
      if (mat3Tomat4(matrix, m4), lastMatrix) {
        if (matrix) {
          const m5 = mat4Allocate.allocate();
          context.modelMatrix = multiplyMat4Mat4(m5, lastMatrix, matrix), mat4Allocate.free(matrix);
        }
      } else
        mat3Tomat4(matrix, group.globalTransMatrix), context.modelMatrix = matrix;
    }
    if (this.InterceptorContributions.length)
      for (let i = 0; i < this.InterceptorContributions.length; i++) {
        const drawContribution = this.InterceptorContributions[i];
        if (drawContribution.beforePickItem) {
          const result3 = drawContribution.beforePickItem(group, this, point5, params2, {
            parentMatrix
          });
          if (result3)
            return context.modelMatrix !== lastMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastMatrix, result3;
        }
      }
    const transMatrix = group.transMatrix, currentGroupMatrix = matrixAllocate.allocateByObj(parentMatrix), newPoint = new Point(point5.x, point5.y);
    currentGroupMatrix.transformPoint(newPoint, newPoint);
    const insideGroup = group.AABBBounds.containsPoint(newPoint);
    if (!insideGroup && !group.stage.camera)
      return result2;
    const pickedItem = this.pickItem(group, newPoint.clone(), parentMatrix, params2);
    pickedItem && pickedItem.graphic && (result2.graphic = pickedItem.graphic, result2.params = pickedItem.params);
    const groupPicked = false !== group.attribute.pickable && insideGroup;
    return currentGroupMatrix.multiply(transMatrix.a, transMatrix.b, transMatrix.c, transMatrix.d, transMatrix.e, transMatrix.f), false === group.attribute.childrenPickable || pickedItem && pickedItem.graphic || foreach(group, DefaultAttribute.zIndex, (graphic) => {
      if (graphic.isContainer) {
        const newPoint2 = new Point(point5.x, point5.y), theme2 = getTheme(group).group, { scrollX = theme2.scrollX, scrollY = theme2.scrollY } = group.attribute;
        newPoint2.x -= scrollX, newPoint2.y -= scrollY, result2 = this.pickGroup(graphic, newPoint2, currentGroupMatrix, params2);
      } else {
        const newPoint2 = new Point(point5.x, point5.y);
        currentGroupMatrix.transformPoint(newPoint2, newPoint2);
        const theme2 = getTheme(group).group, { scrollX = theme2.scrollX, scrollY = theme2.scrollY } = group.attribute;
        newPoint2.x -= scrollX, newPoint2.y -= scrollY;
        const pickedItem2 = this.pickItem(graphic, newPoint2, parentMatrix, params2);
        pickedItem2 && pickedItem2.graphic && (result2.graphic = pickedItem2.graphic, result2.params = pickedItem2.params);
      }
      return !!result2.graphic || !!result2.group;
    }, true, !!context.camera), context.modelMatrix !== lastMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastMatrix, result2.graphic || result2.group || !groupPicked || group.stage.camera || (result2.group = group), matrixAllocate.free(currentGroupMatrix), result2;
  }
  selectPicker(graphic) {
    const picker = this.pickerMap.get(graphic.numberType);
    return picker || null;
  }
};
DefaultPickService = __decorate37([injectable(), __param19(0, inject(ContributionProvider)), __param19(0, named(PickItemInterceptor)), __metadata28("design:paramtypes", [Object])], DefaultPickService);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/picker/global-picker-service
var __decorate38 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata29 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var DefaultGlobalPickerService = class {
  constructor() {
    this.global = application.global, this.global.hooks.onSetEnv.tap("global-picker-service", (lastEnv, env, global) => {
      this.configure(global, env);
    }), this.configure(this.global, this.global.env);
  }
  configure(global, env) {
  }
  pick(graphics, point5, params2) {
    let result2 = {
      graphic: null,
      group: null
    };
    const parentMatrix = new Matrix(1, 0, 0, 1, 0, 0);
    let group;
    for (let i = 0; i < graphics.length; i++) {
      if (graphics[i].isContainer)
        result2 = this.pickGroup(graphics[i], point5, parentMatrix, params2);
      else {
        const data = this.pickItem(graphics[i], point5, parentMatrix, params2);
        data && (result2.graphic = data.graphic, result2.params = data.params);
      }
      if (result2.graphic)
        break;
      group || (group = result2.group);
    }
    if (result2.graphic || (result2.group = group), result2.graphic) {
      let g = result2.graphic;
      for (; g.parent; )
        g = g.parent;
      g.shadowHost && (result2.params = {
        shadowTarget: result2.graphic
      }, result2.graphic = g.shadowHost);
    }
    return result2;
  }
  containsPoint(graphic, point5, params2) {
    return !!this.pickItem(graphic, point5, null, params2);
  }
  pickGroup(group, point5, parentMatrix, params2) {
    let result2 = {
      group: null,
      graphic: null
    };
    if (false === group.attribute.visibleAll)
      return result2;
    const transMatrix = group.transMatrix, newPoint = new Point(point5.x, point5.y);
    parentMatrix.transformPoint(newPoint, newPoint);
    const insideGroup = group.AABBBounds.containsPoint(newPoint);
    if (!insideGroup)
      return result2;
    const groupPicked = false !== group.attribute.pickable && insideGroup;
    return parentMatrix.multiply(transMatrix.a, transMatrix.b, transMatrix.c, transMatrix.d, transMatrix.e, transMatrix.f), false !== group.attribute.childrenPickable && group.forEachChildren((graphic) => {
      if (graphic.isContainer)
        result2 = this.pickGroup(graphic, point5, parentMatrix, params2);
      else {
        const newPoint2 = new Point(point5.x, point5.y);
        parentMatrix.transformPoint(newPoint2, newPoint2);
        const data = this.pickItem(graphic, newPoint2, parentMatrix, params2);
        data && (result2.graphic = data.graphic, result2.params = data.params);
      }
      return !!result2.graphic || !!result2.group;
    }), result2.graphic || result2.group || !groupPicked || (result2.group = group), result2;
  }
  pickItem(graphic, point5, parentMatrix, params2) {
    return false === graphic.attribute.pickable ? null : graphic.AABBBounds.containsPoint(point5) ? {
      graphic
    } : null;
  }
};
DefaultGlobalPickerService = __decorate38([injectable(), __metadata29("design:paramtypes", [])], DefaultGlobalPickerService);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/common/simplify
function simplifyRadialDist(points, sqTolerance) {
  let deltaX, deltaY, lastX = points[0].x, lastY = points[0].y;
  const newPoints = [points[0]];
  for (let i = 1, len = points.length; i < len; i++)
    deltaX = points[i].x - lastX, deltaY = points[i].y - lastY, deltaX * deltaX + deltaY * deltaY > sqTolerance && (lastX = points[i].x, lastY = points[i].y, newPoints.push(points[i]));
  return points[points.length - 1].x === lastX && points[points.length - 1].y === lastY || newPoints.push(points[points.length - 1]), newPoints;
}
function simplifyDPStep(points, startIdx, endIdx, sqTolerance, simplified) {
  let maxSqDist = sqTolerance, nextIdx = startIdx;
  const startX = points[startIdx].x, startY = points[startIdx].y, vecX2 = points[endIdx].x - startX, vecY2 = points[endIdx].y - startY, sqLength = vecX2 * vecX2 + vecY2 * vecY2;
  let area2, sqArea, sqDistance, vecX1, vecY1;
  for (let i = startIdx + 1, len = endIdx - 1; i < len; i++)
    vecX1 = points[i].x - startX, vecY1 = points[i].y - startY, area2 = vecX1 * vecY2 - vecX2 * vecY1, sqArea = area2 * area2, sqDistance = sqArea / sqLength, sqDistance > maxSqDist && (maxSqDist = sqDistance, nextIdx = i);
  maxSqDist > sqTolerance && (nextIdx - startIdx > 2 && simplifyDPStep(points, startIdx, nextIdx, sqTolerance, simplified), simplified.push(points[nextIdx], points[nextIdx + 1]), endIdx - nextIdx > 2 && simplifyDPStep(points, nextIdx, endIdx, sqTolerance, simplified));
}
function simplifyDouglasPeucker(points, sqTolerance) {
  const lastIdx = points.length - 1, simplified = [points[0]];
  return simplifyDPStep(points, 0, lastIdx, sqTolerance, simplified), simplified.push(points[lastIdx]), simplified;
}
function flatten_simplify(points, tolerance, highestQuality) {
  if (points.length <= 10)
    return points;
  const sqTolerance = void 0 !== tolerance ? tolerance * tolerance : 1;
  return points = simplifyDouglasPeucker(points = highestQuality ? points : simplifyRadialDist(points, sqTolerance), sqTolerance);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/allocator/graphic-allocate
var DefaultGraphicAllocate = class {
  constructor() {
    this.pools = [];
  }
  free(d) {
    this.pools.push(d);
  }
  get length() {
    return this.pools.length;
  }
  release(...params2) {
    this.pools = [];
  }
};
var DefaultRectAllocate = class extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length)
      return application.graphicService.creator.rect(attribute);
    const g = this.pools.pop();
    return g.initAttributes(attribute), g;
  }
  allocateByObj(rect) {
    if (!this.pools.length)
      return application.graphicService.creator.rect(rect.attribute);
    const g = this.pools.pop();
    return g.initAttributes(rect.attribute), g;
  }
};
var defaultRectAllocate = new DefaultRectAllocate();
var DefaultArcAllocate = class extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length)
      return application.graphicService.creator.arc(attribute);
    const g = this.pools.pop();
    return g.initAttributes(attribute), g;
  }
  allocateByObj(arc) {
    if (!this.pools.length)
      return application.graphicService.creator.arc(arc.attribute);
    const g = this.pools.pop();
    return g.initAttributes(arc.attribute), g;
  }
};
var defaultArcAllocate = new DefaultArcAllocate();
var DefaultAreaAllocate = class extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length)
      return application.graphicService.creator.area(attribute);
    const g = this.pools.pop();
    return g.initAttributes(attribute), g;
  }
  allocateByObj(area2) {
    if (!this.pools.length)
      return application.graphicService.creator.area(area2.attribute);
    const g = this.pools.pop();
    return g.initAttributes(area2.attribute), g;
  }
};
var defaultAreaAllocate = new DefaultAreaAllocate();
var DefaultCircleAllocate = class extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length)
      return application.graphicService.creator.circle(attribute);
    const g = this.pools.pop();
    return g.initAttributes(attribute), g;
  }
  allocateByObj(area2) {
    if (!this.pools.length)
      return application.graphicService.creator.circle(area2.attribute);
    const g = this.pools.pop();
    return g.initAttributes(area2.attribute), g;
  }
};
var defaultCircleAllocate = new DefaultCircleAllocate();
var DefaultLineAllocate = class extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length)
      return application.graphicService.creator.line(attribute);
    const g = this.pools.pop();
    return g.initAttributes(attribute), g;
  }
  allocateByObj(line2) {
    if (!this.pools.length)
      return application.graphicService.creator.line(line2.attribute);
    const g = this.pools.pop();
    return g.initAttributes(line2.attribute), g;
  }
};
var defaultLineAllocate = new DefaultLineAllocate();
var DefaultPathAllocate = class extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length)
      return application.graphicService.creator.path(attribute);
    const g = this.pools.pop();
    return g.initAttributes(attribute), g;
  }
  allocateByObj(path) {
    if (!this.pools.length)
      return application.graphicService.creator.path(path.attribute);
    const g = this.pools.pop();
    return g.initAttributes(path.attribute), g;
  }
};
var defaultPathAllocate = new DefaultPathAllocate();
var DefaultSymbolAllocate = class extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length)
      return application.graphicService.creator.symbol(attribute);
    const g = this.pools.pop();
    return g.initAttributes(attribute), g;
  }
  allocateByObj(symbol) {
    if (!this.pools.length)
      return application.graphicService.creator.symbol(symbol.attribute);
    const g = this.pools.pop();
    return g.initAttributes(symbol.attribute), g;
  }
};
var defaultSymbolAllocate = new DefaultSymbolAllocate();
var DefaultTextAllocate = class extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length)
      return application.graphicService.creator.text(attribute);
    const g = this.pools.pop();
    return g.initAttributes(attribute), g;
  }
  allocateByObj(text2) {
    if (!this.pools.length)
      return application.graphicService.creator.text(text2.attribute);
    const g = this.pools.pop();
    return g.initAttributes(text2.attribute), g;
  }
};
var defaultTextAllocate = new DefaultTextAllocate();
var DefaultGraphicMemoryManager = class {
  constructor() {
    this.map = {
      text: defaultTextAllocate,
      symbol: defaultSymbolAllocate
    };
  }
  gc(g) {
    g.isContainer ? g.forEachChildren((i) => this.gc(i)) : this.gcItem(g);
  }
  gcItem(g) {
    const allocate = this.map[g.type];
    allocate && allocate.free(g);
  }
};
var defaultGraphicMemoryManager = new DefaultGraphicMemoryManager();

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/arc-module
var loadArcModule = false;
var arcModule = new ContainerModule((bind) => {
  loadArcModule || (loadArcModule = true, bind(DefaultCanvasArcRender).toSelf().inSingletonScope(), bind(ArcRender).to(DefaultCanvasArcRender).inSingletonScope(), bind(GraphicRender).toService(ArcRender), bind(ArcRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, ArcRenderContribution));
});

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/rect-module
var loadRectModule = false;
var rectModule = new ContainerModule((bind) => {
  loadRectModule || (loadRectModule = true, bind(DefaultCanvasRectRender).toSelf().inSingletonScope(), bind(RectRender).to(DefaultCanvasRectRender).inSingletonScope(), bind(GraphicRender).toService(RectRender), bind(SplitRectAfterRenderContribution).toSelf(), bind(SplitRectBeforeRenderContribution).toSelf(), bind(RectRenderContribution).toService(SplitRectAfterRenderContribution), bind(RectRenderContribution).toService(SplitRectBeforeRenderContribution), bind(RectRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, RectRenderContribution));
});

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/line-module
var loadLineModule = false;
var lineModule = new ContainerModule((bind) => {
  loadLineModule || (loadLineModule = true, bind(DefaultCanvasLineRender).toSelf().inSingletonScope(), bind(DefaultIncrementalCanvasLineRender).toSelf().inSingletonScope(), bind(LineRender).to(DefaultCanvasLineRender).inSingletonScope(), bind(GraphicRender).toService(LineRender));
});

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/area-module
var loadAreaModule = false;
var areaModule = new ContainerModule((bind) => {
  loadAreaModule || (loadAreaModule = true, bind(DefaultCanvasAreaRender).toSelf().inSingletonScope(), bind(AreaRender).to(DefaultCanvasAreaRender).inSingletonScope(), bind(GraphicRender).toService(AreaRender), bind(AreaRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, AreaRenderContribution), bind(DefaultIncrementalCanvasAreaRender).toSelf().inSingletonScope());
});

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/symbol-module
var loadSymbolModule = false;
var symbolModule = new ContainerModule((bind) => {
  loadSymbolModule || (loadSymbolModule = true, bind(DefaultCanvasSymbolRender).toSelf().inSingletonScope(), bind(SymbolRender).to(DefaultCanvasSymbolRender).inSingletonScope(), bind(GraphicRender).toService(SymbolRender), bind(SymbolRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, SymbolRenderContribution));
});

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/circle-module
var loadCircleModule = false;
var circleModule = new ContainerModule((bind) => {
  loadCircleModule || (loadCircleModule = true, bind(DefaultCanvasCircleRender).toSelf().inSingletonScope(), bind(CircleRender).to(DefaultCanvasCircleRender).inSingletonScope(), bind(GraphicRender).toService(CircleRender), bind(CircleRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, CircleRenderContribution));
});

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/text-module
var loadTextModule = false;
var textModule = new ContainerModule((bind) => {
  loadTextModule || (loadTextModule = true, bind(TextRender).to(DefaultCanvasTextRender).inSingletonScope(), bind(GraphicRender).toService(TextRender), bind(TextRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, TextRenderContribution));
});

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/path-module
var loadPathModule = false;
var pathModule = new ContainerModule((bind) => {
  loadPathModule || (loadPathModule = true, bind(DefaultCanvasPathRender).toSelf().inSingletonScope(), bind(PathRender).to(DefaultCanvasPathRender).inSingletonScope(), bind(GraphicRender).toService(PathRender), bind(PathRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, PathRenderContribution));
});

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/polygon-module
var loadPolygonModule = false;
var polygonModule = new ContainerModule((bind) => {
  loadPolygonModule || (loadPolygonModule = true, bind(PolygonRender).to(DefaultCanvasPolygonRender).inSingletonScope(), bind(GraphicRender).toService(PolygonRender), bind(PolygonRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, PolygonRenderContribution));
});

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/glyph-render
var __decorate39 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultCanvasGlyphRender = class {
  constructor() {
    this.numberType = GLYPH_NUMBER_TYPE;
  }
  drawShape(glyph, context, x, y, drawContext, params2, fillCb, strokeCb) {
    drawContext.drawContribution && glyph.getSubGraphic().forEach((item) => {
      const renderer = drawContext.drawContribution.getRenderContribution(item);
      renderer && renderer.drawShape && renderer.drawShape(item, context, x, y, drawContext, params2, fillCb, strokeCb);
    });
  }
  draw(glyph, renderService, drawContext, params2) {
    const { context } = drawContext;
    if (!context)
      return;
    if (context.highPerformanceSave(), !drawContext.drawContribution)
      return;
    const glyphTheme = getTheme(glyph), subGraphic = glyph.getSubGraphic();
    subGraphic.length && subGraphic.forEach((g) => {
      drawContext.drawContribution.renderItem(g, drawContext, {
        theme: glyphTheme
      });
    }), context.highPerformanceRestore();
  }
};
DefaultCanvasGlyphRender = __decorate39([injectable()], DefaultCanvasGlyphRender);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/glyph-module
var loadGlyphModule = false;
var glyphModule = new ContainerModule((bind) => {
  loadGlyphModule || (loadGlyphModule = true, bind(GlyphRender).to(DefaultCanvasGlyphRender).inSingletonScope(), bind(GraphicRender).toService(GlyphRender));
});

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/richtext-render
var __decorate40 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata30 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var DefaultCanvasRichTextRender = class extends BaseRender {
  constructor() {
    super(), this.numberType = RICHTEXT_NUMBER_TYPE, this.builtinContributions = [defaultTextBackgroundRenderContribution], this.init();
  }
  drawShape(richtext, context, x, y, drawContext) {
    const richtextAttribute = getTheme(richtext).richtext, { strokeOpacity = richtextAttribute.strokeOpacity, opacity = richtextAttribute.opacity, fillOpacity = richtextAttribute.fillOpacity, visible = richtextAttribute.visible } = richtext.attribute;
    if (!richtext.valid || !visible)
      return;
    const fVisible = fillVisible(opacity, fillOpacity, true), sVisible = fillVisible(opacity, strokeOpacity, true);
    if (!fVisible)
      return;
    context.translate(x, y), this.beforeRenderStep(richtext, context, x, y, fVisible, sVisible, fVisible, sVisible, richtextAttribute, drawContext);
    richtext.getFrameCache().draw(context, this.drawIcon), this.afterRenderStep(richtext, context, x, y, fVisible, sVisible, fVisible, sVisible, richtextAttribute, drawContext);
  }
  drawIcon(icon, context, x, y, baseline) {
    var _a;
    const richtextIconAttribute = getTheme(icon).richtextIcon, { width = richtextIconAttribute.width, height = richtextIconAttribute.height, opacity = richtextIconAttribute.opacity, image: url, backgroundFill = richtextIconAttribute.backgroundFill, backgroundFillOpacity = richtextIconAttribute.backgroundFillOpacity, backgroundStroke = richtextIconAttribute.backgroundStroke, backgroundStrokeOpacity = richtextIconAttribute.backgroundStrokeOpacity, backgroundRadius = richtextIconAttribute.backgroundRadius, margin } = icon.attribute, { backgroundWidth = width, backgroundHeight = height } = icon.attribute;
    if (margin && (x += icon._marginArray[3], y += icon._marginArray[0]), icon._hovered) {
      const expandX = (backgroundWidth - width) / 2, expandY = (backgroundHeight - height) / 2;
      0 === backgroundRadius ? (context.beginPath(), context.rect(x - expandX, y - expandY, backgroundWidth, backgroundHeight)) : (context.beginPath(), createRectPath(context, x - expandX, y - expandY, backgroundWidth, backgroundHeight, backgroundRadius)), backgroundFill && (context.globalAlpha = backgroundFillOpacity, context.fillStyle = backgroundFill, context.fill()), backgroundStroke && (context.globalAlpha = backgroundStrokeOpacity, context.strokeStyle = backgroundStroke, context.stroke());
    }
    const res = url && (null === (_a = null == icon ? void 0 : icon.resources) || void 0 === _a ? void 0 : _a.get(url));
    res && "success" === res.state && (context.globalAlpha = opacity, context.drawImage(res.data, x, y, width, height));
  }
  draw(richtext, renderService, drawContext) {
    const richtextAttribute = getTheme(richtext).richtext;
    this._draw(richtext, richtextAttribute, false, drawContext);
  }
};
DefaultCanvasRichTextRender = __decorate40([injectable(), __metadata30("design:paramtypes", [])], DefaultCanvasRichTextRender);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/richtext-module
var loadRichtextModule = false;
var richtextModule = new ContainerModule((bind) => {
  loadRichtextModule || (loadRichtextModule = true, bind(RichTextRender).to(DefaultCanvasRichTextRender).inSingletonScope(), bind(GraphicRender).toService(RichTextRender));
});

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/image-module
var loadImageModule = false;
var imageModule = new ContainerModule((bind) => {
  loadImageModule || (loadImageModule = true, bind(ImageRender).to(DefaultCanvasImageRender).inSingletonScope(), bind(GraphicRender).toService(ImageRender), bind(ImageRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, ImageRenderContribution));
});

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/rect3d-render
var __decorate41 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultCanvasRect3dRender = class extends BaseRender {
  constructor() {
    super(...arguments), this.type = "rect3d", this.numberType = RECT3D_NUMBER_TYPE;
  }
  drawShape(rect, context, x, y, drawContext, params2, fillCb, strokeCb) {
    var _a;
    const rectAttribute = getTheme(rect, null == params2 ? void 0 : params2.theme).rect, { fill = rectAttribute.fill, stroke: stroke2 = rectAttribute.stroke, x1: x14, y1: y14, x: originX, y: originY, opacity = rectAttribute.opacity, fillOpacity = rectAttribute.fillOpacity, lineWidth = rectAttribute.lineWidth, strokeOpacity = rectAttribute.strokeOpacity, visible = rectAttribute.visible } = rect.attribute;
    let { width, height } = rect.attribute;
    width = (null != width ? width : x14 - originX) || 0, height = (null != height ? height : y14 - originY) || 0;
    const z = null !== (_a = this.z) && void 0 !== _a ? _a : 0, fVisible = rectFillVisible(opacity, fillOpacity, width, height, fill), sVisible = rectStrokeVisible(opacity, strokeOpacity, width, height), doFill = runFill(fill), doStroke = runStroke(stroke2, lineWidth);
    if (!rect.valid || !visible)
      return;
    if (!doFill && !doStroke)
      return;
    if (!(fVisible || sVisible || fillCb || strokeCb))
      return;
    const { light, camera } = drawContext.stage || {}, face3d = rect.findFace();
    if (false !== fill) {
      context.setCommonStyle(rect, rect.attribute, x, y, rectAttribute);
      let fc = fill;
      "string" != typeof fc && (fc = "black"), this.fill(x, y, z, face3d, fc, context, light, fillCb);
    }
    false !== stroke2 && (context.setStrokeStyle(rect, rect.attribute, x, y, rectAttribute), this.stroke(x, y, z, face3d, context));
  }
  stroke(x, y, z, face3d, context) {
    const vertices = face3d.vertices;
    face3d.edges.forEach((edge) => {
      const p1 = vertices[edge[0]], v1 = {
        x: x + p1[0],
        y: y + p1[1],
        z: z + p1[2]
      }, p2 = vertices[edge[1]], v2 = {
        x: x + p2[0],
        y: y + p2[1],
        z: z + p2[2]
      };
      context.beginPath(), context.moveTo(v1.x, v1.y, v1.z), context.lineTo(v2.x, v2.y, v2.z), context.stroke();
    });
  }
  fill(x, y, z, face3d, fillColor, context, light, fillCb) {
    const rgbArray = ColorStore.Get(fillColor, ColorType.Color255), vertices = face3d.vertices, viewdVerticesZ = vertices.map((v) => context.view(v[0], v[1], v[2])[2]), sortFace = [];
    face3d.polygons.forEach((p, i) => {
      sortFace.push({
        faceIdx: i,
        polygon: p
      });
      const { polygon, normal } = p, z1 = viewdVerticesZ[polygon[0]], z2 = viewdVerticesZ[polygon[1]], z3 = viewdVerticesZ[polygon[2]], z4 = viewdVerticesZ[polygon[3]];
      p.ave_z = z1 + z2 + z3 + z4;
    }), sortFace.sort((a3, b) => b.polygon.ave_z - a3.polygon.ave_z), sortFace.forEach((item) => {
      const { polygon, normal } = item.polygon, p1 = vertices[polygon[0]], p2 = vertices[polygon[1]], p3 = vertices[polygon[2]], p4 = vertices[polygon[3]], v1 = {
        x: x + p1[0],
        y: y + p1[1],
        z: z + p1[2]
      }, v2 = {
        x: x + p2[0],
        y: y + p2[1],
        z: z + p2[2]
      }, v3 = {
        x: x + p3[0],
        y: y + p3[1],
        z: z + p3[2]
      }, v4 = {
        x: x + p4[0],
        y: y + p4[1],
        z: z + p4[2]
      };
      context.beginPath(), context.moveTo(v1.x, v1.y, v1.z), context.lineTo(v2.x, v2.y, v2.z), context.lineTo(v3.x, v3.y, v3.z), context.lineTo(v4.x, v4.y, v4.z), context.closePath(), fillCb ? fillCb(context, null, null) : (context.fillStyle = light ? light.computeColor(normal, rgbArray) : fillColor, context.fill());
    });
  }
  draw(rect, renderService, drawContext) {
    const rectAttribute = getTheme(rect).rect;
    this._draw(rect, rectAttribute, false, drawContext);
  }
};
DefaultCanvasRect3dRender = __decorate41([injectable()], DefaultCanvasRect3dRender);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/rect3d-module
var loadRect3dModule = false;
var rect3dModule = new ContainerModule((bind) => {
  loadRect3dModule || (loadRect3dModule = true, bind(Rect3DRender).to(DefaultCanvasRect3dRender).inSingletonScope(), bind(GraphicRender).toService(Rect3DRender));
});

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/arc3d-render
var __decorate42 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
function drawArcPath2(arc, context, cx, cy, z, outerRadius, innerRadius) {
  const { startAngle, endAngle } = arc.getParsedAngle(), deltaAngle = abs(endAngle - startAngle), clockwise = endAngle > startAngle;
  let collapsedToLine = false;
  if (outerRadius < innerRadius) {
    const temp3 = outerRadius;
    outerRadius = innerRadius, innerRadius = temp3;
  }
  if (outerRadius <= epsilon)
    context.moveTo(cx, cy, z);
  else if (deltaAngle >= pi2 - epsilon)
    context.moveTo(cx + outerRadius * cos(startAngle), cy + outerRadius * sin(startAngle), z), context.arc(cx, cy, outerRadius, startAngle, endAngle, !clockwise, z), innerRadius > epsilon && (context.moveTo(cx + innerRadius * cos(endAngle), cy + innerRadius * sin(endAngle), z), context.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise, z));
  else {
    const { outerDeltaAngle, innerDeltaAngle, outerStartAngle, outerEndAngle, innerEndAngle, innerStartAngle } = arc.getParsePadAngle(startAngle, endAngle), xors = outerRadius * cos(outerStartAngle), yors = outerRadius * sin(outerStartAngle), xire = innerRadius * cos(innerEndAngle), yire = innerRadius * sin(innerEndAngle);
    outerDeltaAngle < 1e-3 ? collapsedToLine = true : (context.moveTo(cx + xors, cy + yors, z), context.arc(cx, cy, outerRadius, outerStartAngle, outerEndAngle, !clockwise, z)), !(innerRadius > epsilon) || innerDeltaAngle < 1e-3 ? (context.lineTo(cx + xire, cy + yire, z), collapsedToLine = true) : (context.lineTo(cx + xire, cy + yire, z), context.arc(cx, cy, innerRadius, innerEndAngle, innerStartAngle, clockwise, z));
  }
  return context.closePath(), collapsedToLine;
}
function drawInnerOuterArcPath(arc, context, cx, cy, z1, z2, radius, getParsePadAngle) {
  const { startAngle, endAngle } = arc.getParsedAngle(), deltaAngle = abs(endAngle - startAngle), clockwise = endAngle > startAngle;
  let collapsedToLine = false;
  if (radius <= epsilon)
    context.moveTo(cx, cy, z1);
  else if (deltaAngle >= pi2 - epsilon)
    context.moveTo(cx + radius * cos(startAngle), cy + radius * sin(startAngle), z1), context.arc(cx, cy, radius, startAngle, endAngle, !clockwise, z1), context.lineTo(cx + radius * cos(endAngle), cy + radius * sin(endAngle), z2), context.arc(cx, cy, radius, endAngle, startAngle, clockwise, z2);
  else {
    const { innerouterDeltaAngle, innerouterStartAngle, innerouterEndAngle } = getParsePadAngle(startAngle, endAngle), xors = radius * cos(innerouterStartAngle), yors = radius * sin(innerouterStartAngle), xore = radius * cos(innerouterEndAngle), yore = radius * sin(innerouterEndAngle);
    innerouterDeltaAngle < 1e-3 ? collapsedToLine = true : (context.moveTo(cx + xors, cy + yors, z1), context.arc(cx, cy, radius, innerouterStartAngle, innerouterEndAngle, !clockwise, z1), context.lineTo(cx + xore, cy + yore, z2), context.arc(cx, cy, radius, innerouterEndAngle, innerouterStartAngle, clockwise, z2));
  }
  return context.closePath(), collapsedToLine;
}
var DefaultCanvasArc3DRender = class extends BaseRender {
  constructor() {
    super(...arguments), this.numberType = ARC3D_NUMBER_TYPE;
  }
  drawShape(arc, context, x, y, drawContext, params2, fillCb, strokeCb) {
    var _a;
    const arcAttribute = getTheme(arc, null == params2 ? void 0 : params2.theme).arc, { fill = arcAttribute.fill } = arc.attribute, data = this.valid(arc, arcAttribute, fillCb, strokeCb);
    if (!data)
      return;
    const { fVisible, sVisible, doFill, doStroke } = data, z = null !== (_a = this.z) && void 0 !== _a ? _a : 0, { outerPadding = arcAttribute.outerPadding, innerPadding = arcAttribute.innerPadding, height = 10 } = arc.attribute;
    let { outerRadius = arcAttribute.outerRadius, innerRadius = arcAttribute.innerRadius } = arc.attribute;
    outerRadius += outerPadding, innerRadius -= innerPadding;
    const rgbArray = ColorStore.Get(fill, ColorType.Color255), { light } = drawContext.stage || {}, face = drawContext.hack_pieFace, z_face = {
      top: z,
      bottom: z + height
    }, n_face = {
      top: [0, 1, 0],
      bottom: [0, -1, 0],
      outside: [1, 0, -1],
      inside: [1, 0, -1]
    };
    "bottom" === face || "top" === face ? (context.beginPath(), drawArcPath2(arc, context, x, y, z_face[face], outerRadius, innerRadius), context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), doFill && (fillCb ? fillCb(context, arc.attribute, arcAttribute) : fVisible && (context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute), context.fillStyle = light ? light.computeColor(n_face[face], rgbArray) : fill, context.fill())), doStroke && (strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), context.stroke()))) : "outside" !== face && "inside" !== face || ("inside" === face && (context.save(), context.beginPath(), context.arc(x, y, innerRadius, 0, pi2, true, z_face.top), context.clip()), context.beginPath(), drawInnerOuterArcPath(arc, context, x, y, z_face.top, z_face.bottom, "outside" === face ? outerRadius : innerRadius, (startAngle, endAngle) => {
      const { outerDeltaAngle, innerDeltaAngle, outerStartAngle, outerEndAngle, innerEndAngle, innerStartAngle } = arc.getParsePadAngle(startAngle, endAngle);
      return "outside" === face ? {
        innerouterDeltaAngle: outerDeltaAngle,
        innerouterEndAngle: outerEndAngle,
        innerouterStartAngle: outerStartAngle
      } : {
        innerouterDeltaAngle: innerDeltaAngle,
        innerouterEndAngle: innerEndAngle,
        innerouterStartAngle: innerStartAngle
      };
    }), context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), doFill && (fillCb ? fillCb(context, arc.attribute, arcAttribute) : fVisible && (context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute), context.fillStyle = light ? light.computeColor(n_face[face], rgbArray) : fill, context.fill())), doStroke && (strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), context.stroke())), "inside" === face && context.restore());
  }
  draw(arc, renderService, drawContext, params2) {
    const arcAttribute = getTheme(arc, null == params2 ? void 0 : params2.theme).arc;
    this._draw(arc, arcAttribute, false, drawContext, params2);
  }
};
DefaultCanvasArc3DRender = __decorate42([injectable()], DefaultCanvasArc3DRender);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/arc3d-module
var loadArc3dModule = false;
var arc3dModule = new ContainerModule((bind) => {
  loadArc3dModule || (loadArc3dModule = true, bind(Arc3dRender).to(DefaultCanvasArc3DRender).inSingletonScope(), bind(GraphicRender).toService(Arc3dRender));
});

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/pyramid3d-render
var __decorate43 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultCanvasPyramid3dRender = class extends BaseRender {
  constructor() {
    super(...arguments), this.type = "pyramid3d", this.numberType = PYRAMID3D_NUMBER_TYPE;
  }
  drawShape(pyramid3d, context, x, y, drawContext, params2, fillCb, strokeCb) {
    var _a;
    const pyramidAttribute = getTheme(pyramid3d, null == params2 ? void 0 : params2.theme).polygon, { fill = pyramidAttribute.fill, stroke: stroke2 = pyramidAttribute.stroke, face = [true, true, true, true, true, true] } = pyramid3d.attribute, z = null !== (_a = this.z) && void 0 !== _a ? _a : 0;
    if (!this.valid(pyramid3d, pyramidAttribute, fillCb, strokeCb))
      return;
    const { light, camera } = drawContext.stage || {}, face3d = pyramid3d.findFace();
    if (false !== fill) {
      context.setCommonStyle(pyramid3d, pyramid3d.attribute, x, y, pyramidAttribute);
      let fc = fill;
      "string" != typeof fc && (fc = "black"), this.fill(x, y, z, face3d, face, fc, context, light, camera, pyramid3d, pyramidAttribute, fillCb);
    }
    false !== stroke2 && (context.setStrokeStyle(pyramid3d, pyramid3d.attribute, x, y, pyramidAttribute), this.stroke(x, y, z, face3d, context));
  }
  stroke(x, y, z, face3d, context) {
    const vertices = face3d.vertices;
    face3d.edges.forEach((p) => {
      const p1 = vertices[p[0]], p2 = vertices[p[1]], v1 = {
        x: x + p1[0],
        y: y + p1[1],
        z: z + p1[2]
      }, v2 = {
        x: x + p2[0],
        y: y + p2[1],
        z: z + p2[2]
      };
      context.beginPath(), context.moveTo(v1.x, v1.y, v1.z), context.lineTo(v2.x, v2.y, v2.z), context.stroke();
    });
  }
  fill(x, y, z, face3d, faces, fillColor, context, light, camera, pyramid3d, pyramid3dAttribute, fillCb) {
    const rgbArray = ColorStore.Get(fillColor, ColorType.Color255), vertices = face3d.vertices, viewdVerticesZ = vertices.map((v) => context.view(v[0], v[1], v[2])[2]), sortFace = [];
    face3d.polygons.forEach((p, i) => {
      if (!faces[i])
        return;
      sortFace.push({
        faceIdx: i,
        polygon: p
      });
      const { polygon, normal } = p, z1 = viewdVerticesZ[polygon[0]], z2 = viewdVerticesZ[polygon[1]], z3 = viewdVerticesZ[polygon[2]], z4 = viewdVerticesZ[polygon[3]];
      p.ave_z = z1 + z2 + z3 + z4;
    }), sortFace.sort((a3, b) => b.polygon.ave_z - a3.polygon.ave_z), sortFace.forEach((item) => {
      const { polygon, normal } = item.polygon, p1 = vertices[polygon[0]], p2 = vertices[polygon[1]], p3 = vertices[polygon[2]], p4 = vertices[polygon[3]], v1 = {
        x: x + p1[0],
        y: y + p1[1],
        z: z + p1[2]
      }, v2 = {
        x: x + p2[0],
        y: y + p2[1],
        z: z + p2[2]
      }, v3 = {
        x: x + p3[0],
        y: y + p3[1],
        z: z + p3[2]
      }, v4 = {
        x: x + p4[0],
        y: y + p4[1],
        z: z + p4[2]
      };
      context.beginPath(), context.moveTo(v1.x, v1.y, v1.z), context.lineTo(v2.x, v2.y, v2.z), context.lineTo(v3.x, v3.y, v3.z), context.lineTo(v4.x, v4.y, v4.z), context.closePath(), fillCb ? fillCb(context, pyramid3d.attribute, pyramid3dAttribute) : (context.fillStyle = light ? light.computeColor(normal, rgbArray) : fillColor, context.fill());
    });
  }
  draw(pyramid3d, renderService, drawContext) {
    const pyramid3dAttribute = getTheme(pyramid3d).polygon;
    this._draw(pyramid3d, pyramid3dAttribute, false, drawContext);
  }
};
DefaultCanvasPyramid3dRender = __decorate43([injectable()], DefaultCanvasPyramid3dRender);

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/render/contributions/render/pyramid3d-module
var loadPyramid3dModule = false;
var pyramid3dModule = new ContainerModule((bind) => {
  loadPyramid3dModule || (loadPyramid3dModule = true, bind(Pyramid3dRender).to(DefaultCanvasPyramid3dRender).inSingletonScope(), bind(GraphicRender).toService(Pyramid3dRender));
});

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/register/register-arc
function registerArcGraphic() {
  graphicCreator.RegisterGraphicCreator("arc", createArc);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/register/register-area
function registerAreaGraphic() {
  graphicCreator.RegisterGraphicCreator("area", createArea);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/register/register-circle
function registerCircleGraphic() {
  graphicCreator.RegisterGraphicCreator("circle", createCircle);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/register/register-group
function registerGroupGraphic() {
  graphicCreator.RegisterGraphicCreator("group", createGroup);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/register/register-image
function registerImageGraphic() {
  graphicCreator.RegisterGraphicCreator("image", createImage);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/register/register-line
function registerLineGraphic() {
  graphicCreator.RegisterGraphicCreator("line", createLine);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/register/register-path
function registerPathGraphic() {
  graphicCreator.RegisterGraphicCreator("path", createPath);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/register/register-polygon
function registerPolygonGraphic() {
  graphicCreator.RegisterGraphicCreator("polygon", createPolygon);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/register/register-rect
function registerRectGraphic() {
  graphicCreator.RegisterGraphicCreator("rect", createRect);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/register/register-richtext
function registerRichtextGraphic() {
  graphicCreator.RegisterGraphicCreator("richtext", createRichText);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/register/register-symbol
function registerSymbolGraphic() {
  graphicCreator.RegisterGraphicCreator("symbol", createSymbol);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/register/register-text
function registerTextGraphic() {
  graphicCreator.RegisterGraphicCreator("text", createText);
}

// http-url:https://unpkg.com/@visactor/vrender-core@0.19.9/es/register/register-shadowRoot
function registerShadowRootGraphic() {
  graphicCreator.RegisterGraphicCreator("shadowRoot", createShadowRoot);
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/util/debug
var warn = (msg, detail) => (isFunction_default(config.warnHandler) && config.warnHandler.call(null, msg, detail), detail ? Logger.getInstance().warn(`[VChart warn]: ${msg}`, detail) : Logger.getInstance().warn(`[VChart warn]: ${msg}`));
var error = (msg, detail, err) => {
  if (!config.silent) {
    if (!isFunction_default(config.errorHandler))
      throw new Error(msg);
    config.errorHandler.call(null, msg, detail);
  }
};
var config = {
  silent: false,
  warnHandler: false,
  errorHandler: false
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/util/env
var isBrowser = isBrowserEnv();
var domDocument = isBrowser && globalThis ? globalThis.document : void 0;
function isTrueBrowser(mode) {
  return ("desktop-browser" === mode || "mobile-browser" === mode) && isBrowser;
}
function isMobileLikeMode(mode) {
  return isMiniAppLikeMode(mode) || "mobile-browser" === mode;
}
function isMiniAppLikeMode(mode) {
  return mode.includes("miniApp") || "lynx" === mode || "wx" === mode;
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/util/id
var VChartId = 0;
function createID() {
  return VChartId >= 9999999 && (VChartId = 0), VChartId++;
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/util/type
function couldBeValidNumber(v) {
  return null != v && "" !== v && (!!isNumber_default(v) || +v == +v);
}
function toValidNumber2(v) {
  if (isValidNumber_default(v))
    return v;
  const value = +v;
  return isValidNumber_default(value) ? value : 0;
}
function isDataDomainSpec(domain) {
  return !(!domain || 0 === domain.length) && (!isNil_default(domain[0]) && !isNil_default(domain[0].dataId) && isArray_default(domain[0].fields));
}

// http-url:https://unpkg.com/@visactor/vgrammar-util@0.13.8/es/accessor
var accessor = (fn, fields2, name) => (fn.fields = fields2 || [], fn.fname = name, fn);

// http-url:https://unpkg.com/@visactor/vgrammar-util@0.13.8/es/getter
var getter = (path) => (obj) => get_default(obj, path);

// http-url:https://unpkg.com/@visactor/vgrammar-util@0.13.8/es/error
var error2 = (message) => {
  Logger.getInstance().error(message);
};

// http-url:https://unpkg.com/@visactor/vgrammar-util@0.13.8/es/splitAccessPath
var splitAccessPath = (p) => {
  const path = [], n = p.length;
  let i, j, c3, q = null, b = 0, s2 = "";
  p += "";
  const push = () => {
    path.push(s2 + p.substring(i, j)), s2 = "", i = j + 1;
  };
  for (i = 0, j = 0; j < n; j += 1)
    if (c3 = p[j], "\\" === c3)
      s2 += p.substring(i, j), s2 += p.substring(++j, ++j), i = j;
    else if (c3 === q)
      push(), q = null, b = -1;
    else {
      if (q)
        continue;
      i === b && '"' === c3 || i === b && "'" === c3 ? (i = j + 1, q = c3) : "." !== c3 || b ? "[" === c3 ? (j > i && push(), i = j + 1, b = i) : "]" === c3 && (b || error2("Access path missing open bracket: " + p), b > 0 && push(), b = 0, i = j + 1) : j > i ? push() : i = j + 1;
    }
  return b && error2("Access path missing closing bracket: " + p), q && error2("Access path missing closing quote: " + p), j > i && (j += 1, push()), path;
};

// http-url:https://unpkg.com/@visactor/vgrammar-util@0.13.8/es/field
var fieldSingle = (fieldStr, name, opt = {}) => {
  if (isFunction_default(fieldStr))
    return fieldStr;
  const path = splitAccessPath(fieldStr), parsedField = 1 === path.length ? path[0] : fieldStr;
  return accessor((opt && opt.get || getter)(path), [parsedField], name || parsedField);
};
var field = (fieldStr, name, opt = {}) => {
  if (isArray_default(fieldStr)) {
    const funcs = fieldStr.map((entry) => fieldSingle(entry, name, opt));
    return (datum) => funcs.map((func) => func(datum));
  }
  return fieldSingle(fieldStr, name, opt);
};

// http-url:https://unpkg.com/@visactor/vgrammar-util@0.13.8/es/accessors
var id = field("id");
var identity2 = accessor(function(_) {
  return _;
}, [], "identity");
var zero2 = accessor(function() {
  return 0;
}, [], "zero");
var one2 = accessor(function() {
  return 1;
}, [], "one");
var truthy = accessor(function() {
  return true;
}, [], "true");
var falsy = accessor(function() {
  return false;
}, [], "false");
var emptyObject = accessor(function() {
  return {};
}, [], "emptyObject");

// http-url:https://unpkg.com/@visactor/vgrammar-util@0.13.8/es/extent
var extent = (array3, func) => {
  const valueGetter = isFunction_default(func) ? func : (val) => val;
  let min3, max3;
  if (array3 && array3.length) {
    const n = array3.length;
    for (let i = 0; i < n; i += 1) {
      let value = valueGetter(array3[i]);
      isNil_default(value) || !isNumber_default(value = +value) || Number.isNaN(value) || (isNil_default(min3) ? (min3 = value, max3 = value) : (min3 = Math.min(min3, value), max3 = Math.max(max3, value)));
    }
    return [min3, max3];
  }
  return [min3, max3];
};

// http-url:https://unpkg.com/@visactor/vgrammar-util@0.13.8/es/isEqual
var isEqual2 = (key, current, target, deep = true) => {
  if (current === target)
    return true;
  if (isNil_default(current) || isNil_default(target))
    return isNil_default(current) && isNil_default(target);
  if (!isObjectLike_default(current) && !isObjectLike_default(target))
    return current === target;
  const c3 = isArray_default(current) ? current : current[key], t = isArray_default(target) ? target : target[key];
  return c3 === t || false !== deep && (isArray_default(t) ? !(!isArray_default(c3) || t.length !== c3.length || !t.every((v, i) => v === c3[i])) : !!isObject_default(t) && !(!isObject_default(c3) || Object.keys(t).length !== Object.keys(c3).length || !Object.keys(t).every((k2) => isEqual2(k2, t, c3))));
};

// http-url:https://unpkg.com/@visactor/vgrammar-util@0.13.8/es/toPercent
var toPercent = (percent, total) => isNil_default(percent) ? total : isString_default(percent) ? total * parseFloat(percent) / 100 : percent;

// http-url:https://unpkg.com/@visactor/vgrammar-util@0.13.8/es/regression-linear
function ordinaryLeastSquares(uX, uY, uXY, uX2) {
  const delta = uX2 - uX * uX, slope = Math.abs(delta) < 1e-24 ? 0 : (uXY - uX * uY) / delta;
  return [uY - slope * uX, slope];
}
function visitPoints(data, x, y, callback) {
  let u, v, i = -1;
  data.forEach((d) => {
    u = x(d), v = y(d), !isNil_default(u) && (u = +u) >= u && !isNil_default(v) && (v = +v) >= v && callback(u, v, ++i);
  });
}
function rSquared(data, x, y, uY, predict) {
  let SSE = 0, SST = 0;
  return visitPoints(data, x, y, (dx, dy) => {
    const sse = dy - predict(dx), sst = dy - uY;
    SSE += sse * sse, SST += sst * sst;
  }), 1 - SSE / SST;
}
function regressionLinear(data, x = (datum) => datum.x, y = (datum) => datum.y) {
  let X = 0, Y = 0, XY = 0, X22 = 0, n = 0;
  visitPoints(data, x, y, (dx, dy) => {
    ++n, X += (dx - X) / n, Y += (dy - Y) / n, XY += (dx * dy - XY) / n, X22 += (dx * dx - X22) / n;
  });
  const coef = ordinaryLeastSquares(X, Y, XY, X22), predict = (x3) => coef[0] + coef[1] * x3;
  return {
    coef,
    predict,
    rSquared: rSquared(data, x, y, Y, predict)
  };
}

// http-url:https://unpkg.com/@visactor/vgrammar-util@0.13.8/es/direction
function isVertical(direction2) {
  return "vertical" === direction2;
}

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/core/base
var GROUP_ATTRIBUTES = ["x", "y", "dx", "dy", "scaleX", "scaleY", "angle", "anchor", "postMatrix", "visible", "clip", "pickable", "childrenPickable", "zIndex", "cursor"];
var AbstractComponent = class extends Group {
  constructor(attributes, options) {
    super(attributes), (null == options ? void 0 : options.mode) && (this.mode = options.mode, this.setMode(options.mode)), (null == options ? void 0 : options.skipDefault) && (this.skipDefault = true), this.setTheme({
      common: {
        strokeBoundsBuffer: 0
      }
    }), this.attribute = attributes, this.onSetStage(() => {
      this.render(), this.bindEvents();
    });
  }
  setAttribute(key, value, forceUpdateTag) {
    isPlainObject_default(this.attribute[key]) && isPlainObject_default(value) && !isFunction_default(this.attribute[key]) && !isFunction_default(value) ? merge(this.attribute[key], value) : this.attribute[key] = value, GROUP_ATTRIBUTES.includes(key) || this.render(), this.valid = this.isValid(), this.updateShapeAndBoundsTagSetted() || !forceUpdateTag && !this.needUpdateTag(key) ? this.addUpdateBoundTag() : this.addUpdateShapeAndBoundsTag(), this.addUpdatePositionTag(), this.onAttributeUpdate();
  }
  setAttributes(params2, forceUpdateTag) {
    const keys2 = Object.keys(params2);
    this._mergeAttributes(params2, keys2), keys2.every((key) => GROUP_ATTRIBUTES.includes(key)) || this.render(), this.valid = this.isValid(), this.updateShapeAndBoundsTagSetted() || !forceUpdateTag && !this.needUpdateTags(keys2) ? this.addUpdateBoundTag() : this.addUpdateShapeAndBoundsTag(), this.addUpdatePositionTag(), this.onAttributeUpdate();
  }
  _mergeAttributes(params2, keys2) {
    isNil_default(keys2) && (keys2 = Object.keys(params2));
    for (let i = 0; i < keys2.length; i++) {
      const key = keys2[i];
      !isPlainObject_default(this.attribute[key]) || isFunction_default(this.attribute[key]) || isFunction_default(params2[key]) ? this.attribute[key] = params2[key] : merge(this.attribute[key], params2[key]);
    }
  }
  bindEvents() {
  }
  _getNodeId(id2) {
    var _a;
    return `${null !== (_a = this.id) && void 0 !== _a ? _a : this._uid}-${this.name}-${id2}`;
  }
  _dispatchEvent(eventName, details) {
    var _a;
    const changeEvent = new CustomEvent(eventName, details);
    changeEvent.manager = null === (_a = this.stage) || void 0 === _a ? void 0 : _a.eventSystem.manager, this.dispatchEvent(changeEvent);
  }
};

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/constants
var MathPickerContribution = Symbol.for("MathPickerContribution");
var MathArcPicker = Symbol.for("MathArcPicker");
var MathAreaPicker = Symbol.for("MathAreaPicker");
var MathCirclePicker = Symbol.for("MathCirclePicker");
var MathImagePicker = Symbol.for("MathImagePicker");
var MathLinePicker = Symbol.for("MathLinePicker");
var MathPathPicker = Symbol.for("MathPathPicker");
var MathRectPicker = Symbol.for("MathRectPicker");
var MathSymbolPicker = Symbol.for("MathSymbolPicker");
var MathTextPicker = Symbol.for("MathTextPicker");
var MathPolygonPicker = Symbol.for("MathPolygonPicker");
var MathGlyphPicker = Symbol.for("MathGlyphPicker");
var CanvasArcPicker = Symbol.for("CanvasArcPicker");
var CanvasArc3dPicker = Symbol.for("CanvasArc3dPicker");
var CanvasAreaPicker = Symbol.for("CanvasAreaPicker");
var CanvasCirclePicker = Symbol.for("CanvasCirclePicker");
var CanvasImagePicker = Symbol.for("CanvasImagePicker");
var CanvasLinePicker = Symbol.for("CanvasLinePicker");
var CanvasPathPicker = Symbol.for("CanvasPathPicker");
var CanvasRectPicker = Symbol.for("CanvasRectPicker");
var CanvasRect3dPicker = Symbol.for("CanvasRect3dPicker");
var CanvasSymbolPicker = Symbol.for("CanvasSymbolPicker");
var CanvasTextPicker = Symbol.for("CanvasTextPicker");
var CanvasPolygonPicker = Symbol.for("CanvasPolygonPicker");
var CanvasPyramid3dPicker = Symbol.for("CanvasPyramid3dPicker");
var CanvasRichTextPicker = Symbol.for("CanvasRichTextPicker");
var CanvasGlyphPicker = Symbol.for("CanvasGlyphPicker");
var CanvasGroupPicker = Symbol.for("CanvasGroupPicker");
var CanvasPickerContribution = Symbol.for("CanvasPickerContribution");

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/event/extension/drag
var DragNDrop = class {
  constructor(rootNode) {
    this.onPointerDown = (event) => {
      const target = event.target, rootNode2 = this.rootNode, isRoot = target === rootNode2;
      if (target && !isRoot) {
        let handlePointerMove = function(moveEvent) {
          if (dragstartTriggered || (moveEvent.type = "dragstart", null == target || target.dispatchEvent(moveEvent), dragstartTriggered = true), moveEvent.type = "drag", null == target || target.dispatchEvent(moveEvent), !isRoot) {
            target.attribute.pickable = false;
            const elemBelow = (null == rootNode2 ? void 0 : rootNode2.pick(moveEvent.global.x, moveEvent.global.y)).graphic;
            target.attribute.pickable = true, currentDroppable !== elemBelow && (currentDroppable && (moveEvent.type = "dragleave", moveEvent.target = currentDroppable, currentDroppable.dispatchEvent(moveEvent)), elemBelow && (moveEvent.type = "dragenter", moveEvent.target = elemBelow, elemBelow.dispatchEvent(moveEvent)), currentDroppable = elemBelow, currentDroppable && (moveEvent.type = "dragover", moveEvent.target = currentDroppable, currentDroppable.dispatchEvent(moveEvent)));
          }
        };
        let currentDroppable, dragstartTriggered = false;
        null == rootNode2 || rootNode2.addEventListener("pointermove", handlePointerMove);
        const stopDragging = function() {
          dragstartTriggered && (currentDroppable && (event.type = "drop", event.target = currentDroppable, currentDroppable.dispatchEvent(event)), event.type = "dragend", target.dispatchEvent(event), dragstartTriggered = false), null == rootNode2 || rootNode2.removeEventListener("pointermove", handlePointerMove);
        };
        target.addEventListener("pointerup", stopDragging, {
          once: true
        }), target.addEventListener("pointerupoutside", stopDragging, {
          once: true
        });
      }
    }, this.rootNode = rootNode, this.initEvents();
  }
  initEvents() {
    var _a;
    null === (_a = this.rootNode) || void 0 === _a || _a.addEventListener("pointerdown", this.onPointerDown);
  }
  removeEvents() {
    var _a;
    null === (_a = this.rootNode) || void 0 === _a || _a.removeEventListener("pointerdown", this.onPointerDown);
  }
  release() {
    this.removeEvents(), this.rootNode = null;
  }
};

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/event/extension/gesture
var calcDirection = (start, end) => {
  const xDistance = end.x - start.x, yDistance = end.y - start.y;
  return Math.abs(xDistance) > Math.abs(yDistance) ? xDistance > 0 ? "right" : "left" : yDistance > 0 ? "down" : "up";
};
var calcDistance = (point1, point22) => {
  const xDistance = Math.abs(point22.x - point1.x), yDistance = Math.abs(point22.y - point1.y);
  return Math.sqrt(xDistance * xDistance + yDistance * yDistance);
};
var getCenter = (points) => {
  const pointersLength = points.length;
  if (1 === pointersLength)
    return {
      x: Math.round(points[0].x),
      y: Math.round(points[0].y)
    };
  let x = 0, y = 0, i = 0;
  for (; i < pointersLength; )
    x += points[i].x, y += points[i].y, i++;
  return {
    x: Math.round(x / pointersLength),
    y: Math.round(y / pointersLength)
  };
};
var Gesture = class extends import_eventemitter3.default {
  constructor(element, config2 = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    super(), this.cachedEvents = [], this.startPoints = [], this.processEvent = {}, this.throttleTimer = 0, this.emitThrottles = [], this.lastTapTarget = null, this.onStart = (ev) => {
      this.reset(), this.startTime = clock.now();
      const { cachedEvents, startPoints } = this;
      ev && cachedEvents.push(ev.clone()), startPoints.length = cachedEvents.length;
      for (let i = 0; i < cachedEvents.length; i++) {
        const { x, y } = cachedEvents[i], point5 = {
          x,
          y
        };
        startPoints[i] = point5;
      }
      if (1 !== startPoints.length)
        this.startDistance = calcDistance(startPoints[0], startPoints[1]), this.center = getCenter([startPoints[0], startPoints[1]]);
      else {
        const event = cachedEvents[0];
        this.pressTimeout = setTimeout(() => {
          event.direction = "none", event.deltaX = 0, event.deltaY = 0, event.points = startPoints, this.triggerStartEvent("press", event), this.triggerEvent("press", event), this.eventType = "press", this.direction = "none";
        }, this.config.press.time);
      }
    }, this.onMove = (ev) => {
      this.clearPressTimeout();
      const { startPoints, cachedEvents } = this;
      if (!startPoints.length)
        return;
      const moveEvent = ev.clone(), { x, y, pointerId } = moveEvent;
      for (let i = 0, len = cachedEvents.length; i < len; i++)
        if (pointerId === cachedEvents[i].pointerId) {
          cachedEvents[i] = moveEvent;
          break;
        }
      const point5 = {
        x,
        y
      }, points = cachedEvents.map((cachedEvent) => ({
        x: cachedEvent.x,
        y: cachedEvent.y
      })), now = clock.now();
      if (this.prevMoveTime = this.lastMoveTime, this.prevMovePoint = this.lastMovePoint, this.lastMoveTime = now, this.lastMovePoint = point5, 1 === startPoints.length) {
        const startPoint = startPoints[0], deltaX = x - startPoint.x, deltaY = y - startPoint.y, direction2 = this.direction || calcDirection(startPoint, point5);
        this.direction = direction2;
        const eventType = this.getEventType(point5);
        return moveEvent.direction = direction2, moveEvent.deltaX = deltaX, moveEvent.deltaY = deltaY, moveEvent.points = points, this.triggerStartEvent(eventType, moveEvent), void this.triggerEvent(eventType, moveEvent);
      }
      const { startDistance } = this, currentDistance = calcDistance(points[0], points[1]);
      moveEvent.scale = currentDistance / startDistance, moveEvent.center = this.center, moveEvent.points = points, this.triggerStartEvent("pinch", moveEvent), this.triggerEvent("pinch", moveEvent);
    }, this.onEnd = (ev) => {
      const endEvent = ev.clone(), { cachedEvents, startPoints } = this, points = cachedEvents.map((ev2) => ({
        x: ev2.x,
        y: ev2.y
      }));
      if (endEvent.points = points, this.triggerEndEvent(endEvent), 1 === cachedEvents.length) {
        const now = clock.now(), lastMoveTime = this.lastMoveTime;
        if (now - lastMoveTime < 100) {
          const intervalTime = lastMoveTime - (this.prevMoveTime || this.startTime);
          if (intervalTime > 0) {
            const prevMovePoint = this.prevMovePoint || startPoints[0], lastMovePoint = this.lastMovePoint || startPoints[0], distance2 = calcDistance(prevMovePoint, lastMovePoint), velocity = distance2 / intervalTime;
            velocity > this.config.swipe.velocity && distance2 > this.config.swipe.threshold && (endEvent.velocity = velocity, endEvent.direction = calcDirection(prevMovePoint, lastMovePoint), this.triggerEvent("swipe", endEvent));
          }
        }
        now - this.lastTapTime < this.config.tap.interval && ev.target === this.lastTapTarget ? this.tapCount++ : this.tapCount = 1, this.lastTapTime = now, this.lastTapTarget = ev.target, 1 === this.tapCount ? this.triggerEvent("tap", endEvent) : 2 === this.tapCount && (this.triggerEvent("doubletap", endEvent), this.tapCount = 0);
      }
      for (let i = 0, len = cachedEvents.length; i < len; i++)
        if (cachedEvents[i].pointerId === endEvent.pointerId) {
          cachedEvents.splice(i, 1), startPoints.splice(i, 1);
          break;
        }
      this.reset(), cachedEvents.length > 0 && this.onStart();
    }, this.element = element, this.tapCount = 0, this.lastTapTime = 0, this.config = {
      press: {
        time: null !== (_b = null === (_a = null == config2 ? void 0 : config2.press) || void 0 === _a ? void 0 : _a.time) && void 0 !== _b ? _b : 251,
        threshold: null !== (_d = null === (_c = null == config2 ? void 0 : config2.press) || void 0 === _c ? void 0 : _c.threshold) && void 0 !== _d ? _d : 9
      },
      swipe: {
        threshold: null !== (_f = null === (_e = null == config2 ? void 0 : config2.swipe) || void 0 === _e ? void 0 : _e.threshold) && void 0 !== _f ? _f : 10,
        velocity: null !== (_h = null === (_g = null == config2 ? void 0 : config2.swipe) || void 0 === _g ? void 0 : _g.velocity) && void 0 !== _h ? _h : 0.3
      },
      tap: {
        interval: null !== (_k = null === (_j = null == config2 ? void 0 : config2.tap) || void 0 === _j ? void 0 : _j.interval) && void 0 !== _k ? _k : 300
      }
    }, this.initEvents();
  }
  initEvents() {
    const { element } = this;
    element && (element.addEventListener("pointerdown", this.onStart), element.addEventListener("pointermove", this.onMove), element.addEventListener("pointerup", this.onEnd), element.addEventListener("pointerupoutside", this.onEnd));
  }
  removeEvents() {
    const { element } = this;
    element && (element.removeEventListener("pointerdown", this.onStart), element.removeEventListener("pointermove", this.onMove), element.removeEventListener("pointerup", this.onEnd), element.removeEventListener("pointerupoutside", this.onEnd));
  }
  release() {
    this.removeEvents(), this.element = null;
  }
  getEventType(point5) {
    const { eventType, startTime, startPoints } = this;
    if (eventType)
      return eventType;
    let type;
    return type = clock.now() - startTime > this.config.press.time && calcDistance(startPoints[0], point5) < this.config.press.threshold ? "press" : "pan", this.eventType = type, type;
  }
  enable(eventType) {
    this.processEvent[eventType] = true;
  }
  isProcess(eventType) {
    return this.processEvent[eventType];
  }
  pushEvent(type, ev) {
    const { emitThrottles } = this, newEvent = {
      type,
      ev
    };
    for (let i = 0, len = emitThrottles.length; i < len; i++)
      if (emitThrottles[i].type === type)
        return void emitThrottles.splice(i, 1, newEvent);
    emitThrottles.push(newEvent);
  }
  clearPressTimeout() {
    this.pressTimeout && (clearTimeout(this.pressTimeout), this.pressTimeout = null);
  }
  reset() {
    this.clearPressTimeout(), this.startTime = 0, this.startDistance = 0, this.direction = null, this.eventType = null, this.prevMoveTime = 0, this.prevMovePoint = null, this.lastMoveTime = 0, this.lastMovePoint = null;
  }
  triggerEvent(type, ev) {
    this.pushEvent(type, ev);
    const { throttleTimer, emitThrottles } = this;
    throttleTimer || (this.throttleTimer = application.global.getRequestAnimationFrame()(() => {
      for (let i = 0, len = emitThrottles.length; i < len; i++) {
        const { type: type2, ev: ev2 } = emitThrottles[i];
        this.emitEvent(type2, ev2);
      }
      this.throttleTimer = 0, this.emitThrottles.length = 0;
    }));
  }
  triggerStartEvent(type, ev) {
    this.isProcess(type) || (this.enable(type), this.triggerEvent(`${type}start`, ev));
  }
  triggerEndEvent(ev) {
    const processEvent = this.processEvent;
    Object.keys(processEvent).forEach((type) => {
      this.triggerEvent(`${type}end`, ev), "press" === type && this.triggerEvent(`${type}up`, ev), delete processEvent[type];
    });
  }
  emitEvent(type, e) {
    const listeners = this.element._events[WILDCARD];
    if (listeners)
      if ("fn" in listeners)
        listeners.fn.call(listeners.context, e, type);
      else
        for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++)
          listeners[i].fn.call(listeners[i].context, e, type);
    this.emit(type, e);
  }
};

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/canvas/contributions/browser/context
var __decorate44 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata31 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var outP = [0, 0, 0];
var addArcToBezierPath2 = (bezierPath, startAngle, endAngle, cx, cy, rx, ry, clockwise) => {
  if (clockwise)
    for (; endAngle > startAngle; )
      endAngle -= pi2;
  else
    for (; endAngle < startAngle; )
      endAngle += pi2;
  const step = pi / 3 * (endAngle > startAngle ? 1 : -1);
  let sa = startAngle, ea = sa;
  for (; ea !== endAngle; ) {
    ea = step > 0 ? Math.min(ea + step, endAngle) : Math.max(ea + step, endAngle);
    const delta = Math.abs(ea - sa), len = 4 * Math.tan(delta / 4) / 3, dir = ea < sa ? -1 : 1, c1 = Math.cos(sa), s1 = Math.sin(sa), c22 = Math.cos(ea), s2 = Math.sin(ea), x14 = c1 * rx + cx, y14 = s1 * ry + cy, x4 = c22 * rx + cx, y4 = s2 * ry + cy, hx = rx * len * dir, hy = ry * len * dir;
    bezierPath.push([x14 - hx * s1, y14 + hy * c1, x4 + hx * s2, y4 - hy * c22, x4, y4]), sa = ea;
  }
};
var BrowserContext2d = class {
  set fillStyle(d) {
    this.nativeContext.fillStyle = d;
  }
  get fillStyle() {
    return this.nativeContext.fillStyle;
  }
  set font(d) {
    this.nativeContext.font = d;
  }
  get font() {
    return this.nativeContext.font;
  }
  set globalAlpha(d) {
    this.nativeContext.globalAlpha = d * this.baseGlobalAlpha;
  }
  get globalAlpha() {
    return this.nativeContext.globalAlpha;
  }
  set lineCap(d) {
    this.nativeContext.lineCap = d;
  }
  get lineCap() {
    return this.nativeContext.lineCap;
  }
  set lineDashOffset(d) {
    this.nativeContext.lineDashOffset = d;
  }
  get lineDashOffset() {
    return this.nativeContext.lineDashOffset;
  }
  set lineJoin(d) {
    this.nativeContext.lineJoin = d;
  }
  get lineJoin() {
    return this.nativeContext.lineJoin;
  }
  set lineWidth(d) {
    this.nativeContext.lineWidth = d;
  }
  get lineWidth() {
    return this.nativeContext.lineWidth;
  }
  set miterLimit(d) {
    this.nativeContext.miterLimit = d;
  }
  get miterLimit() {
    return this.nativeContext.miterLimit;
  }
  set shadowBlur(d) {
    this.nativeContext.shadowBlur = d;
  }
  get shadowBlur() {
    return this.nativeContext.shadowBlur;
  }
  set shadowColor(d) {
    this.nativeContext.shadowColor = d;
  }
  get shadowColor() {
    return this.nativeContext.shadowColor;
  }
  set shadowOffsetX(d) {
    this.nativeContext.shadowOffsetX = d;
  }
  get shadowOffsetX() {
    return this.nativeContext.shadowOffsetX;
  }
  set shadowOffsetY(d) {
    this.nativeContext.shadowOffsetY = d;
  }
  get shadowOffsetY() {
    return this.nativeContext.shadowOffsetY;
  }
  set strokeStyle(d) {
    this.nativeContext.strokeStyle = d;
  }
  get strokeStyle() {
    return this.nativeContext.strokeStyle;
  }
  set textAlign(d) {
    this.nativeContext.textAlign = d;
  }
  get textAlign() {
    return this.nativeContext.textAlign;
  }
  set textBaseline(d) {
    this.nativeContext.textBaseline = d;
  }
  get textBaseline() {
    return this.nativeContext.textBaseline;
  }
  get inuse() {
    return !!this._inuse;
  }
  set inuse(use) {
    use !== !!this._inuse && (this._inuse = use, use ? (this.nativeContext.save(), this.reset()) : this.nativeContext.restore());
  }
  constructor(canvas, dpr) {
    this.fillAttributes = Object.assign(Object.assign({}, DefaultFillStyle), {
      opacity: 1
    }), this.strokeAttributes = Object.assign(Object.assign({}, DefaultStrokeStyle), {
      opacity: 1
    }), this.textAttributes = Object.assign(Object.assign({}, DefaultTextStyle), {
      opacity: 1
    }), this._clearShadowStyle = false, this._clearFilterStyle = false, this._clearGlobalCompositeOperationStyle = false;
    const context = canvas.nativeCanvas.getContext("2d");
    if (!context)
      throw new Error("\u53D1\u751F\u9519\u8BEF\uFF0C\u83B7\u53D62d\u4E0A\u4E0B\u6587\u5931\u8D25");
    this.nativeContext = context, this.canvas = canvas, this.matrix = new Matrix(1, 0, 0, 1, 0, 0), this.stack = [], this.dpr = dpr, this.applyedMatrix = new Matrix(1, 0, 0, 1, 0, 0), this._clearMatrix = new Matrix(1, 0, 0, 1, 0, 0), this.baseGlobalAlpha = 1;
  }
  reset() {
    this.stack.length && Logger.getInstance().warn("\u53EF\u80FD\u5B58\u5728bug\uFF0Cmatrix\u6CA1\u6709\u6E05\u7A7A"), this.matrix.setValue(1, 0, 0, 1, 0, 0), this.applyedMatrix = new Matrix(1, 0, 0, 1, 0, 0), this.stack.length = 0, this.nativeContext.setTransform(1, 0, 0, 1, 0, 0);
  }
  getCanvas() {
    return this.canvas;
  }
  getContext() {
    return this.nativeContext;
  }
  setTransformForCurrent(force = false) {
    !force && this.applyedMatrix.equalToMatrix(this.matrix) || (this.applyedMatrix.setValue(this.matrix.a, this.matrix.b, this.matrix.c, this.matrix.d, this.matrix.e, this.matrix.f), this.nativeContext.setTransform(this.matrix.a, this.matrix.b, this.matrix.c, this.matrix.d, this.matrix.e, this.matrix.f));
  }
  get currentMatrix() {
    return this.matrix;
  }
  cloneMatrix(m4) {
    return matrixAllocate.allocateByObj(m4);
  }
  clear() {
    this.save(), this.resetTransform(), this.nativeContext.clearRect(0, 0, this.canvas.width, this.canvas.height), this.restore();
  }
  restore() {
    this.nativeContext.restore(), this.stack.length > 0 && (matrixAllocate.free(this.matrix), this.matrix = this.stack.pop(), this.setTransformForCurrent(true));
  }
  highPerformanceRestore() {
    this.stack.length > 0 && (matrixAllocate.free(this.matrix), this.matrix = this.stack.pop());
  }
  rotate(rad, setTransform = true) {
    this.matrix.rotate(rad), setTransform && this.setTransformForCurrent();
  }
  save() {
    const matrix = this.cloneMatrix(this.matrix);
    this.stack.push(matrix), this.nativeContext.save();
  }
  highPerformanceSave() {
    const matrix = this.cloneMatrix(this.matrix);
    this.stack.push(matrix);
  }
  scale(sx, sy, setTransform = true) {
    this.matrix.scale(sx, sy), setTransform && this.setTransformForCurrent();
  }
  setScale(sx, sy, setTransform = true) {
    this.matrix.setScale(sx, sy), setTransform && this.setTransformForCurrent();
  }
  scalePoint(sx, sy, px, py, setTransform = true) {
    this.translate(px, py, false), this.scale(sx, sy, false), this.translate(-px, -py, false), setTransform && this.setTransformForCurrent();
  }
  setTransform(a3, b, c3, d, e, f, setTransform = true, dpr = this.dpr) {
    this.matrix.setValue(dpr * a3, dpr * b, dpr * c3, dpr * d, dpr * e, dpr * f), setTransform && this.setTransformForCurrent();
  }
  setTransformFromMatrix(matrix, setTransform = true, dpr = this.dpr) {
    this.matrix.setValue(matrix.a * dpr, matrix.b * dpr, matrix.c * dpr, matrix.d * dpr, matrix.e * dpr, matrix.f * dpr), setTransform && this.setTransformForCurrent();
  }
  resetTransform(setTransform = true, dpr = this.dpr) {
    this.setTransform(dpr, 0, 0, dpr, 0, 0), setTransform && this.setTransformForCurrent();
  }
  transform(a3, b, c3, d, e, f, setTransform = true) {
    this.matrix.multiply(a3, b, c3, d, e, f), setTransform && this.setTransformForCurrent();
  }
  transformFromMatrix(matrix, setTransform) {
    this.matrix.multiply(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f), setTransform && this.setTransformForCurrent();
  }
  translate(x, y, setTransform = true) {
    this.matrix.translate(x, y), setTransform && this.setTransformForCurrent();
  }
  rotateDegrees(deg, setTransform = true) {
    const rad = deg * Math.PI / 180;
    this.rotate(rad, setTransform);
  }
  rotateAbout(rad, x, y, setTransform = true) {
    this.translate(x, y, false), this.rotate(rad, false), this.translate(-x, -y, false), setTransform && this.setTransformForCurrent();
  }
  rotateDegreesAbout(deg, x, y, setTransform = true) {
    this.translate(x, y, false), this.rotateDegrees(deg, false), this.translate(-x, -y, false), setTransform && this.setTransformForCurrent();
  }
  beginPath() {
    this.disableBeginPath || this.nativeContext.beginPath();
  }
  clip(path, fillRule) {
    path ? "string" == typeof path ? this.nativeContext.clip(path) : this.nativeContext.clip(path, fillRule) : this.nativeContext.clip();
  }
  arc(x, y, radius, startAngle, endAngle, anticlockwise, z) {
    if (z = z || 0, this.camera) {
      const arr = [];
      addArcToBezierPath2(arr, startAngle, endAngle, x, y, radius, radius, anticlockwise);
      for (let i = 0; i < arr.length; ++i) {
        const bez = arr[i];
        this.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5], z);
      }
    } else
      this.nativeContext.arc(x, y, radius, startAngle, endAngle, anticlockwise);
  }
  arcTo(x14, y14, x23, y23, radiusX) {
    this.nativeContext.arcTo(x14, y14, x23, y23, radiusX);
  }
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, z) {
    if (z = z || 0, this.camera) {
      let cp1z = z, cp2z = z;
      this.modelMatrix && (transformMat4(outP, [cp1x, cp1y, z], this.modelMatrix), cp1x = outP[0], cp1y = outP[1], cp1z = outP[2], transformMat4(outP, [cp2x, cp2y, z], this.modelMatrix), cp2x = outP[0], cp2y = outP[1], cp2z = outP[2], transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
      let data = this.camera.vp(x, y, z);
      x = data.x, y = data.y, data = this.camera.vp(cp1x, cp1y, cp1z), cp1x = data.x, cp1y = data.y, data = this.camera.vp(cp2x, cp2y, cp2z), cp2x = data.x, cp2y = data.y;
    }
    this.nativeContext.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
  }
  closePath() {
    this.nativeContext.closePath();
  }
  ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
    null == anticlockwise ? this.nativeContext.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle) : this.nativeContext.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);
  }
  lineTo(x, y, z) {
    if (z = z || 0, this.camera) {
      this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
      const data = this.camera.vp(x, y, z);
      x = data.x, y = data.y;
    }
    this.nativeContext.lineTo(x, y);
  }
  moveTo(x, y, z) {
    if (z = z || 0, this.camera) {
      this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
      const data = this.camera.vp(x, y, z);
      x = data.x, y = data.y;
    }
    this.nativeContext.moveTo(x, y);
  }
  quadraticCurveTo(cpx, cpy, x, y, z) {
    if (z = z || 0, this.camera) {
      let cpz = z;
      this.modelMatrix && (transformMat4(outP, [cpx, cpy, z], this.modelMatrix), cpx = outP[0], cpy = outP[1], cpz = outP[2], transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
      let data = this.camera.vp(x, y, z);
      x = data.x, y = data.y, data = this.camera.vp(cpx, cpy, cpz), cpx = data.x, cpy = data.y;
    }
    this.nativeContext.quadraticCurveTo(cpx, cpy, x, y);
  }
  rect(x, y, w, h, z) {
    z = z || 0, this.camera ? (this.moveTo(x, y, z), this.lineTo(x + w, y, z), this.lineTo(x + w, y + h, z), this.lineTo(x, y + h, z), this.closePath()) : this.nativeContext.rect(x, y, w, h);
  }
  createImageData() {
    const a3 = arguments;
    return 2 === a3.length ? this.nativeContext.createImageData(a3[0], a3[1]) : 1 === a3.length ? this.nativeContext.createImageData(a3[0]) : null;
  }
  createLinearGradient(x05, y05, x14, y14) {
    return this.nativeContext.createLinearGradient(x05, y05, x14, y14);
  }
  createPattern(image, repetition) {
    return 0 === image.width || 0 === image.height ? null : this.nativeContext.createPattern(image, repetition);
  }
  createRadialGradient(x05, y05, r0, x14, y14, r1) {
    return this.nativeContext.createRadialGradient(x05, y05, r0, x14, y14, r1);
  }
  createConicGradient(x, y, startAngle, endAngle) {
    let pattern, edit = false;
    const ctx = this;
    return {
      stops: [],
      addColorStop(offset, color) {
        this.stops.push([offset, color]), edit = true;
      },
      GetPattern(minW, minH, deltaAngle) {
        return edit && (deltaAngle || (deltaAngle = endAngle - startAngle), pattern = createConicalGradient(ctx, this.stops, x, y, deltaAngle, startAngle, endAngle, minW, minH), edit = false), pattern;
      }
    };
  }
  fill(path, fillRule) {
    this.disableFill || (path ? this.nativeContext.fill(path) : this.nativeContext.fill());
  }
  fillRect(x, y, width, height) {
    this.nativeContext.fillRect(x, y, width, height);
  }
  clearRect(x, y, w, h) {
    this.nativeContext.clearRect(x, y, w, h);
  }
  project(x, y, z) {
    if (z = z || 0, this.camera) {
      this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
      const data = this.camera.vp(x, y, z);
      x = data.x, y = data.y;
    }
    return {
      x,
      y
    };
  }
  view(x, y, z) {
    return z = z || 0, this.camera ? (this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]), this.camera.view(x, y, z)) : [x, y, z];
  }
  fillText(text2, x, y, z) {
    if (z = z || 0, this.camera) {
      this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
      const data = this.camera.vp(x, y, z);
      x = data.x, y = data.y;
    }
    this.nativeContext.fillText(text2, x, y);
  }
  getImageData(sx, sy, sw, sh) {
    return this.nativeContext.getImageData(sx, sy, sw, sh);
  }
  getLineDash() {
    return this.nativeContext.getLineDash();
  }
  isPointInPath(x, y) {
    return this.nativeContext.isPointInPath(x, y);
  }
  isPointInStroke(x, y) {
    return this.nativeContext.isPointInStroke(x, y);
  }
  measureText(text2, method = application.global.measureTextMethod) {
    var _a, _b;
    if (!method || "native" === method)
      return this.nativeContext.measureText(text2);
    this.mathTextMeasure || (this.mathTextMeasure = application.graphicUtil.createTextMeasureInstance({}, {}, () => this.canvas.nativeCanvas));
    const fontFamily = null !== (_a = this.fontFamily) && void 0 !== _a ? _a : DefaultTextStyle.fontFamily, fontSize = null !== (_b = this.fontSize) && void 0 !== _b ? _b : DefaultTextStyle.fontSize;
    return this.mathTextMeasure.textSpec.fontFamily === fontFamily && this.mathTextMeasure.textSpec.fontSize === fontSize || (this.mathTextMeasure.textSpec.fontFamily = fontFamily, this.mathTextMeasure.textSpec.fontSize = fontSize, this.mathTextMeasure._numberCharSize = null, this.mathTextMeasure._fullCharSize = null, this.mathTextMeasure._letterCharSize = null, this.mathTextMeasure._specialCharSizeMap = {}), this.mathTextMeasure.measure(text2, method);
  }
  putImageData(imagedata, dx, dy) {
    this.nativeContext.putImageData(imagedata, dx, dy);
  }
  setLineDash(segments2) {
    const a3 = arguments, _context = this.nativeContext;
    this.nativeContext.setLineDash ? a3[0] && _context.setLineDash(a3[0]) : "mozDash" in _context ? _context.mozDash = a3[0] : "webkitLineDash" in _context && (_context.webkitLineDash = a3[0]);
  }
  stroke(path) {
    this.disableStroke || (path ? this.nativeContext.stroke(path) : this.nativeContext.stroke());
  }
  strokeRect(x, y, width, height) {
    this.nativeContext.strokeRect(x, y, width, height);
  }
  strokeText(text2, x, y, z) {
    if (z = z || 0, this.camera) {
      this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
      const data = this.camera.vp(x, y, z);
      x = data.x, y = data.y;
    }
    this.nativeContext.strokeText(text2, x, y);
  }
  drawImage() {
    const _context = this.nativeContext, a3 = arguments;
    3 === a3.length ? _context.drawImage(a3[0], a3[1], a3[2]) : 5 === a3.length ? _context.drawImage(a3[0], a3[1], a3[2], a3[3], a3[4]) : 9 === a3.length && _context.drawImage(a3[0], a3[1], a3[2], a3[3], a3[4], a3[5], a3[6], a3[7], a3[8]);
  }
  setCommonStyle(params2, attribute, offsetX, offsetY, defaultParams) {
    if (Array.isArray(defaultParams)) {
      if (defaultParams.length <= 1)
        return this._setCommonStyle(params2, attribute, offsetX, offsetY, defaultParams[0]);
      const dp = Object.create(defaultParams[0]);
      return defaultParams.forEach((p, i) => {
        0 !== i && Object.assign(dp, p);
      }), this._setCommonStyle(params2, attribute, offsetX, offsetY, dp);
    }
    return this._setCommonStyle(params2, attribute, offsetX, offsetY, defaultParams);
  }
  _setCommonStyle(params2, attribute, offsetX, offsetY, defaultParams) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.fillAttributes);
    const { fillOpacity = defaultParams.fillOpacity, opacity = defaultParams.opacity, fill = defaultParams.fill } = attribute;
    fillOpacity > 1e-12 && opacity > 1e-12 ? (_context.globalAlpha = fillOpacity * opacity * this.baseGlobalAlpha, _context.fillStyle = createColor(this, fill, params2, offsetX, offsetY)) : _context.globalAlpha = fillOpacity * opacity * this.baseGlobalAlpha;
  }
  setShadowBlendStyle(params2, attribute, defaultParams) {
    if (Array.isArray(defaultParams)) {
      if (defaultParams.length <= 1)
        return this._setShadowBlendStyle(params2, defaultParams[0]);
      const dp = Object.create(defaultParams[0]);
      return defaultParams.forEach((p, i) => {
        0 !== i && Object.assign(dp, p);
      }), this._setShadowBlendStyle(params2, attribute, dp);
    }
    return this._setShadowBlendStyle(params2, attribute, defaultParams);
  }
  _setShadowBlendStyle(params2, attribute, defaultParams) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.fillAttributes);
    const { opacity = defaultParams.opacity, shadowBlur = defaultParams.shadowBlur, shadowColor = defaultParams.shadowColor, shadowOffsetX = defaultParams.shadowOffsetX, shadowOffsetY = defaultParams.shadowOffsetY, blur = defaultParams.blur, globalCompositeOperation = defaultParams.globalCompositeOperation } = attribute;
    opacity <= 1e-12 || (shadowBlur || shadowOffsetX || shadowOffsetY ? (_context.shadowBlur = shadowBlur * this.dpr, _context.shadowColor = shadowColor, _context.shadowOffsetX = shadowOffsetX * this.dpr, _context.shadowOffsetY = shadowOffsetY * this.dpr, this._clearShadowStyle = true) : this._clearShadowStyle && (_context.shadowBlur = 0, _context.shadowOffsetX = 0, _context.shadowOffsetY = 0), blur ? (_context.filter = `blur(${blur}px)`, this._clearFilterStyle = true) : this._clearFilterStyle && (_context.filter = "blur(0px)", this._clearFilterStyle = false), globalCompositeOperation ? (_context.globalCompositeOperation = globalCompositeOperation, this._clearGlobalCompositeOperationStyle = true) : this._clearGlobalCompositeOperationStyle && (_context.globalCompositeOperation = "source-over", this._clearGlobalCompositeOperationStyle = false));
  }
  setStrokeStyle(params2, attribute, offsetX, offsetY, defaultParams) {
    if (Array.isArray(defaultParams)) {
      if (defaultParams.length <= 1)
        return this._setStrokeStyle(params2, attribute, offsetX, offsetY, defaultParams[0]);
      const dp = Object.create(defaultParams[0]);
      return defaultParams.forEach((p, i) => {
        0 !== i && Object.assign(dp, p);
      }), this._setStrokeStyle(params2, attribute, offsetX, offsetY, dp);
    }
    return this._setStrokeStyle(params2, attribute, offsetX, offsetY, defaultParams);
  }
  _setStrokeStyle(params2, attribute, offsetX, offsetY, defaultParams) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.strokeAttributes);
    const { strokeOpacity = defaultParams.strokeOpacity, opacity = defaultParams.opacity } = attribute;
    if (strokeOpacity > 1e-12 && opacity > 1e-12) {
      const { lineWidth = defaultParams.lineWidth, stroke: stroke2 = defaultParams.stroke, lineJoin = defaultParams.lineJoin, lineDash = defaultParams.lineDash, lineCap = defaultParams.lineCap, miterLimit = defaultParams.miterLimit } = attribute;
      _context.globalAlpha = strokeOpacity * opacity * this.baseGlobalAlpha, _context.lineWidth = getScaledStroke(this, lineWidth, this.dpr), _context.strokeStyle = createColor(this, stroke2, params2, offsetX, offsetY), _context.lineJoin = lineJoin, lineDash && _context.setLineDash(lineDash), _context.lineCap = lineCap, _context.miterLimit = miterLimit;
    }
  }
  setTextStyleWithoutAlignBaseline(params2, defaultParams, z) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.textAttributes);
    const { scaleIn3d = defaultParams.scaleIn3d } = params2;
    params2.font ? _context.font = params2.font : _context.font = getContextFont2(params2, defaultParams, scaleIn3d && this.camera && this.camera.getProjectionScale(z));
    const { fontFamily = defaultParams.fontFamily, fontSize = defaultParams.fontSize } = params2;
    this.fontFamily = fontFamily, this.fontSize = fontSize, _context.textAlign = "left", _context.textBaseline = "alphabetic";
  }
  setTextStyle(params2, defaultParams, z) {
    var _a, _b;
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.textAttributes), params2.font ? _context.font = params2.font : _context.font = getContextFont2(params2, defaultParams, this.camera && this.camera.getProjectionScale(z));
    const { fontFamily = defaultParams.fontFamily, fontSize = defaultParams.fontSize } = params2;
    this.fontFamily = fontFamily, this.fontSize = fontSize, _context.textAlign = null !== (_a = params2.textAlign) && void 0 !== _a ? _a : defaultParams.textAlign, _context.textBaseline = null !== (_b = params2.textBaseline) && void 0 !== _b ? _b : defaultParams.textBaseline;
  }
  draw() {
  }
  clearMatrix(setTransform = true, dpr = this.dpr) {
    this.setTransformFromMatrix(this._clearMatrix, setTransform, dpr);
  }
  setClearMatrix(a3, b, c3, d, e, f) {
    this._clearMatrix.setValue(a3, b, c3, d, e, f);
  }
  onlyTranslate(dpr = this.dpr) {
    return this.matrix.a === dpr && 0 === this.matrix.b && 0 === this.matrix.c && this.matrix.d === dpr;
  }
  release(...params2) {
    this.stack.forEach((m4) => matrixAllocate.free(m4)), this.stack.length = 0;
  }
};
BrowserContext2d.env = "browser", BrowserContext2d = __decorate44([injectable(), __metadata31("design:paramtypes", [Object, Number])], BrowserContext2d);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/canvas/contributions/browser/canvas
var __decorate45 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata32 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var BrowserCanvas = class extends BaseCanvas {
  constructor(params2) {
    super(params2);
  }
  init(params2) {
    const { container: container2 } = params2;
    if ("string" == typeof container2) {
      const _c = application.global.getElementById(container2);
      _c && (this._container = _c);
    } else
      this._container = container2;
    this._context = new BrowserContext2d(this, this._dpr), this.initStyle();
  }
  initStyle() {
    if (!this.controled)
      return;
    const { nativeCanvas } = this;
    nativeCanvas.width = this._pixelWidth, nativeCanvas.height = this._pixelHeight;
    !nativeCanvas.style || this.setCanvasStyle(nativeCanvas, this._x, this._y, this._displayWidth, this._displayHeight), this._container && this._container.appendChild(nativeCanvas), this.visiable || this.hide();
  }
  hide() {
    this._nativeCanvas && (this._nativeCanvas.style.display = "none");
  }
  show() {
    this._nativeCanvas && (this._nativeCanvas.style.display = "block");
  }
  applyPosition() {
    const canvas = this._nativeCanvas;
    canvas.style.position = "absolute", canvas.style.top = `${this._y}px`, canvas.style.left = `${this._x}px`;
  }
  resetStyle(params2) {
    if (!this.controled)
      return;
    const { width = this._displayWidth, height = this._displayHeight, dpr = this._dpr, x = this._x, y = this._y } = params2, { nativeCanvas } = this;
    nativeCanvas.width = width * dpr, nativeCanvas.height = height * dpr;
    !nativeCanvas.style || this.setCanvasStyle(nativeCanvas, x, y, width, height), params2.id && (nativeCanvas.id = params2.id), this.visiable || this.hide();
  }
  setCanvasStyle(canvas, x, y, w, h) {
    this.controled && (canvas.style.width = `${w}px`, canvas.style.height = `${h}px`);
  }
  toDataURL(mimeType, quality) {
    return "image/jpeg" === mimeType ? this._nativeCanvas.toDataURL(mimeType, quality) : "image/png" === mimeType ? this._nativeCanvas.toDataURL(mimeType) : this._nativeCanvas.toDataURL(mimeType, quality);
  }
  resize(width, height) {
    if (!this.controled)
      return;
    this._pixelWidth = width * this._dpr, this._pixelHeight = height * this._dpr, this._displayWidth = width, this._displayHeight = height, this._nativeCanvas.style && (this._nativeCanvas.style.width = `${width}px`, this._nativeCanvas.style.height = `${height}px`), this._nativeCanvas.width = this._pixelWidth, this._nativeCanvas.height = this._pixelHeight;
    this._context.dpr = this._dpr;
  }
};
BrowserCanvas.env = "browser", BrowserCanvas = __decorate45([injectable(), __metadata32("design:paramtypes", [Object])], BrowserCanvas);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/canvas/contributions/create-canvas-module
function createModule(CanvasConstructor, ContextConstructor) {
  return new ContainerModule((bind) => {
    bind(CanvasFactory).toDynamicValue(() => (params2) => new CanvasConstructor(params2)).whenTargetNamed(CanvasConstructor.env), bind(Context2dFactory).toDynamicValue(() => (params2, dpr) => new ContextConstructor(params2, dpr)).whenTargetNamed(ContextConstructor.env);
  });
}

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/canvas/contributions/browser/modules
var browserCanvasModule = createModule(BrowserCanvas, BrowserContext2d);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/canvas-picker-service
var __decorate46 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata33 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param20 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasPickerService = class extends DefaultPickService {
  constructor(contributions, drawContribution, pickItemInterceptorContributions) {
    super(pickItemInterceptorContributions), this.contributions = contributions, this.drawContribution = drawContribution, this.pickItemInterceptorContributions = pickItemInterceptorContributions, this.global.hooks.onSetEnv.tap("canvas-picker-service", (_, env, global) => {
      this.configure(global, env);
    }), this.configure(this.global, this.global.env), this.pickerMap = /* @__PURE__ */ new Map(), this.init();
  }
  init() {
    this.contributions.getContributions().forEach((item) => {
      this.pickerMap.set(item.numberType, item);
    }), super._init();
  }
  configure(global, env) {
    this.pickCanvas = canvasAllocate.shareCanvas(), this.pickContext = this.pickCanvas.getContext("2d");
  }
  pickItem(graphic, point5, parentMatrix, params2) {
    if (false === graphic.attribute.pickable)
      return null;
    if (this.InterceptorContributions.length)
      for (let i = 0; i < this.InterceptorContributions.length; i++) {
        const drawContribution = this.InterceptorContributions[i];
        if (drawContribution.beforePickItem) {
          const ret = drawContribution.beforePickItem(graphic, this, point5, params2, {
            parentMatrix
          });
          if (ret)
            return ret;
        }
      }
    const picker = this.pickerMap.get(graphic.numberType);
    if (!picker)
      return null;
    const pd = picker.contains(graphic, point5, params2), g = pd ? graphic : null, data = {
      graphic: g,
      params: pd
    };
    if (g)
      return data;
    if (this.InterceptorContributions.length)
      for (let i = 0; i < this.InterceptorContributions.length; i++) {
        const drawContribution = this.InterceptorContributions[i];
        if (drawContribution.afterPickItem) {
          const ret = drawContribution.afterPickItem(graphic, this, point5, params2, {
            parentMatrix
          });
          if (ret)
            return ret;
        }
      }
    return data;
  }
};
DefaultCanvasPickerService = __decorate46([injectable(), __param20(0, inject(ContributionProvider)), __param20(0, named(CanvasPickerContribution)), __param20(1, inject(DrawContribution)), __param20(2, inject(ContributionProvider)), __param20(2, named(PickItemInterceptor)), __metadata33("design:paramtypes", [Object, Object, Object])], DefaultCanvasPickerService);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/canvas-picker/group-picker
var __decorate47 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultCanvasGroupPicker = class {
  constructor() {
    this.type = "group", this.numberType = GROUP_NUMBER_TYPE;
  }
  contains(group, point5, params2) {
    return false;
  }
};
DefaultCanvasGroupPicker = __decorate47([injectable()], DefaultCanvasGroupPicker);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/canvas-picker/module
var m = new ContainerModule((bind, unbind, isBound, rebind) => {
  m.__vloaded || (m.__vloaded = true, bind(CanvasGroupPicker).to(DefaultCanvasGroupPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasGroupPicker), bindContributionProvider(bind, CanvasPickerContribution));
});
m.__vloaded = false;
var module_default2 = m;

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/canvas-module
var canvasPickerModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  isBound(DefaultCanvasPickerService) || bind(DefaultCanvasPickerService).toSelf().inSingletonScope(), isBound(PickerService) ? rebind(PickerService).toService(DefaultCanvasPickerService) : bind(PickerService).toService(DefaultCanvasPickerService);
});
function loadCanvasPicker(c3) {
  c3.load(module_default2), c3.load(canvasPickerModule);
}

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/window/contributions/browser-contribution
var BrowserWindowHandlerContribution_1;
var __decorate48 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata34 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var BrowserWindowHandlerContribution = BrowserWindowHandlerContribution_1 = class extends BaseWindowHandlerContribution {
  get container() {
    return this.canvas.nativeCanvas.parentElement;
  }
  static GenerateCanvasId() {
    return `${BrowserWindowHandlerContribution_1.idprefix}_${BrowserWindowHandlerContribution_1.prefix_count++}`;
  }
  constructor() {
    super(), this.type = "browser", this._canvasIsIntersecting = true, this.global = application.global, this.viewBox = new AABBBounds(), this.modelMatrix = new Matrix(1, 0, 0, 1, 0, 0);
  }
  getTitle() {
    return this.canvas.id && this.canvas.id.toString();
  }
  getWH() {
    return {
      width: this.canvas.width / (this.canvas.dpr || 1),
      height: this.canvas.height / (this.canvas.dpr || 1)
    };
  }
  getXY() {
    return this.canvas.nativeCanvas.getBoundingClientRect();
  }
  createWindow(params2) {
    params2.canvas ? this.createWindowByCanvas(params2) : this.createWindowByConfig(params2), this.postInit();
  }
  postInit() {
    if (this.global.optimizeVisible)
      try {
        this.observerCanvas();
      } catch (err) {
        console.error("\u53D1\u751F\u9519\u8BEF\uFF0C\u8BE5\u73AF\u5883\u4E0D\u5B58\u5728IntersectionObserver");
      }
  }
  isElementVisible(el) {
    const rect = el.getBoundingClientRect(), vWidth = window.innerWidth || document.documentElement.clientWidth, vHeight = window.innerHeight || document.documentElement.clientHeight;
    return !(rect.right < 0 || rect.bottom < 0 || rect.left > vWidth || rect.top > vHeight);
  }
  observerCanvas() {
    this._canvasIsIntersecting = this.isElementVisible(this.canvas.nativeCanvas);
    const observer = new IntersectionObserver((entries, observer2) => {
      entries.forEach((entry) => {
        this._canvasIsIntersecting !== entry.isIntersecting ? (this._canvasIsIntersecting = entry.isIntersecting, this._onVisibleChangeCb && this._onVisibleChangeCb(entry.isIntersecting)) : this._canvasIsIntersecting = entry.isIntersecting;
      });
    });
    observer && observer.observe(this.canvas.nativeCanvas);
  }
  createWindowByConfig(params2) {
    const nativeCanvas = this.global.createCanvas({
      width: params2.width,
      height: params2.height
    });
    let container2;
    if (container2 = "string" == typeof params2.container ? this.global.getElementById(params2.container) : params2.container ? params2.container : this.global.getRootElement(), !container2)
      throw new Error("\u53D1\u751F\u9519\u8BEF\uFF0CcontainerId\u53EF\u80FD\u4F20\u5165\u6709\u8BEF");
    params2.offscreen ? container2 = null : container2.appendChild(nativeCanvas);
    const options = {
      width: params2.width,
      height: params2.height,
      dpr: params2.dpr,
      nativeCanvas,
      container: container2,
      id: BrowserWindowHandlerContribution_1.GenerateCanvasId(),
      canvasControled: true
    };
    this.canvas = new BrowserCanvas(options);
  }
  createWindowByCanvas(params2) {
    var _a;
    let canvas;
    if ("string" == typeof params2.canvas) {
      if (canvas = this.global.getElementById(params2.canvas), !canvas)
        throw new Error("canvasId \u53C2\u6570\u4E0D\u6B63\u786E\uFF0C\u8BF7\u786E\u8BA4canvas\u5B58\u5728\u5E76\u63D2\u5165dom");
    } else
      canvas = params2.canvas;
    if (!canvas)
      throw new Error("\u53D1\u751F\u9519\u8BEF\uFF0C\u4F20\u5165\u7684canvas\u4E0D\u6B63\u786E");
    let width = params2.width, height = params2.height;
    if (null == width || null == height || !params2.canvasControled) {
      const data = canvas.getBoundingClientRect();
      width = data.width, height = data.height;
    }
    let dpr = params2.dpr;
    if (null == dpr) {
      dpr = null !== (_a = canvas.getContext("2d").pixelRatio) && void 0 !== _a ? _a : canvas.width / width;
    }
    this.canvas = new BrowserCanvas({
      width,
      height,
      dpr,
      nativeCanvas: canvas,
      canvasControled: params2.canvasControled
    });
  }
  releaseWindow() {
    this.canvas.release();
  }
  resizeWindow(width, height) {
    this.canvas.resize(width, height);
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  getContext() {
    return this.canvas.getContext();
  }
  getNativeHandler() {
    return this.canvas;
  }
  getDpr() {
    return this.canvas.dpr;
  }
  addEventListener(type, listener, options) {
    return this.canvas.nativeCanvas.addEventListener(type, listener, options);
  }
  removeEventListener(type, listener, options) {
    return this.canvas.nativeCanvas.removeEventListener(type, listener, options);
  }
  dispatchEvent(event) {
    return this.canvas.nativeCanvas.dispatchEvent(event);
  }
  getStyle() {
    var _a;
    return null !== (_a = this.canvas.nativeCanvas.style) && void 0 !== _a ? _a : {};
  }
  setStyle(style) {
    this.canvas.nativeCanvas.style = style;
  }
  getBoundingClientRect() {
    const c3 = this.canvas.nativeCanvas, wh = this.getWH();
    return c3.parentElement ? this.canvas.nativeCanvas.getBoundingClientRect() : {
      x: 0,
      y: 0,
      width: wh.width,
      height: wh.height,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }
  clearViewBox(color) {
    const vb = this.viewBox, context = this.getContext(), dpr = this.getDpr();
    context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
  }
  isVisible(bbox) {
    return this._canvasIsIntersecting;
  }
  onVisibleChange(cb) {
    this._onVisibleChangeCb = cb;
  }
  getTopLeft(baseWindow) {
    return this.global.getElementTopLeft(this.canvas.nativeCanvas, baseWindow);
  }
};
BrowserWindowHandlerContribution.env = "browser", BrowserWindowHandlerContribution.idprefix = "visactor_window", BrowserWindowHandlerContribution.prefix_count = 0, BrowserWindowHandlerContribution = BrowserWindowHandlerContribution_1 = __decorate48([injectable(), __metadata34("design:paramtypes", [])], BrowserWindowHandlerContribution);
var browserWindowModule = new ContainerModule((bind) => {
  bind(BrowserWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue((ctx) => ctx.container.get(BrowserWindowHandlerContribution)).whenTargetNamed(BrowserWindowHandlerContribution.env);
});

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/env/contributions/browser-contribution
var __decorate49 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata35 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var DynamicB = class {
  get x1() {
    return this.dom.getBoundingClientRect().left;
  }
  get x2() {
    return this.dom.getBoundingClientRect().right;
  }
  get y1() {
    return this.dom.getBoundingClientRect().top;
  }
  get y2() {
    return this.dom.getBoundingClientRect().bottom;
  }
  get width() {
    return this.dom.getBoundingClientRect().width;
  }
  get height() {
    return this.dom.getBoundingClientRect().height;
  }
  constructor(dom) {
    this.dom = dom;
  }
};
function createImageElement(src, isSvg2 = false) {
  const img = document.createElement("img");
  if (img.crossOrigin = "anonymous", isSvg2) {
    const data = new Blob([src], {
      type: "image/svg+xml"
    });
    src = window.URL.createObjectURL(data);
  }
  if (img.src = src, img.complete)
    return Promise.resolve(img);
  return new Promise((resolve, reject) => {
    img.onload = () => {
      resolve(img);
    }, img.onerror = () => {
      reject(new Error("\u52A0\u8F7D\u5931\u8D25"));
    };
  });
}
var BrowserEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(), this.type = "browser", this.supportEvent = true;
    try {
      this.supportsTouchEvents = "ontouchstart" in globalThis, this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;
    } catch (err) {
      this.supportsTouchEvents = false, this.supportsPointerEvents = false, this.supportsPointerEvents = false;
    }
    this.applyStyles = true;
  }
  mapToCanvasPoint(nativeEvent, domElement) {
    var _a, _b;
    let clientX = 0, clientY = 0, offsetX = 0, offsetY = 0;
    if (nativeEvent.changedTouches) {
      const data = null !== (_a = nativeEvent.changedTouches[0]) && void 0 !== _a ? _a : {};
      clientX = data.clientX || 0, clientY = data.clientY || 0, offsetX = clientX, offsetY = clientY;
    } else
      clientX = nativeEvent.clientX || 0, clientY = nativeEvent.clientY || 0, offsetX = nativeEvent.offsetX || 0, offsetY = nativeEvent.offsetY || 0;
    if (domElement) {
      const x = clientX, y = clientY, rect = domElement.getBoundingClientRect(), nativeCanvas = null === (_b = domElement.getNativeHandler) || void 0 === _b ? void 0 : _b.call(domElement).nativeCanvas;
      let scaleX, scaleY;
      return nativeCanvas && (scaleX = rect.width / nativeCanvas.offsetWidth, scaleY = rect.height / nativeCanvas.offsetHeight), {
        x: (x - rect.left) / (isValidNumber_default(scaleX) ? scaleX : 1),
        y: (y - rect.top) / (isValidNumber_default(scaleY) ? scaleY : 1)
      };
    }
    return {
      x: offsetX,
      y: offsetY
    };
  }
  getNativeAABBBounds(_dom) {
    let dom = _dom;
    if ("string" == typeof _dom && (dom = new DOMParser().parseFromString(_dom, "text/html").firstChild, dom.lastChild && (dom = dom.lastChild.firstChild)), dom.getBoundingClientRect) {
      const b = dom.getBoundingClientRect();
      return new DynamicB(b);
    }
    return new AABBBounds();
  }
  removeDom(dom) {
    return dom.parentElement.removeChild(dom), true;
  }
  updateDom(dom, params2) {
    const { width, height, style } = params2;
    return style && (isString_default(style) ? dom.setAttribute("style", style) : Object.keys(style).forEach((k2) => {
      dom.style[k2] = style[k2];
    })), null != width && (dom.style.width = `${width}px`), null != height && (dom.style.height = `${height}px`), true;
  }
  createDom(params2) {
    const { tagName = "div", parent } = params2, element = document.createElement(tagName);
    if (this.updateDom(element, params2), parent) {
      const pd = isString_default(parent) ? this.getElementById(parent) : parent;
      pd && pd.appendChild && pd.appendChild(element);
    }
    return element;
  }
  loadImage(url) {
    return createImageElement(url, false).then((img) => ({
      data: img,
      loadState: "success"
    })).catch(() => ({
      data: null,
      loadState: "fail"
    }));
  }
  loadSvg(url) {
    return createImageElement(url, true).then((img) => ({
      data: img,
      loadState: "success"
    })).catch(() => ({
      data: null,
      loadState: "fail"
    }));
  }
  createCanvas(params2) {
    var _a, _b;
    const canvas = document.createElement("canvas");
    params2.id && (canvas.id = null !== (_a = params2.id) && void 0 !== _a ? _a : Generator.GenAutoIncrementId().toString());
    const dpr = null !== (_b = params2.dpr) && void 0 !== _b ? _b : window.devicePixelRatio;
    return params2.width && params2.height && (canvas.style.width = `${params2.width}px`, canvas.style.height = `${params2.height}px`, canvas.width = params2.width * dpr, canvas.height = params2.height * dpr), canvas;
  }
  createOffscreenCanvas(params2) {
    var _a;
    const dpr = null !== (_a = params2.dpr) && void 0 !== _a ? _a : window.devicePixelRatio;
    return new OffscreenCanvas(params2.width * dpr, params2.height * dpr);
  }
  releaseCanvas(canvas) {
    let c3;
    c3 = "string" == typeof canvas ? document.getElementById(canvas) : canvas, c3 && c3.parentElement && c3.parentElement.removeChild(c3);
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getRequestAnimationFrame() {
    return window.requestAnimationFrame;
  }
  getCancelAnimationFrame() {
    return window.cancelAnimationFrame;
  }
  addEventListener(type, listener, options) {
    return document.addEventListener(type, listener, options);
  }
  removeEventListener(type, listener, options) {
    return document.removeEventListener(type, listener, options);
  }
  dispatchEvent(event) {
    return document.dispatchEvent(event);
  }
  getElementById(str) {
    return document.getElementById(str);
  }
  getRootElement() {
    return document.body;
  }
  getDocument() {
    return document;
  }
  release(...params2) {
  }
  getElementTop(element, baseWindow) {
    let actualTop = element.offsetTop, current = element.offsetParent;
    for (; null !== current; )
      actualTop += current.offsetTop, current = current.offsetParent;
    return actualTop;
  }
  getElementLeft(element, baseWindow) {
    let actualLeft = element.offsetLeft, current = element.offsetParent;
    for (; null !== current; )
      actualLeft += current.offsetLeft, current = current.offsetParent;
    return actualLeft;
  }
  getElementTopLeft(element, baseWindow) {
    let actualTop = element.offsetTop, actualLeft = element.offsetLeft, current = element.offsetParent;
    for (; null !== current; )
      actualTop += current.offsetTop, actualLeft += current.offsetLeft, current = current.offsetParent;
    return {
      top: actualTop,
      left: actualLeft
    };
  }
};
BrowserEnvContribution = __decorate49([injectable(), __metadata35("design:paramtypes", [])], BrowserEnvContribution);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/env/browser
var browserEnvModule = new ContainerModule((bind) => {
  browserEnvModule.isBrowserBound || (browserEnvModule.isBrowserBound = true, bind(BrowserEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(BrowserEnvContribution));
});
browserEnvModule.isBrowserBound = false;
function loadBrowserEnv(container2, loadPicker = true) {
  loadBrowserEnv.__loaded || (loadBrowserEnv.__loaded = true, container2.load(browserEnvModule), container2.load(browserCanvasModule), container2.load(browserWindowModule), loadPicker && loadCanvasPicker(container2));
}
loadBrowserEnv.__loaded = false;

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/math-picker-service
var __decorate50 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata36 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param21 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathPickerService = class extends DefaultPickService {
  constructor(contributions, pickItemInterceptorContributions) {
    super(pickItemInterceptorContributions), this.contributions = contributions, this.pickItemInterceptorContributions = pickItemInterceptorContributions, this.global.hooks.onSetEnv.tap("math-picker-service", (lastEnv, env, global) => {
      this.configure(global, env);
    }), this.configure(this.global, this.global.env), this.pickerMap = /* @__PURE__ */ new Map(), this.init();
  }
  init() {
    this.contributions.getContributions().forEach((item) => {
      this.pickerMap.set(item.numberType, item);
    }), super._init();
  }
  configure(global, env) {
    this.pickContext = new EmptyContext2d(null, 1);
  }
  pickItem(graphic, point5, parentMatrix, params2) {
    if (false === graphic.attribute.pickable)
      return null;
    const picker = this.pickerMap.get(graphic.numberType);
    if (!picker)
      return null;
    const pd = picker.contains(graphic, point5, params2), g = pd ? graphic : null;
    return g ? {
      graphic: g,
      params: pd
    } : null;
  }
};
DefaultMathPickerService = __decorate50([injectable(), __param21(0, inject(ContributionProvider)), __param21(0, named(MathPickerContribution)), __param21(1, inject(ContributionProvider)), __param21(1, named(PickItemInterceptor)), __metadata36("design:paramtypes", [Object, Object])], DefaultMathPickerService);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/math-picker/module
var m2 = new ContainerModule((bind) => {
  m2.__vloaded || (m2.__vloaded = true, bindContributionProvider(bind, MathPickerContribution));
});
m2.__vloaded = false;
var module_default3 = m2;

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/math-picker/arc-picker
var __decorate51 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata37 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param22 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathArcPicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "arc", this.numberType = ARC_NUMBER_TYPE;
  }
  contains(arc, point5, params2) {
    if (!arc.AABBBounds.containsPoint(point5))
      return false;
    if ("imprecise" === arc.attribute.pickMode)
      return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext)
      return false;
    const arcAttribute = getTheme(arc).arc;
    pickContext.highPerformanceSave();
    let { x = arcAttribute.x, y = arcAttribute.y } = arc.attribute;
    if (arc.transMatrix.onlyTranslate()) {
      const point6 = arc.getOffsetXY(arcAttribute);
      x += point6.x, y += point6.y, pickContext.setTransformForCurrent();
    } else
      x = 0, y = 0, pickContext.transformFromMatrix(arc.transMatrix, true);
    let picked = false;
    return this.canvasRenderer.drawShape(arc, pickContext, x, y, {}, null, (context, arcAttribute2, themeAttribute) => !!picked || (picked = context.isPointInPath(point5.x, point5.y), picked), (context, arcAttribute2, themeAttribute) => {
      if (picked)
        return true;
      const lineWidth = arcAttribute2.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = arcAttribute2.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
      return pickContext.lineWidth = lineWidth + pickStrokeBuffer, picked = context.isPointInStroke(point5.x, point5.y), picked;
    }), pickContext.highPerformanceRestore(), picked;
  }
};
DefaultMathArcPicker = __decorate51([injectable(), __param22(0, inject(ArcRender)), __metadata37("design:paramtypes", [Object])], DefaultMathArcPicker);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/math-picker/arc-module
var loadArcPick = false;
var arcMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadArcPick || (loadArcPick = true, bind(MathArcPicker).to(DefaultMathArcPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathArcPicker));
});

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/math-picker/area-picker
var __decorate52 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata38 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param23 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathAreaPicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "area", this.numberType = AREA_NUMBER_TYPE;
  }
  contains(area2, point5, params2) {
    if (!area2.AABBBounds.containsPoint(point5))
      return false;
    if ("imprecise" === area2.attribute.pickMode)
      return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext)
      return false;
    const areaAttribute = getTheme(area2).area;
    let { x = areaAttribute.x, y = areaAttribute.y } = area2.attribute;
    if (pickContext.highPerformanceSave(), area2.transMatrix.onlyTranslate()) {
      const point6 = area2.getOffsetXY(areaAttribute);
      x += point6.x, y += point6.y, pickContext.setTransformForCurrent();
    } else
      x = 0, y = 0, pickContext.transformFromMatrix(area2.transMatrix, true);
    let picked = false;
    return this.canvasRenderer.drawShape(area2, pickContext, x, y, {}, null, (context) => !!picked || (picked = context.isPointInPath(point5.x, point5.y), picked)), pickContext.highPerformanceRestore(), picked;
  }
};
DefaultMathAreaPicker = __decorate52([injectable(), __param23(0, inject(AreaRender)), __metadata38("design:paramtypes", [Object])], DefaultMathAreaPicker);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/math-picker/area-module
var loadAreaPick = false;
var areaMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadAreaPick || (loadAreaPick = true, bind(MathAreaPicker).to(DefaultMathAreaPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathAreaPicker));
});

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/math-picker/circle-picker
var __decorate53 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata39 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param24 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathCirclePicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "circle", this.numberType = CIRCLE_NUMBER_TYPE;
  }
  contains(circle3, point5, params2) {
    if (!circle3.AABBBounds.containsPoint(point5))
      return false;
    if ("imprecise" === circle3.attribute.pickMode)
      return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext)
      return false;
    const circleAttribute = getTheme(circle3).circle;
    let { x = circleAttribute.x, y = circleAttribute.y } = circle3.attribute;
    if (pickContext.highPerformanceSave(), circle3.transMatrix.onlyTranslate()) {
      const point6 = circle3.getOffsetXY(circleAttribute);
      x += point6.x, y += point6.y, pickContext.setTransformForCurrent();
    } else
      x = 0, y = 0, pickContext.transformFromMatrix(circle3.transMatrix, true);
    let picked = false;
    return this.canvasRenderer.drawShape(circle3, pickContext, x, y, {}, null, (context, circleAttribute2, themeAttribute) => !!picked || (picked = context.isPointInPath(point5.x, point5.y), picked), (context, circleAttribute2, themeAttribute) => {
      if (picked)
        return true;
      const lineWidth = circleAttribute2.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = circleAttribute2.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
      return pickContext.lineWidth = lineWidth + pickStrokeBuffer, picked = context.isPointInStroke(point5.x, point5.y), picked;
    }), pickContext.highPerformanceRestore(), picked;
  }
};
DefaultMathCirclePicker = __decorate53([injectable(), __param24(0, inject(CircleRender)), __metadata39("design:paramtypes", [Object])], DefaultMathCirclePicker);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/math-picker/circle-module
var loadCirclePick = false;
var circleMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadCirclePick || (loadCirclePick = true, bind(MathCirclePicker).to(DefaultMathCirclePicker).inSingletonScope(), bind(MathPickerContribution).toService(MathCirclePicker));
});

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/math-picker/glyph-picker
var __decorate54 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata40 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param25 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathGlyphPicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "glyph", this.numberType = GLYPH_NUMBER_TYPE;
  }
  contains(glyph, point5, params2) {
    if (!glyph.AABBBounds.containsPoint(point5))
      return false;
    if ("imprecise" === glyph.attribute.pickMode)
      return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext)
      return false;
    const pickerService = null == params2 ? void 0 : params2.pickerService;
    if (pickerService) {
      let picked = false;
      return glyph.getSubGraphic().forEach((g) => {
        picked || (picked = !!pickerService.pickItem(g, point5, null, params2));
      }), picked;
    }
    return false;
  }
};
DefaultMathGlyphPicker = __decorate54([injectable(), __param25(0, inject(GlyphRender)), __metadata40("design:paramtypes", [Object])], DefaultMathGlyphPicker);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/math-picker/glyph-module
var loadGlyphPick = false;
var glyphMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadGlyphPick || (loadGlyphPick = true, bind(MathGlyphPicker).to(DefaultMathGlyphPicker).inSingletonScope(), bind(DefaultMathGlyphPicker).toService(MathGlyphPicker));
});

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/math-picker/image-picker
var __decorate55 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultMathImagePicker = class {
  constructor() {
    this.type = "image", this.numberType = IMAGE_NUMBER_TYPE;
  }
  contains(image, point5, params2) {
    const { pickContext } = null != params2 ? params2 : {};
    return !!pickContext && !!image.AABBBounds.containsPoint(point5);
  }
};
DefaultMathImagePicker = __decorate55([injectable()], DefaultMathImagePicker);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/math-picker/image-module
var loadImagePick = false;
var imageMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadImagePick || (loadImagePick = true, bind(MathImagePicker).to(DefaultMathImagePicker).inSingletonScope(), bind(DefaultMathImagePicker).toService(MathImagePicker));
});

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/math-picker/line-picker
var __decorate56 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata41 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param26 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathLinePicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "line", this.numberType = LINE_NUMBER_TYPE;
  }
  contains(line2, point5, params2) {
    if (!line2.AABBBounds.containsPoint(point5))
      return false;
    if ("imprecise" === line2.attribute.pickMode)
      return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext)
      return false;
    const lineAttribute = getTheme(line2).line;
    let { x = lineAttribute.x, y = lineAttribute.y } = line2.attribute;
    if (pickContext.highPerformanceSave(), line2.transMatrix.onlyTranslate()) {
      const point6 = line2.getOffsetXY(lineAttribute);
      x += point6.x, y += point6.y, pickContext.setTransformForCurrent();
    } else
      x = 0, y = 0, pickContext.transformFromMatrix(line2.transMatrix, true);
    let picked = false;
    return this.canvasRenderer.drawShape(line2, pickContext, x, y, {}, null, (context) => !!picked || (picked = context.isPointInPath(point5.x, point5.y), picked), (context, circleAttribute, themeAttribute) => {
      if (picked)
        return true;
      const lineWidth = circleAttribute.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = circleAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
      return pickContext.lineWidth = lineWidth + pickStrokeBuffer, picked = context.isPointInStroke(point5.x, point5.y), picked;
    }), pickContext.highPerformanceRestore(), picked;
  }
};
DefaultMathLinePicker = __decorate56([injectable(), __param26(0, inject(LineRender)), __metadata41("design:paramtypes", [Object])], DefaultMathLinePicker);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/math-picker/line-module
var loadLinePick = false;
var lineMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadLinePick || (loadLinePick = true, bind(MathLinePicker).to(DefaultMathLinePicker).inSingletonScope(), bind(MathPickerContribution).toService(MathLinePicker));
});

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/math-picker/polygon-picker
var __decorate57 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata42 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param27 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathPolygonPicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "polygon", this.numberType = POLYGON_NUMBER_TYPE;
  }
  contains(polygon, point5, params2) {
    if (!polygon.AABBBounds.contains(point5.x, point5.y))
      return false;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext)
      return false;
    const pathAttribute = getTheme(polygon).polygon;
    let { x = pathAttribute.x, y = pathAttribute.y } = polygon.attribute;
    if (pickContext.highPerformanceSave(), polygon.transMatrix.onlyTranslate()) {
      const point6 = polygon.getOffsetXY(pathAttribute);
      x += point6.x, y += point6.y, pickContext.setTransformForCurrent();
    } else
      x = 0, y = 0, pickContext.transformFromMatrix(polygon.transMatrix, true);
    let picked = false;
    return this.canvasRenderer.drawShape(polygon, pickContext, x, y, {}, null, (context, pathAttribute2, themeAttribute) => !!picked || (picked = context.isPointInPath(point5.x, point5.y), picked), (context, pathAttribute2, themeAttribute) => {
      if (picked)
        return true;
      const lineWidth = pathAttribute2.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = pathAttribute2.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
      return pickContext.lineWidth = lineWidth + pickStrokeBuffer, picked = context.isPointInStroke(point5.x, point5.y), picked;
    }), pickContext.highPerformanceRestore(), picked;
  }
};
DefaultMathPolygonPicker = __decorate57([injectable(), __param27(0, inject(PolygonRender)), __metadata42("design:paramtypes", [Object])], DefaultMathPolygonPicker);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/math-picker/polygon-module
var loadPolygonPick = false;
var polygonMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadPolygonPick || (loadPolygonPick = true, bind(MathPolygonPicker).to(DefaultMathPolygonPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathPolygonPicker));
});

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/math-picker/path-picker
var __decorate58 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata43 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param28 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathPathPicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "path", this.numberType = PATH_NUMBER_TYPE;
  }
  contains(path, point5, params2) {
    if (!path.AABBBounds.containsPoint(point5))
      return false;
    if ("imprecise" === path.attribute.pickMode)
      return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext)
      return false;
    const pathAttribute = getTheme(path).path;
    let { x = pathAttribute.x, y = pathAttribute.y } = path.attribute;
    if (pickContext.highPerformanceSave(), path.transMatrix.onlyTranslate()) {
      const point6 = path.getOffsetXY(pathAttribute);
      x += point6.x, y += point6.y, pickContext.setTransformForCurrent();
    } else
      x = 0, y = 0, pickContext.transformFromMatrix(path.transMatrix, true);
    let picked = false;
    return this.canvasRenderer.drawShape(path, pickContext, x, y, {}, null, (context, pathAttribute2, themeAttribute) => !!picked || (picked = context.isPointInPath(point5.x, point5.y), picked), (context, pathAttribute2, themeAttribute) => {
      if (picked)
        return true;
      const lineWidth = pathAttribute2.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = pathAttribute2.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
      return pickContext.lineWidth = lineWidth + pickStrokeBuffer, picked = context.isPointInStroke(point5.x, point5.y), picked;
    }), pickContext.highPerformanceRestore(), picked;
  }
};
DefaultMathPathPicker = __decorate58([injectable(), __param28(0, inject(PathRender)), __metadata43("design:paramtypes", [Object])], DefaultMathPathPicker);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/math-picker/path-module
var loadPathPick = false;
var pathMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadPathPick || (loadPathPick = true, bind(MathPathPicker).to(DefaultMathPathPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathPathPicker));
});

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/math-picker/rect-picker
var __decorate59 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata44 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param29 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var _bounds = new AABBBounds();
var DefaultMathRectPicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "rect", this.numberType = RECT_NUMBER_TYPE;
  }
  contains(rect, point5, params2) {
    if (!rect.AABBBounds.containsPoint(point5))
      return false;
    if ("imprecise" === rect.attribute.pickMode)
      return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext)
      return false;
    const rectAttribute = getTheme(rect).rect, { cornerRadius = rectAttribute.cornerRadius } = rect.attribute;
    let { x = rectAttribute.x, y = rectAttribute.y } = rect.attribute;
    pickContext.highPerformanceSave();
    let onlyTranslate = true;
    if (rect.transMatrix.onlyTranslate()) {
      const point6 = rect.getOffsetXY(rectAttribute);
      x += point6.x, y += point6.y, pickContext.setTransformForCurrent();
    } else
      x = 0, y = 0, onlyTranslate = false, pickContext.transformFromMatrix(rect.transMatrix, true);
    let picked = true;
    if (!onlyTranslate || isNumber_default(cornerRadius, true) && 0 !== cornerRadius || isArray_default(cornerRadius) && cornerRadius.some((num) => 0 !== num))
      picked = false, this.canvasRenderer.drawShape(rect, pickContext, x, y, {}, null, (context, rectAttribute2, themeAttribute) => !!picked || (picked = context.isPointInPath(point5.x, point5.y), picked), (context, rectAttribute2, themeAttribute) => {
        if (picked)
          return true;
        const lineWidth = rectAttribute2.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = rectAttribute2.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
        return pickContext.lineWidth = lineWidth + pickStrokeBuffer, picked = context.isPointInStroke(point5.x, point5.y), picked;
      });
    else if (picked) {
      const { fill = rectAttribute.fill, stroke: stroke2 = rectAttribute.stroke, lineWidth = rectAttribute.lineWidth } = rect.attribute;
      if (fill)
        picked = true;
      else if (stroke2) {
        const bounds = rect.AABBBounds;
        _bounds.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), _bounds.expand(-lineWidth / 2), picked = !_bounds.containsPoint(point5);
      }
    }
    return pickContext.highPerformanceRestore(), picked;
  }
};
DefaultMathRectPicker = __decorate59([injectable(), __param29(0, inject(RectRender)), __metadata44("design:paramtypes", [Object])], DefaultMathRectPicker);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/math-picker/rect-module
var loadRectPick = false;
var rectMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadRectPick || (loadRectPick = true, bind(MathRectPicker).to(DefaultMathRectPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathRectPicker));
});

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/math-picker/richtext-module
var loadRichTextPick = false;
var richTextMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadRichTextPick || (loadRichTextPick = true, bind(MathImagePicker).to(DefaultMathImagePicker).inSingletonScope(), bind(DefaultMathImagePicker).toService(MathImagePicker));
});

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/math-picker/symbol-picker
var __decorate60 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata45 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param30 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultMathSymbolPicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "symbol", this.numberType = SYMBOL_NUMBER_TYPE;
  }
  contains(symbol, point5, params2) {
    if (!symbol.AABBBounds.containsPoint(point5))
      return false;
    if ("imprecise" === symbol.attribute.pickMode)
      return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext)
      return false;
    const symbolAttribute = getTheme(symbol).symbol;
    let { x = symbolAttribute.x, y = symbolAttribute.y } = symbol.attribute;
    if (pickContext.highPerformanceSave(), symbol.transMatrix.onlyTranslate()) {
      const point6 = symbol.getOffsetXY(symbolAttribute);
      x += point6.x, y += point6.y, pickContext.setTransformForCurrent();
    } else
      x = 0, y = 0, pickContext.transformFromMatrix(symbol.transMatrix, true);
    let picked = false;
    return this.canvasRenderer.drawShape(symbol, pickContext, x, y, {}, null, (context, symbolAttribute2, themeAttribute) => !!picked || (picked = context.isPointInPath(point5.x, point5.y), picked), (context, symbolAttribute2, themeAttribute) => {
      if (picked)
        return true;
      const lineWidth = symbolAttribute2.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = symbolAttribute2.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
      return pickContext.lineWidth = lineWidth + pickStrokeBuffer, picked = context.isPointInStroke(point5.x, point5.y), picked;
    }), pickContext.highPerformanceRestore(), picked;
  }
};
DefaultMathSymbolPicker = __decorate60([injectable(), __param30(0, inject(SymbolRender)), __metadata45("design:paramtypes", [Object])], DefaultMathSymbolPicker);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/math-picker/symbol-module
var loadSymbolPick = false;
var symbolMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadSymbolPick || (loadSymbolPick = true, bind(MathSymbolPicker).to(DefaultMathSymbolPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathSymbolPicker));
});

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/math-picker/text-picker
var __decorate61 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultMathTextPicker = class {
  constructor() {
    this.type = "text", this.numberType = TEXT_NUMBER_TYPE;
  }
  contains(text2, point5, params2) {
    return !!text2.AABBBounds.containsPoint(point5);
  }
};
DefaultMathTextPicker = __decorate61([injectable()], DefaultMathTextPicker);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/math-picker/text-module
var loadTextPick = false;
var textMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadTextPick || (loadTextPick = true, bind(MathTextPicker).to(DefaultMathTextPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathTextPicker));
});

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/math-module
var mathPickerModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  isBound(DefaultMathPickerService) || bind(DefaultMathPickerService).toSelf().inSingletonScope(), isBound(PickerService) ? rebind(PickerService).toService(DefaultMathPickerService) : bind(PickerService).toService(DefaultMathPickerService);
});
function loadMathPicker(c3) {
  c3.load(module_default3), c3.load(mathPickerModule), c3.load(arcMathPickModule), c3.load(areaMathPickModule), c3.load(circleMathPickModule), c3.load(glyphMathPickModule), c3.load(imageMathPickModule), c3.load(lineMathPickModule), c3.load(polygonMathPickModule), c3.load(pathMathPickModule), c3.load(rectMathPickModule), c3.load(richTextMathPickModule), c3.load(symbolMathPickModule), c3.load(textMathPickModule);
}

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/canvas/contributions/node/context
var __decorate62 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata46 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var NodeContext2d = class extends BrowserContext2d {
  constructor(canvas, dpr) {
    super(canvas, dpr);
    const context = canvas.nativeCanvas.getContext("2d");
    if (!context)
      throw new Error("\u53D1\u751F\u9519\u8BEF\uFF0C\u83B7\u53D62d\u4E0A\u4E0B\u6587\u5931\u8D25");
    this.nativeContext = context, this.canvas = canvas, this.matrix = new Matrix(1, 0, 0, 1, 0, 0), this.stack = [], this.dpr = null != dpr ? dpr : 1;
  }
  release(...params2) {
  }
};
NodeContext2d.env = "node", NodeContext2d = __decorate62([injectable(), __metadata46("design:paramtypes", [Object, Number])], NodeContext2d);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/canvas/contributions/node/canvas
var __decorate63 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata47 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var NodeCanvas = class extends BaseCanvas {
  constructor(params2) {
    super(params2);
  }
  init() {
    this._context = new NodeContext2d(this, this._dpr), this.nativeCanvas.width = this._pixelWidth, this.nativeCanvas.height = this._pixelHeight;
  }
  release(...params2) {
    this._nativeCanvas.release && isFunction_default(this._nativeCanvas.release) && this._nativeCanvas.release();
  }
};
NodeCanvas.env = "node", NodeCanvas = __decorate63([injectable(), __metadata47("design:paramtypes", [Object])], NodeCanvas);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/canvas/contributions/node/modules
var nodeCanvasModule = createModule(NodeCanvas, NodeContext2d);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/window/contributions/node-contribution
var __decorate64 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata48 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param31 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var NodeWindowHandlerContribution = class extends BaseWindowHandlerContribution {
  get container() {
    return null;
  }
  constructor(global) {
    super(), this.global = global, this.type = "node";
  }
  getTitle() {
    return "";
  }
  getWH() {
    return {
      width: this.canvas.displayWidth,
      height: this.canvas.displayHeight
    };
  }
  getXY() {
    return {
      x: 0,
      y: 0
    };
  }
  createWindow(params2) {
    params2.canvas ? this.createWindowByCanvas(params2) : this.createWindowByConfig(params2);
  }
  createWindowByConfig(params2) {
    const nativeCanvas = this.global.createCanvas({
      width: params2.width,
      height: params2.height
    }), options = {
      width: params2.width,
      height: params2.height,
      dpr: params2.dpr,
      nativeCanvas,
      id: Generator.GenAutoIncrementId().toString(),
      canvasControled: true
    };
    this.canvas = new NodeCanvas(options);
  }
  createWindowByCanvas(params2) {
    const canvas = params2.canvas;
    let width = params2.width, height = params2.height;
    null != width && null != height && params2.canvasControled || (width = canvas.width, height = canvas.height), this.canvas = new NodeCanvas({
      width,
      height,
      dpr: 1,
      nativeCanvas: canvas,
      canvasControled: params2.canvasControled
    });
  }
  releaseWindow() {
    this.canvas.release();
  }
  resizeWindow(width, height) {
    this.canvas.resize(width, height);
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  getContext() {
    return this.canvas.getContext();
  }
  getNativeHandler() {
    return this.canvas;
  }
  getDpr() {
    return this.canvas.dpr;
  }
  getImageBuffer(type = "image/png") {
    return this.canvas.nativeCanvas.toBuffer(type);
  }
  addEventListener(type, listener, options) {
  }
  dispatchEvent(event) {
    return true;
  }
  removeEventListener(type, listener, options) {
  }
  getStyle() {
  }
  setStyle(style) {
  }
  getBoundingClientRect() {
    return null;
  }
  clearViewBox(color) {
  }
};
NodeWindowHandlerContribution.env = "node", NodeWindowHandlerContribution = __decorate64([injectable(), __param31(0, inject(VGlobal)), __metadata48("design:paramtypes", [Object])], NodeWindowHandlerContribution);
var nodeWindowModule = new ContainerModule((bind) => {
  bind(NodeWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue((ctx) => ctx.container.get(NodeWindowHandlerContribution)).whenTargetNamed(NodeWindowHandlerContribution.env);
});

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/env/contributions/node-contribution
var __decorate65 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var NodeEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(...arguments), this.type = "node", this._lastTime = 0, this.supportEvent = false;
  }
  configure(service, pkg) {
    service.env === this.type && (service.setActiveEnvContribution(this), this.pkg = pkg);
  }
  getDynamicCanvasCount() {
    return 0;
  }
  getStaticCanvasCount() {
    return 999;
  }
  loadJson(url) {
    const jsonPromise = fetch(url).then((data) => data.json());
    return jsonPromise.then((json) => ({
      data: json,
      state: "success"
    })).catch(() => ({
      data: null,
      state: "fail"
    })), jsonPromise;
  }
  loadArrayBuffer(url) {
    return fetch(url).then((data) => data.arrayBuffer()).then((arrayBuffer) => ({
      data: arrayBuffer,
      loadState: "success"
    })).catch(() => ({
      data: null,
      loadState: "fail"
    }));
  }
  loadImage(url) {
    const { loadImage } = this.pkg;
    return loadImage ? loadImage(url).then((image) => ({
      loadState: image ? "success" : "fail",
      data: image
    })).catch(() => ({
      loadState: "fail",
      data: null
    })) : Promise.reject(new Error("node-canvas loadImage could not be found!"));
  }
  loadSvg(svgStr) {
    const Resvg = this.pkg.Resvg;
    if (!Resvg)
      return Promise.reject(new Error("@resvg/resvg-js svgParser could not be found!"));
    const pngData = new Resvg(svgStr).render().asPng();
    return this.loadImage(pngData);
  }
  createCanvas(params2) {
    return this.pkg.createCanvas(params2.width, params2.height);
  }
  releaseCanvas(canvas) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getRequestAnimationFrame() {
    return function(callback) {
      return rafBasedSto.call(callback);
    };
  }
  getCancelAnimationFrame() {
    return (h) => {
      rafBasedSto.clear(h);
    };
  }
  addEventListener(type, listener, options) {
  }
  removeEventListener(type, listener, options) {
  }
  getElementById(str) {
    return null;
  }
  getRootElement() {
    return null;
  }
  dispatchEvent(event) {
  }
  release(...params2) {
  }
  createOffscreenCanvas(params2) {
  }
};
NodeEnvContribution = __decorate65([injectable()], NodeEnvContribution);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/env/node
var nodeEnvModule = new ContainerModule((bind) => {
  nodeEnvModule.isNodeBound || (nodeEnvModule.isNodeBound = true, bind(NodeEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(NodeEnvContribution));
});
nodeEnvModule.isNodeBound = false;
function loadNodeEnv(container2, loadPicker = true) {
  loadNodeEnv.__loaded || (loadNodeEnv.__loaded = true, container2.load(nodeEnvModule), container2.load(nodeCanvasModule), container2.load(nodeWindowModule));
}
loadNodeEnv.__loaded = false;

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/canvas/contributions/wx/context
var __decorate66 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var WxContext2d = class extends BrowserContext2d {
  draw() {
  }
  createPattern(image, repetition) {
    return null;
  }
};
WxContext2d.env = "wx", WxContext2d = __decorate66([injectable()], WxContext2d);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/canvas/contributions/wx/canvas
var __decorate67 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata49 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var WxCanvas = class extends BaseCanvas {
  constructor(params2) {
    super(params2);
  }
  init() {
    this._context = new WxContext2d(this, this._dpr);
  }
  release(...params2) {
  }
};
WxCanvas.env = "wx", WxCanvas = __decorate67([injectable(), __metadata49("design:paramtypes", [Object])], WxCanvas);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/canvas/contributions/wx/modules
var wxCanvasModule = createModule(WxCanvas, WxContext2d);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/window/contributions/wx-contribution
var __decorate68 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata50 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param32 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var MiniAppEventManager = class {
  constructor() {
    this.cache = {};
  }
  addEventListener(type, func) {
    type && func && (this.cache[type] = this.cache[type] || {
      listener: []
    }, this.cache[type].listener.push(func));
  }
  removeEventListener(type, func) {
    if (!type || !func)
      return;
    if (!this.cache[type])
      return;
    const index = this.cache[type].listener.findIndex((f) => f === func);
    index >= 0 && this.cache[type].listener.splice(index, 1);
  }
  cleanEvent() {
    this.cache = {};
  }
};
var WxWindowHandlerContribution = class extends BaseWindowHandlerContribution {
  get container() {
    return null;
  }
  constructor(global) {
    super(), this.global = global, this.type = "wx", this.eventManager = new MiniAppEventManager();
  }
  getTitle() {
    return this.canvas.id.toString();
  }
  getWH() {
    return {
      width: this.canvas.width / (this.canvas.dpr || 1),
      height: this.canvas.height / (this.canvas.dpr || 1)
    };
  }
  getXY() {
    return {
      x: 0,
      y: 0
    };
  }
  createWindow(params2) {
    params2.canvas ? this.createWindowByCanvas(params2) : this.createWindowByConfig(params2);
  }
  createWindowByConfig(params2) {
    const nativeCanvas = this.global.createCanvas({
      width: params2.width,
      height: params2.height
    }), options = {
      width: params2.width,
      height: params2.height,
      dpr: params2.dpr,
      nativeCanvas,
      id: Generator.GenAutoIncrementId().toString(),
      canvasControled: false
    };
    this.canvas = new WxCanvas(options);
  }
  createWindowByCanvas(params2) {
    let canvas;
    if ("string" == typeof params2.canvas) {
      if (canvas = this.global.getElementById(params2.canvas), !canvas)
        throw new Error("canvasId \u53C2\u6570\u4E0D\u6B63\u786E\uFF0C\u8BF7\u786E\u8BA4canvas\u5B58\u5728\u5E76\u63D2\u5165dom");
    } else
      canvas = params2.canvas;
    let width = params2.width, height = params2.height;
    if (null == width || null == height || !params2.canvasControled) {
      const data = canvas.getBoundingClientRect();
      width = data.width, height = data.height;
    }
    let dpr = params2.dpr;
    null == dpr && (dpr = canvas.width / width), this.canvas = new WxCanvas({
      width,
      height,
      dpr,
      nativeCanvas: canvas,
      canvasControled: params2.canvasControled
    });
  }
  releaseWindow() {
  }
  resizeWindow(width, height) {
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  getContext() {
    return this.canvas.getContext();
  }
  getNativeHandler() {
    return this.canvas;
  }
  getDpr() {
    return this.canvas.dpr;
  }
  addEventListener(type, listener) {
    this.eventManager.addEventListener(type, listener);
  }
  removeEventListener(type, listener) {
    this.eventManager.removeEventListener(type, listener);
  }
  dispatchEvent(event) {
    var _a, _b, _c, _d;
    const { type } = event;
    return !!this.eventManager.cache[type] && (event.changedTouches && event.changedTouches[0] && (event.offsetX = event.changedTouches[0].x, event.changedTouches[0].offsetX = null !== (_a = event.changedTouches[0].x) && void 0 !== _a ? _a : event.changedTouches[0].pageX, event.changedTouches[0].clientX = null !== (_b = event.changedTouches[0].x) && void 0 !== _b ? _b : event.changedTouches[0].pageX, event.offsetY = event.changedTouches[0].y, event.changedTouches[0].offsetY = null !== (_c = event.changedTouches[0].y) && void 0 !== _c ? _c : event.changedTouches[0].pageY, event.changedTouches[0].clientY = null !== (_d = event.changedTouches[0].y) && void 0 !== _d ? _d : event.changedTouches[0].pageY), event.preventDefault = () => {
    }, event.stopPropagation = () => {
    }, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach((f) => {
      f(event);
    }), true);
  }
  getStyle() {
    return {};
  }
  setStyle(style) {
  }
  getBoundingClientRect() {
    const wh = this.getWH();
    return {
      x: 0,
      y: 0,
      width: wh.width,
      height: wh.height,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }
  clearViewBox(color) {
    const vb = this.viewBox, context = this.getContext(), dpr = this.getDpr();
    context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
  }
};
WxWindowHandlerContribution.env = "wx", WxWindowHandlerContribution = __decorate68([injectable(), __param32(0, inject(VGlobal)), __metadata50("design:paramtypes", [Object])], WxWindowHandlerContribution);
var wxWindowModule = new ContainerModule((bind) => {
  bind(WxWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue((ctx) => ctx.container.get(WxWindowHandlerContribution)).whenTargetNamed(WxWindowHandlerContribution.env);
});

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/env/contributions/wx-contribution
var __decorate69 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata51 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function makeUpCanvas(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList, component2) {
  return __awaiter5(this, void 0, void 0, function* () {
    const dpr = uni.getWindowInfo().pixelRatio;
    for (let i = 0; i < canvasIdLists.length; i++) {
      const id2 = canvasIdLists[i];
      yield new Promise((resolve) => {
        let data = uni.createSelectorQuery();
        component2 && (data = data.in(component2)), data.select(`#${id2}`).fields({
          node: true,
          size: true
        }).exec((res) => {
          if (!res[0])
            return;
          const canvas = res[0].node, width = res[0].width, height = res[0].height;
          canvas.width = width * dpr, canvas.height = height * dpr, canvasMap.set(id2, canvas), i >= freeCanvasIdx && freeCanvasList.push(canvas), resolve(null);
        });
      });
    }
  });
}
var WxEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(), this.type = "wx", this.supportEvent = true, this.canvasMap = /* @__PURE__ */ new Map(), this.freeCanvasList = [], this.canvasIdx = 0, this.supportsTouchEvents = true;
    try {
      this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;
    } catch (err) {
      this.supportsPointerEvents = false, this.supportsMouseEvents = false;
    }
    this.applyStyles = true;
  }
  configure(service, params2) {
    if (service.env === this.type)
      return service.setActiveEnvContribution(this), makeUpCanvas(params2.domref, params2.canvasIdLists, this.canvasMap, params2.freeCanvasIdx, this.freeCanvasList, params2.component).then(() => {
      });
  }
  loadImage(url) {
    return Promise.resolve({
      data: url,
      loadState: "success"
    });
  }
  loadSvg(url) {
    return Promise.reject();
  }
  createCanvas(params2) {
    const result2 = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
    return this.canvasIdx++, result2;
  }
  createOffscreenCanvas(params2) {
  }
  releaseCanvas(canvas) {
  }
  getDevicePixelRatio() {
    return uni.getWindowInfo().pixelRatio;
  }
  getRequestAnimationFrame() {
    return function(callback) {
      return rafBasedSto.call(callback);
    };
  }
  getCancelAnimationFrame() {
    return (h) => {
      rafBasedSto.clear(h);
    };
  }
  addEventListener(type, listener, options) {
    return null;
  }
  removeEventListener(type, listener, options) {
    return null;
  }
  dispatchEvent(event) {
    return null;
  }
  getElementById(str) {
    return this.canvasMap.get(str);
  }
  getRootElement() {
    return null;
  }
  getDocument() {
    return null;
  }
  release(...params2) {
  }
  mapToCanvasPoint(event) {
    var _a;
    return null === (_a = null == event ? void 0 : event.type) || void 0 === _a || _a.startsWith("mouse"), event;
  }
};
WxEnvContribution = __decorate69([injectable(), __metadata51("design:paramtypes", [])], WxEnvContribution);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/env/wx
var wxEnvModule = new ContainerModule((bind) => {
  wxEnvModule._isWxBound || (wxEnvModule._isWxBound = true, bind(WxEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(WxEnvContribution));
});
wxEnvModule._isWxBound = false;
function loadWxEnv(container2, loadPicker = true) {
  loadWxEnv.__loaded || (loadWxEnv.__loaded = true, container2.load(wxEnvModule), container2.load(wxCanvasModule), container2.load(wxWindowModule), loadPicker && loadMathPicker(container2));
}
loadWxEnv.__loaded = false;

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/canvas-picker/arc-picker
var __decorate70 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata52 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param33 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasArcPicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "arc", this.numberType = ARC_NUMBER_TYPE;
  }
  contains(arc, point5, params2) {
    if (!arc.AABBBounds.containsPoint(point5))
      return false;
    if ("imprecise" === arc.attribute.pickMode)
      return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext)
      return false;
    const arcAttribute = getTheme(arc).arc;
    pickContext.highPerformanceSave();
    let { x = arcAttribute.x, y = arcAttribute.y } = arc.attribute;
    if (arc.transMatrix.onlyTranslate()) {
      const point6 = arc.getOffsetXY(arcAttribute);
      x += point6.x, y += point6.y, pickContext.setTransformForCurrent();
    } else
      x = 0, y = 0, pickContext.transformFromMatrix(arc.transMatrix, true);
    let picked = false;
    return this.canvasRenderer.drawShape(arc, pickContext, x, y, {}, null, (context, arcAttribute2, themeAttribute) => !!picked || (picked = context.isPointInPath(point5.x, point5.y), picked), (context, arcAttribute2, themeAttribute) => {
      if (picked)
        return true;
      const lineWidth = arcAttribute2.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = arcAttribute2.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
      return pickContext.lineWidth = getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(point5.x, point5.y), picked;
    }), pickContext.highPerformanceRestore(), picked;
  }
};
DefaultCanvasArcPicker = __decorate70([injectable(), __param33(0, inject(ArcRender)), __metadata52("design:paramtypes", [Object])], DefaultCanvasArcPicker);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/canvas-picker/arc-module
var loadArcPick2 = false;
var arcCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadArcPick2 || (loadArcPick2 = true, bind(CanvasArcPicker).to(DefaultCanvasArcPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasArcPicker));
});

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/canvas-picker/rect-picker
var __decorate71 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata53 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param34 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var _bounds2 = new AABBBounds();
var DefaultCanvasRectPicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "rect", this.numberType = RECT_NUMBER_TYPE;
  }
  contains(rect, point5, params2) {
    if (!rect.AABBBounds.containsPoint(point5))
      return false;
    if ("imprecise" === rect.attribute.pickMode)
      return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext)
      return false;
    const rectAttribute = getTheme(rect).rect, { cornerRadius = rectAttribute.cornerRadius } = rect.attribute;
    let { x = rectAttribute.x, y = rectAttribute.y } = rect.attribute;
    pickContext.highPerformanceSave();
    let onlyTranslate = true;
    if (rect.transMatrix.onlyTranslate()) {
      const point6 = rect.getOffsetXY(rectAttribute);
      x += point6.x, y += point6.y, pickContext.setTransformForCurrent();
    } else
      x = 0, y = 0, onlyTranslate = false, pickContext.transformFromMatrix(rect.transMatrix, true);
    let picked = true;
    if (!onlyTranslate || rect.shadowRoot || isNumber_default(cornerRadius, true) && 0 !== cornerRadius || isArray_default(cornerRadius) && cornerRadius.some((num) => 0 !== num))
      picked = false, this.canvasRenderer.drawShape(rect, pickContext, x, y, {}, null, (context, rectAttribute2, themeAttribute) => !!picked || (picked = context.isPointInPath(point5.x, point5.y), picked), (context, rectAttribute2, themeAttribute) => {
        if (picked)
          return true;
        const lineWidth = rectAttribute2.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = rectAttribute2.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
        return pickContext.lineWidth = getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(point5.x, point5.y), picked;
      });
    else {
      const { fill = rectAttribute.fill, stroke: stroke2 = rectAttribute.stroke, lineWidth = rectAttribute.lineWidth } = rect.attribute;
      if (fill)
        picked = true;
      else if (stroke2) {
        const bounds = rect.AABBBounds;
        _bounds2.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), _bounds2.expand(-lineWidth / 2), picked = !_bounds2.containsPoint(point5);
      }
    }
    return pickContext.highPerformanceRestore(), picked;
  }
};
DefaultCanvasRectPicker = __decorate71([injectable(), __param34(0, inject(RectRender)), __metadata53("design:paramtypes", [Object])], DefaultCanvasRectPicker);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/canvas-picker/rect-module
var loadRectPick2 = false;
var rectCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadRectPick2 || (loadRectPick2 = true, bind(CanvasRectPicker).to(DefaultCanvasRectPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasRectPicker));
});

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/canvas-picker/base-picker
var __decorate72 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var BasePicker = class extends BaseRender {
};
BasePicker = __decorate72([injectable()], BasePicker);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/canvas-picker/line-picker
var __decorate73 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata54 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param35 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasLinePicker = class extends BasePicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "line", this.numberType = LINE_NUMBER_TYPE;
  }
  contains(line2, point5, params2) {
    if (!line2.AABBBounds.containsPoint(point5))
      return false;
    if ("imprecise" === line2.attribute.pickMode)
      return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext)
      return false;
    pickContext.highPerformanceSave();
    const lineAttribute = getTheme(line2).line, data = this.transform(line2, lineAttribute, pickContext), { x, y, z, lastModelMatrix } = data;
    let pickPoint = point5;
    if (pickContext.camera) {
      pickPoint = point5.clone();
      const globalMatrix = line2.parent.globalTransMatrix;
      pickPoint.x = globalMatrix.a * point5.x + globalMatrix.c * point5.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point5.x + globalMatrix.d * point5.y + globalMatrix.f;
    }
    this.canvasRenderer.z = z;
    let picked = false;
    return this.canvasRenderer.drawShape(line2, pickContext, x, y, {}, null, (context) => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked), (context, lineAttribute2, themeAttribute) => {
      if (picked)
        return true;
      const lineWidth = lineAttribute2.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = lineAttribute2.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
      return pickContext.lineWidth = getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(pickPoint.x, pickPoint.y), picked;
    }), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
  }
};
DefaultCanvasLinePicker = __decorate73([injectable(), __param35(0, inject(LineRender)), __metadata54("design:paramtypes", [Object])], DefaultCanvasLinePicker);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/canvas-picker/line-module
var loadLinePick2 = false;
var lineCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadLinePick2 || (loadLinePick2 = true, bind(CanvasLinePicker).to(DefaultCanvasLinePicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasLinePicker));
});

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/canvas-picker/area-picker
var __decorate74 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata55 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param36 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasAreaPicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "area", this.numberType = AREA_NUMBER_TYPE;
  }
  contains(area2, point5, params2) {
    if (!area2.AABBBounds.containsPoint(point5))
      return false;
    if ("imprecise" === area2.attribute.pickMode)
      return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext)
      return false;
    const areaAttribute = getTheme(area2).area;
    let { x = areaAttribute.x, y = areaAttribute.y } = area2.attribute;
    const { fillPickable = areaAttribute.fillPickable, strokePickable = areaAttribute.strokePickable } = area2.attribute;
    if (pickContext.highPerformanceSave(), area2.transMatrix.onlyTranslate()) {
      const point6 = area2.getOffsetXY(areaAttribute);
      x += point6.x, y += point6.y, pickContext.setTransformForCurrent();
    } else
      x = 0, y = 0, pickContext.transformFromMatrix(area2.transMatrix, true);
    let picked = false;
    return this.canvasRenderer.drawShape(area2, pickContext, x, y, {}, null, (context) => !!picked || !!fillPickable && (picked = context.isPointInPath(point5.x, point5.y), picked), (context, areaAttribute2, themeAttribute) => {
      if (picked)
        return true;
      if (!strokePickable)
        return false;
      const lineWidth = areaAttribute2.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = areaAttribute2.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
      return pickContext.lineWidth = getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(point5.x, point5.y), picked;
    }), pickContext.highPerformanceRestore(), picked;
  }
};
DefaultCanvasAreaPicker = __decorate74([injectable(), __param36(0, inject(AreaRender)), __metadata55("design:paramtypes", [Object])], DefaultCanvasAreaPicker);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/canvas-picker/area-module
var loadAreaPick2 = false;
var areaCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadAreaPick2 || (loadAreaPick2 = true, bind(CanvasAreaPicker).to(DefaultCanvasAreaPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasAreaPicker));
});

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/canvas-picker/symbol-picker
var __decorate75 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata56 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param37 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasSymbolPicker = class extends BasePicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "symbol", this.numberType = SYMBOL_NUMBER_TYPE;
  }
  contains(symbol, point5, params2) {
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext)
      return false;
    const parsedPath = symbol.getParsedPath();
    if (!pickContext.camera) {
      if (!symbol.AABBBounds.containsPoint(point5))
        return false;
      if (parsedPath.isSvg || "imprecise" === symbol.attribute.pickMode)
        return true;
    }
    pickContext.highPerformanceSave();
    const symbolAttribute = getTheme(symbol).symbol, data = this.transform(symbol, symbolAttribute, pickContext), { x, y, z, lastModelMatrix } = data;
    let pickPoint = point5;
    if (pickContext.camera) {
      pickPoint = point5.clone();
      const globalMatrix = symbol.parent.globalTransMatrix;
      pickPoint.x = globalMatrix.a * point5.x + globalMatrix.c * point5.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point5.x + globalMatrix.d * point5.y + globalMatrix.f;
    }
    this.canvasRenderer.z = z;
    let picked = false;
    return this.canvasRenderer.drawShape(symbol, pickContext, x, y, {}, null, (context, symbolAttribute2, themeAttribute) => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked), (context, symbolAttribute2, themeAttribute) => {
      if (picked)
        return true;
      const lineWidth = symbolAttribute2.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = symbolAttribute2.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
      return pickContext.lineWidth = getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(pickPoint.x, pickPoint.y), picked;
    }), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
  }
};
DefaultCanvasSymbolPicker = __decorate75([injectable(), __param37(0, inject(SymbolRender)), __metadata56("design:paramtypes", [Object])], DefaultCanvasSymbolPicker);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/canvas-picker/symbol-module
var loadSymbolPick2 = false;
var symbolCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadSymbolPick2 || (loadSymbolPick2 = true, bind(CanvasSymbolPicker).to(DefaultCanvasSymbolPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasSymbolPicker));
});

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/canvas-picker/circle-picker
var __decorate76 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata57 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param38 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasCirclePicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "circle", this.numberType = CIRCLE_NUMBER_TYPE;
  }
  contains(circle3, point5, params2) {
    if (!circle3.AABBBounds.containsPoint(point5))
      return false;
    if ("imprecise" === circle3.attribute.pickMode)
      return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext)
      return false;
    const circleAttribute = getTheme(circle3).circle;
    let { x = circleAttribute.x, y = circleAttribute.y } = circle3.attribute;
    if (pickContext.highPerformanceSave(), circle3.transMatrix.onlyTranslate()) {
      const point6 = circle3.getOffsetXY(circleAttribute);
      x += point6.x, y += point6.y, pickContext.setTransformForCurrent();
    } else
      x = 0, y = 0, pickContext.transformFromMatrix(circle3.transMatrix, true);
    let picked = false;
    return this.canvasRenderer.drawShape(circle3, pickContext, x, y, {}, null, (context, circleAttribute2, themeAttribute) => !!picked || (picked = context.isPointInPath(point5.x, point5.y), picked), (context, circleAttribute2, themeAttribute) => {
      if (picked)
        return true;
      const lineWidth = circleAttribute2.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = circleAttribute2.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
      return pickContext.lineWidth = getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(point5.x, point5.y), picked;
    }), pickContext.highPerformanceRestore(), picked;
  }
};
DefaultCanvasCirclePicker = __decorate76([injectable(), __param38(0, inject(CircleRender)), __metadata57("design:paramtypes", [Object])], DefaultCanvasCirclePicker);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/canvas-picker/circle-module
var loadCirclePick2 = false;
var circleCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadCirclePick2 || (loadCirclePick2 = true, bind(CanvasCirclePicker).to(DefaultCanvasCirclePicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasCirclePicker));
});

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/canvas-picker/text-picker
var __decorate77 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata58 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param39 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasTextPicker = class extends BasePicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "text", this.numberType = TEXT_NUMBER_TYPE;
  }
  contains(text2, point5, params2) {
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext)
      return false;
    const bounds = text2.AABBBounds;
    if (!pickContext.camera)
      return !!bounds.containsPoint(point5);
    pickContext.highPerformanceSave();
    const textAttribute2 = getTheme(text2).text, { keepDirIn3d = textAttribute2.keepDirIn3d } = text2.attribute, computed3dMatrix = !keepDirIn3d, data = this.transform(text2, textAttribute2, pickContext, computed3dMatrix), { x, y, z, lastModelMatrix } = data;
    this.canvasRenderer.z = z;
    let pickPoint = point5;
    if (pickContext.camera) {
      pickPoint = point5.clone();
      const globalMatrix = text2.parent.globalTransMatrix;
      pickPoint.x = globalMatrix.a * point5.x + globalMatrix.c * point5.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point5.x + globalMatrix.d * point5.y + globalMatrix.f;
    }
    let picked = false;
    return this.canvasRenderer.drawShape(text2, pickContext, x, y, {}, null, (context, symbolAttribute, themeAttribute) => {
      if (picked)
        return true;
      const { fontSize = textAttribute2.fontSize, textBaseline = textAttribute2.textBaseline, textAlign = textAttribute2.textAlign } = text2.attribute, bounds2 = text2.AABBBounds, height = bounds2.height(), width = bounds2.width(), offsetY = textLayoutOffsetY(textBaseline, height, fontSize), offsetX = textDrawOffsetX(textAlign, width);
      return context.rect(offsetX + x, offsetY + y, width, height, z), picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked;
    }, (context, symbolAttribute, themeAttribute) => picked), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
  }
};
DefaultCanvasTextPicker = __decorate77([injectable(), __param39(0, inject(TextRender)), __metadata58("design:paramtypes", [Object])], DefaultCanvasTextPicker);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/canvas-picker/text-module
var loadTextPick2 = false;
var textCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadTextPick2 || (loadTextPick2 = true, bind(CanvasTextPicker).to(DefaultCanvasTextPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasTextPicker));
});

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/canvas-picker/path-picker
var __decorate78 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata59 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param40 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasPathPicker = class extends BasePicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "path", this.numberType = PATH_NUMBER_TYPE;
  }
  contains(path, point5, params2) {
    if (!path.AABBBounds.containsPoint(point5))
      return false;
    if ("imprecise" === path.attribute.pickMode)
      return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext)
      return false;
    const pathAttribute = getTheme(path).path;
    pickContext.highPerformanceSave();
    const data = this.transform(path, pathAttribute, pickContext), { x, y, z, lastModelMatrix } = data;
    let pickPoint = point5;
    if (pickContext.camera) {
      pickPoint = point5.clone();
      const globalMatrix = path.parent.globalTransMatrix;
      pickPoint.x = globalMatrix.a * point5.x + globalMatrix.c * point5.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point5.x + globalMatrix.d * point5.y + globalMatrix.f;
    }
    this.canvasRenderer.z = z;
    let picked = false;
    return this.canvasRenderer.drawShape(path, pickContext, x, y, {}, null, (context, pathAttribute2, themeAttribute) => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked), (context, pathAttribute2, themeAttribute) => {
      if (picked)
        return true;
      const lineWidth = pathAttribute2.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = pathAttribute2.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
      return pickContext.lineWidth = getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(pickPoint.x, pickPoint.y), picked;
    }), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
  }
};
DefaultCanvasPathPicker = __decorate78([injectable(), __param40(0, inject(PathRender)), __metadata59("design:paramtypes", [Object])], DefaultCanvasPathPicker);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/canvas-picker/path-module
var loadPathPick2 = false;
var pathCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadPathPick2 || (loadPathPick2 = true, bind(CanvasPathPicker).to(DefaultCanvasPathPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasPathPicker));
});

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/canvas-picker/polygon-picker
var __decorate79 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata60 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param41 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasPolygonPicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "polygon", this.numberType = POLYGON_NUMBER_TYPE;
  }
  contains(polygon, point5, params2) {
    if (!polygon.AABBBounds.contains(point5.x, point5.y))
      return false;
    if ("imprecise" === polygon.attribute.pickMode)
      return true;
    const { pickContext } = null != params2 ? params2 : {};
    if (!pickContext)
      return false;
    const polygonAttribute = getTheme(polygon).polygon;
    let { x = polygonAttribute.x, y = polygonAttribute.y } = polygon.attribute;
    if (pickContext.highPerformanceSave(), polygon.transMatrix.onlyTranslate()) {
      const point6 = polygon.getOffsetXY(polygonAttribute);
      x += point6.x, y += point6.y, pickContext.setTransformForCurrent();
    } else
      x = 0, y = 0, pickContext.transformFromMatrix(polygon.transMatrix, true);
    let picked = false;
    return this.canvasRenderer.drawShape(polygon, pickContext, x, y, {}, null, (context, pathAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(point5.x, point5.y), picked), (context, pathAttribute, themeAttribute) => {
      if (picked)
        return true;
      const lineWidth = pathAttribute.lineWidth || themeAttribute.lineWidth, pickStrokeBuffer = pathAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer;
      return pickContext.lineWidth = getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(point5.x, point5.y), picked;
    }), pickContext.highPerformanceRestore(), picked;
  }
};
DefaultCanvasPolygonPicker = __decorate79([injectable(), __param41(0, inject(PolygonRender)), __metadata60("design:paramtypes", [Object])], DefaultCanvasPolygonPicker);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/canvas-picker/polygon-module
var loadPolygonPick2 = false;
var polygonCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadPolygonPick2 || (loadPolygonPick2 = true, bind(CanvasPolygonPicker).to(DefaultCanvasPolygonPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasPolygonPicker));
});

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/canvas-picker/richtext-picker
var __decorate80 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata61 = function(k2, v) {
  if ("object" == typeof Reflect && "function" == typeof Reflect.metadata)
    return Reflect.metadata(k2, v);
};
var __param42 = function(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
};
var DefaultCanvasRichTextPicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "richtext", this.numberType = RICHTEXT_NUMBER_TYPE;
  }
  contains(richtext, point5, params2) {
    return !!richtext.AABBBounds.containsPoint(point5);
  }
};
DefaultCanvasRichTextPicker = __decorate80([injectable(), __param42(0, inject(RichTextRender)), __metadata61("design:paramtypes", [Object])], DefaultCanvasRichTextPicker);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/canvas-picker/richtext-module
var loadRichtextPick = false;
var richtextCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadRichtextPick || (loadRichtextPick = true, bind(CanvasRichTextPicker).to(DefaultCanvasRichTextPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasRichTextPicker));
});

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/canvas-picker/image-picker
var __decorate81 = function(decorators, target, key, desc) {
  var d, c3 = arguments.length, r = c3 < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d = decorators[i]) && (r = (c3 < 3 ? d(r) : c3 > 3 ? d(target, key, r) : d(target, key)) || r);
  return c3 > 3 && r && Object.defineProperty(target, key, r), r;
};
var DefaultCanvasImagePicker = class {
  constructor() {
    this.type = "image", this.numberType = IMAGE_NUMBER_TYPE;
  }
  contains(image, point5, params2) {
    const { pickContext } = null != params2 ? params2 : {};
    return !!pickContext && !!image.AABBBounds.containsPoint(point5);
  }
};
DefaultCanvasImagePicker = __decorate81([injectable()], DefaultCanvasImagePicker);

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/picker/contributions/canvas-picker/image-module
var loadImagePick2 = false;
var imageCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadImagePick2 || (loadImagePick2 = true, bind(CanvasImagePicker).to(DefaultCanvasImagePicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasImagePicker));
});

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/register/env
var browser = isBrowserEnv();

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/register/register-arc
function _registerArc() {
  _registerArc.__loaded || (_registerArc.__loaded = true, registerArcGraphic(), container.load(arcModule), container.load(browser ? arcCanvasPickModule : arcMathPickModule));
}
_registerArc.__loaded = false;
var registerArc = _registerArc;

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/register/register-area
function _registerArea() {
  _registerArea.__loaded || (_registerArea.__loaded = true, registerAreaGraphic(), container.load(areaModule), container.load(browser ? areaCanvasPickModule : areaMathPickModule));
}
_registerArea.__loaded = false;
var registerArea = _registerArea;

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/register/register-circle
function _registerCircle() {
  _registerCircle.__loaded || (_registerCircle.__loaded = true, registerCircleGraphic(), container.load(circleModule), container.load(browser ? circleCanvasPickModule : circleMathPickModule));
}
_registerCircle.__loaded = false;
var registerCircle = _registerCircle;

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/register/register-group
function _registerGroup() {
  _registerGroup.__loaded || (_registerGroup.__loaded = true, registerGroupGraphic());
}
_registerGroup.__loaded = false;
var registerGroup = _registerGroup;

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/register/register-image
function _registerImage() {
  _registerImage.__loaded || (_registerImage.__loaded = true, registerImageGraphic(), container.load(imageModule), container.load(browser ? imageCanvasPickModule : imageMathPickModule));
}
_registerImage.__loaded = false;
var registerImage = _registerImage;

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/register/register-line
function _registerLine() {
  _registerLine.__loaded || (_registerLine.__loaded = true, registerLineGraphic(), container.load(lineModule), container.load(browser ? lineCanvasPickModule : lineMathPickModule));
}
_registerLine.__loaded = false;
var registerLine = _registerLine;

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/register/register-path
function _registerPath() {
  _registerPath.__loaded || (_registerPath.__loaded = true, registerPathGraphic(), container.load(pathModule), container.load(browser ? pathCanvasPickModule : pathMathPickModule));
}
_registerPath.__loaded = false;
var registerPath = _registerPath;

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/register/register-polygon
function _registerPolygon() {
  _registerPolygon.__loaded || (_registerPolygon.__loaded = true, registerPolygonGraphic(), container.load(polygonModule), container.load(browser ? polygonCanvasPickModule : polygonMathPickModule));
}
_registerPolygon.__loaded = false;
var registerPolygon = _registerPolygon;

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/register/register-rect
function _registerRect() {
  _registerRect.__loaded || (_registerRect.__loaded = true, registerRectGraphic(), container.load(rectModule), container.load(browser ? rectCanvasPickModule : rectMathPickModule));
}
_registerRect.__loaded = false;
var registerRect = _registerRect;

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/register/register-richtext
function _registerRichtext() {
  _registerRichtext.__loaded || (_registerRichtext.__loaded = true, registerRichtextGraphic(), container.load(richtextModule), container.load(browser ? richtextCanvasPickModule : richTextMathPickModule));
}
_registerRichtext.__loaded = false;
var registerRichtext = _registerRichtext;

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/register/register-shadowRoot
function _registerShadowRoot() {
  _registerShadowRoot.__loaded || (_registerShadowRoot.__loaded = true, registerShadowRootGraphic());
}
_registerShadowRoot.__loaded = false;
var registerShadowRoot = _registerShadowRoot;

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/register/register-symbol
function _registerSymbol() {
  _registerSymbol.__loaded || (_registerSymbol.__loaded = true, registerSymbolGraphic(), container.load(symbolModule), container.load(browser ? symbolCanvasPickModule : symbolMathPickModule));
}
_registerSymbol.__loaded = false;
var registerSymbol = _registerSymbol;

// http-url:https://unpkg.com/@visactor/vrender-kits@0.19.9/es/register/register-text
function _registerText() {
  _registerText.__loaded || (_registerText.__loaded = true, registerTextGraphic(), container.load(textModule), container.load(browser ? textCanvasPickModule : textMathPickModule));
}
_registerText.__loaded = false;
var registerText = _registerText;

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/scrollbar/register
function loadScrollbarComponent() {
  registerGroup(), registerRect();
}

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/constant
var POLAR_START_ANGLE = -0.5 * Math.PI;
var POLAR_END_ANGLE = 1.5 * Math.PI;
var DEFAULT_TEXT_FONT_FAMILY = "PingFang SC,Helvetica Neue,Microsoft Yahei,system-ui,-apple-system,segoe ui,Roboto,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol";
var DEFAULT_TEXT_FONT_SIZE = 14;
var StateValue;
!function(StateValue2) {
  StateValue2.selected = "selected", StateValue2.selectedReverse = "selected_reverse", StateValue2.hover = "hover", StateValue2.hoverReverse = "hover_reverse";
}(StateValue || (StateValue = {}));
var DEFAULT_STATES = {
  [StateValue.selectedReverse]: {},
  [StateValue.selected]: {},
  [StateValue.hover]: {},
  [StateValue.hoverReverse]: {}
};
var DEFAULT_HTML_TEXT_SPEC = {
  container: "",
  width: 30,
  height: 30,
  style: {}
};
var SCROLLBAR_EVENT = "scrollDrag";

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/scrollbar/scrollbar
var delayMap = {
  debounce: debounce_default,
  throttle: throttle_default
};
loadScrollbarComponent();
var ScrollBar = class _ScrollBar extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _ScrollBar.defaultAttributes, attributes)), this.name = "scrollbar", this._onRailPointerDown = (e) => {
      const { viewX, viewY } = e, { direction: direction2, width, height, range: range2 } = this.attribute, sliderSize = this._sliderSize, [min3, max3] = this._getScrollRange();
      let currentScrollValue;
      if ("vertical" === direction2) {
        const relativeY = viewY - this._viewPosition.y, currentYPos = clamp_default(relativeY - sliderSize / 2, min3, max3);
        currentScrollValue = relativeY / height, this._slider.setAttribute("y", currentYPos, true);
      } else {
        const relativeX = viewX - this._viewPosition.x, currentXPos = clamp_default(relativeX - sliderSize / 2, min3, max3);
        currentScrollValue = relativeX / width, this._slider.setAttribute("x", currentXPos, true);
      }
      this.setScrollRange([currentScrollValue - (range2[1] - range2[0]) / 2, currentScrollValue + (range2[1] - range2[0]) / 2], false), this.stage && !this.stage.autoRender && this.stage.renderNextFrame();
    }, this._onSliderPointerDown = (e) => {
      const { stopSliderDownPropagation = true } = this.attribute;
      stopSliderDownPropagation && e.stopPropagation();
      const { direction: direction2 } = this.attribute, { x, y } = this.stage.eventPointTransform(e);
      this._prePos = "horizontal" === direction2 ? x : y, this._dispatchEvent("scrollDown", {
        pos: this._prePos,
        event: e
      }), "browser" === vglobal.env ? (vglobal.addEventListener("pointermove", this._onSliderPointerMoveWithDelay, {
        capture: true
      }), vglobal.addEventListener("pointerup", this._onSliderPointerUp)) : (this.stage.addEventListener("pointermove", this._onSliderPointerMoveWithDelay, {
        capture: true
      }), this.stage.addEventListener("pointerup", this._onSliderPointerUp), this.stage.addEventListener("pointerupoutside", this._onSliderPointerUp));
    }, this._computeScrollValue = (e) => {
      const { direction: direction2 } = this.attribute, { x, y } = this.stage.eventPointTransform(e);
      let currentScrollValue, currentPos, delta = 0;
      const { width, height } = this._getSliderRenderBounds();
      return "vertical" === direction2 ? (currentPos = y, delta = currentPos - this._prePos, currentScrollValue = delta / height) : (currentPos = x, delta = currentPos - this._prePos, currentScrollValue = delta / width), [currentPos, currentScrollValue];
    }, this._onSliderPointerMove = (e) => {
      const { stopSliderMovePropagation = true } = this.attribute;
      stopSliderMovePropagation && e.stopPropagation();
      const preScrollRange = this.getScrollRange(), [currentPos, currentScrollValue] = this._computeScrollValue(e);
      this.setScrollRange([preScrollRange[0] + currentScrollValue, preScrollRange[1] + currentScrollValue], true), this._prePos = currentPos;
    }, this._onSliderPointerMoveWithDelay = 0 === this.attribute.delayTime ? this._onSliderPointerMove : delayMap[this.attribute.delayType](this._onSliderPointerMove, this.attribute.delayTime), this._onSliderPointerUp = (e) => {
      e.preventDefault();
      const { realTime = true, range: preRange, limitRange = [0, 1] } = this.attribute, preScrollRange = this.getScrollRange(), [currentPos, currentScrollValue] = this._computeScrollValue(e), range2 = [preScrollRange[0] + currentScrollValue, preScrollRange[1] + currentScrollValue];
      this._dispatchEvent("scrollUp", {
        pre: preRange,
        value: clampRange_default(range2, limitRange[0], limitRange[1])
      }), "browser" === vglobal.env ? (vglobal.removeEventListener("pointermove", this._onSliderPointerMoveWithDelay, {
        capture: true
      }), vglobal.removeEventListener("pointerup", this._onSliderPointerUp)) : (this.stage.removeEventListener("pointermove", this._onSliderPointerMoveWithDelay, {
        capture: true
      }), this.stage.removeEventListener("pointerup", this._onSliderPointerUp), this.stage.removeEventListener("pointerupoutside", this._onSliderPointerUp));
    };
  }
  setScrollRange(range2, render = true) {
    const { direction: direction2 = "horizontal", limitRange = [0, 1], range: preRange, realTime = true } = this.attribute, currScrollRange = clampRange_default(range2, limitRange[0], limitRange[1]);
    if (render) {
      const sliderPos = this._getSliderPos(currScrollRange);
      if (this._slider) {
        const sliderSize = sliderPos[1] - sliderPos[0];
        this._sliderSize = sliderSize, "horizontal" === direction2 ? this._slider.setAttributes({
          x: sliderPos[0],
          width: sliderSize
        }, true) : this._slider.setAttributes({
          y: sliderPos[0],
          height: sliderSize
        }, true), this.stage && !this.stage.autoRender && this.stage.renderNextFrame();
      }
    }
    this.attribute.range = currScrollRange, realTime && this._dispatchEvent(SCROLLBAR_EVENT, {
      pre: preRange,
      value: currScrollRange
    });
  }
  getScrollRange() {
    return this.attribute.range;
  }
  bindEvents() {
    if (this.attribute.disableTriggerEvent)
      return;
    const { delayType = "throttle", delayTime = 0 } = this.attribute;
    this._rail && this._rail.addEventListener("pointerdown", delayMap[delayType](this._onRailPointerDown, delayTime)), this._slider && this._slider.addEventListener("pointerdown", this._onSliderPointerDown);
  }
  render() {
    this._reset();
    const { direction: direction2 = "horizontal", width, height, range: range2, limitRange = [0, 1], railStyle, sliderStyle, padding = 2 } = this.attribute, group = this.createOrUpdateChild("scrollbar-container", {}, "group"), rail = group.createOrUpdateChild("scrollbar-rail", Object.assign({
      x: 0,
      y: 0,
      width,
      height
    }, railStyle), "rect");
    this._rail = rail;
    const sliderRenderBounds = this._getSliderRenderBounds(), sliderPos = this._getSliderPos(clampRange_default(range2, limitRange[0], limitRange[1])), sliderSize = sliderPos[1] - sliderPos[0];
    let sliderAttribute;
    this._sliderSize = sliderSize, sliderAttribute = "horizontal" === direction2 ? {
      x: sliderPos[0],
      y: sliderRenderBounds.y1,
      width: sliderSize,
      height: sliderRenderBounds.height
    } : {
      x: sliderRenderBounds.x1,
      y: sliderPos[0],
      width: sliderRenderBounds.width,
      height: sliderSize
    };
    const slider2 = group.createOrUpdateChild("slider", Object.assign(Object.assign(Object.assign(Object.assign({}, sliderAttribute), {
      cornerRadius: this._getDefaultSliderCornerRadius()
    }), sliderStyle), {
      boundsPadding: normalizePadding(padding),
      pickMode: "imprecise"
    }), "rect");
    this._slider = slider2, this._container = group;
    const containerAABBBounds = this._container.AABBBounds;
    this._viewPosition = {
      x: containerAABBBounds.x1,
      y: containerAABBBounds.y1
    };
  }
  _getSliderRenderBounds() {
    if (this._sliderRenderBounds)
      return this._sliderRenderBounds;
    const { width, height, padding = 2 } = this.attribute, [top, right2, bottom, left2] = normalizePadding(padding), renderBounds = {
      x1: left2,
      y1: top,
      x2: width - right2,
      y2: height - bottom,
      width: Math.max(0, width - (left2 + right2)),
      height: Math.max(0, height - (top + bottom))
    };
    return this._sliderRenderBounds = renderBounds, renderBounds;
  }
  _getDefaultSliderCornerRadius() {
    const { direction: direction2, round } = this.attribute;
    if (round) {
      const { width, height } = this._getSliderRenderBounds();
      return "horizontal" === direction2 ? height : width;
    }
    return 0;
  }
  _getSliderPos(range2) {
    const { direction: direction2 } = this.attribute, { width, height, x1: x14, y1: y14 } = this._getSliderRenderBounds();
    return "horizontal" === direction2 ? [width * range2[0] + x14, width * range2[1] + x14] : [height * range2[0] + y14, height * range2[1] + y14];
  }
  _getScrollRange() {
    if (this._sliderLimitRange)
      return this._sliderLimitRange;
    const { limitRange = [0, 1], direction: direction2 } = this.attribute, [min3, max3] = clampRange_default(limitRange, 0, 1), { width, height, x1: x14, y1: y14 } = this._getSliderRenderBounds(), sliderSize = this._sliderSize;
    return "horizontal" === direction2 ? clampRange_default([x14 + min3 * width, x14 + max3 * width], x14, width - sliderSize) : clampRange_default([y14 + min3 * height, y14 + max3 * height], y14, height - sliderSize);
  }
  _reset() {
    this._sliderRenderBounds = null, this._sliderLimitRange = null;
  }
};
ScrollBar.defaultAttributes = {
  direction: "horizontal",
  round: true,
  sliderSize: 20,
  sliderStyle: {
    fill: "rgba(0, 0, 0, .5)"
  },
  railStyle: {
    fill: "rgba(0, 0, 0, .0)"
  },
  padding: 2,
  scrollRange: [0, 1],
  delayType: "throttle",
  delayTime: 0,
  realTime: true
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/util/common
function traverseGroup(group, cb) {
  group.forEachChildren((node) => {
    const stopped = cb(node);
    node.isContainer && !stopped && traverseGroup(node, cb);
  });
}
var isVisible = (obj) => !isNil_default(obj) && false !== obj.visible;
function removeRepeatPoint(points) {
  const result2 = [points[0]];
  for (let i = 1; i < points.length; i++)
    points[i].x === points[i - 1].x && points[i].y === points[i - 1].y || result2.push(points[i]);
  return result2;
}
function isPostiveXAxis(angle2) {
  return angle2 >= 0 && angle2 < Math.PI / 2 || angle2 > 3 * Math.PI / 2 && angle2 <= 2 * Math.PI;
}
function fuzzyEqualNumber(a3, b, delta) {
  return Math.abs(a3 - b) < delta;
}
function getTextAlignAttrOfVerticalDir(autoRotate2, lineEndAngle, itemPosition) {
  return autoRotate2 ? {
    textAlign: "right",
    textBaseline: "middle"
  } : {
    textAlign: lineEndAngle < Math.PI && itemPosition.toLocaleLowerCase().includes("top") || lineEndAngle > Math.PI && itemPosition.toLocaleLowerCase().includes("bottom") ? "left" : lineEndAngle < Math.PI && itemPosition.toLocaleLowerCase().includes("bottom") || lineEndAngle > Math.PI && itemPosition.toLocaleLowerCase().includes("top") ? "right" : "center",
    textBaseline: lineEndAngle < Math.PI && itemPosition.includes("inside") || lineEndAngle > Math.PI && !itemPosition.includes("inside") ? "bottom" : "top"
  };
}

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/util/label-smartInvert
var defaultAlternativeColors = ["#ffffff", "#000000"];
function labelSmartInvert(foregroundColorOrigin, backgroundColorOrogin, textType, contrastRatiosThreshold, alternativeColors, mode) {
  if ("string" != typeof foregroundColorOrigin || "string" != typeof backgroundColorOrogin)
    return foregroundColorOrigin;
  const foregroundColor = new Color(foregroundColorOrigin).toHex(), backgroundColor = new Color(backgroundColorOrogin).toHex();
  return contrastAccessibilityChecker(foregroundColor, backgroundColor, textType, contrastRatiosThreshold, mode) ? foregroundColor : improveContrastReverse(foregroundColor, backgroundColor, textType, contrastRatiosThreshold, alternativeColors, mode);
}
function improveContrastReverse(foregroundColor, backgroundColor, textType, contrastRatiosThreshold, alternativeColors, mode) {
  const alternativeColorPalletes = [];
  alternativeColors && (alternativeColors instanceof Array ? alternativeColorPalletes.push(...alternativeColors) : alternativeColorPalletes.push(alternativeColors)), alternativeColorPalletes.push(...defaultAlternativeColors);
  for (const alternativeColor of alternativeColorPalletes)
    if (foregroundColor !== alternativeColor && contrastAccessibilityChecker(alternativeColor, backgroundColor, textType, contrastRatiosThreshold, mode))
      return alternativeColor;
}
function contrastAccessibilityChecker(foregroundColor, backgroundColor, textType, contrastRatiosThreshold, mode) {
  if ("lightness" === mode) {
    const backgroundColorLightness = Color.getColorBrightness(new Color(backgroundColor));
    return Color.getColorBrightness(new Color(foregroundColor)) < 0.5 ? backgroundColorLightness >= 0.5 : backgroundColorLightness < 0.5;
  }
  return contrastRatiosThreshold ? contrastRatios(foregroundColor, backgroundColor) > contrastRatiosThreshold : "largeText" === textType ? contrastRatios(foregroundColor, backgroundColor) > 3 : contrastRatios(foregroundColor, backgroundColor) > 4.5;
}
function contrastRatios(foregroundColor, backgroundColor) {
  const foregroundColorLuminance = getColorLuminance(foregroundColor), backgroundColorLuminance = getColorLuminance(backgroundColor);
  return ((foregroundColorLuminance > backgroundColorLuminance ? foregroundColorLuminance : backgroundColorLuminance) + 0.05) / ((foregroundColorLuminance > backgroundColorLuminance ? backgroundColorLuminance : foregroundColorLuminance) + 0.05);
}
function getColorLuminance(color) {
  const rgb8bit = hexToRgb(color), RsRGB = rgb8bit[0] / 255, GsRGB = rgb8bit[1] / 255, BsRGB = rgb8bit[2] / 255;
  let R, G, B;
  R = RsRGB <= 0.03928 ? RsRGB / 12.92 : Math.pow((RsRGB + 0.055) / 1.055, 2.4), G = GsRGB <= 0.03928 ? GsRGB / 12.92 : Math.pow((GsRGB + 0.055) / 1.055, 2.4), B = BsRGB <= 0.03928 ? BsRGB / 12.92 : Math.pow((BsRGB + 0.055) / 1.055, 2.4);
  return 0.2126 * R + 0.7152 * G + 0.0722 * B;
}

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/util/matrix
function scale3(vector, scale4) {
  return [vector[0] * scale4, vector[1] * scale4];
}
function length(vector) {
  const [x, y] = vector;
  return Math.sqrt(x * x + y * y);
}
function normalize(vector) {
  const [x, y] = vector;
  let len = x * x + y * y;
  return len > 0 && (len = 1 / Math.sqrt(len)), [vector[0] * len, vector[1] * len];
}
function angle(vector1, vector2) {
  const [x14, y14] = vector1, [x23, y23] = vector2, mag = Math.sqrt((x14 * x14 + y14 * y14) * (x23 * x23 + y23 * y23)), cosine = mag && (x14 * x23 + y14 * y23) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function direction(v1, v2) {
  return v1[0] * v2[1] - v2[0] * v1[1];
}
function angleTo(v1, v2, direct) {
  const ang = angle(v1, v2), angleLargeThanPI = direction(v1, v2) >= 0;
  return direct ? angleLargeThanPI ? 2 * Math.PI - ang : ang : angleLargeThanPI ? ang : 2 * Math.PI - ang;
}

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/util/text
var initTextMeasure = (textSpec, option, useNaiveCanvas, defaultFontParams) => new TextMeasure(Object.assign({
  defaultFontParams: Object.assign({
    fontFamily: DEFAULT_TEXT_FONT_FAMILY,
    fontSize: DEFAULT_TEXT_FONT_SIZE
  }, defaultFontParams),
  getTextBounds: useNaiveCanvas ? void 0 : getTextBounds,
  specialCharSet: `-/: .,@%'"~` + TextMeasure.ALPHABET_CHAR_SET + TextMeasure.ALPHABET_CHAR_SET.toUpperCase()
}, null != option ? option : {}), textSpec);
function measureTextSize(text2, textSpec, defaultTextTheme = {}) {
  if (!text2)
    return {
      width: 0,
      height: 0
    };
  const bounds = getTextBounds({
    text: text2,
    fontFamily: textSpec.fontFamily || defaultTextTheme.fontFamily || DEFAULT_TEXT_FONT_FAMILY,
    fontSize: textSpec.fontSize || defaultTextTheme.fontSize || 12,
    fontWeight: textSpec.fontWeight || defaultTextTheme.fontWeight,
    textAlign: textSpec.textAlign || "center",
    textBaseline: textSpec.textBaseline,
    ellipsis: !!textSpec.ellipsis,
    maxLineWidth: textSpec.maxLineWidth || 1 / 0,
    lineHeight: textSpec.fontSize || defaultTextTheme.fontSize || 12
  });
  return {
    width: bounds.width(),
    height: bounds.height()
  };
}
function isRichText(attributes, typeKey = "type") {
  return "rich" === getTextType(attributes, typeKey);
}
function getTextType(attributes, typeKey = "type") {
  var _a, _b;
  return isObject_default(attributes.text) && "type" in attributes.text ? null !== (_a = attributes.text.type) && void 0 !== _a ? _a : "text" : typeKey in attributes && null !== (_b = attributes[typeKey]) && void 0 !== _b ? _b : "text";
}
function richTextAttributeTransform(attributes) {
  var _a, _b;
  return attributes.width = null !== (_a = attributes.width) && void 0 !== _a ? _a : 0, attributes.height = null !== (_b = attributes.height) && void 0 !== _b ? _b : 0, attributes.maxWidth = attributes.maxLineWidth, attributes.textConfig = attributes.text.text || attributes.text, attributes;
}
function htmlAttributeTransform(attributes) {
  const { text: text2, _originText } = attributes, { text: html } = text2;
  return attributes.html = html, attributes.text = _originText, attributes.renderable = false, attributes;
}
function reactAttributeTransform(attributes) {
  const { text: text2, _originText } = attributes, { text: react } = text2;
  return attributes.react = react, attributes.text = _originText, attributes.renderable = false, attributes;
}
function createTextGraphicByType(textAttributes, typeKey = "type") {
  const textType = getTextType(textAttributes, typeKey);
  return "rich" === textType ? graphicCreator.richtext(richTextAttributeTransform(textAttributes)) : ("html" === textType ? textAttributes = htmlAttributeTransform(textAttributes) : "react" === textType && (textAttributes = reactAttributeTransform(textAttributes)), graphicCreator.text(textAttributes));
}

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/util/polar
var deltaXYToAngle = (y, x) => {
  const angle2 = Math.atan2(y, x);
  return angle2 < 0 ? angle2 + 2 * Math.PI : angle2;
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/tag/register
function loadTagComponent() {
  registerGroup(), registerRect(), registerSymbol(), registerRichtext(), registerText();
}

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/tag/tag
var __rest = function(s2, e) {
  var t = {};
  for (var p in s2)
    Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++)
      e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
loadTagComponent();
var Tag = class _Tag extends AbstractComponent {
  getBgRect() {
    return this._bgRect;
  }
  getTextShape() {
    return this._textShape;
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Tag.defaultAttributes, attributes)), this.name = "tag";
  }
  render() {
    var _a, _b, _c;
    const { text: text2 = "", textStyle = {}, shape = {}, panel = {}, space = 4, minWidth, maxWidth, padding = 4, visible, state, type, textAlwaysCenter, containerTextAlign } = this.attribute, parsedPadding = normalizePadding(padding), group = this.createOrUpdateChild("tag-content", {
      x: 0,
      y: 0,
      zIndex: 1
    }, "group");
    let symbol, tagWidth = parsedPadding[1] + parsedPadding[3], tagHeight = parsedPadding[0] + parsedPadding[2], textX = 0, symbolPlaceWidth = 0;
    const { visible: shapeVisible } = shape, shapeStyle = __rest(shape, ["visible"]);
    if (isBoolean_default(shapeVisible)) {
      const size = (null == shapeStyle ? void 0 : shapeStyle.size) || 10, maxSize = isNumber_default(size) ? size : Math.max(size[0], size[1]);
      symbol = group.createOrUpdateChild("tag-shape", Object.assign(Object.assign({
        symbolType: "circle",
        size,
        strokeBoundsBuffer: 0
      }, shapeStyle), {
        visible: shapeVisible,
        x: maxSize / 2,
        y: maxSize / 2
      }), "symbol"), isEmpty_default(null == state ? void 0 : state.shape) || (symbol.states = state.shape), shapeVisible && (symbolPlaceWidth = maxSize + space);
    }
    let textShape;
    tagWidth += symbolPlaceWidth, textX += symbolPlaceWidth;
    if (isRichText({
      text: text2
    }) || "rich" === type) {
      const richTextAttrs = Object.assign(Object.assign(Object.assign({}, richTextAttributeTransform(Object.assign({
        type,
        text: text2
      }, textStyle))), textStyle), {
        visible: isValid_default(text2) && false !== visible,
        x: textX,
        y: 0
      });
      textShape = group.createOrUpdateChild("tag-text", richTextAttrs, "richtext");
      const { visible: bgVisible } = panel, backgroundStyle = __rest(panel, ["visible"]);
      if (visible && isBoolean_default(bgVisible)) {
        const bgRect = this.createOrUpdateChild("tag-panel", Object.assign(Object.assign({}, backgroundStyle), {
          visible: bgVisible && !!text2,
          x: textShape.AABBBounds.x1,
          y: textShape.AABBBounds.y1,
          width: textShape.AABBBounds.width(),
          height: textShape.AABBBounds.height()
        }), "rect");
        isEmpty_default(null == state ? void 0 : state.panel) || (bgRect.states = state.panel), this._bgRect = bgRect;
      }
    } else {
      const textAttrs = Object.assign(Object.assign({
        text: isObject_default(text2) && "type" in text2 && "text" === text2.type ? text2.text : text2,
        visible: isValid_default(text2) && false !== visible,
        lineHeight: null == textStyle ? void 0 : textStyle.fontSize
      }, textStyle), {
        x: textX,
        y: 0
      });
      isNil_default(textAttrs.lineHeight) && (textAttrs.lineHeight = textStyle.fontSize), textShape = group.createOrUpdateChild("tag-text", textAttrs, "text"), isEmpty_default(null == state ? void 0 : state.text) || (textShape.states = state.text);
      const textBounds = measureTextSize(textAttrs.text, textStyle, null === (_b = null === (_a = this.stage) || void 0 === _a ? void 0 : _a.getTheme()) || void 0 === _b ? void 0 : _b.text), textWidth = textBounds.width, textHeight = textBounds.height;
      tagWidth += textWidth;
      const size = null !== (_c = shape.size) && void 0 !== _c ? _c : 10, maxSize = isNumber_default(size) ? size : Math.max(size[0], size[1]);
      tagHeight += Math.max(textHeight, shape.visible ? maxSize : 0);
      const { textAlign, textBaseline } = textStyle;
      (isValid_default(minWidth) || isValid_default(maxWidth)) && (isValid_default(minWidth) && tagWidth < minWidth && (tagWidth = minWidth), isValid_default(maxWidth) && tagWidth > maxWidth && (tagWidth = maxWidth, textShape.setAttribute("maxLineWidth", maxWidth - parsedPadding[1] - parsedPadding[2])));
      let x = 0, y = 0, flag = 0;
      "left" === textAlign || "start" === textAlign ? flag = 1 : "right" === textAlign || "end" === textAlign ? flag = -1 : "center" === textAlign && (flag = 0), flag ? flag < 0 ? (x -= tagWidth, symbol && symbol.setAttribute("x", (symbol.attribute.x || 0) - textWidth), group.setAttribute("x", -parsedPadding[1] - symbolPlaceWidth)) : flag > 0 && group.setAttribute("x", parsedPadding[3]) : (x -= tagWidth / 2, symbol && symbol.setAttribute("x", (symbol.attribute.x || 0) - textWidth / 2), group.setAttribute("x", -symbolPlaceWidth / 2));
      const shouldRight = "right" === containerTextAlign || "end" === containerTextAlign, shouldLeft = "left" === containerTextAlign || "start" === containerTextAlign;
      if ((containerTextAlign ? "center" === containerTextAlign : textAlwaysCenter) && flag) {
        const containerWidth = tagWidth - parsedPadding[1] - parsedPadding[3], tsWidth = textWidth + symbolPlaceWidth, textX2 = 1 === flag ? (containerWidth - tsWidth) / 2 + symbolPlaceWidth + textWidth / 2 : parsedPadding[0] + symbolPlaceWidth - (tagWidth / 2 + tsWidth / 2 - symbolPlaceWidth) + textWidth / 2;
        if (textShape.setAttributes({
          x: textX2,
          textAlign: "center"
        }), symbol) {
          const symbolX = textX2 - textWidth / 2 - symbolPlaceWidth + maxSize / 2;
          symbol.setAttributes({
            x: symbolX
          });
        }
      }
      if (shouldLeft && 1 !== flag) {
        const containerWidth = tagWidth - parsedPadding[1] - parsedPadding[3], offset = 0 === flag ? -containerWidth / 2 + symbolPlaceWidth / 2 : -tagWidth + parsedPadding[3] + parsedPadding[1] + symbolPlaceWidth, textX2 = offset + symbolPlaceWidth;
        if (textShape.setAttributes({
          x: textX2,
          textAlign: "left"
        }), symbol) {
          const symbolX = offset + maxSize / 2;
          symbol.setAttributes({
            x: symbolX
          });
        }
      }
      if (shouldRight && -1 !== flag) {
        const containerWidth = tagWidth - parsedPadding[1] - parsedPadding[3], textX2 = 0 === flag ? containerWidth / 2 + symbolPlaceWidth / 2 : containerWidth;
        if (textShape.setAttributes({
          x: textX2,
          textAlign: "right"
        }), symbol) {
          const symbolX = textX2 - textWidth - symbolPlaceWidth + maxSize / 2;
          symbol.setAttributes({
            x: symbolX
          });
        }
      }
      "middle" === textBaseline ? (y -= tagHeight / 2, symbol && symbol.setAttribute("y", 0)) : "bottom" === textBaseline ? (y -= tagHeight, symbol && symbol.setAttribute("y", -textHeight / 2), group.setAttribute("y", -parsedPadding[2])) : "top" === textBaseline && (group.setAttribute("y", parsedPadding[0]), symbol && symbol.setAttribute("y", textHeight / 2));
      const { visible: bgVisible } = panel, backgroundStyle = __rest(panel, ["visible"]);
      if (visible && isBoolean_default(bgVisible)) {
        const bgRect = this.createOrUpdateChild("tag-panel", Object.assign(Object.assign({}, backgroundStyle), {
          visible: bgVisible && !!text2,
          x,
          y,
          width: tagWidth,
          height: tagHeight
        }), "rect");
        isEmpty_default(null == state ? void 0 : state.panel) || (bgRect.states = state.panel), this._bgRect = bgRect;
      }
    }
    this._textShape = textShape;
  }
};
Tag.defaultAttributes = {
  visible: true,
  textStyle: {
    fontSize: 12,
    fill: "#000",
    textAlign: "left",
    textBaseline: "top"
  },
  space: 4,
  padding: 4,
  shape: {
    fill: "#000"
  }
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/poptip/theme
var DEFAULT_THEME = {
  visible: true,
  position: "auto",
  titleStyle: {
    fontSize: 16,
    fill: "#08979c"
  },
  contentStyle: {
    fontSize: 12,
    fill: "green"
  },
  panel: {
    visible: true,
    fill: "#e6fffb",
    size: 12,
    space: 0,
    stroke: "#87e8de",
    lineWidth: 1,
    cornerRadius: 4
  }
};
var theme = {
  poptip: merge({}, DEFAULT_THEME)
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/poptip/register
function setPoptipTheme(defaultPoptipTheme) {
  merge(theme.poptip, DEFAULT_THEME, defaultPoptipTheme);
}

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/crosshair/base
var CrosshairBase = class extends AbstractComponent {
  constructor() {
    super(...arguments), this.name = "crosshair";
  }
  render() {
    this.renderCrosshair(this);
  }
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/crosshair/register
function loadLineCrosshairComponent() {
  registerGroup(), registerLine();
}
function loadCircleCrosshairComponent() {
  registerGroup(), registerArc();
}
function loadPolygonCrosshairComponent() {
  registerGroup(), registerPath();
}
function loadRectCrosshairComponent() {
  registerGroup(), registerRect();
}
function loadSectorCrosshairComponent() {
  registerGroup(), registerArc();
}

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/crosshair/line
loadLineCrosshairComponent();
var LineCrosshair = class _LineCrosshair extends CrosshairBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _LineCrosshair.defaultAttributes, attributes));
  }
  renderCrosshair(container2) {
    const { start, end, lineStyle } = this.attribute;
    return container2.createOrUpdateChild("crosshair-line", Object.assign({
      points: [start, end]
    }, lineStyle), "line");
  }
  setLocation(region) {
    const { start, end } = region;
    this.setAttributes({
      start,
      end
    });
  }
};
LineCrosshair.defaultAttributes = {
  lineStyle: {
    stroke: "#b2bacf",
    lineWidth: 1,
    lineDash: [2]
  }
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/crosshair/rect
loadRectCrosshairComponent();
var RectCrosshair = class _RectCrosshair extends CrosshairBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _RectCrosshair.defaultAttributes, attributes));
  }
  renderCrosshair(container2) {
    const { start, end, rectStyle } = this.attribute;
    return container2.createOrUpdateChild("crosshair-rect", Object.assign({
      x: start.x,
      y: start.y,
      width: end.x - start.x,
      height: end.y - start.y
    }, rectStyle), "rect");
  }
  setLocation(region) {
    const { start, end } = region;
    this.setAttributes({
      start,
      end
    });
  }
};
RectCrosshair.defaultAttributes = {
  rectStyle: {
    fill: "#b2bacf",
    opacity: 0.2
  }
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/crosshair/circle
loadCircleCrosshairComponent();
var CircleCrosshair = class _CircleCrosshair extends CrosshairBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _CircleCrosshair.defaultAttributes, attributes));
  }
  renderCrosshair(container2) {
    const { center: center2, radius, lineStyle } = this.attribute;
    return container2.createOrUpdateChild("crosshair-circle", Object.assign(Object.assign(Object.assign(Object.assign({}, center2), {
      outerRadius: radius
    }), this.attribute), lineStyle), "arc");
  }
  setLocation(point5) {
    const { center: center2 } = this.attribute, radius = PointService.distancePP(point5, center2);
    this.setAttribute("radius", radius);
  }
};
CircleCrosshair.defaultAttributes = {
  lineStyle: {
    stroke: ["#b2bacf", false, false, false],
    lineWidth: 1,
    lineDash: [2]
  }
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/crosshair/sector
loadSectorCrosshairComponent();
var SectorCrosshair = class _SectorCrosshair extends CrosshairBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _SectorCrosshair.defaultAttributes, attributes));
  }
  renderCrosshair(container2) {
    const { center: center2, radius, innerRadius = 0, sectorStyle } = this.attribute, { startAngle, endAngle } = this.attribute;
    return container2.createOrUpdateChild("crosshair-sector", Object.assign(Object.assign(Object.assign({}, center2), {
      outerRadius: radius,
      innerRadius,
      startAngle,
      endAngle
    }), sectorStyle), "arc");
  }
  setLocation(point5) {
    const { center: center2, startAngle = POLAR_START_ANGLE, endAngle = POLAR_END_ANGLE } = this.attribute, sectorAngle = endAngle - startAngle, pointAngle = radianToDegree(getAngleByPoint(center2, point5));
    this.setAttributes({
      startAngle: pointAngle - sectorAngle / 2,
      endAngle: pointAngle + sectorAngle / 2
    });
  }
};
SectorCrosshair.defaultAttributes = {
  sectorStyle: {
    fill: "#b2bacf",
    opacity: 0.2
  }
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/crosshair/polygon
loadPolygonCrosshairComponent();
var PolygonCrosshair = class _PolygonCrosshair extends CrosshairBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _PolygonCrosshair.defaultAttributes, attributes));
  }
  renderCrosshair(container2) {
    const { center: center2, radius, sides = 6, lineStyle } = this.attribute, { startAngle, endAngle } = this.attribute, isClose2 = (endAngle - startAngle) % (2 * Math.PI) == 0, eachAngle = (endAngle - startAngle) / sides;
    let path;
    for (let index = 0; index <= sides; index++) {
      const point5 = polarToCartesian(center2, radius, startAngle + eachAngle * index);
      0 === index ? path = `M${point5.x},${point5.y}` : path += `L${point5.x},${point5.y}`, index === sides && isClose2 && (path += "Z");
    }
    return container2.createOrUpdateChild("crosshair-polygon", Object.assign({
      path
    }, lineStyle), "path");
  }
  setLocation(point5) {
    const { center: center2 } = this.attribute, radius = PointService.distancePP(point5, center2);
    this.setAttribute("radius", radius);
  }
};
PolygonCrosshair.defaultAttributes = {
  lineStyle: {
    stroke: "#b2bacf",
    lineWidth: 1,
    lineDash: [2]
  }
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/segment/register
function loadSegmentComponent() {
  registerGroup(), registerLine(), registerPolygon(), registerSymbol();
}
function loadArcSegmentComponent() {
  registerGroup(), registerLine(), registerArc(), registerSymbol();
}

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/segment/segment
loadSegmentComponent();
var Segment = class _Segment extends AbstractComponent {
  getStartAngle() {
    return normalizeAngle(this._startAngle);
  }
  getEndAngle() {
    return normalizeAngle(this._endAngle);
  }
  getMainSegmentPoints() {
    return this._mainSegmentPoints;
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Segment.defaultAttributes, attributes)), this.name = "segment", this.key = "segment", this.lines = [];
  }
  render() {
    this.removeAllChild(true), this._reset();
    const { startSymbol, endSymbol, lineStyle, state, visible = true, multiSegment, mainSegmentIndex } = this.attribute;
    if (!visible)
      return;
    this._computeLineAngle();
    const points = this._getMainSegmentPoints(), startSymbolShape = this._renderSymbol(startSymbol, points, "start"), endSymbolShape = this._renderSymbol(endSymbol, points, "end");
    if (this.startSymbol = startSymbolShape, this.endSymbol = endSymbolShape, multiSegment) {
      const points2 = [...this.attribute.points];
      if (isValidNumber_default(mainSegmentIndex))
        points2[mainSegmentIndex] = this._clipPoints(points2[mainSegmentIndex]);
      else {
        const clipPoints = this._clipPoints(flattenArray(points2));
        points2[0][0] = clipPoints[0], points2[points2.length - 1][points2[points2.length - 1].length - 1] = clipPoints[clipPoints.length - 1];
      }
      points2.forEach((point5, index) => {
        var _a, _b;
        const line2 = graphicCreator.line(Object.assign(Object.assign({
          points: point5
        }, isArray_default(lineStyle) ? null !== (_a = lineStyle[index]) && void 0 !== _a ? _a : lineStyle[lineStyle.length - 1] : lineStyle), {
          fill: false
        }));
        line2.name = `${this.name}-line`, line2.id = this._getNodeId("line" + index), isEmpty_default(null == state ? void 0 : state.line) || (line2.states = isArray_default(state.line) ? null !== (_b = state.line[index]) && void 0 !== _b ? _b : state.line[state.line.length - 1] : state.line), this.add(line2), this.lines.push(line2);
      });
    } else {
      let lineCreator = graphicCreator.line;
      array(lineStyle)[0].cornerRadius && (lineCreator = graphicCreator.polygon);
      const line2 = lineCreator(Object.assign(Object.assign({
        points: this._clipPoints(this.attribute.points)
      }, array(lineStyle)[0]), {
        fill: false,
        closePath: false
      }));
      line2.name = `${this.name}-line`, line2.id = this._getNodeId("line"), isEmpty_default(null == state ? void 0 : state.line) || (line2.states = [].concat(state.line)[0]), this.add(line2), this.lines.push(line2);
    }
  }
  _computeStartRotate(angle2) {
    return angle2 + Math.PI / 2;
  }
  _computeEndRotate(angle2) {
    return angle2 + Math.PI / 2;
  }
  _renderSymbol(attribute, points, dim) {
    if (!points.length)
      return;
    const { autoRotate: autoRotate2 = true } = attribute;
    let symbol;
    if (attribute && attribute.visible) {
      const startAngle = this.getStartAngle(), endAngle = this.getEndAngle(), { state } = this.attribute, start = points[0], end = points[points.length - 1], { refX = 0, refY = 0, refAngle = 0, style, symbolType, size = 12 } = attribute;
      let position, rotate3;
      "start" === dim ? (position = {
        x: start.x + (isValidNumber_default(startAngle) ? refX * Math.cos(startAngle) + refY * Math.cos(startAngle - Math.PI / 2) : 0),
        y: start.y + (isValidNumber_default(startAngle) ? refX * Math.sin(startAngle) + refY * Math.sin(startAngle - Math.PI / 2) : 0)
      }, rotate3 = this._computeStartRotate(this._startAngle)) : (position = {
        x: end.x + (isValidNumber_default(endAngle) ? refX * Math.cos(endAngle) + refY * Math.cos(endAngle - Math.PI / 2) : 0),
        y: end.y + (isValidNumber_default(endAngle) ? refX * Math.sin(endAngle) + refY * Math.sin(endAngle - Math.PI / 2) : 0)
      }, rotate3 = this._computeEndRotate(this._endAngle)), symbol = graphicCreator.symbol(Object.assign(Object.assign(Object.assign({}, position), {
        symbolType,
        size,
        angle: autoRotate2 ? rotate3 + refAngle : 0,
        strokeBoundsBuffer: 0
      }), style)), symbol.name = `${this.name}-${dim}-symbol`, symbol.id = this._getNodeId(`${dim}-symbol`), isEmpty_default(null == state ? void 0 : state.symbol) || (symbol.states = state.symbol), "start" === dim ? isEmpty_default(null == state ? void 0 : state.startSymbol) || (symbol.states = state.startSymbol) : isEmpty_default(null == state ? void 0 : state.endSymbol) || (symbol.states = state.endSymbol), this.add(symbol);
    }
    return symbol;
  }
  _getMainSegmentPoints() {
    if (this._mainSegmentPoints)
      return this._mainSegmentPoints;
    const { points: originPoints, multiSegment, mainSegmentIndex } = this.attribute;
    let points;
    return points = multiSegment ? isValidNumber_default(mainSegmentIndex) ? originPoints[mainSegmentIndex] : flattenArray(originPoints) : originPoints, this._mainSegmentPoints = points, points;
  }
  _clipPoints(points) {
    const { startSymbol = {}, endSymbol = {} } = this.attribute;
    let pointsAfterClip = points;
    if (startSymbol.visible) {
      const startSize = startSymbol.clip ? startSymbol.size || 10 : 0;
      pointsAfterClip = [{
        x: points[0].x - startSize / 2 * (Math.cos(this._startAngle) || 0),
        y: points[0].y - startSize / 2 * (Math.sin(this._startAngle) || 0)
      }, ...pointsAfterClip.slice(1)];
    }
    if (endSymbol.visible) {
      const endSize = endSymbol.clip ? endSymbol.size || 10 : 0, pointsEnd = {
        x: points[points.length - 1].x - endSize / 2 * (Math.cos(this._endAngle) || 0),
        y: points[points.length - 1].y - endSize / 2 * (Math.sin(this._endAngle) || 0)
      };
      pointsAfterClip = [...pointsAfterClip.slice(0, pointsAfterClip.length - 1), pointsEnd];
    }
    return pointsAfterClip;
  }
  _computeLineAngle() {
    const points = this._getMainSegmentPoints();
    if (points.length <= 1)
      return;
    const start = points[0], startInside = points[1], endInside = points[points.length - 2], end = points[points.length - 1], startVector = [start.x - startInside.x, start.y - startInside.y], startAngle = Math.atan2(startVector[1], startVector[0]), endVector = [end.x - endInside.x, end.y - endInside.y], endAngle = Math.atan2(endVector[1], endVector[0]);
    this._startAngle = startAngle, this._endAngle = endAngle;
  }
  _reset() {
    this.startSymbol = null, this.endSymbol = null, this._startAngle = null, this._endAngle = null, this._mainSegmentPoints = null;
  }
};
Segment.defaultAttributes = {
  visible: true,
  lineStyle: {
    lineWidth: 1,
    stroke: "#000"
  },
  startSymbol: {
    visible: false,
    autoRotate: true,
    symbolType: "triangle",
    size: 12,
    refX: 0,
    refY: 0,
    refAngle: 0,
    style: {
      fill: "#000",
      zIndex: 1
    }
  },
  endSymbol: {
    visible: false,
    autoRotate: true,
    symbolType: "triangle",
    size: 12,
    refX: 0,
    refY: 0,
    refAngle: 0,
    style: {
      fill: "#000",
      zIndex: 1
    }
  }
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/segment/arc-segment
loadArcSegmentComponent();
var ArcSegment = class extends Segment {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, Segment.defaultAttributes, attributes)), this.name = "arc-segment", this.key = "arc-segment", this.isReverseArc = false;
  }
  getStartAngle() {
    const tangAng = this.isReverseArc ? this._startAngle + Math.PI / 2 : this._startAngle - Math.PI / 2;
    return tangAng < 0 ? tangAng + 2 * Math.PI : tangAng > 2 * Math.PI ? tangAng - 2 * Math.PI : tangAng;
  }
  getEndAngle() {
    const tangAng = this.isReverseArc ? this._endAngle - Math.PI / 2 : this._endAngle + Math.PI / 2;
    return tangAng < 0 ? tangAng + 2 * Math.PI : tangAng > 2 * Math.PI ? tangAng - 2 * Math.PI : tangAng;
  }
  getMainSegmentPoints() {
    return this._mainSegmentPoints;
  }
  _computeStartRotate(angle2) {
    return this.isReverseArc ? angle2 + Math.PI : angle2;
  }
  _computeEndRotate(angle2) {
    return this.isReverseArc ? angle2 : angle2 + Math.PI;
  }
  render() {
    this.removeAllChild(true), this._reset();
    const { startSymbol, endSymbol, lineStyle, state, visible = true, radius, startAngle, endAngle, center: center2 } = this.attribute;
    if (!visible)
      return;
    this._startAngle = startAngle, this._endAngle = endAngle, this.isReverseArc = startAngle > endAngle;
    const startPoint = {
      x: center2.x + radius * Math.cos(this._startAngle),
      y: center2.y + radius * Math.sin(this._startAngle)
    }, endPoint = {
      x: center2.x + radius * Math.cos(this._endAngle),
      y: center2.y + radius * Math.sin(this._endAngle)
    };
    this._mainSegmentPoints = [startPoint, endPoint];
    const startSymbolShape = this._renderSymbol(startSymbol, this._mainSegmentPoints, "start"), endSymbolShape = this._renderSymbol(endSymbol, this._mainSegmentPoints, "end");
    this.startSymbol = startSymbolShape, this.endSymbol = endSymbolShape;
    const line2 = graphicCreator.arc(Object.assign({
      x: center2.x,
      y: center2.y,
      startAngle,
      endAngle,
      innerRadius: radius,
      outerRadius: radius
    }, lineStyle));
    line2.name = `${this.name}-line`, line2.id = this._getNodeId("arc"), isEmpty_default(null == state ? void 0 : state.line) || (line2.states = [].concat(state.line)[0]), this.add(line2), this.line = line2;
  }
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/axis/constant
var AXIS_ELEMENT_NAME;
!function(AXIS_ELEMENT_NAME2) {
  AXIS_ELEMENT_NAME2.innerView = "inner-view", AXIS_ELEMENT_NAME2.axisContainer = "axis-container", AXIS_ELEMENT_NAME2.labelContainer = "axis-label-container", AXIS_ELEMENT_NAME2.tickContainer = "axis-tick-container", AXIS_ELEMENT_NAME2.tick = "axis-tick", AXIS_ELEMENT_NAME2.subTick = "axis-sub-tick", AXIS_ELEMENT_NAME2.label = "axis-label", AXIS_ELEMENT_NAME2.title = "axis-title", AXIS_ELEMENT_NAME2.gridContainer = "axis-grid-container", AXIS_ELEMENT_NAME2.grid = "axis-grid", AXIS_ELEMENT_NAME2.gridRegion = "axis-grid-region", AXIS_ELEMENT_NAME2.line = "axis-line", AXIS_ELEMENT_NAME2.background = "axis-background", AXIS_ELEMENT_NAME2.axisLabelBackground = "axis-label-background";
}(AXIS_ELEMENT_NAME || (AXIS_ELEMENT_NAME = {}));
var AxisStateValue;
!function(AxisStateValue2) {
  AxisStateValue2.selected = "selected", AxisStateValue2.selectedReverse = "selected_reverse", AxisStateValue2.hover = "hover", AxisStateValue2.hoverReverse = "hover_reverse";
}(AxisStateValue || (AxisStateValue = {}));
var DEFAULT_STATES2 = {
  [AxisStateValue.selectedReverse]: {},
  [AxisStateValue.selected]: {},
  [AxisStateValue.hover]: {},
  [AxisStateValue.hoverReverse]: {}
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/axis/config
var DEFAULT_AXIS_THEME = {
  title: {
    space: 4,
    padding: 0,
    textStyle: {
      fontSize: 12,
      fill: "#333333",
      fontWeight: "normal",
      fillOpacity: 1
    }
  },
  label: {
    visible: true,
    inside: false,
    space: 4,
    padding: 0,
    style: {
      fontSize: 12,
      fill: "#333",
      fontWeight: "normal",
      fillOpacity: 1
    }
  },
  tick: {
    visible: true,
    inside: false,
    alignWithLabel: true,
    length: 4,
    style: {
      lineWidth: 1,
      stroke: "#000",
      strokeOpacity: 1
    }
  },
  subTick: {
    visible: false,
    inside: false,
    count: 4,
    length: 2,
    style: {
      lineWidth: 1,
      stroke: "#999",
      strokeOpacity: 1
    }
  },
  line: {
    visible: true,
    style: {
      lineWidth: 1,
      stroke: "#000",
      strokeOpacity: 1
    }
  }
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/axis/util
var clampRadian2 = (angle2 = 0) => {
  if (angle2 < 0)
    for (; angle2 < 0; )
      angle2 += tau;
  else if (angle2 > 0)
    for (; angle2 > tau; )
      angle2 -= tau;
  return angle2;
};
function isInRange(a3, min3, max3) {
  return !isLess(a3, min3, 0, 1e-6) && !isGreater(a3, max3, 0, 1e-6);
}
function getCircleLabelPosition(tickPosition, tickVector, text2, style) {
  const labelBounds = getTextBounds(Object.assign({
    text: text2
  }, style)), width = labelBounds.width(), height = labelBounds.height(), angle2 = clampRadian2(Math.atan2(tickVector[1], tickVector[0])) - Math.PI, PI_3_4 = 3 * Math.PI / 4, PI_1_4 = Math.PI / 4, PI_1_2 = Math.PI / 2, baseX = tickPosition.x;
  let dx = 0;
  dx = isInRange(angle2, -PI_3_4, -PI_1_4) ? ((angle2 + PI_3_4) / PI_1_2 - 0.5) * width : isInRange(angle2, PI_1_4, PI_3_4) ? (0.5 - (angle2 - PI_1_4) / PI_1_2) * width : Math.cos(angle2) >= 0 ? 0.5 * width : 0.5 * -width;
  const x = baseX - dx, baseY = tickPosition.y;
  let dy = 0;
  dy = isInRange(angle2, -PI_3_4, -PI_1_4) ? 0.5 * -height : isInRange(angle2, PI_1_4, PI_3_4) ? 0.5 * height : Math.cos(angle2) >= 0 ? (0.5 - (PI_1_4 - angle2) / PI_1_2) * height : (0.5 - clampRadian2(angle2 - PI_3_4) / PI_1_2) * height;
  return {
    x,
    y: baseY - dy
  };
}
function getElMap(g) {
  const elMap = {};
  return traverseGroup(g, (el) => {
    "group" !== el.type && el.id && (elMap[el.id] = el);
  }), elMap;
}
function getVerticalCoord(point5, vector) {
  return {
    x: point5.x + vector[0],
    y: point5.y + vector[1]
  };
}
function getCircleVerticalVector(offset, point5, center2, inside = false, axisInside = false) {
  const vector = [point5.x - center2.x, point5.y - center2.y];
  return scale3(vector, (inside ? -1 : 1) * (axisInside ? -1 : 1) * offset / length(vector));
}
function angleLabelOrientAttribute(angle2) {
  let align = "center", baseline = "middle";
  return align = (angle2 = normalizeAngle(angle2)) >= Math.PI * (5 / 3) || angle2 <= Math.PI * (1 / 3) ? "left" : angle2 >= Math.PI * (2 / 3) && angle2 <= Math.PI * (4 / 3) ? "right" : "center", baseline = angle2 >= Math.PI * (7 / 6) && angle2 <= Math.PI * (11 / 6) ? "bottom" : angle2 >= Math.PI * (1 / 6) && angle2 <= Math.PI * (5 / 6) ? "top" : "middle", {
    align,
    baseline
  };
}
function getPolarAngleLabelPosition(angle2, center2, radius, labelOffset, inside, text2, style) {
  const point5 = polarToCartesian({
    x: 0,
    y: 0
  }, radius, angle2), labelPoint = getVerticalCoord(point5, getCircleVerticalVector(labelOffset, point5, center2, inside));
  return getCircleLabelPosition(labelPoint, getCircleVerticalVector(labelOffset || 1, labelPoint, center2, inside), text2, style);
}

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/util/interaction
var dispatchHoverState = (e, container2, lastHover) => {
  const target = e.target;
  return target !== lastHover && target.name && !isEmpty_default(target.states) ? (target.addState(StateValue.hover, true), traverseGroup(container2, (node) => {
    node !== target && node.name && !isEmpty_default(node.states) && node.addState(StateValue.hoverReverse, true);
  }), target) : lastHover;
};
var dispatchUnHoverState = (e, container2, lastHover) => lastHover ? (traverseGroup(container2, (node) => {
  node.name && !isEmpty_default(node.states) && (node.removeState(StateValue.hoverReverse), node.removeState(StateValue.hover));
}), null) : lastHover;
var dispatchClickState = (e, container2, lastSelect) => {
  const target = e.target;
  return lastSelect === target && target.hasState(StateValue.selected) ? (traverseGroup(container2, (node) => {
    node.name && !isEmpty_default(node.states) && (node.removeState(StateValue.selectedReverse), node.removeState(StateValue.selected));
  }), null) : target.name && !isEmpty_default(target.states) ? (target.addState(StateValue.selected, true), traverseGroup(container2, (node) => {
    node !== target && node.name && !isEmpty_default(node.states) && node.addState(StateValue.selectedReverse, true);
  }), target) : lastSelect;
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/axis/base
var AxisBase = class extends AbstractComponent {
  constructor() {
    super(...arguments), this.name = "axis", this.data = [], this.tickLineItems = [], this.subTickLineItems = [], this.axisLabelLayerSize = {}, this.axisLabelsContainer = null, this._onHover = (e) => {
      this._lastHover = dispatchHoverState(e, this.axisContainer, this._lastHover);
    }, this._onUnHover = (e) => {
      this._lastHover = dispatchUnHoverState(e, this.axisContainer, this._lastHover);
    }, this._onClick = (e) => {
      this._lastSelect = dispatchClickState(e, this.axisContainer, this._lastSelect);
    };
  }
  getInnerView() {
    return this._innerView;
  }
  getPrevInnerView() {
    return this._prevInnerView;
  }
  getBoundsWithoutRender(attributes) {
    const currentAttribute = cloneDeep(this.attribute);
    merge(this.attribute, attributes);
    const offscreenGroup = graphicCreator.group({
      x: this.attribute.x,
      y: this.attribute.y
    });
    return this.add(offscreenGroup), this._renderInner(offscreenGroup), this.removeChild(offscreenGroup), this.attribute = currentAttribute, offscreenGroup.AABBBounds;
  }
  render() {
    this._prevInnerView = this._innerView && getElMap(this._innerView), this.removeAllChild(true), this._innerView = graphicCreator.group({
      x: 0,
      y: 0,
      pickable: false
    }), this.add(this._innerView), this._renderInner(this._innerView), this._bindEvent();
  }
  _bindEvent() {
    if (this.attribute.disableTriggerEvent)
      return;
    const { hover, select } = this.attribute;
    hover && (this._innerView.addEventListener("pointermove", this._onHover), this._innerView.addEventListener("pointerout", this._onUnHover)), select && this._innerView.addEventListener("pointerdown", this._onClick);
  }
  _renderInner(container2) {
    const { title: title3, label, tick, line: line2, items } = this.attribute, axisContainer = graphicCreator.group({
      x: 0,
      y: 0,
      zIndex: 1
    });
    if (axisContainer.name = AXIS_ELEMENT_NAME.axisContainer, axisContainer.id = this._getNodeId("container"), axisContainer.setMode(this.mode), this.axisContainer = axisContainer, container2.add(axisContainer), line2 && line2.visible && this.renderLine(axisContainer), items && items.length && (this.data = this._transformItems(items[0]), tick && tick.visible && this.renderTicks(axisContainer), label && label.visible)) {
      const labelGroup = graphicCreator.group({
        x: 0,
        y: 0,
        pickable: false
      });
      labelGroup.name = AXIS_ELEMENT_NAME.labelContainer, labelGroup.id = this._getNodeId("label-container"), this.axisLabelsContainer = labelGroup, axisContainer.add(labelGroup), items.forEach((axisItems, layer) => {
        const layerLabelGroup = this.renderLabels(labelGroup, axisItems, layer), labels = layerLabelGroup.getChildren();
        this.beforeLabelsOverlap(labels, axisItems, layerLabelGroup, layer, items.length), this.handleLabelsOverlap(labels, axisItems, layerLabelGroup, layer, items.length), this.afterLabelsOverlap(labels, axisItems, layerLabelGroup, layer, items.length);
        let maxTextWidth = 0, maxTextHeight = 0, textAlign = "center", textBaseline = "middle";
        labels.forEach((label2) => {
          var _a;
          const labelStyle = label2.attribute, angle2 = null !== (_a = labelStyle.angle) && void 0 !== _a ? _a : 0, textBounds = label2.AABBBounds;
          let textWidth = textBounds.width(), textHeight = textBounds.height();
          angle2 && (textWidth = Math.abs(textWidth * Math.cos(angle2)), textHeight = Math.abs(textHeight * Math.sin(angle2))), maxTextWidth = Math.max(maxTextWidth, textWidth), maxTextHeight = Math.max(maxTextHeight, textHeight), textAlign = labelStyle.textAlign, textBaseline = labelStyle.textBaseline;
        }), this.axisLabelLayerSize[layer] = {
          width: maxTextWidth,
          height: maxTextHeight,
          textAlign,
          textBaseline
        };
      });
    }
    title3 && title3.visible && this.renderTitle(axisContainer);
  }
  renderTicks(container2) {
    const tickLineItems = this.getTickLineItems(), tickLineGroup = graphicCreator.group({
      x: 0,
      y: 0,
      pickable: false
    });
    tickLineGroup.name = AXIS_ELEMENT_NAME.tickContainer, tickLineGroup.id = this._getNodeId("tick-container"), container2.add(tickLineGroup), tickLineItems.forEach((item, index) => {
      var _a;
      const line2 = graphicCreator.line(Object.assign({}, this._getTickLineAttribute("tick", item, index, tickLineItems)));
      if (line2.name = AXIS_ELEMENT_NAME.tick, line2.id = this._getNodeId(item.id), isEmpty_default(null === (_a = this.attribute.tick) || void 0 === _a ? void 0 : _a.state))
        line2.states = DEFAULT_STATES;
      else {
        const data = this.data[index], tickLineState = merge({}, DEFAULT_STATES, this.attribute.tick.state);
        Object.keys(tickLineState).forEach((key) => {
          isFunction_default(tickLineState[key]) && (tickLineState[key] = tickLineState[key](data.rawValue, index, data, this.data));
        }), line2.states = tickLineState;
      }
      tickLineGroup.add(line2);
    }), this.tickLineItems = tickLineItems;
    const { subTick } = this.attribute;
    if (subTick && subTick.visible) {
      const subTickLineItems = this.getSubTickLineItems();
      subTickLineItems.length && subTickLineItems.forEach((item, index) => {
        const line2 = graphicCreator.line(Object.assign({}, this._getTickLineAttribute("subTick", item, index, tickLineItems)));
        if (line2.name = AXIS_ELEMENT_NAME.subTick, line2.id = this._getNodeId(`${index}`), isEmpty_default(subTick.state))
          line2.states = DEFAULT_STATES;
        else {
          const subTickLineState = merge({}, DEFAULT_STATES, subTick.state);
          Object.keys(subTickLineState).forEach((key) => {
            isFunction_default(subTickLineState[key]) && (subTickLineState[key] = subTickLineState[key](item.value, index, item, tickLineItems));
          }), line2.states = subTickLineState;
        }
        tickLineGroup.add(line2);
      }), this.subTickLineItems = subTickLineItems;
    }
  }
  renderLabels(container2, items, layer) {
    const { dataFilter } = this.attribute.label;
    dataFilter && isFunction_default(dataFilter) && (items = dataFilter(items, layer));
    const data = this._transformItems(items), labelGroup = graphicCreator.group({
      x: 0,
      y: 0,
      pickable: false
    });
    return labelGroup.name = `${AXIS_ELEMENT_NAME.labelContainer}-layer-${layer}`, labelGroup.id = this._getNodeId(`label-container-layer-${layer}`), container2.add(labelGroup), data.forEach((item, index) => {
      var _a;
      const labelStyle = this._getLabelAttribute(item, index, data, layer), text2 = createTextGraphicByType(labelStyle);
      if (text2.name = AXIS_ELEMENT_NAME.label, text2.id = this._getNodeId(`layer${layer}-label-${item.id}`), isEmpty_default(null === (_a = this.attribute.label) || void 0 === _a ? void 0 : _a.state))
        text2.states = DEFAULT_STATES;
      else {
        const labelState = merge({}, DEFAULT_STATES, this.attribute.label.state);
        Object.keys(labelState).forEach((key) => {
          isFunction_default(labelState[key]) && (labelState[key] = labelState[key](item, index, data, layer));
        }), text2.states = labelState;
      }
      labelGroup.add(text2);
    }), labelGroup;
  }
  renderTitle(container2) {
    const titleAttributes = this.getTitleAttribute(), axisTitle = new Tag(Object.assign({}, titleAttributes));
    axisTitle.name = AXIS_ELEMENT_NAME.title, axisTitle.id = this._getNodeId("title"), container2.add(axisTitle);
  }
  getVerticalCoord(point5, offset, inside) {
    return getVerticalCoord(point5, this.getVerticalVector(offset, inside, point5));
  }
  getTextAlign(vector) {
    let align = "center";
    return isNumberClose(vector[0], 0) ? isNumberClose(vector[1], 0) ? Object.is(vector[1], -0) ? align = "start" : Object.is(vector[0], -0) && (align = "end") : align = "center" : vector[0] > 0 ? align = "start" : vector[0] < 0 && (align = "end"), align;
  }
  getTickLineItems() {
    const { tick } = this.attribute, data = this.data, tickLineItems = [], { alignWithLabel, inside = false, length: length2, dataFilter } = tick;
    let tickSegment = 1;
    return data.length >= 2 && (tickSegment = data[1].value - data[0].value), (dataFilter && isFunction_default(dataFilter) ? dataFilter(data) : data).forEach((item) => {
      let point5 = item.point, tickValue = item.value;
      if (!alignWithLabel) {
        const value = item.value - tickSegment / 2;
        if (this.isInValidValue(value))
          return;
        point5 = this.getTickCoord(value), tickValue = value;
      }
      const endPoint = this.getVerticalCoord(point5, length2, inside);
      if ("3d" === this.mode) {
        const vec = this.getVerticalVector(length2, inside, point5);
        let alpha = 0, beta = 0;
        abs(vec[0]) > abs(vec[1]) ? alpha = pi / 2 * (endPoint.x > point5.x ? 1 : -1) : beta = pi / 2 * (endPoint.y > point5.y ? -1 : 1), tickLineItems.push({
          start: point5,
          end: endPoint,
          value: tickValue,
          id: `tick-${item.id}`,
          anchor: [point5.x, point5.y],
          alpha,
          beta
        });
      } else
        tickLineItems.push({
          start: point5,
          end: endPoint,
          value: tickValue,
          id: `tick-${item.id}`
        });
    }), tickLineItems;
  }
  getSubTickLineItems() {
    const { subTick } = this.attribute, subTickLineItems = [], { count: subCount = 4, inside = false, length: length2 = 2 } = subTick, tickLineItems = this.tickLineItems, tickLineCount = tickLineItems.length;
    if (tickLineCount >= 2)
      for (let i = 0; i < tickLineCount - 1; i++) {
        const pre = tickLineItems[i], next = tickLineItems[i + 1];
        for (let j = 0; j < subCount; j++) {
          const percent = (j + 1) / (subCount + 1), value = (1 - percent) * pre.value + percent * next.value, point5 = this.getTickCoord(value), endPoint = this.getVerticalCoord(point5, length2, inside);
          subTickLineItems.push({
            start: point5,
            end: endPoint,
            value,
            id: `sub-tick-${value}`
          });
        }
      }
    return subTickLineItems;
  }
  _getTickLineAttribute(type, tickItem, index, tickItems) {
    let style = get_default(this.attribute, `${type}.style`);
    const data = this.data[index];
    style = isFunction_default(style) ? merge({}, get_default(DEFAULT_AXIS_THEME, `${type}.style`), "tick" === type ? style(data.rawValue, index, data, this.data) : style(tickItem.value, index, tickItem, tickItems)) : style;
    const { start, end, anchor, alpha, beta } = tickItem;
    return Object.assign({
      points: [start, end],
      anchor,
      alpha,
      beta
    }, style);
  }
  _getLabelAttribute(tickDatum, index, tickData, layer) {
    var _a, _b;
    const { space = 4, inside = false, formatMethod, type = "text", text: text2 } = this.attribute.label;
    let offset = space, tickLength = 0;
    (null === (_a = this.attribute.tick) || void 0 === _a ? void 0 : _a.visible) && this.attribute.tick.inside === inside && (tickLength = this.attribute.tick.length || 4), (null === (_b = this.attribute.subTick) || void 0 === _b ? void 0 : _b.visible) && this.attribute.subTick.inside === inside && (tickLength = Math.max(tickLength, this.attribute.subTick.length || 2)), offset += tickLength;
    const axisVector = this.getRelativeVector(tickDatum.point);
    layer > 0 && (0 === axisVector[1] ? offset += (this.axisLabelLayerSize[layer - 1].height + get_default(this.attribute, "label.space", 4)) * layer : offset += (this.axisLabelLayerSize[layer - 1].width + get_default(this.attribute, "label.space", 4)) * layer);
    const point5 = this.getVerticalCoord(tickDatum.point, offset, inside), vector = this.getVerticalVector(offset || 1, inside, point5), textContent = formatMethod ? formatMethod(`${tickDatum.label}`, tickDatum, index, tickData, layer) : tickDatum.label;
    let { style: textStyle } = this.attribute.label;
    textStyle = isFunction_default(textStyle) ? merge({}, DEFAULT_AXIS_THEME.label.style, textStyle(tickDatum, index, tickData, layer)) : textStyle;
    const labelAlign = this.getLabelAlign(vector, inside, textStyle.angle);
    return textStyle = merge(labelAlign, textStyle), isFunction_default(textStyle.text) && (textStyle.text = textStyle.text({
      label: tickDatum.label,
      value: tickDatum.rawValue,
      index: tickDatum.index,
      layer
    })), Object.assign(Object.assign(Object.assign({}, this.getLabelPosition(point5, vector, textContent, textStyle)), {
      text: null != text2 ? text2 : textContent,
      _originText: tickDatum.label,
      lineHeight: null == textStyle ? void 0 : textStyle.fontSize,
      type
    }), textStyle);
  }
  getLabelPosition(point5, vector, text2, style) {
    return point5;
  }
  _transformItems(items) {
    const data = [];
    return items.forEach((item) => {
      var _a;
      data.push(Object.assign(Object.assign({}, item), {
        point: this.getTickCoord(item.value),
        id: null !== (_a = item.id) && void 0 !== _a ? _a : item.label
      }));
    }), data;
  }
  release() {
    super.release(), this._prevInnerView = null, this._innerView = null;
  }
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/axis/overlap/util
function rotate2(x, y, deg, originX, originY) {
  return {
    x: (x - originX) * Math.cos(deg) + (y - originY) * Math.sin(deg) + originX,
    y: (x - originX) * Math.sin(deg) + (originY - y) * Math.cos(deg) + originY
  };
}
function genNormalBounds(item) {
  const bounds = item.AABBBounds;
  return {
    x1: bounds.x1,
    x2: bounds.x2,
    y1: bounds.y1,
    y2: bounds.y2,
    centerX: item.attribute.x,
    centerY: item.attribute.y,
    angle: item.attribute.angle
  };
}
function genRotateBounds(items) {
  items.forEach((item) => {
    if (item.rotatedBounds || !item.attribute.angle)
      return;
    const bounds = genNormalBounds(item), rotatedCenter = rotate2(bounds.centerX, bounds.centerY, bounds.angle, item.attribute.x, item.attribute.y), deltaX = rotatedCenter.x - bounds.centerX, deltaY = rotatedCenter.y - bounds.centerY;
    bounds.x1 += deltaX, bounds.x2 += deltaX, bounds.y1 += deltaY, bounds.y2 += deltaY, bounds.centerX += deltaX, bounds.centerY += deltaY, item.rotatedBounds = bounds;
  });
}
function itemIntersect(item1, item2) {
  return isRectIntersect(item1.AABBBounds, item2.AABBBounds, false) && (!item1.rotatedBounds || !item2.rotatedBounds || isRotateAABBIntersect(item1.rotatedBounds, item2.rotatedBounds, true));
}

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/axis/overlap/auto-hide
var methods = {
  parity: function(items) {
    return items.filter((item, i) => i % 2 ? item.setAttribute("opacity", 0) : 1);
  },
  greedy: function(items, sep) {
    let a3;
    return items.filter((b, i) => i && intersect2(a3, b, sep) ? b.setAttribute("opacity", 0) : (a3 = b, 1));
  }
};
function intersect2(textA, textB, sep) {
  const a3 = textA.AABBBounds, b = textB.AABBBounds;
  return sep > Math.max(b.x1 - a3.x2, a3.x1 - b.x2, b.y1 - a3.y2, a3.y1 - b.y2) && (!textA.rotatedBounds || !textB.rotatedBounds || sep > Math.max(textB.rotatedBounds.x1 - textA.rotatedBounds.x2, textA.rotatedBounds.x1 - textB.rotatedBounds.x2, textB.rotatedBounds.y1 - textA.rotatedBounds.y2, textA.rotatedBounds.y1 - textB.rotatedBounds.y2));
}
function hasOverlap(items, pad2) {
  for (let b, i = 1, n = items.length, a3 = items[0]; i < n; a3 = b, ++i)
    if (intersect2(a3, b = items[i], pad2))
      return true;
}
function hasBounds(item) {
  const b = item.AABBBounds;
  return b.width() > 1 && b.height() > 1;
}
function reset(items) {
  return items.forEach((item) => item.setAttribute("opacity", 1)), items;
}
function autoHide(labels, config2) {
  if (isEmpty_default(labels))
    return;
  const source = labels.filter(hasBounds);
  if (isEmpty_default(source))
    return;
  let items;
  items = reset(source), genRotateBounds(items);
  const { method = "parity", separation: sep = 0 } = config2, reduce = isFunction_default(method) ? method : methods[method] || methods.parity;
  if (items.length >= 3 && hasOverlap(items, sep)) {
    do {
      items = reduce(items, sep);
    } while (items.length >= 3 && hasOverlap(items, sep));
    if (items.length < 3 || config2.lastVisible) {
      const lastSourceItem = last(source);
      if (!lastSourceItem.attribute.opacity) {
        const remainLength = items.length;
        if (remainLength > 1) {
          lastSourceItem.setAttribute("opacity", 1);
          for (let i = remainLength - 1; i >= 0 && intersect2(items[i], lastSourceItem, sep); i--)
            items[i].setAttribute("opacity", 0);
        }
      }
    }
  }
  source.forEach((item) => {
    item.setAttribute("visible", !!item.attribute.opacity);
  });
}

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/axis/overlap/auto-rotate
function autoRotate(items, rotateConfig) {
  if (isEmpty_default(items))
    return;
  const { orient, labelRotateAngle = [0, 45, 90] } = rotateConfig;
  if (0 === labelRotateAngle.length || items.some((item) => !!item.attribute.angle))
    return;
  let i = 0, n = 0;
  for (labelRotateAngle && labelRotateAngle.length > 0 && (n = labelRotateAngle.length); i < n; ) {
    const angle2 = labelRotateAngle[i++];
    if (items.forEach((item) => {
      item.attribute.angle = degreeToRadian(angle2);
    }), tryRotate(orient, items), !hasIntersect(items))
      break;
  }
}
function hasIntersect(items) {
  for (let i = 1; i < items.length; i++)
    if (itemIntersect(items[i - 1], items[i]))
      return true;
  return false;
}
function tryRotate(orient, items) {
  "bottom" !== orient && "top" !== orient || rotateXAxis(orient, items), "left" !== orient && "right" !== orient || rotateYAxis(orient, items), genRotateBounds(items);
}
function clampAngle(angle2 = 0) {
  if (angle2 < 0)
    for (; angle2 < 0; )
      angle2 += 2 * Math.PI;
  if (angle2 > 0)
    for (; angle2 >= 2 * Math.PI; )
      angle2 -= 2 * Math.PI;
  return angle2;
}
function rotateYAxis(orient, items) {
  items.forEach((item, i) => {
    item.attribute.angle && item.setAttributes(Object.assign(Object.assign({}, getYAxisLabelAlign(orient, item.attribute.angle)), {
      angle: clampAngle(item.attribute.angle)
    }));
  });
}
function rotateXAxis(orient, items) {
  items.forEach((item) => {
    item.attribute.angle && item.setAttributes(Object.assign(Object.assign({}, getXAxisLabelAlign(orient, item.attribute.angle)), {
      angle: clampAngle(item.attribute.angle)
    }));
  });
}
function getXAxisLabelAlign(orient, angle2 = 0) {
  let align = ["center", "left", "left", "left", "center", "right", "right", "right", "left"], baseline = ["top", "top", "middle", "bottom", "bottom", "bottom", "middle", "top", "top"];
  "top" === orient && (align = ["center", "right", "right", "right", "center", "left", "left", "left", "right"], baseline = ["bottom", "bottom", "middle", "top", "top", "top", "middle", "bottom", "bottom"]);
  const step = (angle2 = clampAngle(angle2)) / (0.5 * Math.PI);
  let index;
  return index = step === Math.floor(step) ? 2 * Math.floor(step) : 2 * Math.floor(step) + 1, {
    textAlign: align[index],
    textBaseline: baseline[index]
  };
}
function getYAxisLabelAlign(orient, angle2 = 0) {
  let align = ["right", "right", "center", "left", "center", "left", "center", "right", "right"], baseline = ["middle", "middle", "top", "top", "middle", "middle", "bottom", "bottom", "middle"];
  "right" === orient && (align = ["left", "right", "right", "right", "left", "left", "left", "left", "right"], baseline = ["middle", "bottom", "middle", "top", "top", "top", "middle", "bottom", "bottom"]);
  const step = (angle2 = clampAngle(angle2)) / (0.5 * Math.PI);
  let index;
  return index = step === Math.floor(step) ? 2 * Math.floor(step) : 2 * Math.floor(step) + 1, {
    textAlign: align[index],
    textBaseline: baseline[index]
  };
}

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/axis/overlap/auto-limit
function autoLimit(labels, config2) {
  const { limitLength, verticalLimitLength, ellipsis = "...", orient, axisLength } = config2;
  if (isEmpty_default(labels) || !isValidNumber_default(limitLength))
    return;
  const DELTA = Math.sin(Math.PI / 10);
  labels.forEach((label) => {
    var _a;
    const angle2 = label.attribute.angle, hasAngle = !isNil_default(angle2), cos3 = hasAngle ? Math.cos(angle2) : 1, sin3 = hasAngle ? Math.sin(angle2) : 0, isHorizontal3 = !hasAngle || Math.abs(sin3) <= DELTA, isVertical3 = hasAngle && Math.abs(cos3) <= DELTA, isX = "top" === orient || "bottom" === orient;
    if (isX) {
      if (isVertical3 && Math.floor(label.AABBBounds.height()) <= limitLength)
        return;
      if (isHorizontal3 && Math.floor(label.AABBBounds.width()) <= verticalLimitLength)
        return;
    }
    const direction2 = label.attribute.direction;
    if (!isX) {
      if ("vertical" === direction2 && Math.floor(label.AABBBounds.height()) <= verticalLimitLength)
        return;
      if ("vertical" !== direction2) {
        if (isHorizontal3 && Math.floor(label.AABBBounds.width()) <= limitLength)
          return;
        if (isVertical3 && Math.floor(label.AABBBounds.height()) <= verticalLimitLength)
          return;
      }
    }
    let limitLabelLength = null;
    if (isHorizontal3 || isVertical3)
      limitLabelLength = isX ? isHorizontal3 ? verticalLimitLength : limitLength : "vertical" === direction2 || isVertical3 ? verticalLimitLength : limitLength;
    else if (isX) {
      const { x1: x14, x2: x23 } = label.AABBBounds, tan2 = sin3 / cos3;
      limitLabelLength = tan2 > 0 && x14 <= axisLength && limitLength / tan2 + x14 > axisLength ? (axisLength - x14) / Math.abs(cos3) : tan2 < 0 && x23 >= 0 && limitLength / tan2 + x23 < 0 ? x23 / Math.abs(cos3) : Math.abs(limitLength / sin3);
    } else
      limitLabelLength = Math.abs(limitLength / cos3);
    isValidNumber_default(label.attribute.maxLineWidth) && (limitLabelLength = isValidNumber_default(limitLabelLength) ? Math.min(label.attribute.maxLineWidth, limitLabelLength) : label.attribute.maxLineWidth), label.setAttributes({
      maxLineWidth: limitLabelLength,
      ellipsis: null !== (_a = label.attribute.ellipsis) && void 0 !== _a ? _a : ellipsis
    });
  });
}

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/util/align
function alignAxisLabels(labels, start, containerSize, orient, align) {
  if ("right" === orient || "left" === orient) {
    if ("left" === align) {
      const flag = "right" === orient ? 0 : -1;
      labels.forEach((label) => {
        label.setAttributes({
          x: start + containerSize * flag,
          textAlign: "left"
        });
      });
    } else if ("right" === align) {
      const flag = "right" === orient ? 1 : 0;
      labels.forEach((label) => {
        label.setAttributes({
          x: start + containerSize * flag,
          textAlign: "right"
        });
      });
    } else if ("center" === align) {
      const flag = "right" === orient ? 1 : -1;
      labels.forEach((label) => {
        label.setAttributes({
          x: start + 0.5 * containerSize * flag,
          textAlign: "center"
        });
      });
    }
  } else if ("bottom" === orient || "top" === orient) {
    if ("top" === align) {
      const flag = "bottom" === orient ? 0 : -1;
      labels.forEach((label) => {
        label.setAttributes({
          y: start + containerSize * flag,
          textBaseline: "top"
        });
      });
    } else if ("bottom" === align) {
      const flag = "bottom" === orient ? 1 : 0;
      labels.forEach((label) => {
        label.setAttributes({
          y: start + containerSize * flag,
          textBaseline: "bottom"
        });
      });
    } else if ("middle" === align) {
      const flag = "bottom" === orient ? 1 : -1;
      labels.forEach((label) => {
        label.setAttributes({
          y: start + 0.5 * containerSize * flag,
          textBaseline: "middle"
        });
      });
    }
  }
}

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/axis/mixin/line
var LineAxisMixin = class {
  isInValidValue(value) {
    return value < 0 || value > 1;
  }
  getTickCoord(tickValue) {
    const { start } = this.attribute, axisVector = this.getRelativeVector();
    return {
      x: start.x + axisVector[0] * tickValue,
      y: start.y + axisVector[1] * tickValue
    };
  }
  getRelativeVector(point5) {
    const { start, end } = this.attribute;
    return [end.x - start.x, end.y - start.y];
  }
  getVerticalVector(offset, inside = false, point5) {
    const { verticalFactor = 1 } = this.attribute, axisVector = this.getRelativeVector(), normalizedAxisVector = normalize(axisVector), verticalVector = [normalizedAxisVector[1], -1 * normalizedAxisVector[0]];
    return scale3(verticalVector, offset * (inside ? 1 : -1) * verticalFactor);
  }
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/axis/register
function loadBasicAxis() {
  registerGroup(), registerLine(), registerRichtext(), registerText();
}
function loadLineAxisComponent() {
  loadBasicAxis(), registerRect();
}
function loadCircleAxisComponent() {
  loadBasicAxis(), registerCircle();
}
function loadLineAxisGridComponent() {
  registerGroup(), registerPath();
}
function loadCircleAxisGridComponent() {
  registerGroup(), registerPath();
}

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/axis/line
var __rest2 = function(s2, e) {
  var t = {};
  for (var p in s2)
    Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++)
      e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
loadLineAxisComponent();
var LineAxis = class _LineAxis extends AxisBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _LineAxis.defaultAttributes, attributes), options);
  }
  _renderInner(container2) {
    var _a;
    super._renderInner(container2);
    const { panel } = this.attribute;
    if (panel && panel.visible) {
      const axisContainer = this.axisContainer, axisContainerBounds = axisContainer.AABBBounds, bgRect = graphicCreator.rect(Object.assign({
        x: axisContainerBounds.x1,
        y: axisContainerBounds.y1,
        width: axisContainerBounds.width(),
        height: axisContainerBounds.height()
      }, panel.style));
      bgRect.name = AXIS_ELEMENT_NAME.background, bgRect.id = this._getNodeId("background"), bgRect.states = merge({}, DEFAULT_STATES2, null !== (_a = panel.state) && void 0 !== _a ? _a : {}), axisContainer.insertBefore(bgRect, axisContainer.firstChild);
    }
  }
  renderLine(container2) {
    const { start, end, line: line2 } = this.attribute, _a = line2, { startSymbol, endSymbol, style, breakRange, breakShape, breakShapeStyle, state } = _a, restLineAttrs = __rest2(_a, ["startSymbol", "endSymbol", "style", "breakRange", "breakShape", "breakShapeStyle", "state"]), lineAttrs = Object.assign({
      points: [start, end],
      startSymbol,
      endSymbol,
      lineStyle: style
    }, restLineAttrs);
    isEmpty_default(state) || (lineAttrs.state = {
      line: merge({}, DEFAULT_STATES2, state),
      symbol: merge({}, DEFAULT_STATES2, state)
    });
    const axisLineGroup = new Segment(lineAttrs);
    axisLineGroup.name = AXIS_ELEMENT_NAME.line, axisLineGroup.id = this._getNodeId("line"), container2.add(axisLineGroup);
  }
  getTitleAttribute() {
    var _a, _b, _c;
    const _d = this.attribute.title, { position = "middle", space = 4, textStyle = {}, autoRotate: autoRotate2 = true, shape, background, state = {}, maxWidth } = _d, restAttrs = __rest2(_d, ["position", "space", "textStyle", "autoRotate", "shape", "background", "state", "maxWidth"]);
    let percent = 0.5;
    "start" === position ? percent = 0 : "end" === position && (percent = 1);
    const { verticalFactor = 1 } = this.attribute, factor = -1 * verticalFactor, point5 = this.getTickCoord(percent), axisVector = this.getRelativeVector();
    let labelLength = 0;
    if ((null === (_a = this.attribute.label) || void 0 === _a ? void 0 : _a.visible) && false === this.attribute.label.inside) {
      const space2 = +get_default(this.attribute, "label.space", 4);
      labelLength += space2;
      const layerCount = Object.keys(this.axisLabelLayerSize).length;
      if (0 === axisVector[1]) {
        const labelBoundsHeight = this.axisLabelsContainer ? this.axisLabelsContainer.AABBBounds.height() : 0;
        isFinite(labelBoundsHeight) ? labelLength += labelBoundsHeight + (layerCount - 1) * space2 : labelLength = 0;
      } else {
        if (0 === axisVector[0]) {
          const boundsWidth = this.axisLabelsContainer ? this.axisLabelsContainer.AABBBounds.width() : 0;
          isFinite(boundsWidth) ? labelLength += boundsWidth + (layerCount - 1) * space2 : labelLength = 0;
        } else
          Object.keys(this.axisLabelLayerSize).forEach((layer, index) => {
            labelLength += this.axisLabelLayerSize[layer].width + (index > 0 ? space2 : 0);
          });
        const textAlign2 = this.axisLabelLayerSize[0].textAlign, isTextAlignStart = "start" === textAlign2 || "left" === textAlign2, isTextCenter = "center" === textAlign2, isReverse = axisVector[1] > 0;
        labelLength = 1 === factor ? isReverse ? isTextAlignStart ? labelLength : isTextCenter ? labelLength / 2 : space2 : isTextAlignStart ? space2 : isTextCenter ? labelLength / 2 : labelLength : isReverse ? isTextAlignStart ? space2 : isTextCenter ? labelLength / 2 : labelLength : isTextAlignStart ? labelLength : isTextCenter ? labelLength / 2 : space2;
      }
    }
    let tickLength = 0;
    (null === (_b = this.attribute.tick) || void 0 === _b ? void 0 : _b.visible) && false === this.attribute.tick.inside && (tickLength = this.attribute.tick.length || 4), (null === (_c = this.attribute.subTick) || void 0 === _c ? void 0 : _c.visible) && false === this.attribute.subTick.inside && (tickLength = Math.max(tickLength, this.attribute.subTick.length || 2));
    const offset = tickLength + labelLength + space, titlePoint = this.getVerticalCoord(point5, offset, false), vector = this.getVerticalVector(offset, false, {
      x: 0,
      y: 0
    });
    let textAlign, textBaseline, { angle: angle2 } = restAttrs;
    if (textAlign = "start" === position ? "start" : "end" === position ? "end" : "center", isNil_default(angle2) && autoRotate2) {
      angle2 = angleTo(axisVector, [1, 0], true);
      const { verticalFactor: verticalFactor2 = 1 } = this.attribute;
      textBaseline = 1 === -1 * verticalFactor2 ? "bottom" : "top";
    } else
      textAlign = this.getTextAlign(vector), textBaseline = this.getTextBaseline(vector, false);
    let maxTagWidth = maxWidth;
    if (isNil_default(maxTagWidth)) {
      const { verticalLimitSize, verticalMinSize, orient } = this.attribute, limitSize = Math.min(verticalLimitSize || 1 / 0, verticalMinSize || 1 / 0);
      if (isValidNumber_default(limitSize)) {
        if ("bottom" === orient || "top" === orient)
          if (angle2 !== Math.PI / 2) {
            const cosValue = Math.abs(Math.cos(null != angle2 ? angle2 : 0));
            maxTagWidth = cosValue < 1e-6 ? 1 / 0 : this.attribute.end.x / cosValue;
          } else
            maxTagWidth = limitSize - offset;
        else if (angle2 && 0 !== angle2) {
          const sinValue = Math.abs(Math.sin(angle2));
          maxTagWidth = sinValue < 1e-6 ? 1 / 0 : this.attribute.end.y / sinValue;
        } else
          maxTagWidth = limitSize - offset;
      }
    }
    const attrs = Object.assign(Object.assign(Object.assign({}, titlePoint), restAttrs), {
      maxWidth: maxTagWidth,
      textStyle: Object.assign({
        textAlign,
        textBaseline
      }, textStyle),
      state: {
        text: merge({}, DEFAULT_STATES2, state.text),
        shape: merge({}, DEFAULT_STATES2, state.shape),
        panel: merge({}, DEFAULT_STATES2, state.background)
      }
    });
    return attrs.angle = angle2, shape && shape.visible && (attrs.shape = Object.assign({
      visible: true
    }, shape.style), shape.space && (attrs.space = shape.space)), background && background.visible && (attrs.panel = Object.assign({
      visible: true
    }, background.style)), attrs;
  }
  getTextBaseline(vector, inside) {
    let base = "middle";
    const { verticalFactor = 1 } = this.attribute, factor = (inside ? 1 : -1) * verticalFactor;
    return isNumberClose(vector[1], 0) ? base = !isNumberClose(vector[0], 0) || Object.is(vector[0], -0) || Object.is(vector[1], -0) ? "middle" : 1 === factor ? "bottom" : "top" : vector[1] > 0 ? base = "top" : vector[1] < 0 && (base = "bottom"), base;
  }
  getLabelAlign(vector, inside, angle2) {
    const orient = this.attribute.orient;
    if (["top", "bottom", "right", "left"].includes(orient) || 0 === vector[0] && 0 === vector[1]) {
      if ("top" === orient || "bottom" === orient)
        return getXAxisLabelAlign(inside ? "bottom" === orient ? "top" : "bottom" : orient, angle2);
      if ("left" === orient || "right" === orient)
        return getYAxisLabelAlign(inside ? "left" === orient ? "right" : "left" : orient, angle2);
    }
    return {
      textAlign: this.getTextAlign(vector),
      textBaseline: this.getTextBaseline(vector, inside)
    };
  }
  beforeLabelsOverlap(labelShapes, labelData, labelContainer, layer, layerCount) {
    var _a, _b, _c, _d;
    const { flush = false } = this.attribute.label || {};
    if (flush && labelShapes.length) {
      const { orient, start: axisStart, end: axisEnd } = this.attribute, isX = "bottom" === orient || "top" === orient, first = labelShapes[0], last2 = last(labelShapes), isInverse = isX ? first.attribute.x > last2.attribute.x : first.attribute.y < last2.attribute.y;
      if (isX) {
        const leftMostLabel = isInverse ? last2 : first, rightMostLabel = isInverse ? first : last2, left2 = axisStart.x, right2 = axisEnd.x, leftBound = leftMostLabel.AABBBounds.x1, rightBound = rightMostLabel.AABBBounds.x2;
        if (leftBound < left2) {
          leftMostLabel.attribute.angle ? leftMostLabel.setAttributes({
            dx: (null !== (_a = leftMostLabel.attribute.dx) && void 0 !== _a ? _a : 0) + left2 - leftBound
          }) : leftMostLabel.setAttributes({
            x: left2,
            textAlign: "left"
          });
        }
        if (rightBound > right2) {
          rightMostLabel.attribute.angle ? rightMostLabel.setAttributes({
            dx: (null !== (_b = rightMostLabel.attribute.dx) && void 0 !== _b ? _b : 0) + right2 - rightBound
          }) : rightMostLabel.setAttributes({
            x: right2,
            textAlign: "right"
          });
        }
      } else {
        const bottomMostLabel = isInverse ? last2 : first, topMostLabel = isInverse ? first : last2, bottomBound = bottomMostLabel.AABBBounds.y2, topBound = topMostLabel.AABBBounds.y1, top = axisStart.y, bottom = axisEnd.y;
        if (topBound < top) {
          topMostLabel.attribute.angle ? topMostLabel.setAttributes({
            dy: (null !== (_c = topMostLabel.attribute.dy) && void 0 !== _c ? _c : 0) + top - topBound
          }) : topMostLabel.setAttributes({
            y: top,
            textBaseline: "top"
          });
        }
        if (bottomBound > bottom) {
          bottomMostLabel.attribute.angle ? bottomMostLabel.setAttributes({
            dy: (null !== (_d = bottomMostLabel.attribute.dy) && void 0 !== _d ? _d : 0) + bottom - bottomBound
          }) : bottomMostLabel.setAttributes({
            y: bottom,
            textBaseline: "bottom"
          });
        }
      }
    }
  }
  handleLabelsOverlap(labelShapes, labelData, labelContainer, layer, layerCount) {
    if (isEmpty_default(labelShapes))
      return;
    const { verticalLimitSize, label, orient } = this.attribute, limitLength = this._getAxisLabelLimitLength(verticalLimitSize, layerCount), { layoutFunc, autoRotate: autoRotate2, autoRotateAngle, autoLimit: autoLimit2, limitEllipsis, autoHide: autoHide2, autoHideMethod, autoHideSeparation, lastVisible } = label;
    if (isFunction_default(layoutFunc))
      layoutFunc(labelShapes, labelData, layer, this);
    else {
      if (autoRotate2 && autoRotate(labelShapes, {
        labelRotateAngle: autoRotateAngle,
        orient
      }), autoLimit2 && isValidNumber_default(limitLength) && limitLength > 0) {
        const isVertical3 = "left" === orient || "right" === orient, axisLength = isVertical3 ? Math.abs(this.attribute.start.y - this.attribute.end.y) : Math.abs(this.attribute.start.x - this.attribute.end.x), verticalLimitLength = isVertical3 ? axisLength / labelShapes.length : autoHide2 || autoRotate2 ? 1 / 0 : axisLength / labelShapes.length;
        autoLimit(labelShapes, {
          limitLength,
          verticalLimitLength,
          ellipsis: limitEllipsis,
          orient,
          axisLength
        });
      }
      autoHide2 && autoHide(labelShapes, {
        orient,
        method: autoHideMethod,
        separation: autoHideSeparation,
        lastVisible
      });
    }
  }
  afterLabelsOverlap(labelShapes, labelData, labelContainer, layer, layerCount) {
    const { verticalLimitSize, orient } = this.attribute, isHorizontal3 = "bottom" === orient || "top" === orient, axisLabelContainerBounds = labelContainer.AABBBounds;
    let axisLabelContainerSize = isHorizontal3 ? axisLabelContainerBounds.height() : axisLabelContainerBounds.width();
    const { verticalMinSize } = this.attribute;
    if (isValidNumber_default(verticalMinSize) && (!isValidNumber_default(verticalLimitSize) || verticalMinSize <= verticalLimitSize)) {
      const minSize = this._getAxisLabelLimitLength(verticalMinSize, layerCount);
      let x, y;
      axisLabelContainerSize = Math.max(axisLabelContainerSize, minSize), "left" === orient ? (x = axisLabelContainerBounds.x2 - axisLabelContainerSize, y = axisLabelContainerBounds.y1) : "right" === orient ? (x = axisLabelContainerBounds.x1, y = axisLabelContainerBounds.y1) : "top" === orient ? (x = axisLabelContainerBounds.x1, y = axisLabelContainerBounds.y2 - axisLabelContainerSize) : "bottom" === orient && (x = axisLabelContainerBounds.x1, y = axisLabelContainerBounds.y1);
      const bgRect = graphicCreator.rect({
        x,
        y,
        width: isHorizontal3 ? axisLabelContainerBounds.width() : axisLabelContainerSize,
        height: isHorizontal3 ? axisLabelContainerSize : axisLabelContainerBounds.height(),
        pickable: false
      });
      bgRect.name = AXIS_ELEMENT_NAME.axisLabelBackground, bgRect.id = this._getNodeId("axis-label-background"), labelContainer.insertBefore(bgRect, labelContainer.firstChild);
    }
    if (isValid_default(this.attribute.label.containerAlign)) {
      let start;
      "left" === orient ? start = axisLabelContainerBounds.x2 : "right" === orient ? start = axisLabelContainerBounds.x1 : "top" === orient ? start = axisLabelContainerBounds.y2 : "bottom" === orient && (start = axisLabelContainerBounds.y1), alignAxisLabels(labelShapes, start, axisLabelContainerSize, orient, this.attribute.label.containerAlign);
    }
  }
  _getAxisLabelLimitLength(limitSize, layerCount) {
    var _a, _b, _c, _d, _e;
    const { label, title: title3, line: line2, tick } = this.attribute, labelSpace = null !== (_a = label.space) && void 0 !== _a ? _a : 4;
    let limitLength = limitSize, titleHeight = 0, titleSpacing = 0;
    const axisLineWidth = line2 && line2.visible ? null !== (_b = line2.style.lineWidth) && void 0 !== _b ? _b : 1 : 0, tickLength = tick && tick.visible ? null !== (_c = tick.length) && void 0 !== _c ? _c : 4 : 0;
    if (title3 && title3.visible && "string" == typeof title3.text) {
      titleHeight = measureTextSize(title3.text, title3.textStyle, null === (_e = null === (_d = this.stage) || void 0 === _d ? void 0 : _d.getTheme()) || void 0 === _e ? void 0 : _e.text).height;
      const padding = normalizePadding(title3.padding);
      titleSpacing = title3.space + padding[0] + padding[2];
    }
    return limitLength && (limitLength = (limitLength - labelSpace - titleSpacing - titleHeight - axisLineWidth - tickLength) / layerCount), limitLength;
  }
};
LineAxis.defaultAttributes = DEFAULT_AXIS_THEME, mixin(LineAxis, LineAxisMixin);

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/axis/mixin/circle
var CircleAxisMixin = class {
  isInValidValue(value) {
    const { startAngle = POLAR_START_ANGLE, endAngle = POLAR_END_ANGLE } = this.attribute;
    return Math.abs(endAngle - startAngle) % (2 * Math.PI) == 0 ? value > 1 : value < 0 || value > 1;
  }
  getTickCoord(tickValue) {
    const { startAngle = POLAR_START_ANGLE, endAngle = POLAR_END_ANGLE, center: center2, radius, inside = false, innerRadius = 0 } = this.attribute;
    return polarToCartesian(center2, inside && innerRadius > 0 ? innerRadius : radius, startAngle + (endAngle - startAngle) * tickValue);
  }
  getVerticalVector(offset, inside = false, point5) {
    return getCircleVerticalVector(offset, point5, this.attribute.center, inside, this.attribute.inside);
  }
  getRelativeVector(point5) {
    const { center: center2 } = this.attribute;
    return [point5.y - center2.y, -1 * (point5.x - center2.x)];
  }
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/axis/circle
var __rest3 = function(s2, e) {
  var t = {};
  for (var p in s2)
    Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++)
      e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
loadCircleAxisComponent();
var CircleAxis = class _CircleAxis extends AxisBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _CircleAxis.defaultAttributes, attributes));
  }
  renderLine(container2) {
    const { startAngle = POLAR_START_ANGLE, endAngle = POLAR_END_ANGLE, radius, center: center2, innerRadius = 0, line: line2 = {}, inside = false } = this.attribute;
    let arcRadius = radius, arcInnerRadius = innerRadius;
    inside && innerRadius > 0 && (arcRadius = innerRadius, arcInnerRadius = 0);
    const arcAttrs = Object.assign(Object.assign(Object.assign({}, center2), {
      startAngle,
      endAngle,
      radius: arcRadius,
      innerRadius: arcInnerRadius
    }), line2.style), axisLine = graphicCreator.circle(arcAttrs);
    axisLine.name = AXIS_ELEMENT_NAME.line, axisLine.id = this._getNodeId("line"), isEmpty_default(line2.state) || (axisLine.states = merge({}, DEFAULT_STATES2, line2.state)), container2.add(axisLine);
  }
  getTitleAttribute() {
    var _a, _b, _c;
    const { center: center2, radius, innerRadius = 0 } = this.attribute, _d = this.attribute.title, { space = 4, textStyle = {}, shape, background, state = {} } = _d, restAttrs = __rest3(_d, ["space", "textStyle", "shape", "background", "state"]);
    let titlePoint = center2, labelHeight = 0;
    (null === (_a = this.attribute.label) || void 0 === _a ? void 0 : _a.visible) && false === this.attribute.label.inside && (labelHeight = get_default(this.attribute.label, "style.fontSize", 12) + get_default(this.attribute.label, "space", 4));
    let tickLength = 0;
    (null === (_b = this.attribute.tick) || void 0 === _b ? void 0 : _b.visible) && false === this.attribute.tick.inside && (tickLength = this.attribute.tick.length || 4), (null === (_c = this.attribute.subTick) || void 0 === _c ? void 0 : _c.visible) && false === this.attribute.subTick.inside && (tickLength = Math.max(tickLength, this.attribute.subTick.length || 2));
    const offset = radius + tickLength + labelHeight + space;
    let textBaseline = "middle", { position } = this.attribute.title;
    isNil_default(position) && (position = 0 === innerRadius ? "end" : "middle"), "start" === position ? (textBaseline = "bottom", titlePoint = {
      x: center2.x,
      y: center2.y - offset
    }) : "end" === position && (textBaseline = "top", titlePoint = {
      x: center2.x,
      y: center2.y + offset
    });
    const attrs = Object.assign(Object.assign(Object.assign({}, titlePoint), restAttrs), {
      textStyle: Object.assign({
        textBaseline,
        textAlign: "center"
      }, textStyle),
      state: {
        text: merge({}, DEFAULT_STATES2, state.text),
        shape: merge({}, DEFAULT_STATES2, state.shape),
        panel: merge({}, DEFAULT_STATES2, state.background)
      }
    }), { angle: angle2 } = restAttrs;
    return attrs.angle = angle2, shape && shape.visible && (attrs.shape = Object.assign({
      visible: true
    }, shape.style), shape.space && (attrs.space = shape.space)), background && background.visible && (attrs.panel = Object.assign({
      visible: true
    }, background.style)), attrs;
  }
  getSubTickLineItems() {
    var _a, _b;
    const { subTick } = this.attribute, subTickLineItems = [], { count: subCount = 4, inside = false, length: length2 = 2 } = subTick, tickLineItems = this.tickLineItems, tickLineCount = tickLineItems.length;
    if (tickLineCount >= 2) {
      const tickSegment = this.data[1].value - this.data[0].value, isAlignWithLable = null === (_b = null === (_a = this.attribute) || void 0 === _a ? void 0 : _a.tick) || void 0 === _b ? void 0 : _b.alignWithLabel;
      for (let i = 0; i < tickLineCount; i++) {
        const pre = tickLineItems[i], next = tickLineItems[i + 1];
        for (let j = 0; j < subCount; j++) {
          const percent = (j + 1) / (subCount + 1), value = (1 - percent) * pre.value + percent * (next ? next.value : isAlignWithLable ? 1 : pre.value + tickSegment), point5 = this.getTickCoord(value), endPoint = this.getVerticalCoord(point5, length2, inside);
          subTickLineItems.push({
            start: point5,
            end: endPoint,
            value
          });
        }
      }
    }
    return subTickLineItems;
  }
  getTextBaseline(vector) {
    let base = "middle";
    return isNumberClose(vector[1], 0) ? base = "middle" : vector[1] > 0 && vector[1] > Math.abs(vector[0]) ? base = "top" : vector[1] < 0 && Math.abs(vector[1]) > Math.abs(vector[0]) && (base = "bottom"), base;
  }
  beforeLabelsOverlap(labelShapes, labelData, labelContainer, layer, layerCount) {
  }
  handleLabelsOverlap(labelShapes, labelData, labelContainer, layer, layerCount) {
  }
  afterLabelsOverlap(labelShapes, labelData, labelContainer, layer, layerCount) {
  }
  getLabelAlign(vector, inside, angle2) {
    return {
      textAlign: "center",
      textBaseline: "middle"
    };
  }
  getLabelPosition(point5, vector, text2, style) {
    return getCircleLabelPosition(point5, vector, text2, style);
  }
};
CircleAxis.defaultAttributes = DEFAULT_AXIS_THEME, mixin(CircleAxis, CircleAxisMixin);

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/axis/animate/group-transition
var GroupTransition = class extends ACustomAnimate {
  constructor() {
    super(...arguments), this.mode = AnimateMode.NORMAL;
  }
  onBind() {
    const currentInnerView = this.target.getInnerView(), prevInnerView = this.target.getPrevInnerView();
    prevInnerView && (this._newElementAttrMap = {}, traverseGroup(currentInnerView, (el) => {
      var _a, _b, _c, _d, _e, _f;
      if ("group" !== el.type && el.id) {
        const oldEl = prevInnerView[el.id];
        if (oldEl) {
          if (!isEqual(el.attribute, oldEl.attribute)) {
            const newProps = cloneDeep(el.attribute);
            this._newElementAttrMap[el.id] = {
              state: "update",
              node: el,
              attrs: Object.assign(Object.assign({}, newProps), {
                opacity: null !== (_a = newProps.opacity) && void 0 !== _a ? _a : 1,
                fillOpacity: null !== (_b = newProps.fillOpacity) && void 0 !== _b ? _b : 1,
                strokeOpacity: null !== (_c = newProps.strokeOpacity) && void 0 !== _c ? _c : 1
              })
            }, el.setAttributes(oldEl.attribute);
          }
        } else {
          const finalOpacityAttrs = {
            opacity: null !== (_d = el.attribute.opacity) && void 0 !== _d ? _d : 1,
            fillOpacity: null !== (_e = el.attribute.fillOpacity) && void 0 !== _e ? _e : 1,
            strokeOpacity: null !== (_f = el.attribute.strokeOpacity) && void 0 !== _f ? _f : 1
          };
          this._newElementAttrMap[el.id] = {
            state: "enter",
            node: el,
            attrs: finalOpacityAttrs
          }, el.setAttributes({
            opacity: 0,
            fillOpacity: 0,
            strokeOpacity: 0
          });
        }
      }
    }));
  }
  onStart() {
    let duration = this.duration, easing = this.easing;
    Object.keys(this._newElementAttrMap).forEach((id2) => {
      var _a;
      const { node, attrs, state } = this._newElementAttrMap[id2];
      if ("enter" === state) {
        const { enter = {} } = null !== (_a = this.params) && void 0 !== _a ? _a : {};
        duration = isValidNumber_default(enter.duration) ? enter.duration : duration, easing = enter.easing ? enter.easing : easing;
      }
      "path" === node.type ? node.animate({
        interpolate: (key, ratio, from, to, nextAttributes) => "path" === key && (nextAttributes.path = interpolateString(from, to)(ratio), true)
      }).to(attrs, duration, easing) : node.animate().to(attrs, duration, easing);
    });
  }
  onUpdate(end, ratio, out) {
  }
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/axis/animate/group-fade
var GroupFadeIn = class extends ACustomAnimate {
  constructor(from, to, duration, easing) {
    super(null, null, duration, easing);
  }
  getEndProps() {
    return {};
  }
  onBind() {
    this.target.setTheme({
      common: {
        opacity: 0
      }
    });
  }
  onEnd() {
    this.target.setTheme({
      common: {
        opacity: 1
      }
    });
  }
  onUpdate(end, ratio, out) {
    this.target.setTheme({
      common: {
        opacity: ratio
      }
    });
  }
};

// http-url:https://unpkg.com/@visactor/vscale@0.18.9/es/type
var ScaleEnum;
!function(ScaleEnum2) {
  ScaleEnum2.Identity = "identity", ScaleEnum2.Linear = "linear", ScaleEnum2.Log = "log", ScaleEnum2.Pow = "pow", ScaleEnum2.Sqrt = "sqrt", ScaleEnum2.Symlog = "symlog", ScaleEnum2.Time = "time", ScaleEnum2.Quantile = "quantile", ScaleEnum2.Quantize = "quantize", ScaleEnum2.Threshold = "threshold", ScaleEnum2.Ordinal = "ordinal", ScaleEnum2.Point = "point", ScaleEnum2.Band = "band";
}(ScaleEnum || (ScaleEnum = {}));
var EnableScaleMap = {};
Object.values(ScaleEnum).forEach((v) => {
  EnableScaleMap[v] = true;
});
function isContinuous(type) {
  switch (type) {
    case ScaleEnum.Linear:
    case ScaleEnum.Log:
    case ScaleEnum.Pow:
    case ScaleEnum.Sqrt:
    case ScaleEnum.Symlog:
    case ScaleEnum.Time:
      return true;
    default:
      return false;
  }
}
function isValidScaleType(type) {
  return !!EnableScaleMap[type];
}
function isDiscrete(type) {
  switch (type) {
    case ScaleEnum.Ordinal:
    case ScaleEnum.Point:
    case ScaleEnum.Band:
      return true;
    default:
      return false;
  }
}

// http-url:https://unpkg.com/@visactor/vscale@0.18.9/es/utils/utils
function identity3(x) {
  return x;
}
var logNegative = (x) => -Math.log(-x);
var expNegative = (x) => -Math.exp(-x);
var pow10 = (x) => isFinite(x) ? Math.pow(10, x) : x < 0 ? 0 : x;
var powp = (base) => 10 === base ? pow10 : base === Math.E ? Math.exp : (x) => Math.pow(base, x);
var logp = (base) => base === Math.E ? Math.log : 10 === base ? Math.log10 : 2 === base ? Math.log2 : (base = Math.log(base), (x) => Math.log(x) / base);
var symlog = (c3) => (x) => Math.sign(x) * Math.log1p(Math.abs(x / c3));
var symexp = (c3) => (x) => Math.sign(x) * Math.expm1(Math.abs(x)) * c3;
function normalize2(a3, b) {
  if (a3 = Number(a3), b = Number(b), b -= a3)
    return (x) => (x - a3) / b;
  const result2 = Number.isNaN(b) ? NaN : 0.5;
  return () => result2;
}
function bimap(domain, range2, interpolate2) {
  const d0 = domain[0], d1 = domain[1], r0 = range2[0], r1 = range2[1];
  let d0Fuc, r0Fuc;
  return d1 < d0 ? (d0Fuc = normalize2(d1, d0), r0Fuc = interpolate2(r1, r0)) : (d0Fuc = normalize2(d0, d1), r0Fuc = interpolate2(r0, r1)), (x) => r0Fuc(d0Fuc(x));
}
function bandSpace(count, paddingInner, paddingOuter) {
  let space;
  return space = 1 === count ? count + 2 * paddingOuter : count - paddingInner + 2 * paddingOuter, count ? space > 0 ? space : 1 : 0;
}
function scaleWholeRangeSize(count, bandwidth, paddingInner, paddingOuter) {
  1 === paddingInner && (paddingInner = 0);
  return bandSpace(count, paddingInner, paddingOuter) * (bandwidth / (1 - paddingInner));
}
function calculateBandwidthFromWholeRangeSize(count, wholeSize, paddingInner, paddingOuter, round) {
  const space = bandSpace(count, paddingInner, paddingOuter);
  let step = wholeSize / Math.max(1, space || 1);
  round && (step = Math.floor(step));
  let bandwidth = step * (1 - paddingInner);
  return round && (bandwidth = Math.round(bandwidth)), bandwidth;
}
function calculateWholeRangeFromRangeFactor(range2, rangeFactor) {
  const k2 = (range2[1] - range2[0]) / (rangeFactor[1] - rangeFactor[0]), b = range2[0] - k2 * rangeFactor[0];
  return [b, k2 + b];
}
function polymap(domain, range2, interpolate2) {
  const j = Math.min(domain.length, range2.length) - 1, d = new Array(j), r = new Array(j);
  let i = -1;
  for (domain[j] < domain[0] && (domain = domain.slice().reverse(), range2 = range2.slice().reverse()); ++i < j; )
    d[i] = normalize2(domain[i], domain[i + 1]), r[i] = interpolate2(range2[i], range2[i + 1]);
  return function(x) {
    const i2 = bisect(domain, x, 1, j) - 1;
    return r[i2](d[i2](x));
  };
}
var nice = (domain, options) => {
  const newDomain = domain.slice();
  let startIndex = 0, endIndex = newDomain.length - 1, x05 = newDomain[startIndex], x14 = newDomain[endIndex];
  return x14 < x05 && ([startIndex, endIndex] = [endIndex, startIndex], [x05, x14] = [x14, x05]), newDomain[startIndex] = options.floor(x05), newDomain[endIndex] = options.ceil(x14), newDomain;
};
var niceNumber = (value, round = false) => {
  const exponent2 = Math.floor(Math.log10(value)), fraction = value / Math.pow(10, exponent2);
  let niceFraction;
  return niceFraction = round ? fraction < 1.5 ? 1 : fraction < 3 ? 2 : fraction < 7 ? 5 : 10 : fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10, niceFraction * Math.pow(10, exponent2);
};
var restrictNumber = (value, domain) => {
  let min3, max3;
  return domain[0] < domain[1] ? (min3 = domain[0], max3 = domain[1]) : (min3 = domain[1], max3 = domain[0]), Math.min(Math.max(value, min3), max3);
};

// http-url:https://unpkg.com/@visactor/vscale@0.18.9/es/base-scale
var BaseScale = class {
  constructor() {
    this._rangeFactorStart = null, this._rangeFactorEnd = null;
  }
  _calculateWholeRange(range2) {
    return this._wholeRange ? this._wholeRange : isValid_default(this._rangeFactorStart) && isValid_default(this._rangeFactorEnd) && 2 === range2.length ? (this._wholeRange = calculateWholeRangeFromRangeFactor(range2, [this._rangeFactorStart, this._rangeFactorEnd]), this._wholeRange) : range2;
  }
  rangeFactor(_, slience, clear) {
    return _ ? (2 === _.length && _.every((r) => r >= 0 && r <= 1) && (this._wholeRange = null, 0 === _[0] && 1 === _[1] ? (this._rangeFactorStart = null, this._rangeFactorEnd = null) : (this._rangeFactorStart = _[0], this._rangeFactorEnd = _[1])), this) : clear ? (this._wholeRange = null, this._rangeFactorStart = null, this._rangeFactorEnd = null, this) : isValid_default(this._rangeFactorStart) && isValid_default(this._rangeFactorEnd) ? [this._rangeFactorStart, this._rangeFactorEnd] : null;
  }
  rangeFactorStart(_, slience) {
    var _a;
    return isNil_default(_) ? this._rangeFactorStart : (_ >= 0 && _ <= 1 && (this._wholeRange = null, 0 !== _ || !isNil_default(this._rangeFactorEnd) && 1 !== this._rangeFactorEnd ? (this._rangeFactorStart = _, this._rangeFactorEnd = null !== (_a = this._rangeFactorEnd) && void 0 !== _a ? _a : 1) : (this._rangeFactorStart = null, this._rangeFactorEnd = null)), this);
  }
  rangeFactorEnd(_, slience) {
    var _a;
    return isNil_default(_) ? this._rangeFactorEnd : (_ >= 0 && _ <= 1 && (this._wholeRange = null, 0 !== _ || !isNil_default(this._rangeFactorStart) && 0 !== this._rangeFactorStart ? (this._rangeFactorEnd = _, this._rangeFactorStart = null !== (_a = this._rangeFactorStart) && void 0 !== _a ? _a : 0) : (this._rangeFactorStart = null, this._rangeFactorEnd = null)), this);
  }
  generateFishEyeTransform() {
    var _a;
    if (!this._fishEyeOptions)
      return void (this._fishEyeTransform = null);
    const { distortion = 2, radiusRatio = 0.1, radius } = this._fishEyeOptions, range2 = this.range(), first = range2[0], last2 = range2[range2.length - 1], min3 = Math.min(first, last2), max3 = Math.max(first, last2), focus = clamp_default(null !== (_a = this._fishEyeOptions.focus) && void 0 !== _a ? _a : 0, min3, max3), rangeRadius = isNil_default(radius) ? (max3 - min3) * radiusRatio : radius;
    let k0 = Math.exp(distortion);
    k0 = k0 / (k0 - 1) * rangeRadius;
    const k1 = distortion / rangeRadius;
    this._fishEyeTransform = (output) => {
      const delta = Math.abs(output - focus);
      if (delta >= rangeRadius)
        return output;
      if (delta <= 1e-6)
        return focus;
      const k2 = k0 * (1 - Math.exp(-delta * k1)) / delta * 0.75 + 0.25;
      return focus + (output - focus) * k2;
    };
  }
  unknown(_) {
    return arguments.length ? (this._unknown = _, this) : this._unknown;
  }
};

// http-url:https://unpkg.com/@visactor/vscale@0.18.9/es/ordinal-scale
var implicit = Symbol("implicit");
var OrdinalScale = class _OrdinalScale extends BaseScale {
  specified(_) {
    var _a;
    return _ ? (this._specified = Object.assign(null !== (_a = this._specified) && void 0 !== _a ? _a : {}, _), this) : Object.assign({}, this._specified);
  }
  _getSpecifiedValue(input) {
    if (this._specified)
      return this._specified[input];
  }
  constructor() {
    super(), this.type = ScaleEnum.Ordinal, this._index = /* @__PURE__ */ new Map(), this._domain = [], this._ordinalRange = [], this._unknown = implicit;
  }
  clone() {
    const s2 = new _OrdinalScale().domain(this._domain).range(this._ordinalRange).unknown(this._unknown);
    return this._specified && s2.specified(this._specified), s2;
  }
  calculateVisibleDomain(range2) {
    if (isValid_default(this._rangeFactorStart) && isValid_default(this._rangeFactorEnd) && 2 === range2.length) {
      return [this.invert(range2[0]), this.invert(range2[1])];
    }
    return this._domain;
  }
  scale(d) {
    const key = `${d}`, special = this._getSpecifiedValue(key);
    if (void 0 !== special)
      return special;
    let i = this._index.get(key);
    if (!i) {
      if (this._unknown !== implicit)
        return this._unknown;
      i = this._domain.push(d), this._index.set(key, i);
    }
    const output = this._ordinalRange[(i - 1) % this._ordinalRange.length];
    return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
  }
  invert(d) {
    let i = 0;
    for (; i < this._ordinalRange.length && this._ordinalRange[i] !== d; )
      i++;
    return this._domain[(i - 1) % this._domain.length];
  }
  domain(_) {
    if (!_)
      return this._domain.slice();
    this._domain = [], this._index = /* @__PURE__ */ new Map();
    for (const value of _) {
      const key = `${value}`;
      this._index.has(key) || this._index.set(key, this._domain.push(value));
    }
    return this;
  }
  range(_) {
    if (!_)
      return this._ordinalRange.slice();
    const nextRange = Array.from(_);
    return this._ordinalRange = nextRange, this;
  }
  index(x) {
    var _a;
    return this._index && null !== (_a = this._index.get(`${x}`)) && void 0 !== _a ? _a : -1;
  }
};

// http-url:https://unpkg.com/@visactor/vscale@0.18.9/es/utils/tick-sample-int
function ticks(start, stop, count, allowExcessive) {
  let reverse;
  const ticks4 = [];
  let step;
  if (stop = Math.floor(+stop), start = Math.floor(+start), !(count = Math.floor(+count)))
    return [];
  if (start === stop)
    return [start];
  if (reverse = stop < start) {
    const n = start;
    start = stop, stop = n;
  }
  let expectedCount = clamper(1, stop - start + 1)(count);
  if (step = Math.floor((stop - start + 1) / expectedCount), !allowExcessive)
    for (; Math.ceil((stop - start + 1) / step) > count && expectedCount > 1; )
      expectedCount -= 1, step = Math.floor((stop - start) / expectedCount);
  let ptr = start;
  for (; ptr <= stop; )
    ticks4.push(ptr), ptr += step;
  return reverse && ticks4.reverse(), ticks4;
}
function stepTicks(start, stop, step) {
  const ticks4 = [];
  let reverse;
  if (stop = Math.floor(+stop), start = Math.floor(+start), step = clamper(1, stop - start + 1)(Math.floor(+step)), reverse = stop < start) {
    const n = start;
    start = stop, stop = n;
  }
  let ptr = start;
  for (; ptr <= stop; )
    ticks4.push(ptr), ptr += step;
  return reverse && ticks4.reverse(), ticks4;
}

// http-url:https://unpkg.com/@visactor/vscale@0.18.9/es/band-scale
var BandScale = class _BandScale extends OrdinalScale {
  constructor(slience) {
    super(), this.type = ScaleEnum.Band, this._range = [0, 1], this._step = void 0, this._bandwidth = void 0, this._isFixed = false, this._round = false, this._paddingInner = 0, this._paddingOuter = 0, this._align = 0.5, this._unknown = void 0, delete this.unknown, this.rescale(slience);
  }
  rescale(slience, changeProperty) {
    if (slience)
      return this;
    this._wholeRange = null;
    const wholeRange = this._calculateWholeRange(this._range, changeProperty), n = super.domain().length, reverse = wholeRange[1] < wholeRange[0];
    let start = wholeRange[Number(reverse) - 0];
    const stop = wholeRange[1 - Number(reverse)], space = bandSpace(n, this._paddingInner, this._paddingOuter);
    return this._step = (stop - start) / Math.max(1, space || 1), this._round && (this._step = Math.floor(this._step)), start += (stop - start - this._step * (n - this._paddingInner)) * this._align, this.isBandwidthFixed() || (this._bandwidth = this._step * (1 - this._paddingInner)), this._round && (start = Math.round(start), this.isBandwidthFixed() || (this._bandwidth = Math.round(this._bandwidth))), this._bandRangeState = {
      reverse,
      start: reverse ? start + this._step * (n - 1) : start,
      count: n
    }, this.generateFishEyeTransform(), this;
  }
  scale(d) {
    if (!this._bandRangeState)
      return;
    const key = `${d}`, special = this._getSpecifiedValue(key);
    if (void 0 !== special)
      return special;
    let i = this._index.get(key);
    if (!i) {
      if (this._unknown !== implicit)
        return this._unknown;
      i = this._domain.push(d), this._index.set(key, i);
    }
    const { count, start, reverse } = this._bandRangeState, output = start + (reverse ? -1 : 1) * ((i - 1) % count) * this._step;
    return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
  }
  _calculateWholeRange(range2, changeProperty) {
    if (this._wholeRange)
      return this._wholeRange;
    if ((this._minBandwidth || this._maxBandwidth) && !this._isBandwidthFixedByUser()) {
      let wholeSize;
      if (isValid_default(this._rangeFactorStart) && isValid_default(this._rangeFactorEnd) && 2 === range2.length) {
        const wholeRange = calculateWholeRangeFromRangeFactor(range2, [this._rangeFactorStart, this._rangeFactorEnd]);
        wholeSize = Math.abs(wholeRange[1] - wholeRange[0]);
      } else
        wholeSize = Math.abs(range2[1] - range2[0]);
      const autoBandwidth = calculateBandwidthFromWholeRangeSize(super.domain().length, wholeSize, this._paddingInner, this._paddingOuter, this._round);
      autoBandwidth < this._minBandwidth ? (this._bandwidth = this._minBandwidth, this._isFixed = true) : autoBandwidth > this._maxBandwidth ? (this._bandwidth = this._maxBandwidth, this._isFixed = true) : (this._bandwidth = autoBandwidth, this._isFixed = false);
    }
    if (this.isBandwidthFixed()) {
      const wholeLength = scaleWholeRangeSize(super.domain().length, this._bandwidth, this._paddingInner, this._paddingOuter) * Math.sign(range2[1] - range2[0]), rangeFactorSize = Math.min((range2[1] - range2[0]) / wholeLength, 1);
      if (isValid_default(this._rangeFactorStart) && isValid_default(this._rangeFactorEnd)) {
        if (wholeLength > 0) {
          const r0 = range2[0] - wholeLength * this._rangeFactorStart, r1 = r0 + wholeLength;
          this._wholeRange = [r0, r1];
        } else {
          const r1 = range2[1] + wholeLength * (1 - this._rangeFactorEnd), r0 = r1 - wholeLength;
          this._wholeRange = [r0, r1];
        }
        const canAlignStart = this._rangeFactorStart + rangeFactorSize <= 1, canAlignEnd = this._rangeFactorEnd - rangeFactorSize >= 0;
        "rangeFactorStart" === changeProperty && canAlignStart ? this._rangeFactorEnd = this._rangeFactorStart + rangeFactorSize : "rangeFactorEnd" === changeProperty && canAlignEnd ? this._rangeFactorStart = this._rangeFactorEnd - rangeFactorSize : range2[0] <= range2[1] ? canAlignStart ? this._rangeFactorEnd = this._rangeFactorStart + rangeFactorSize : canAlignEnd ? this._rangeFactorStart = this._rangeFactorEnd - rangeFactorSize : (this._rangeFactorStart = 0, this._rangeFactorEnd = rangeFactorSize) : canAlignEnd ? this._rangeFactorStart = this._rangeFactorEnd - rangeFactorSize : canAlignStart ? this._rangeFactorEnd = this._rangeFactorStart + rangeFactorSize : (this._rangeFactorStart = 1 - rangeFactorSize, this._rangeFactorEnd = 1);
      } else
        this._rangeFactorStart = 0, this._rangeFactorEnd = rangeFactorSize, this._wholeRange = [range2[0], range2[0] + wholeLength];
      return this._wholeRange;
    }
    return super._calculateWholeRange(range2);
  }
  calculateWholeRangeSize() {
    const wholeRange = this._calculateWholeRange(this._range);
    return Math.abs(wholeRange[1] - wholeRange[0]);
  }
  calculateVisibleDomain(range2) {
    const domain = this._domain;
    if (isValid_default(this._rangeFactorStart) && isValid_default(this._rangeFactorEnd) && domain.length) {
      const d0 = this._getInvertIndex(range2[0]), d1 = this._getInvertIndex(range2[1]);
      return domain.slice(Math.min(d0, d1), Math.max(d0, d1) + 1);
    }
    return domain;
  }
  domain(_, slience) {
    return _ ? (super.domain(_), this.rescale(slience)) : super.domain();
  }
  range(_, slience) {
    return _ ? (this._range = [toNumber(_[0]), toNumber(_[1])], this.rescale(slience)) : this._range;
  }
  rangeRound(_, slience) {
    return this._range = [toNumber(_[0]), toNumber(_[1])], this._round = true, this.rescale(slience);
  }
  ticks(count = 10) {
    const d = this.calculateVisibleDomain(this._range);
    if (-1 === count)
      return d;
    return ticks(0, d.length - 1, count, false).map((i) => d[i]);
  }
  tickData(count = 10) {
    return this.ticks(count).map((tick, index) => ({
      index,
      tick,
      value: (this.scale(tick) - this._range[0] + this._bandwidth / 2) / (this._range[1] - this._range[0])
    }));
  }
  forceTicks(count = 10) {
    const d = this.calculateVisibleDomain(this._range);
    return ticks(0, d.length - 1, count, true).filter((i) => i < d.length).map((i) => d[i]);
  }
  stepTicks(step) {
    const d = this.calculateVisibleDomain(this._range);
    return stepTicks(0, d.length - 1, step).map((i) => d[i]);
  }
  _getInvertIndex(d) {
    let i = 0;
    const halfStep = this.step() / 2, halfBandwidth = this.bandwidth() / 2, len = this._domain.length, range2 = this.range(), reverse = range2[0] > range2[range2.length - 1];
    for (i = 0; i < len; i++) {
      const r = this.scale(this._domain[i]) + halfBandwidth;
      if (0 === i && (!reverse && !isGreater(d, r + halfStep) || reverse && !isLess(d, r - halfStep)))
        break;
      if (i === len - 1)
        break;
      if (!isLess(d, r - halfStep) && !isGreater(d, r + halfStep))
        break;
    }
    return i >= 0 && i <= len - 1 ? i : len - 1;
  }
  invert(d) {
    return this._domain[this._getInvertIndex(d)];
  }
  padding(p, slience) {
    return void 0 !== p ? (this._paddingOuter = Math.max(0, Math.min(Array.isArray(p) ? Math.min.apply(null, p) : p)), this._paddingInner = this._paddingOuter, this.rescale(slience)) : this._paddingInner;
  }
  paddingInner(_, slience) {
    return void 0 !== _ ? (this._paddingInner = Math.max(0, Math.min(1, _)), this.rescale(slience)) : this._paddingInner;
  }
  paddingOuter(_, slience) {
    return void 0 !== _ ? (this._paddingOuter = Math.max(0, Math.min(1, _)), this.rescale(slience)) : this._paddingOuter;
  }
  step() {
    return this._step;
  }
  round(_, slience) {
    return void 0 !== _ ? (this._round = _, this.rescale(slience)) : this._round;
  }
  align(_, slience) {
    return void 0 !== _ ? (this._align = Math.max(0, Math.min(1, _)), this.rescale(slience)) : this._align;
  }
  rangeFactor(_, slience) {
    return _ ? (super.rangeFactor(_), this.rescale(slience)) : super.rangeFactor();
  }
  rangeFactorStart(_, slience) {
    return isNil_default(_) ? super.rangeFactorStart() : (super.rangeFactorStart(_), this.rescale(slience, "rangeFactorStart"));
  }
  rangeFactorEnd(_, slience) {
    return isNil_default(_) ? super.rangeFactorEnd() : (super.rangeFactorEnd(_), this.rescale(slience, "rangeFactorEnd"));
  }
  bandwidth(_, slience) {
    return _ ? ("auto" === _ ? (this._bandwidth = void 0, this._isFixed = false) : (this._bandwidth = _, this._isFixed = true), this._userBandwidth = _, this.rescale(slience)) : this._bandwidth;
  }
  maxBandwidth(_, slience) {
    return _ ? (this._maxBandwidth = "auto" === _ ? void 0 : _, this.rescale(slience)) : this._maxBandwidth;
  }
  minBandwidth(_, slience) {
    return _ ? (this._minBandwidth = "auto" === _ ? void 0 : _, this.rescale(slience)) : this._minBandwidth;
  }
  fishEye(options, slience, clear) {
    return options || clear ? (this._fishEyeOptions = options, this._fishEyeTransform = null, this.rescale(slience)) : this._fishEyeOptions;
  }
  isBandwidthFixed() {
    return this._isFixed && !!this._bandwidth;
  }
  _isBandwidthFixedByUser() {
    return this._isFixed && this._userBandwidth && isNumber_default(this._userBandwidth);
  }
  clone() {
    var _a, _b, _c;
    return new _BandScale(true).domain(this._domain, true).range(this._range, true).round(this._round, true).paddingInner(this._paddingInner, true).paddingOuter(this._paddingOuter, true).align(this._align, true).bandwidth(null !== (_a = this._userBandwidth) && void 0 !== _a ? _a : "auto", true).maxBandwidth(null !== (_b = this._maxBandwidth) && void 0 !== _b ? _b : "auto", true).minBandwidth(null !== (_c = this._maxBandwidth) && void 0 !== _c ? _c : "auto");
  }
};

// http-url:https://unpkg.com/@visactor/vscale@0.18.9/es/utils/interpolate
var { interpolateRgb: interpolateRgb2 } = color_exports;
function interpolate(a3, b) {
  const t = typeof b;
  let c3;
  if (isNil_default(b) || "boolean" === t)
    return () => b;
  if ("number" === t)
    return interpolateNumber(a3, b);
  if ("string" === t) {
    if (c3 = color_exports.Color.parseColorString(b)) {
      const rgb2 = interpolateRgb2(color_exports.Color.parseColorString(a3), c3);
      return (t2) => rgb2(t2).formatRgb();
    }
    return interpolateNumber(Number(a3), Number(b));
  }
  return b instanceof color_exports.RGB ? interpolateRgb2(a3, b) : b instanceof color_exports.Color ? interpolateRgb2(a3.color, b.color) : b instanceof Date ? interpolateDate(a3, b) : interpolateNumber(Number(a3), Number(b));
}

// http-url:https://unpkg.com/@visactor/vscale@0.18.9/es/continuous-scale
var ContinuousScale = class extends BaseScale {
  constructor(transformer2 = identity3, untransformer = identity3) {
    super(), this._unknown = void 0, this.transformer = transformer2, this.untransformer = untransformer, this._forceAlign = true, this._domain = [0, 1], this._range = [0, 1], this._clamp = identity3, this._piecewise = bimap, this._interpolate = interpolate;
  }
  calculateVisibleDomain(range2) {
    var _a;
    if (isValid_default(this._rangeFactorStart) && isValid_default(this._rangeFactorEnd) && 2 === range2.length) {
      return [this.invert(range2[0]), this.invert(range2[1])];
    }
    return null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain;
  }
  fishEye(options, slience, clear) {
    return options || clear ? (this._fishEyeOptions = options, this._fishEyeTransform = null, this.rescale(slience)) : this._fishEyeOptions;
  }
  scale(x) {
    var _a;
    if (x = Number(x), Number.isNaN(x) || this._domainValidator && !this._domainValidator(x))
      return this._unknown;
    this._output || (this._output = this._piecewise((null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).map(this.transformer), this._calculateWholeRange(this._range), this._interpolate));
    const output = this._output(this.transformer(this._clamp(x)));
    return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
  }
  invert(y) {
    var _a;
    return this._input || (this._input = this._piecewise(this._calculateWholeRange(this._range), (null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).map(this.transformer), interpolateNumber)), this._clamp(this.untransformer(this._input(y)));
  }
  domain(_, slience) {
    var _a;
    if (!_)
      return (null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).slice();
    this._domainValidator = null, this._niceType = null, this._niceDomain = null;
    const nextDomain = Array.from(_, toNumber);
    return this._domain = nextDomain, this.rescale(slience);
  }
  range(_, slience) {
    if (!_)
      return this._range.slice();
    const nextRange = Array.from(_);
    return this._range = nextRange, this.rescale(slience);
  }
  rangeRound(_, slience) {
    const nextRange = Array.from(_);
    return this._range = nextRange, this._interpolate = interpolateNumberRound, this.rescale(slience);
  }
  rescale(slience) {
    var _a;
    if (slience)
      return this;
    const domain = null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain, domainLength = domain.length, rangeLength = this._range.length;
    let n = Math.min(domainLength, rangeLength);
    if (domainLength && domainLength < rangeLength && this._forceAlign) {
      const deltaStep = rangeLength - domainLength + 1, last2 = domain[domainLength - 1], delta = domainLength >= 2 ? (last2 - domain[domainLength - 2]) / deltaStep : 0;
      for (let i = 1; i <= deltaStep; i++)
        domain[domainLength - 2 + i] = last2 - delta * (deltaStep - i);
      n = rangeLength;
    }
    return this._autoClamp && (this._clamp = clamper(domain[0], domain[n - 1])), this._piecewise = n > 2 ? polymap : bimap, this._output = this._input = null, this._wholeRange = null, this.generateFishEyeTransform(), this;
  }
  clamp(_, f, slience) {
    return arguments.length ? (f ? (this._autoClamp = false, this._clamp = f) : (this._autoClamp = !!_, this._clamp = _ ? void 0 : identity3), this.rescale(slience)) : this._clamp !== identity3;
  }
  interpolate(_, slience) {
    return arguments.length ? (this._interpolate = _, this.rescale(slience)) : this._interpolate;
  }
  ticks(count = 10) {
    return [];
  }
  tickData(count = 10) {
    const ticks4 = this.ticks(count);
    return (null != ticks4 ? ticks4 : []).map((tick, index) => ({
      index,
      tick,
      value: (this.scale(tick) - this._range[0]) / (this._range[1] - this._range[0])
    }));
  }
  rangeFactor(_, slience) {
    return _ ? (super.rangeFactor(_), this._output = this._input = null, this) : super.rangeFactor();
  }
  rangeFactorStart(_, slience) {
    return isNil_default(_) ? super.rangeFactorStart() : (super.rangeFactorStart(_), this._output = this._input = null, this);
  }
  rangeFactorEnd(_, slience) {
    return isNil_default(_) ? super.rangeFactorEnd() : (super.rangeFactorEnd(_), this._output = this._input = null, this);
  }
  forceAlignDomainRange(forceAlign) {
    return arguments.length ? (this._forceAlign = forceAlign, this) : this._forceAlign;
  }
};

// http-url:https://unpkg.com/@visactor/vscale@0.18.9/es/utils/tick-sample
var e102 = Math.sqrt(50);
var e52 = Math.sqrt(10);
var e22 = Math.sqrt(2);
var niceNumbers = [1, 2, 5, 10];
var calculateTicksOfSingleValue = (value, tickCount, noDecimals) => {
  let step = 1, start = value;
  const middleIndex = Math.floor((tickCount - 1) / 2), absVal = Math.abs(value);
  return value >= 0 && value <= Number.MIN_VALUE ? start = 0 : value < 0 && value >= -Number.MIN_VALUE ? start = -(tickCount - 1) : !noDecimals && absVal < 1 ? step = getNickStep(absVal).step : (noDecimals || absVal > 1) && (start = Math.floor(value) - middleIndex * step), step > 0 ? (value > 0 ? start = Math.max(start, 0) : value < 0 && (start = Math.min(start, -(tickCount - 1) * step)), range(0, tickCount).map((index) => start + index * step)) : value > 0 ? calculateTicksByStep(0, -(tickCount - 1) / step, step) : calculateTicksByStep((tickCount - 1) / step, 0, step);
};
var d3Ticks = memoize((start, stop, count, options) => {
  let reverse, n, ticks4, step, i = -1;
  if (count = +count, (start = +start) === (stop = +stop))
    return [start];
  if (Math.abs(start - stop) <= Number.MIN_VALUE && count > 0)
    return [start];
  if ((reverse = stop < start) && (n = start, start = stop, stop = n), step = tickIncrement2(start, stop, count).step, !isFinite(step))
    return [];
  if (step > 0) {
    let r0 = Math.round(start / step), r1 = Math.round(stop / step);
    for (r0 * step < start && ++r0, r1 * step > stop && --r1, ticks4 = new Array(n = r1 - r0 + 1); ++i < n; )
      ticks4[i] = (r0 + i) * step;
  } else if (step < 0 && (null == options ? void 0 : options.noDecimals)) {
    step = 1;
    const r0 = Math.ceil(start), r1 = Math.floor(stop);
    if (!(r0 <= r1))
      return [];
    for (ticks4 = new Array(n = r1 - r0 + 1); ++i < n; )
      ticks4[i] = r0 + i;
  } else {
    step = -step;
    let r0 = Math.round(start * step), r1 = Math.round(stop * step);
    for (r0 / step < start && ++r0, r1 / step > stop && --r1, ticks4 = new Array(n = r1 - r0 + 1); ++i < n; )
      ticks4[i] = (r0 + i) / step;
  }
  return reverse && ticks4.reverse(), ticks4;
});
var calculateTicksByStep = (start, stop, step) => {
  let n, ticks4, i = -1;
  if (step > 0) {
    let r0 = Math.floor(start / step), r1 = Math.ceil(stop / step);
    for ((r0 + 1) * step < start && ++r0, (r1 - 1) * step > stop && --r1, ticks4 = new Array(n = r1 - r0 + 1); ++i < n; )
      ticks4[i] = (r0 + i) * step;
  } else {
    step = -step;
    let r0 = Math.floor(start * step), r1 = Math.ceil(stop * step);
    for ((r0 + 1) / step < start && ++r0, (r1 - 1) / step > stop && --r1, ticks4 = new Array(n = r1 - r0 + 1); ++i < n; )
      ticks4[i] = (r0 + i) / step;
  }
  return ticks4;
};
var appendTicksToCount = (ticks4, count, step) => {
  let n;
  const firstTick = ticks4[0], lastTick = ticks4[ticks4.length - 1], appendCount = count - ticks4.length;
  if (lastTick <= 0) {
    const headTicks2 = [];
    for (n = appendCount; n >= 1; n--)
      headTicks2.push(firstTick - n * step);
    return headTicks2.concat(ticks4);
  }
  if (firstTick >= 0) {
    for (n = 1; n <= appendCount; n++)
      ticks4.push(lastTick + n * step);
    return ticks4;
  }
  let headTicks = [];
  const tailTicks = [];
  for (n = 1; n <= appendCount; n++)
    n % 2 == 0 ? headTicks = [firstTick - Math.floor(n / 2) * step].concat(headTicks) : tailTicks.push(lastTick + Math.ceil(n / 2) * step);
  return headTicks.concat(ticks4).concat(tailTicks);
};
var ticks2 = memoize((start, stop, count, options) => {
  let reverse, ticks4, n;
  if (count = +count, (start = +start) === (stop = +stop))
    return calculateTicksOfSingleValue(start, count, null == options ? void 0 : options.noDecimals);
  if (Math.abs(start - stop) <= Number.MIN_VALUE && count > 0)
    return calculateTicksOfSingleValue(start, count, null == options ? void 0 : options.noDecimals);
  (reverse = stop < start) && (n = start, start = stop, stop = n);
  const stepRes = tickIncrement2(start, stop, count);
  let step = stepRes.step;
  if (!isFinite(step))
    return [];
  if (step > 0) {
    let cur = 1;
    const { power, gap } = stepRes, delatStep = 10 === gap ? 2 * 10 ** power : 1 * 10 ** power;
    for (; cur <= 5 && (ticks4 = calculateTicksByStep(start, stop, step), ticks4.length > count + 1) && count > 2; )
      step += delatStep, cur += 1;
    count > 2 && ticks4.length < count - 1 && (ticks4 = appendTicksToCount(ticks4, count, step));
  } else
    (null == options ? void 0 : options.noDecimals) && step < 0 && (step = 1), ticks4 = calculateTicksByStep(start, stop, step);
  return reverse && ticks4.reverse(), ticks4;
});
var getNickStep = (step) => {
  const power = Math.floor(Math.log(step) / Math.LN10), error3 = step / 10 ** power;
  let gap = niceNumbers[0];
  return error3 >= e102 ? gap = niceNumbers[3] : error3 >= e52 ? gap = niceNumbers[2] : error3 >= e22 && (gap = niceNumbers[1]), power >= 0 ? {
    step: gap * 10 ** power,
    gap,
    power
  } : {
    step: -(10 ** -power) / gap,
    gap,
    power
  };
};
function tickIncrement2(start, stop, count) {
  const step = (stop - start) / Math.max(0, count);
  return getNickStep(step);
}
function forceTicks(start, stop, count) {
  let step;
  if (count = +count, (start = +start) === (stop = +stop) && count > 0)
    return [start];
  if (count <= 0 || 0 === (step = forceTickIncrement(start, stop, count)) || !isFinite(step))
    return [];
  const ticks4 = new Array(count);
  for (let i = 0; i < count; i++)
    ticks4[i] = start + i * step;
  return ticks4;
}
function forceTickIncrement(start, stop, count) {
  return (stop - start) / Math.max(1, count - 1);
}
function stepTicks2(start, stop, step) {
  let n, reverse, i = -1;
  if (step = +step, (reverse = (stop = +stop) < (start = +start)) && (n = start, start = stop, stop = n), !isFinite(step) || stop - start <= step)
    return [start];
  const count = Math.floor((stop - start) / step + 1), ticks4 = new Array(count);
  for (; ++i < count; )
    ticks4[i] = start + i * step;
  return reverse && ticks4.reverse(), ticks4;
}
function niceLinear(d, count = 10) {
  let prestep, step, i0 = 0, i1 = d.length - 1, start = d[i0], stop = d[i1], maxIter = 10;
  for (stop < start && (step = start, start = stop, stop = step, step = i0, i0 = i1, i1 = step); maxIter-- > 0; ) {
    if (step = tickIncrement2(start, stop, count).step, step === prestep)
      return d[i0] = start, d[i1] = stop, d;
    if (step > 0)
      start = Math.floor(start / step) * step, stop = Math.ceil(stop / step) * step;
    else {
      if (!(step < 0))
        break;
      start = Math.ceil(start * step) / step, stop = Math.floor(stop * step) / step;
    }
    prestep = step;
  }
}
function parseNiceOptions(originalDomain, option) {
  const hasForceMin = isNumber_default(option.forceMin), hasForceMax = isNumber_default(option.forceMax);
  let niceType = null;
  const niceMinMax = [];
  let niceDomain = null;
  const domainValidator = hasForceMin && hasForceMax ? (x) => x >= option.forceMin && x <= option.forceMax : hasForceMin ? (x) => x >= option.forceMin : hasForceMax ? (x) => x <= option.forceMax : null;
  return hasForceMin ? niceMinMax[0] = option.forceMin : isNumber_default(option.min) && option.min <= Math.min(originalDomain[0], originalDomain[originalDomain.length - 1]) && (niceMinMax[0] = option.min), hasForceMax ? niceMinMax[1] = option.forceMax : isNumber_default(option.max) && option.max >= Math.max(originalDomain[0], originalDomain[originalDomain.length - 1]) && (niceMinMax[1] = option.max), isNumber_default(niceMinMax[0]) && isNumber_default(niceMinMax[1]) ? (niceDomain = originalDomain.slice(), niceDomain[0] = niceMinMax[0], niceDomain[niceDomain.length - 1] = niceMinMax[1]) : niceType = isNumber_default(niceMinMax[0]) || isNumber_default(niceMinMax[1]) ? isNumber_default(niceMinMax[0]) ? "max" : "min" : "all", {
    niceType,
    niceDomain,
    niceMinMax,
    domainValidator
  };
}
var fixPrecision2 = (start, stop, value) => Math.abs(stop - start) < 1 ? +value.toFixed(1) : Math.round(+value);
var d3TicksForLog = memoize((start, stop, count, base, transformer2, untransformer, options) => {
  let u = start, v = stop;
  const r = v < u;
  r && ([u, v] = [v, u]);
  let k2, t, i = transformer2(u), j = transformer2(v), z = [];
  if (!(base % 1) && j - i < count) {
    if (i = Math.floor(i), j = Math.ceil(j), u > 0) {
      for (; i <= j; ++i)
        for (k2 = 1; k2 < base; ++k2)
          if (t = i < 0 ? k2 / untransformer(-i) : k2 * untransformer(i), !(t < u)) {
            if (t > v)
              break;
            z.push(t);
          }
    } else
      for (; i <= j; ++i)
        for (k2 = base - 1; k2 >= 1; --k2)
          if (t = i > 0 ? k2 / untransformer(-i) : k2 * untransformer(i), !(t < u)) {
            if (t > v)
              break;
            z.push(t);
          }
    2 * z.length < count && (z = ticks2(u, v, count));
  } else
    z = ticks2(i, j, Math.min(j - i, count)).map(untransformer);
  return z = z.filter((t2) => 0 !== t2), (null == options ? void 0 : options.noDecimals) && (z = Array.from(new Set(z.map((t2) => Math.floor(t2))))), r ? z.reverse() : z;
});
var ticksBaseTransform = memoize((start, stop, count, base, transformer2, untransformer) => {
  const ticksResult = [], ticksMap = {}, startExp = transformer2(start), stopExp = transformer2(stop);
  let ticksExp = [];
  if (Number.isInteger(base))
    ticksExp = ticks2(startExp, stopExp, count);
  else {
    const stepExp = (stopExp - startExp) / (count - 1);
    for (let i = 0; i < count; i++)
      ticksExp.push(startExp + i * stepExp);
  }
  return ticksExp.forEach((tl) => {
    const power = untransformer(tl), nicePower = Number.isInteger(base) ? fixPrecision2(start, stop, power) : fixPrecision2(start, stop, niceNumber(power)), scopePower = fixPrecision2(start, stop, restrictNumber(nicePower, [start, stop]));
    !ticksMap[scopePower] && !isNaN(scopePower) && ticksExp.length > 1 && (ticksMap[scopePower] = 1, ticksResult.push(scopePower));
  }), ticksResult;
});
var forceTicksBaseTransform = memoize((start, stop, count, transformer2, untransformer) => forceTicks(transformer2(start), transformer2(stop), count).map((te) => niceNumber(untransformer(te))));
var forceStepTicksBaseTransform = memoize((start, stop, step, transformer2, untransformer) => stepTicks2(transformer2(start), transformer2(stop), step).map((te) => niceNumber(untransformer(te))));

// http-url:https://unpkg.com/@visactor/vscale@0.18.9/es/linear-scale
var LinearScale = class _LinearScale extends ContinuousScale {
  constructor() {
    super(...arguments), this.type = ScaleEnum.Linear;
  }
  clone() {
    return new _LinearScale().domain(this._domain, true).range(this._range, true).unknown(this._unknown).clamp(this.clamp(), null, true).interpolate(this._interpolate);
  }
  tickFormat() {
    return () => {
    };
  }
  d3Ticks(count = 10, options) {
    const d = this.calculateVisibleDomain(this._range);
    return d3Ticks(d[0], d[d.length - 1], count, options);
  }
  ticks(count = 10, options) {
    var _a;
    if (isValid_default(this._rangeFactorStart) && isValid_default(this._rangeFactorEnd) && (this._rangeFactorStart > 0 || this._rangeFactorEnd < 1) && 2 === this._range.length || !this._niceType)
      return this.d3Ticks(count, options);
    const curNiceDomain = null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain, originalDomain = this._domain, start = curNiceDomain[0], stop = curNiceDomain[curNiceDomain.length - 1];
    let ticksResult = ticks2(originalDomain[0], originalDomain[originalDomain.length - 1], count, options);
    if (!ticksResult.length)
      return ticksResult;
    if (this._domainValidator)
      ticksResult = ticksResult.filter(this._domainValidator);
    else if ((ticksResult[0] !== start || ticksResult[ticksResult.length - 1] !== stop) && this._niceType) {
      const newNiceDomain = curNiceDomain.slice();
      if ("all" === this._niceType ? (newNiceDomain[0] = ticksResult[0], newNiceDomain[newNiceDomain.length - 1] = ticksResult[ticksResult.length - 1], this._niceDomain = newNiceDomain, this.rescale()) : "min" === this._niceType && ticksResult[0] !== start ? (newNiceDomain[0] = ticksResult[0], this._niceDomain = newNiceDomain, this.rescale()) : "max" === this._niceType && ticksResult[ticksResult.length - 1] !== stop && (newNiceDomain[newNiceDomain.length - 1] = ticksResult[ticksResult.length - 1], this._niceDomain = newNiceDomain, this.rescale()), "all" !== this._niceType) {
        const min3 = Math.min(newNiceDomain[0], newNiceDomain[newNiceDomain.length - 1]), max3 = Math.max(newNiceDomain[0], newNiceDomain[newNiceDomain.length - 1]);
        ticksResult = ticksResult.filter((entry) => entry >= min3 && entry <= max3);
      }
    }
    return ticksResult;
  }
  forceTicks(count = 10) {
    const d = this.calculateVisibleDomain(this._range);
    return forceTicks(d[0], d[d.length - 1], count);
  }
  stepTicks(step) {
    const d = this.calculateVisibleDomain(this._range);
    return stepTicks2(d[0], d[d.length - 1], step);
  }
  nice(count = 10, option) {
    var _a, _b;
    const originalDomain = this._domain;
    let niceMinMax = [];
    if (option) {
      const res = parseNiceOptions(originalDomain, option);
      if (niceMinMax = res.niceMinMax, this._domainValidator = res.domainValidator, this._niceType = res.niceType, res.niceDomain)
        return this._niceDomain = res.niceDomain, this.rescale(), this;
    } else
      this._niceType = "all";
    if (this._niceType) {
      const niceDomain = niceLinear(originalDomain.slice(), count);
      "min" === this._niceType ? niceDomain[niceDomain.length - 1] = null !== (_a = niceMinMax[1]) && void 0 !== _a ? _a : niceDomain[niceDomain.length - 1] : "max" === this._niceType && (niceDomain[0] = null !== (_b = niceMinMax[0]) && void 0 !== _b ? _b : niceDomain[0]), this._niceDomain = niceDomain, this.rescale();
    }
    return this;
  }
  niceMin(count = 10) {
    this._niceType = "min";
    const maxD = this._domain[this._domain.length - 1], niceDomain = niceLinear(this.domain(), count);
    return niceDomain && (niceDomain[niceDomain.length - 1] = maxD, this._niceDomain = niceDomain, this.rescale()), this;
  }
  niceMax(count = 10) {
    this._niceType = "max";
    const minD = this._domain[0], niceDomain = niceLinear(this._domain.slice(), count);
    return niceDomain && (niceDomain[0] = minD, this._niceDomain = niceDomain, this.rescale()), this;
  }
};

// http-url:https://unpkg.com/@visactor/vscale@0.18.9/es/log-scale
function reflect(f) {
  return (x) => -f(-x);
}
function limitPositiveZero(min3 = Number.EPSILON) {
  return (x) => Math.max(x, min3);
}
function limitNegativeZero(min3 = Number.EPSILON) {
  return (x) => Math.min(x, -min3);
}
var LogScale = class _LogScale extends ContinuousScale {
  constructor() {
    super(logp(10), powp(10)), this.type = ScaleEnum.Log, this._limit = limitPositiveZero(), this._logs = this.transformer, this._pows = this.untransformer, this._domain = [1, 10], this._base = 10;
  }
  clone() {
    return new _LogScale().domain(this._domain, true).range(this._range, true).unknown(this._unknown).clamp(this.clamp(), null, true).interpolate(this._interpolate, true).base(this._base);
  }
  rescale(slience) {
    var _a;
    if (slience)
      return this;
    super.rescale();
    const logs = logp(this._base), pows = powp(this._base);
    return (null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain)[0] < 0 ? (this._logs = reflect(logs), this._pows = reflect(pows), this._limit = limitNegativeZero(), this.transformer = logNegative, this.untransformer = expNegative) : (this._logs = logs, this._pows = pows, this._limit = limitPositiveZero(), this.transformer = this._logs, this.untransformer = pows), this;
  }
  scale(x) {
    var _a;
    if (x = Number(x), Number.isNaN(x) || this._domainValidator && !this._domainValidator(x))
      return this._unknown;
    this._output || (this._output = this._piecewise((null !== (_a = this._niceDomain) && void 0 !== _a ? _a : this._domain).map(this._limit).map(this.transformer), this._calculateWholeRange(this._range), this._interpolate));
    const output = this._output(this.transformer(this._limit(this._clamp(x))));
    return this._fishEyeTransform ? this._fishEyeTransform(output) : output;
  }
  base(_, slience) {
    return arguments.length ? (this._base = _, this.rescale(slience)) : this._base;
  }
  tickFormat() {
    return identity3;
  }
  d3Ticks(count = 10, options) {
    const d = this.domain(), u = this._limit(d[0]), v = this._limit(d[d.length - 1]);
    return d3TicksForLog(u, v, count, this._base, this.transformer, this.untransformer, options);
  }
  ticks(count = 10) {
    const d = this.calculateVisibleDomain(this._range);
    return ticksBaseTransform(this._limit(d[0]), this._limit(d[d.length - 1]), count, this._base, this.transformer, this.untransformer);
  }
  forceTicks(count = 10) {
    const d = this.calculateVisibleDomain(this._range);
    return forceTicksBaseTransform(d[0], d[d.length - 1], count, this.transformer, this.untransformer);
  }
  stepTicks(step) {
    const d = this.calculateVisibleDomain(this._range);
    return forceTicksBaseTransform(this._limit(d[0]), this._limit(d[d.length - 1]), step, this.transformer, this.untransformer);
  }
  nice(count = 10, option) {
    var _a, _b;
    const originalDomain = this._domain;
    let niceMinMax = [], niceType = null;
    if (option) {
      const res = parseNiceOptions(originalDomain, option);
      if (niceMinMax = res.niceMinMax, this._domainValidator = res.domainValidator, niceType = res.niceType, res.niceDomain)
        return this._niceDomain = res.niceDomain, this.rescale(), this;
    } else
      niceType = "all";
    if (niceType) {
      const niceDomain = nice(originalDomain.slice(), {
        floor: (x) => this._pows(Math.floor(this._logs(this._limit(x)))),
        ceil: (x) => Math.abs(x) >= 1 ? Math.ceil(x) : this._pows(Math.ceil(this._logs(this._limit(x))))
      });
      return "min" === niceType ? niceDomain[niceDomain.length - 1] = null !== (_a = niceMinMax[1]) && void 0 !== _a ? _a : niceDomain[niceDomain.length - 1] : "max" === niceType && (niceDomain[0] = null !== (_b = niceMinMax[0]) && void 0 !== _b ? _b : niceDomain[0]), this._niceDomain = niceDomain, this.rescale(), this;
    }
    return this;
  }
  niceMin() {
    const maxD = this._domain[this._domain.length - 1];
    this.nice();
    const niceDomain = this._domain.slice();
    return this._domain && (niceDomain[niceDomain.length - 1] = maxD, this._niceDomain = niceDomain, this.rescale()), this;
  }
  niceMax() {
    const minD = this._domain[0];
    this.nice();
    const niceDomain = this._domain.slice();
    return this._domain && (niceDomain[0] = minD, this._niceDomain = niceDomain, this.rescale()), this;
  }
};

// http-url:https://unpkg.com/@visactor/vscale@0.18.9/es/point-scale
var PointScale = class extends BandScale {
  constructor(slience) {
    super(false), this.type = ScaleEnum.Point, this._padding = 0, this.paddingInner(1, slience), this.padding = this.paddingOuter, this.paddingInner = void 0, this.paddingOuter = void 0;
  }
};

// http-url:https://unpkg.com/@visactor/vscale@0.18.9/es/symlog-scale
var SymlogScale = class _SymlogScale extends LinearScale {
  constructor() {
    super(symlog(1), symexp(1)), this.type = ScaleEnum.Symlog, this._const = 1;
  }
  clone() {
    return new _SymlogScale().domain(this._domain, true).range(this._range, true).unknown(this._unknown).clamp(this.clamp(), null, true).interpolate(this._interpolate, true).constant(this._const);
  }
  constant(_, slience) {
    return arguments.length ? (this._const = _, this.transformer = symlog(_), this.untransformer = symexp(_), this.rescale(slience)) : this._const;
  }
  d3Ticks(count = 10, options) {
    const d = this.domain(), u = d[0], v = d[d.length - 1];
    return d3TicksForLog(u, v, count, this._const, this.transformer, this.untransformer, options);
  }
  ticks(count = 10) {
    const d = this.calculateVisibleDomain(this._range);
    return ticksBaseTransform(d[0], d[d.length - 1], count, this._const, this.transformer, this.untransformer);
  }
  forceTicks(count = 10) {
    const d = this.calculateVisibleDomain(this._range);
    return forceTicksBaseTransform(d[0], d[d.length - 1], count, this.transformer, this.untransformer);
  }
  stepTicks(step) {
    const d = this.calculateVisibleDomain(this._range);
    return forceTicksBaseTransform(d[0], d[d.length - 1], step, this.transformer, this.untransformer);
  }
  nice(count = 10, option) {
    var _a, _b;
    const originalDomain = this._domain;
    let niceMinMax = [], niceType = null;
    if (option) {
      const res = parseNiceOptions(originalDomain, option);
      if (niceMinMax = res.niceMinMax, this._domainValidator = res.domainValidator, niceType = res.niceType, res.niceDomain)
        return this._niceDomain = res.niceDomain, this.rescale(), this;
    } else
      niceType = "all";
    if (niceType) {
      const niceDomain = nice(originalDomain.slice(), {
        floor: (x) => Math.floor(x),
        ceil: (x) => Math.ceil(x)
      });
      return "min" === niceType ? niceDomain[niceDomain.length - 1] = null !== (_a = niceMinMax[1]) && void 0 !== _a ? _a : niceDomain[niceDomain.length - 1] : "max" === niceType && (niceDomain[0] = null !== (_b = niceMinMax[0]) && void 0 !== _b ? _b : niceDomain[0]), this._niceDomain = niceDomain, this.rescale(), this;
    }
    return this;
  }
  niceMin() {
    const maxD = this._domain[this._domain.length - 1];
    this.nice();
    const niceDomain = this._domain.slice();
    return this._domain && (niceDomain[niceDomain.length - 1] = maxD, this._niceDomain = niceDomain, this.rescale()), this;
  }
  niceMax() {
    const minD = this._domain[0];
    this.nice();
    const niceDomain = this._domain.slice();
    return this._domain && (niceDomain[0] = minD, this._niceDomain = niceDomain, this.rescale()), this;
  }
};

// http-url:https://unpkg.com/@visactor/vscale@0.18.9/es/threshold-scale
var ThresholdScale = class _ThresholdScale {
  constructor() {
    this.type = ScaleEnum.Threshold, this._range = [0, 1], this._domain = [0.5], this.n = 1;
  }
  unknown(_) {
    return arguments.length ? (this._unknown = _, this) : this._unknown;
  }
  scale(x) {
    return !isNil_default(x) && isValidNumber_default(+x) ? this._range[bisect(this._domain, x, 0, this.n)] : this._unknown;
  }
  invertExtent(y) {
    const i = this._range.indexOf(y);
    return [this._domain[i - 1], this._domain[i]];
  }
  domain(_) {
    return _ ? (this._domain = Array.from(_), this.n = Math.min(this._domain.length, this._range.length - 1), this) : this._domain.slice();
  }
  range(_) {
    return _ ? (this._range = Array.from(_), this.n = Math.min(this._domain.length, this._range.length - 1), this) : this._range.slice();
  }
  clone() {
    return new _ThresholdScale().domain(this._domain).range(this._range).unknown(this._unknown);
  }
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/axis/tick-data/util
var convertDomainToTickData = (domain) => domain.map((t, index) => ({
  index,
  value: t
}));
var labelOverlap = (prevLabel, nextLabel, gap = 0) => {
  const prevBounds = new AABBBounds(prevLabel).expand(gap / 2), nextBounds = new AABBBounds(nextLabel).expand(gap / 2);
  return prevBounds.intersects(nextBounds);
};
function intersect3(a3, b, sep) {
  return sep > Math.max(b.x1 - a3.x2, a3.x1 - b.x2, b.y1 - a3.y2, a3.y1 - b.y2);
}
function hasOverlap2(items, pad2) {
  for (let b, i = 1, n = items.length, a3 = items[0]; i < n; a3 = b, ++i)
    if (b = items[i], intersect3(a3.AABBBounds, b.AABBBounds, pad2))
      return true;
  return false;
}
var calculateFlushPos = (basePosition, size, rangePosition, otherEnd) => rangePosition < basePosition ? Math.max(basePosition - size / 2, rangePosition) : rangePosition > basePosition ? Math.min(basePosition - size / 2, rangePosition - size) : rangePosition < otherEnd ? rangePosition : rangePosition - size;
var getCartesianLabelBounds = (scale4, domain, op) => {
  var _a;
  const { labelStyle, axisOrientType, labelFlush, labelFormatter, startAngle = 0 } = op;
  let labelAngle = null !== (_a = labelStyle.angle) && void 0 !== _a ? _a : 0;
  "vertical" === labelStyle.direction && (labelAngle += degreeToRadian(90));
  const isHorizontal3 = ["bottom", "top"].includes(axisOrientType), isVertical3 = ["left", "right"].includes(axisOrientType);
  let scaleX = 1, scaleY = 0;
  isHorizontal3 || (isVertical3 ? (scaleX = 0, scaleY = 1) : startAngle && (scaleX = Math.cos(startAngle), scaleY = -Math.sin(startAngle)));
  const textMeasure = initTextMeasure(labelStyle), range2 = scale4.range(), labelBoundsList = domain.map((v, i) => {
    var _a2, _b;
    const str = labelFormatter ? labelFormatter(v) : `${v}`, { width, height } = textMeasure.quickMeasure(str), textWidth = Math.max(width, 12), textHeight = Math.max(height, 12), pos = scale4.scale(v), baseTextX = scaleX * pos, baseTextY = scaleY * pos;
    let align, baseline, textX = baseTextX, textY = baseTextY;
    labelFlush && isHorizontal3 && 0 === i ? textX = calculateFlushPos(baseTextX, textWidth, range2[0], range2[range2.length - 1]) : labelFlush && isHorizontal3 && i === domain.length - 1 ? textX = calculateFlushPos(baseTextX, textWidth, range2[range2.length - 1], range2[0]) : align = null !== (_a2 = labelStyle.textAlign) && void 0 !== _a2 ? _a2 : "center", "right" === align ? textX -= textWidth : "center" === align && (textX -= textWidth / 2), labelFlush && isVertical3 && 0 === i ? textY = calculateFlushPos(baseTextY, textHeight, range2[0], range2[range2.length - 1]) : labelFlush && isVertical3 && i === domain.length - 1 ? textY = calculateFlushPos(baseTextY, textHeight, range2[range2.length - 1], range2[0]) : baseline = null !== (_b = labelStyle.textBaseline) && void 0 !== _b ? _b : "middle", "bottom" === baseline ? textY -= textHeight : "middle" === baseline && (textY -= textHeight / 2);
    const bounds = new AABBBounds().set(textX, textY, textX + textWidth, textY + textHeight);
    return labelAngle && bounds.rotate(labelAngle, baseTextX, baseTextY), bounds;
  });
  return labelBoundsList;
};
var getPolarAngleLabelBounds = (scale4, domain, op) => {
  var _a;
  const { labelStyle, getRadius, labelOffset, labelFormatter, inside } = op, radius = null == getRadius ? void 0 : getRadius(), labelAngle = null !== (_a = labelStyle.angle) && void 0 !== _a ? _a : 0, textMeasure = initTextMeasure(labelStyle), labelBoundsList = domain.map((v) => {
    var _a2, _b;
    const str = labelFormatter ? labelFormatter(v) : `${v}`, { width, height } = textMeasure.quickMeasure(str), textWidth = Math.max(width, 12), textHeight = Math.max(height, 12), angle2 = scale4.scale(v);
    let textX = 0, textY = 0;
    const orient_align = null !== (_a2 = labelStyle.textAlign) && void 0 !== _a2 ? _a2 : "center", orient_baseline = null !== (_b = labelStyle.textBaseline) && void 0 !== _b ? _b : "middle", { x, y } = getPolarAngleLabelPosition(angle2, {
      x: 0,
      y: 0
    }, radius, labelOffset, inside, str, labelStyle);
    textX = x + ("right" === orient_align ? -textWidth : "center" === orient_align ? -textWidth / 2 : 0), textY = y + ("bottom" === orient_baseline ? -textHeight : "middle" === orient_baseline ? -textHeight / 2 : 0);
    return new AABBBounds().set(textX, textY, textX + textWidth, textY + textHeight).rotate(labelAngle, textX + textWidth / 2, textY + textHeight / 2);
  });
  return labelBoundsList;
};
var isAxisHorizontal = (axisOrientType) => ["bottom", "top", "z"].includes(axisOrientType);

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/axis/tick-data/continuous
var continuousTicks = (scale4, op) => {
  if (!isContinuous(scale4.type))
    return convertDomainToTickData(scale4.domain());
  const range2 = scale4.range(), rangeSize = Math.abs(range2[range2.length - 1] - range2[0]);
  if (rangeSize < 2)
    return convertDomainToTickData([scale4.domain()[0]]);
  const { tickCount, forceTickCount, tickStep: tickStep2, noDecimals = false, labelStyle } = op;
  let scaleTicks;
  if (isValid_default(tickStep2))
    scaleTicks = scale4.stepTicks(tickStep2);
  else if (isValid_default(forceTickCount))
    scaleTicks = scale4.forceTicks(forceTickCount);
  else if ("d3" === op.tickMode) {
    const count = isFunction_default(tickCount) ? tickCount({
      axisLength: rangeSize,
      labelStyle
    }) : tickCount;
    scaleTicks = scale4.d3Ticks(null != count ? count : 5, {
      noDecimals
    });
  } else {
    const count = isFunction_default(tickCount) ? tickCount({
      axisLength: rangeSize,
      labelStyle
    }) : tickCount;
    scaleTicks = scale4.ticks(null != count ? count : 5, {
      noDecimals
    });
  }
  if (op.sampling && ("cartesian" === op.coordinateType || "polar" === op.coordinateType && "radius" === op.axisOrientType)) {
    const { labelGap = 4, labelFlush } = op;
    let items = getCartesianLabelBounds(scale4, scaleTicks, op).map((bounds, i) => ({
      AABBBounds: bounds,
      value: scaleTicks[i]
    }));
    for (; items.length >= 3 && hasOverlap2(items, labelGap); )
      items = methods2.parity(items);
    const ticks4 = items.map((item) => item.value);
    ticks4.length < 3 && labelFlush && (ticks4.length > 1 && ticks4.pop(), last(ticks4) !== last(scaleTicks) && ticks4.push(last(scaleTicks))), scaleTicks = ticks4;
  }
  return convertDomainToTickData(scaleTicks);
};
var methods2 = {
  parity: function(items) {
    return items.filter((item, i) => i % 2 == 0);
  },
  greedy: function(items, sep) {
    let a3;
    return items.filter((b, i) => (!i || !intersect3(a3.AABBBounds, b.AABBBounds, sep)) && (a3 = b, true));
  }
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/axis/tick-data/discrete/linear
var getOneDimensionalLabelBounds = (scale4, domain, op, isHorizontal3) => getCartesianLabelBounds(scale4, domain, op).map((bounds) => isHorizontal3 ? [bounds.x1, bounds.x2, bounds.width()] : [bounds.y1, bounds.y2, bounds.height()]);
var boundsOverlap = (prevBounds, nextBounds, gap = 0) => Math.max(prevBounds[0], nextBounds[0]) - gap / 2 <= Math.min(prevBounds[1], nextBounds[1]) + gap / 2;
var boundsDistance = (prevBounds, nextBounds) => prevBounds[1] < nextBounds[0] ? nextBounds[0] - prevBounds[1] : nextBounds[1] < prevBounds[0] ? prevBounds[0] - nextBounds[1] : 0;
var linearDiscreteTicks = (scale4, op) => {
  var _a;
  const domain = scale4.domain();
  if (!domain.length)
    return [];
  const { tickCount, forceTickCount, tickStep: tickStep2, labelGap = 4, axisOrientType, labelStyle } = op, isHorizontal3 = isAxisHorizontal(axisOrientType), range2 = scale4.range(), rangeSize = scale4.calculateWholeRangeSize();
  if (rangeSize < 2)
    return op.labelLastVisible ? convertDomainToTickData([domain[domain.length - 1]]) : convertDomainToTickData([domain[0]]);
  let scaleTicks;
  if (isValid_default(tickStep2))
    scaleTicks = scale4.stepTicks(tickStep2);
  else if (isValid_default(forceTickCount))
    scaleTicks = scale4.forceTicks(forceTickCount);
  else if (isValid_default(tickCount)) {
    const count = isFunction_default(tickCount) ? tickCount({
      axisLength: rangeSize,
      labelStyle
    }) : tickCount;
    scaleTicks = scale4.ticks(count);
  } else if (op.sampling) {
    const fontSize = (null !== (_a = op.labelStyle.fontSize) && void 0 !== _a ? _a : 12) + 2, rangeStart = minInArray(range2), rangeEnd = maxInArray(range2);
    if (domain.length <= rangeSize / fontSize) {
      const incrementUnit = (rangeEnd - rangeStart) / domain.length, labelBoundsList = getOneDimensionalLabelBounds(scale4, domain, op, isHorizontal3), minBoundsLength = Math.min(...labelBoundsList.map((bounds) => bounds[2])), stepResult = getStep(domain, labelBoundsList, labelGap, op.labelLastVisible, Math.floor(minBoundsLength / incrementUnit), false);
      scaleTicks = scale4.stepTicks(stepResult.step), op.labelLastVisible && (stepResult.delCount && (scaleTicks = scaleTicks.slice(0, scaleTicks.length - stepResult.delCount)), scaleTicks.push(domain[domain.length - 1]));
    } else {
      const tempDomain = [domain[0], domain[Math.floor(domain.length / 2)], domain[domain.length - 1]], tempList = getOneDimensionalLabelBounds(scale4, tempDomain, op, isHorizontal3);
      let maxBounds = null;
      tempList.forEach((current) => {
        maxBounds ? maxBounds[2] < current[2] && (maxBounds = current) : maxBounds = current;
      });
      const step = rangeEnd - rangeStart - labelGap > 0 ? Math.ceil(domain.length * (labelGap + maxBounds[2]) / (rangeEnd - rangeStart - labelGap)) : domain.length - 1;
      scaleTicks = scale4.stepTicks(step), !op.labelLastVisible || scaleTicks.length && scaleTicks[scaleTicks.length - 1] === domain[domain.length - 1] || (scaleTicks.length && Math.abs(scale4.scale(scaleTicks[scaleTicks.length - 1]) - scale4.scale(domain[domain.length - 1])) < maxBounds[2] && (scaleTicks = scaleTicks.slice(0, -1)), scaleTicks.push(domain[domain.length - 1]));
    }
  } else
    scaleTicks = scale4.domain();
  return convertDomainToTickData(scaleTicks);
};
var getStep = (domain, labelBoundsList, labelGap, labelLastVisible, defaultStep, areAllBoundsSame) => {
  let resultDelCount = 0, resultStep = 0, resultTickCount = -1, minDiff = Number.MAX_VALUE;
  const validateStep = (step2) => {
    let success = true, ptr = 0;
    do {
      ptr + step2 < domain.length && boundsOverlap(labelBoundsList[ptr], labelBoundsList[ptr + step2], labelGap) && (success = false), ptr += step2;
    } while (success && ptr < domain.length);
    return success;
  }, minValidStep = binaryFuzzySearchInNumberRange(defaultStep, domain.length, (step2) => validateStep(step2) ? 1 : -1);
  let step = minValidStep;
  do {
    if (step > minValidStep && !areAllBoundsSame && !validateStep(step))
      step++;
    else {
      if (!labelLastVisible) {
        resultStep = step;
        break;
      }
      {
        const lastIndex = domain.length - 1;
        let ptr, delCount = 0;
        ptr = domain.length % step > 0 ? domain.length - domain.length % step + step : domain.length;
        do {
          if (ptr -= step, ptr !== lastIndex && !boundsOverlap(labelBoundsList[ptr], labelBoundsList[lastIndex], labelGap))
            break;
          delCount++;
        } while (ptr > 0);
        if (ptr === lastIndex) {
          resultStep = step, resultDelCount = delCount;
          break;
        }
        {
          const tickCount = Math.floor(domain.length / step) - delCount + 1;
          if (tickCount < resultTickCount)
            break;
          {
            resultTickCount = tickCount;
            const distance1 = boundsDistance(labelBoundsList[ptr], labelBoundsList[lastIndex]), distance2 = ptr - step >= 0 ? boundsDistance(labelBoundsList[ptr - step], labelBoundsList[ptr]) : distance1, diff = Math.abs(distance1 - distance2);
            if (diff < minDiff && (minDiff = diff, resultStep = step, resultDelCount = delCount), distance1 <= distance2)
              break;
          }
        }
      }
      step++;
    }
  } while (step <= domain.length);
  return {
    step: resultStep,
    delCount: resultDelCount
  };
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/axis/tick-data/discrete/polar-angle
var polarAngleAxisDiscreteTicks = (scale4, op) => {
  const { tickCount, forceTickCount, tickStep: tickStep2, getRadius, labelOffset, labelGap = 0, labelStyle } = op, radius = null == getRadius ? void 0 : getRadius();
  if (!radius)
    return convertDomainToTickData(scale4.domain());
  let scaleTicks;
  if (isValid_default(tickStep2))
    scaleTicks = scale4.stepTicks(tickStep2);
  else if (isValid_default(forceTickCount))
    scaleTicks = scale4.forceTicks(forceTickCount);
  else if (isValid_default(tickCount)) {
    const range2 = scale4.range(), rangeSize = Math.abs(range2[range2.length - 1] - range2[0]), count = isFunction_default(tickCount) ? tickCount({
      axisLength: rangeSize,
      labelStyle
    }) : tickCount;
    scaleTicks = scale4.ticks(count);
  } else if (op.sampling) {
    const domain = scale4.domain(), range2 = scale4.range(), labelBoundsList = getPolarAngleLabelBounds(scale4, domain, op), rangeStart = minInArray(range2), rangeEnd = maxInArray(range2), incrementUnit = Math.abs(rangeEnd - rangeStart) * (radius + labelOffset) / domain.length, { step, delCount } = getStep2(domain, labelBoundsList, labelGap, Math.floor(labelBoundsList.reduce((min3, curBounds) => Math.min(min3, curBounds.width(), curBounds.height()), Number.MAX_VALUE) / incrementUnit));
    scaleTicks = scale4.stepTicks(step), scaleTicks = scaleTicks.slice(0, scaleTicks.length - delCount);
  } else
    scaleTicks = scale4.domain();
  return convertDomainToTickData(scaleTicks);
};
var getStep2 = (domain, labelBoundsList, labelGap, defaultStep) => {
  let step = defaultStep;
  do {
    let success = true;
    step++;
    let ptr = 0;
    do {
      ptr + step < domain.length && labelOverlap(labelBoundsList[ptr], labelBoundsList[ptr + step], labelGap) && (success = false), ptr += step;
    } while (success && ptr < domain.length);
    if (success)
      break;
  } while (step <= domain.length);
  let delCount = 0;
  if (domain.length > 2) {
    let ptr = domain.length - domain.length % step;
    for (ptr >= domain.length && (ptr -= step); ptr > 0 && labelOverlap(labelBoundsList[0], labelBoundsList[ptr]); )
      delCount++, ptr -= step;
  }
  return {
    step,
    delCount
  };
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/axis/tick-data
var ticks3 = (scale4, op) => {
  if (isContinuous(scale4.type))
    return continuousTicks(scale4, op);
  if (isDiscrete(scale4.type)) {
    if ("cartesian" === op.coordinateType)
      return linearDiscreteTicks(scale4, op);
    if ("polar" === op.coordinateType && "angle" === op.axisOrientType)
      return polarAngleAxisDiscreteTicks(scale4, op);
  }
  return convertDomainToTickData(scale4.domain());
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/axis/grid/base
function getLinePath(points, closed) {
  let path = "";
  return 0 === points.length || (points.forEach((point5, index) => {
    0 === index ? path = `M${point5.x},${point5.y}` : path += `L${point5.x},${point5.y}`;
  }), closed && (path += "Z")), path;
}
function getArcPath(center2, points, reverse, closed) {
  let path = "";
  if (!center2 || 0 === points.length)
    return path;
  const firstPoint = points[0], radius = PointService.distancePP(center2, firstPoint), sweepFlag = reverse ? 0 : 1;
  return closed ? path += `M${center2.x},${center2.y - radius}A${radius},${radius},0,0,${sweepFlag},${center2.x},${center2.y + radius}A${radius},${radius},0,0,${sweepFlag},${center2.x},${center2.y - radius}Z` : points.forEach((point5, index) => {
    0 === index ? path = `M${point5.x},${point5.y}` : path += `A${radius},${radius},0,0,${sweepFlag},${point5.x},${point5.y}`;
  }), path;
}
function getRegionPath(from, to, attribute) {
  const { type, closed } = attribute, reversePoints = to.slice(0).reverse();
  let regionPath = "", nextPath = "";
  if ("line" === type && attribute.smoothLink && attribute.center) {
    const fromStart = from[0], toEnd = reversePoints[0], center2 = attribute.center;
    regionPath = getLinePath(from, !!closed), nextPath = getLinePath(reversePoints, !!closed);
    const toEndRadius = PointService.distancePP(toEnd, center2), fromStartRadius = PointService.distancePP(fromStart, center2);
    regionPath += `A${toEndRadius},${toEndRadius},0,0,1,${toEnd.x},${toEnd.y}L${toEnd.x},${toEnd.y}`, nextPath += `A${fromStartRadius},${fromStartRadius},0,0,0,${fromStart.x},${fromStart.y}`;
  } else if ("circle" === type) {
    const { center: center2 } = attribute;
    regionPath = getArcPath(center2, from, false, !!closed), nextPath = getArcPath(center2, reversePoints, true, !!closed);
  } else
    "line" !== type && "polygon" !== type || (regionPath = getLinePath(from, !!closed), nextPath = getLinePath(reversePoints, !!closed));
  return closed ? regionPath += nextPath : (nextPath = "L" + nextPath.substring(1), regionPath += nextPath, regionPath += "Z"), regionPath;
}
var BaseGrid = class _BaseGrid extends AbstractComponent {
  constructor() {
    super(...arguments), this.name = "axis-grid", this.data = [];
  }
  getInnerView() {
    return this._innerView;
  }
  getPrevInnerView() {
    return this._prevInnerView;
  }
  render() {
    this._prevInnerView = this._innerView && getElMap(this._innerView), this.removeAllChild(true), this._innerView = graphicCreator.group({
      x: 0,
      y: 0,
      pickable: false
    }), this.add(this._innerView);
    const { items, visible } = this.attribute;
    items && items.length && false !== visible && (this.data = this._transformItems(items), this._renderGrid(this._innerView));
  }
  getVerticalCoord(point5, offset, inside) {
    return getVerticalCoord(point5, this.getVerticalVector(offset, inside, point5));
  }
  _transformItems(items) {
    const data = [];
    return items.forEach((item) => {
      var _a;
      data.push(Object.assign(Object.assign({}, item), {
        point: this.getTickCoord(item.value),
        id: null !== (_a = item.id) && void 0 !== _a ? _a : item.label
      }));
    }), data;
  }
  _renderGrid(container2) {
    const { visible } = this.attribute.subGrid || {};
    visible && this._renderGridByType(true, container2), this._renderGridByType(false, container2);
  }
  _renderGridByType(isSubGrid, container2) {
    const gridAttrs = merge({}, this.attribute, this.getGridAttribute(isSubGrid)), { type, items, style, closed, alternateColor, depth = 0 } = gridAttrs, name = isSubGrid ? `${AXIS_ELEMENT_NAME.grid}-sub` : `${AXIS_ELEMENT_NAME.grid}`;
    if (items.forEach((item, index) => {
      const { id: id2, points } = item;
      let path = "";
      if ("line" === type || "polygon" === type)
        path = getLinePath(points, !!closed);
      else if ("circle" === type) {
        const { center: center2 } = this.attribute;
        path = getArcPath(center2, points, false, !!closed);
      }
      const shape = graphicCreator.path(Object.assign({
        path,
        z: depth
      }, isFunction_default(style) ? merge({}, this.skipDefault ? null : _BaseGrid.defaultAttributes.style, style(item, index)) : style));
      shape.name = `${name}-line`, shape.id = this._getNodeId(`${name}-path-${id2}`), container2.add(shape);
    }), depth && "line" === type && items.forEach((item, index) => {
      const { id: id2, points } = item, nextPoints = [];
      nextPoints.push(points[0]);
      const dir_x = points[1].x - points[0].x, dir_y = points[1].y - points[0].y, dirLen = Math.sqrt(dir_x * dir_x + dir_y * dir_y), ratio = depth / dirLen;
      nextPoints.push({
        x: points[0].x + dir_x * ratio,
        y: points[0].y + dir_y * ratio
      });
      const path = getLinePath(nextPoints, !!closed), deltaX = abs(nextPoints[0].x - nextPoints[1].x), deltaY = abs(nextPoints[0].y - nextPoints[1].y), shape = graphicCreator.path(Object.assign({
        path,
        z: 0,
        alpha: deltaX > deltaY ? (points[1].x - points[0].x > 0 ? -1 : 1) * pi / 2 : 0,
        beta: deltaX < deltaY ? -pi / 2 : 0,
        anchor3d: deltaX > deltaY ? [nextPoints[0].x, 0] : [0, nextPoints[0].y]
      }, isFunction_default(style) ? merge({}, this.skipDefault ? null : _BaseGrid.defaultAttributes.style, style(item, index)) : style));
      shape.name = `${name}-line`, shape.id = this._getNodeId(`${name}-path-${id2}`), container2.add(shape);
    }), items.length > 1 && alternateColor) {
      const colors = isArray_default(alternateColor) ? alternateColor : [alternateColor, "transparent"], getColor = (index) => colors[index % colors.length];
      for (let index = 0; index < items.length - 1; index++) {
        const [prev, curr] = [items[index].points, items[index + 1].points], path = getRegionPath(prev, curr, gridAttrs), shape = graphicCreator.path({
          path,
          fill: getColor(index)
        });
        shape.name = `${name}-region`, shape.id = this._getNodeId(`${name}-region-${index}`), container2.add(shape);
      }
    }
  }
  _getNodeId(id2) {
    return `${this.id}-${id2}`;
  }
  release() {
    super.release(), this._prevInnerView = null, this._innerView = null;
  }
};
BaseGrid.defaultAttributes = {
  style: {
    lineWidth: 1,
    stroke: "#999",
    strokeOpacity: 1,
    lineDash: [4, 4]
  },
  subGrid: {
    visible: false,
    style: {
      lineWidth: 1,
      stroke: "#999",
      strokeOpacity: 1,
      lineDash: [4, 4]
    }
  }
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/axis/grid/line
function getCirclePoints(center2, count, radius, startAngle, endAngle) {
  const points = [], range2 = endAngle - startAngle;
  for (let i = 0; i < count; i++) {
    const angle2 = startAngle + i * range2 / count;
    points.push(polarToCartesian(center2, radius, angle2));
  }
  return points;
}
loadLineAxisGridComponent();
var LineAxisGrid = class extends BaseGrid {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, BaseGrid.defaultAttributes, attributes), options);
  }
  _getGridPoint(gridType, point5) {
    let gridPoints;
    if ("line" === gridType) {
      const { length: length2 } = this.attribute;
      gridPoints = [point5, this.getVerticalCoord(point5, length2, true)];
    } else if ("circle" === gridType || "polygon" === gridType) {
      const { center: center2, sides = 6, startAngle = POLAR_START_ANGLE, endAngle = POLAR_END_ANGLE } = this.attribute;
      gridPoints = getCirclePoints(center2, sides, PointService.distancePP(center2, point5), startAngle, endAngle);
    }
    return gridPoints;
  }
  getGridAttribute(isSubGrid) {
    const { type: gridType, alignWithLabel = true } = this.attribute;
    let tickSegment = 1;
    let gridAttribute;
    this.data.length >= 2 && (tickSegment = this.data[1].value - this.data[0].value);
    let items = [];
    if (isSubGrid) {
      gridAttribute = merge({}, this.attribute, this.attribute.subGrid);
      const subGridItems = [], { count: subCount = 4 } = this.attribute.subGrid || {};
      if (this.data.length >= 2) {
        const points = [];
        this.data.forEach((item) => {
          let tickValue = item.value;
          if (!alignWithLabel) {
            const value = item.value - tickSegment / 2;
            if (this.isInValidValue(value))
              return;
            tickValue = value;
          }
          points.push({
            value: tickValue
          });
        });
        for (let i = 0; i < points.length - 1; i++) {
          const pre = points[i], next = points[i + 1];
          subGridItems.push({
            id: `sub-${i}-0`,
            points: this._getGridPoint(gridType, this.getTickCoord(pre.value)),
            datum: {}
          });
          for (let j = 0; j < subCount; j++) {
            const percent = (j + 1) / (subCount + 1), value = (1 - percent) * pre.value + percent * next.value, point5 = this.getTickCoord(value);
            subGridItems.push({
              id: `sub-${i}-${j + 1}`,
              points: this._getGridPoint(gridType, point5),
              datum: {}
            });
          }
          i === points.length - 2 && subGridItems.push({
            id: `sub-${i}-${subCount + 1}`,
            points: this._getGridPoint(gridType, this.getTickCoord(next.value)),
            datum: {}
          });
        }
        items = subGridItems;
      }
    } else {
      gridAttribute = this.attribute;
      const gridItems = [];
      this.data.forEach((item) => {
        let { point: point5 } = item;
        if (!alignWithLabel) {
          const value = item.value - tickSegment / 2;
          if (this.isInValidValue(value))
            return;
          point5 = this.getTickCoord(value);
        }
        gridItems.push({
          id: item.label,
          datum: item,
          points: this._getGridPoint(gridType, point5)
        });
      }), items = gridItems;
    }
    return Object.assign(Object.assign({}, gridAttribute), {
      items
    });
  }
};
mixin(LineAxisGrid, LineAxisMixin);

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/axis/grid/circle
var __rest4 = function(s2, e) {
  var t = {};
  for (var p in s2)
    Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++)
      e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
loadCircleAxisGridComponent();
var CircleAxisGrid = class extends BaseGrid {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, BaseGrid.defaultAttributes, attributes), options);
  }
  getGridAttribute(isSubGrid) {
    let gridAttribute, items = [];
    const _a = this.attribute, { radius, innerRadius = 0, startAngle = POLAR_START_ANGLE, endAngle = POLAR_END_ANGLE, center: center2, subGrid } = _a, grid2 = __rest4(_a, ["radius", "innerRadius", "startAngle", "endAngle", "center", "subGrid"]), { alignWithLabel = true } = grid2 || {}, length2 = radius - innerRadius;
    let tickSegment = 1;
    if (this.data.length >= 2 && (tickSegment = this.data[1].value - this.data[0].value), isSubGrid) {
      gridAttribute = merge({}, grid2, subGrid);
      const subGridItems = [], { count: subCount = 4 } = subGrid || {}, tickLineCount = this.data.length;
      if (tickLineCount >= 2) {
        const points = [];
        this.data.forEach((item) => {
          let tickValue = item.value;
          if (!alignWithLabel) {
            const value = item.value - tickSegment / 2;
            if (this.isInValidValue(value))
              return;
            tickValue = value;
          }
          points.push({
            value: tickValue
          });
        });
        for (let i = 0; i < tickLineCount; i++) {
          const pre = points[i], next = points[i + 1];
          subGridItems.push({
            id: `sub-${i}-0`,
            points: [this.getTickCoord(pre.value), this.getVerticalCoord(this.getTickCoord(pre.value), length2, true)],
            datum: {}
          });
          for (let j = 0; j < subCount; j++) {
            const percent = (j + 1) / (subCount + 1), value = (1 - percent) * pre.value + percent * (next ? next.value : alignWithLabel ? 1 : pre.value + tickSegment), point5 = this.getTickCoord(value), endPoint = this.getVerticalCoord(point5, length2, true);
            subGridItems.push({
              id: `sub-${i}-${j + 1}`,
              points: [point5, endPoint],
              datum: {}
            });
          }
        }
        Math.abs(endAngle - startAngle) % (2 * Math.PI) == 0 && subGridItems.push(subGridItems[0]), items = subGridItems;
      }
    } else {
      gridAttribute = grid2;
      const gridItems = [];
      let data;
      data = Math.abs(endAngle - startAngle) % (2 * Math.PI) == 0 ? [...this.data].concat(this.data[0]) : this.data, data.forEach((item) => {
        let { point: point5 } = item;
        if (!alignWithLabel) {
          const value = item.value - tickSegment / 2;
          if (this.isInValidValue(value))
            return;
          point5 = this.getTickCoord(value);
        }
        const endPoint = this.getVerticalCoord(point5, length2, true);
        gridItems.push({
          id: item.id,
          points: [point5, endPoint],
          datum: item
        });
      }), items = gridItems;
    }
    return Object.assign(Object.assign({}, gridAttribute), {
      items,
      center: center2,
      type: "line"
    });
  }
};
mixin(CircleAxisGrid, CircleAxisMixin);

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/data-zoom/config
var DEFAULT_HANDLER_PATH = "M -0.0544 0.25 C -0.0742 0.25 -0.0901 0.234 -0.0901 0.2143 L -0.0901 -0.1786 C -0.0901 -0.1983 -0.0742 -0.2143 -0.0544 -0.2143 L -0.0187 -0.2143 L -0.0187 -0.5 L 0.017 -0.5 L 0.017 -0.2143 L 0.0527 -0.2143 C 0.0724 -0.2143 0.0884 -0.1983 0.0884 -0.1786 L 0.0884 0.2143 C 0.0884 0.234 0.0724 0.25 0.0527 0.25 L 0.017 0.25 L 0.017 0.5 L -0.0187 0.5 L -0.0187 0.25 L -0.0544 0.25 Z M -0.0187 -0.1429 L -0.0544 -0.1429 L -0.0544 0.1786 L -0.0187 0.1786 L -0.0187 -0.1429 Z M 0.0527 -0.1429 L 0.017 -0.1429 L 0.017 0.1786 L 0.0527 0.1786 L 0.0527 -0.1429 Z";
var DEFAULT_DATA_ZOOM_ATTRIBUTES = {
  orient: "bottom",
  showDetail: "auto",
  brushSelect: true,
  zoomLock: false,
  minSpan: 0,
  maxSpan: 1,
  delayType: "throttle",
  delayTime: 0,
  realTime: true,
  backgroundStyle: {
    fill: "white",
    stroke: "#D1DBEE",
    lineWidth: 1,
    cornerRadius: 2
  },
  dragMaskStyle: {
    fill: "#B0C8F9",
    fillOpacity: 0.2
  },
  backgroundChartStyle: {
    area: {
      visible: true,
      stroke: "#D1DBEE",
      lineWidth: 1,
      fill: "#F6F8FC"
    },
    line: {
      visible: true,
      stroke: "#D1DBEE",
      lineWidth: 1
    }
  },
  selectedBackgroundStyle: {
    fill: "#B0C8F9",
    fillOpacity: 0.5
  },
  selectedBackgroundChartStyle: {
    area: {
      visible: true,
      stroke: "#B0C8F9",
      lineWidth: 1,
      fill: "#fbb934"
    },
    line: {
      visible: true,
      stroke: "#fbb934",
      lineWidth: 1
    }
  },
  middleHandlerStyle: {
    visible: true,
    background: {
      size: 8,
      style: {
        fill: "white",
        stroke: "#B0C8F9",
        cornerRadius: 2
      }
    },
    icon: {
      size: 6,
      fill: "white",
      stroke: "#B0C8F9",
      symbolType: "M 0.3 -0.5 C 0.41 -0.5 0.5 -0.41 0.5 -0.3 C 0.5 -0.3 0.5 0.3 0.5 0.3 C 0.5 0.41 0.41 0.5 0.3 0.5 C 0.3 0.5 -0.3 0.5 -0.3 0.5 C -0.41 0.5 -0.5 0.41 -0.5 0.3 C -0.5 0.3 -0.5 -0.3 -0.5 -0.3 C -0.5 -0.41 -0.41 -0.5 -0.3 -0.5 C -0.3 -0.5 0.3 -0.5 0.3 -0.5 Z",
      lineWidth: 0.5
    }
  },
  startHandlerStyle: {
    visible: true,
    triggerMinSize: 0,
    symbolType: DEFAULT_HANDLER_PATH,
    fill: "white",
    stroke: "#B0C8F9",
    lineWidth: 0.5
  },
  endHandlerStyle: {
    visible: true,
    triggerMinSize: 0,
    symbolType: DEFAULT_HANDLER_PATH,
    fill: "white",
    stroke: "#B0C8F9",
    lineWidth: 0.5
  },
  startTextStyle: {
    padding: 4,
    textStyle: {
      fontSize: 10,
      fill: "#6F6F6F"
    }
  },
  endTextStyle: {
    padding: 4,
    textStyle: {
      fontSize: 10,
      fill: "#6F6F6F"
    }
  }
};
var DEFAULT_HANDLER_ATTR_MAP = {
  horizontal: {
    angle: 0,
    strokeBoundsBuffer: 0,
    boundsPadding: 2,
    pickMode: "imprecise",
    cursor: "ew-resize"
  },
  vertical: {
    angle: Math.PI / 180 * 90,
    cursor: "ns-resize",
    boundsPadding: 2,
    pickMode: "imprecise",
    strokeBoundsBuffer: 0
  }
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/data-zoom/type
var DataZoomActiveTag;
!function(DataZoomActiveTag2) {
  DataZoomActiveTag2.startHandler = "startHandler", DataZoomActiveTag2.endHandler = "endHandler", DataZoomActiveTag2.middleHandler = "middleHandler", DataZoomActiveTag2.background = "background";
}(DataZoomActiveTag || (DataZoomActiveTag = {}));

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/data-zoom/register
function loadDataZoomComponent() {
  loadTagComponent(), registerRect(), registerSymbol(), registerArea(), registerLine();
}

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/data-zoom/data-zoom
var __rest5 = function(s2, e) {
  var t = {};
  for (var p in s2)
    Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++)
      e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var delayMap2 = {
  debounce: debounce_default,
  throttle: throttle_default
};
loadDataZoomComponent();
var DataZoom = class _DataZoom extends AbstractComponent {
  setPropsFromAttrs() {
    const { start, end, orient, previewData, previewPointsX, previewPointsY, previewPointsX1, previewPointsY1 } = this.attribute;
    start && (this.state.start = start), end && (this.state.end = end);
    const { width, height } = this.getLayoutAttrFromConfig();
    this._spanCache = this.state.end - this.state.start, this._isHorizontal = "top" === orient || "bottom" === orient, this._layoutCache.max = this._isHorizontal ? width : height, this._layoutCache.attPos = this._isHorizontal ? "x" : "y", this._layoutCache.attSize = this._isHorizontal ? "width" : "height", previewData && (this._previewData = previewData), isFunction_default(previewPointsX) && (this._previewPointsX = previewPointsX), isFunction_default(previewPointsY) && (this._previewPointsY = previewPointsY), isFunction_default(previewPointsX1) && (this._previewPointsX1 = previewPointsX1), isFunction_default(previewPointsY1) && (this._previewPointsY1 = previewPointsY1);
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _DataZoom.defaultAttributes, attributes)), this.name = "dataZoom", this._previewData = [], this._activeState = false, this._activeCache = {
      startPos: {
        x: 0,
        y: 0
      },
      lastPos: {
        x: 0,
        y: 0
      }
    }, this._layoutCache = {
      attPos: "x",
      attSize: "width",
      max: 0
    }, this.state = {
      start: 0,
      end: 1
    }, this._statePointToData = (state) => state, this._onHandlerPointerDown = (e, tag) => {
      e.stopPropagation(), "start" === tag ? (this._activeTag = DataZoomActiveTag.startHandler, this._activeItem = this._startHandlerMask) : "end" === tag ? (this._activeTag = DataZoomActiveTag.endHandler, this._activeItem = this._endHandlerMask) : "middleRect" === tag ? (this._activeTag = DataZoomActiveTag.middleHandler, this._activeItem = this._middleHandlerRect) : "middleSymbol" === tag ? (this._activeTag = DataZoomActiveTag.middleHandler, this._activeItem = this._middleHandlerSymbol) : "background" === tag && (this._activeTag = DataZoomActiveTag.background, this._activeItem = this._background), this._activeState = true, this._activeCache.startPos = this.eventPosToStagePos(e), this._activeCache.lastPos = this.eventPosToStagePos(e), "browser" === vglobal.env && (vglobal.addEventListener("pointermove", this._onHandlerPointerMove, {
        capture: true
      }), vglobal.addEventListener("pointerup", this._onHandlerPointerUp)), this.addEventListener("pointermove", this._onHandlerPointerMove, {
        capture: true
      });
    }, this._pointerMove = (e) => {
      e.stopPropagation();
      const { start: startAttr, end: endAttr, brushSelect, realTime = true } = this.attribute, pos = this.eventPosToStagePos(e), { attPos, max: max3 } = this._layoutCache, dis = (pos[attPos] - this._activeCache.lastPos[attPos]) / max3;
      let { start, end } = this.state;
      this._activeState && (this._activeTag === DataZoomActiveTag.middleHandler ? this.moveZoomWithMiddle((this.state.start + this.state.end) / 2 + dis) : this._activeTag === DataZoomActiveTag.startHandler ? start + dis > end ? (start = end, end = start + dis, this._activeTag = DataZoomActiveTag.endHandler) : start += dis : this._activeTag === DataZoomActiveTag.endHandler && (end + dis < start ? (end = start, start = end + dis, this._activeTag = DataZoomActiveTag.startHandler) : end += dis), this._activeCache.lastPos = pos, brushSelect && this.renderDragMask()), start = Math.min(Math.max(start, 0), 1), end = Math.min(Math.max(end, 0), 1), startAttr === start && endAttr === end || (this.setStateAttr(start, end, true), realTime && this._dispatchEvent("change", {
        start,
        end,
        tag: this._activeTag
      }));
    }, this._onHandlerPointerMove = 0 === this.attribute.delayTime ? this._pointerMove : delayMap2[this.attribute.delayType](this._pointerMove, this.attribute.delayTime), this._onHandlerPointerUp = (e) => {
      e.preventDefault();
      const { start, end, brushSelect, realTime = true } = this.attribute;
      if (this._activeState && this._activeTag === DataZoomActiveTag.background) {
        const pos = this.eventPosToStagePos(e);
        this.backgroundDragZoom(this._activeCache.startPos, pos);
      }
      this._activeState = false, brushSelect && this.renderDragMask(), start === this.state.start && end === this.state.end || (this.setStateAttr(this.state.start, this.state.end, true), this._dispatchEvent("change", {
        start: this.state.start,
        end: this.state.end,
        tag: this._activeTag
      })), "browser" === vglobal.env && (vglobal.removeEventListener("pointermove", this._onHandlerPointerMove, {
        capture: true
      }), vglobal.removeEventListener("pointerup", this._onHandlerPointerUp)), this.removeEventListener("pointermove", this._onHandlerPointerMove, {
        capture: true
      }), this.removeEventListener("pointerup", this._onHandlerPointerUp);
    };
    const { position, showDetail } = attributes;
    this._activeCache.startPos = position, this._activeCache.lastPos = position, this._showText = "auto" !== showDetail && showDetail, this.setPropsFromAttrs();
  }
  setAttributes(params2, forceUpdateTag) {
    super.setAttributes(params2, forceUpdateTag), this.setPropsFromAttrs();
  }
  bindEvents() {
    if (this.attribute.disableTriggerEvent)
      return void this.setAttribute("childrenPickable", false);
    const { showDetail, brushSelect } = this.attribute;
    this._startHandlerMask && this._startHandlerMask.addEventListener("pointerdown", (e) => this._onHandlerPointerDown(e, "start")), this._endHandlerMask && this._endHandlerMask.addEventListener("pointerdown", (e) => this._onHandlerPointerDown(e, "end")), this._middleHandlerSymbol && this._middleHandlerSymbol.addEventListener("pointerdown", (e) => this._onHandlerPointerDown(e, "middleSymbol")), this._middleHandlerRect && this._middleHandlerRect.addEventListener("pointerdown", (e) => this._onHandlerPointerDown(e, "middleRect"));
    const selectedTag = brushSelect ? "background" : "middleRect";
    this._selectedBackground && this._selectedBackground.addEventListener("pointerdown", (e) => this._onHandlerPointerDown(e, selectedTag)), brushSelect && this._background && this._background.addEventListener("pointerdown", (e) => this._onHandlerPointerDown(e, "background")), brushSelect && this._previewGroup && this._previewGroup.addEventListener("pointerdown", (e) => this._onHandlerPointerDown(e, "background")), this._selectedPreviewGroup && this._selectedPreviewGroup.addEventListener("pointerdown", (e) => this._onHandlerPointerDown(e, selectedTag)), this.addEventListener("pointerup", this._onHandlerPointerUp), this.addEventListener("pointerupoutside", this._onHandlerPointerUp), "auto" === showDetail && (this.addEventListener("pointerenter", this._onHandlerPointerEnter), this.addEventListener("pointerleave", this._onHandlerPointerLeave));
  }
  dragMaskSize() {
    const { position } = this.attribute, { attPos, max: max3 } = this._layoutCache;
    return this._activeCache.lastPos[attPos] - position[attPos] > max3 ? max3 + position[attPos] - this._activeCache.startPos[attPos] : this._activeCache.lastPos[attPos] - position[attPos] < 0 ? position[attPos] - this._activeCache.startPos[attPos] : this._activeCache.lastPos[attPos] - this._activeCache.startPos[attPos];
  }
  setStateAttr(start, end, shouldRender) {
    const { zoomLock = false, minSpan = 0, maxSpan = 1 } = this.attribute, span = end - start;
    span !== this._spanCache && (zoomLock || span < minSpan || span > maxSpan) || (this._spanCache = span, this.state.start = start, this.state.end = end, shouldRender && this.setAttributes({
      start,
      end
    }));
  }
  eventPosToStagePos(e) {
    return this.stage.eventPointTransform(e);
  }
  _onHandlerPointerEnter(e) {
    e.stopPropagation(), this._showText = true, this.renderText();
  }
  _onHandlerPointerLeave(e) {
    e.stopPropagation(), this._showText = false, this.renderText();
  }
  backgroundDragZoom(startPos, endPos) {
    const { attPos, max: max3 } = this._layoutCache, { position } = this.attribute, startPosInComponent = startPos[attPos] - position[attPos], endPosInComponent = endPos[attPos] - position[attPos], start = Math.min(Math.max(Math.min(startPosInComponent, endPosInComponent) / max3, 0), 1), end = Math.min(Math.max(Math.max(startPosInComponent, endPosInComponent) / max3, 0), 1);
    Math.abs(start - end) < 0.01 ? this.moveZoomWithMiddle(start) : this.setStateAttr(start, end, false);
  }
  moveZoomWithMiddle(middle) {
    let offset = middle - (this.state.start + this.state.end) / 2;
    0 !== offset && (offset > 0 ? this.state.end + offset > 1 && (offset = 1 - this.state.end) : offset < 0 && this.state.start + offset < 0 && (offset = -this.state.start), this.setStateAttr(this.state.start + offset, this.state.end + offset, false));
  }
  renderDragMask() {
    const { dragMaskStyle } = this.attribute, { position, width, height } = this.getLayoutAttrFromConfig();
    this._isHorizontal ? this._dragMask = this._container.createOrUpdateChild("dragMask", Object.assign({
      x: clamp_default(this.dragMaskSize() < 0 ? this._activeCache.lastPos.x : this._activeCache.startPos.x, position.x, position.x + width),
      y: position.y,
      width: this._activeState && this._activeTag === DataZoomActiveTag.background && Math.abs(this.dragMaskSize()) || 0,
      height
    }, dragMaskStyle), "rect") : this._dragMask = this._container.createOrUpdateChild("dragMask", Object.assign({
      x: position.x,
      y: clamp_default(this.dragMaskSize() < 0 ? this._activeCache.lastPos.y : this._activeCache.startPos.y, position.y, position.y + height),
      width,
      height: this._activeState && this._activeTag === DataZoomActiveTag.background && Math.abs(this.dragMaskSize()) || 0
    }, dragMaskStyle), "rect");
  }
  isTextOverflow(componentBoundsLike, textBounds, layout) {
    if (!textBounds)
      return false;
    if (this._isHorizontal) {
      if ("start" === layout) {
        if (textBounds.x1 < componentBoundsLike.x1)
          return true;
      } else if (textBounds.x2 > componentBoundsLike.x2)
        return true;
    } else if ("start" === layout) {
      if (textBounds.y1 < componentBoundsLike.y1)
        return true;
    } else if (textBounds.y2 > componentBoundsLike.y2)
      return true;
    return false;
  }
  setTextAttr(startTextBounds, endTextBounds) {
    const { startTextStyle, endTextStyle } = this.attribute, { formatMethod: startTextFormat } = startTextStyle, restStartTextStyle = __rest5(startTextStyle, ["formatMethod"]), { formatMethod: endTextFormat } = endTextStyle, restEndTextStyle = __rest5(endTextStyle, ["formatMethod"]), { start, end } = this.state;
    this._startValue = this._statePointToData(start), this._endValue = this._statePointToData(end);
    const { position, width, height } = this.getLayoutAttrFromConfig(), startTextValue = startTextFormat ? startTextFormat(this._startValue) : this._startValue, endTextValue = endTextFormat ? endTextFormat(this._endValue) : this._endValue, componentBoundsLike = {
      x1: position.x,
      y1: position.y,
      x2: position.x + width,
      y2: position.y + height
    };
    let startTextPosition, endTextPosition, startTextAlignStyle, endTextAlignStyle;
    this._isHorizontal ? (startTextPosition = {
      x: position.x + start * width,
      y: position.y + height / 2
    }, endTextPosition = {
      x: position.x + end * width,
      y: position.y + height / 2
    }, startTextAlignStyle = {
      textAlign: this.isTextOverflow(componentBoundsLike, startTextBounds, "start") ? "left" : "right",
      textBaseline: "middle"
    }, endTextAlignStyle = {
      textAlign: this.isTextOverflow(componentBoundsLike, endTextBounds, "end") ? "right" : "left",
      textBaseline: "middle"
    }) : (startTextPosition = {
      x: position.x + width / 2,
      y: position.y + start * height
    }, endTextPosition = {
      x: position.x + width / 2,
      y: position.y + end * height
    }, startTextAlignStyle = {
      textAlign: "center",
      textBaseline: this.isTextOverflow(componentBoundsLike, startTextBounds, "start") ? "top" : "bottom"
    }, endTextAlignStyle = {
      textAlign: "center",
      textBaseline: this.isTextOverflow(componentBoundsLike, endTextBounds, "end") ? "bottom" : "top"
    }), this._startText = this.maybeAddLabel(this._container, merge({}, restStartTextStyle, {
      text: startTextValue,
      x: startTextPosition.x,
      y: startTextPosition.y,
      visible: this._showText,
      pickable: false,
      childrenPickable: false,
      textStyle: startTextAlignStyle
    }), `data-zoom-start-text-${position}`), this._endText = this.maybeAddLabel(this._container, merge({}, restEndTextStyle, {
      text: endTextValue,
      x: endTextPosition.x,
      y: endTextPosition.y,
      visible: this._showText,
      pickable: false,
      childrenPickable: false,
      textStyle: endTextAlignStyle
    }), `data-zoom-end-text-${position}`);
  }
  renderText() {
    let startTextBounds = null, endTextBounds = null;
    this.setTextAttr(startTextBounds, endTextBounds), startTextBounds = this._startText.AABBBounds, endTextBounds = this._endText.AABBBounds, this.setTextAttr(startTextBounds, endTextBounds), startTextBounds = this._startText.AABBBounds, endTextBounds = this._endText.AABBBounds;
    const { x1: x14, x2: x23, y1: y14, y2: y23 } = startTextBounds, { dx: startTextDx = 0, dy: startTextDy = 0 } = this.attribute.startTextStyle;
    if (new Bounds().set(x14, y14, x23, y23).intersects(endTextBounds)) {
      const direction2 = "bottom" === this.attribute.orient || "right" === this.attribute.orient ? -1 : 1;
      this._isHorizontal ? this._startText.setAttribute("dy", startTextDy + direction2 * Math.abs(endTextBounds.y1 - endTextBounds.y2)) : this._startText.setAttribute("dx", startTextDx + direction2 * Math.abs(endTextBounds.x1 - endTextBounds.x2));
    } else
      this._isHorizontal ? this._startText.setAttribute("dy", startTextDy) : this._startText.setAttribute("dx", startTextDx);
  }
  getLayoutAttrFromConfig() {
    var _a, _b, _c, _d, _e, _f;
    if (this._layoutAttrFromConfig)
      return this._layoutAttrFromConfig;
    const { position: positionConfig, size, orient, middleHandlerStyle = {}, startHandlerStyle = {}, endHandlerStyle = {}, backgroundStyle = {} } = this.attribute, { width: widthConfig, height: heightConfig } = size, middleHandlerSize = null !== (_b = null === (_a = middleHandlerStyle.background) || void 0 === _a ? void 0 : _a.size) && void 0 !== _b ? _b : 10;
    let width, height, position;
    middleHandlerStyle.visible ? this._isHorizontal ? (width = widthConfig, height = heightConfig - middleHandlerSize, position = {
      x: positionConfig.x,
      y: positionConfig.y + middleHandlerSize
    }) : (width = widthConfig - middleHandlerSize, height = heightConfig, position = {
      x: positionConfig.x + ("left" === orient ? middleHandlerSize : 0),
      y: positionConfig.y
    }) : (width = widthConfig, height = heightConfig, position = positionConfig);
    const startHandlerSize = null !== (_c = startHandlerStyle.size) && void 0 !== _c ? _c : this._isHorizontal ? height : width, endHandlerSize = null !== (_d = endHandlerStyle.size) && void 0 !== _d ? _d : this._isHorizontal ? height : width;
    return startHandlerStyle.visible && (this._isHorizontal ? (width -= (startHandlerSize + endHandlerSize) / 2, position = {
      x: position.x + startHandlerSize / 2,
      y: position.y
    }) : (height -= (startHandlerSize + endHandlerSize) / 2, position = {
      x: position.x,
      y: position.y + startHandlerSize / 2
    })), height += null !== (_e = backgroundStyle.lineWidth / 2) && void 0 !== _e ? _e : 1, width += null !== (_f = backgroundStyle.lineWidth / 2) && void 0 !== _f ? _f : 1, this._layoutAttrFromConfig = {
      position,
      width,
      height
    }, this._layoutAttrFromConfig;
  }
  render() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9;
    this._layoutAttrFromConfig = null;
    const { orient, backgroundStyle, backgroundChartStyle = {}, selectedBackgroundStyle = {}, selectedBackgroundChartStyle = {}, middleHandlerStyle = {}, startHandlerStyle = {}, endHandlerStyle = {}, brushSelect, zoomLock } = this.attribute, { start, end } = this.state, { position, width, height } = this.getLayoutAttrFromConfig(), startHandlerMinSize = null !== (_a = startHandlerStyle.triggerMinSize) && void 0 !== _a ? _a : 40, endHandlerMinSize = null !== (_b = endHandlerStyle.triggerMinSize) && void 0 !== _b ? _b : 40, group = this.createOrUpdateChild("dataZoom-container", {}, "group");
    if (this._container = group, this._background = group.createOrUpdateChild("background", Object.assign(Object.assign({
      x: position.x,
      y: position.y,
      width,
      height,
      cursor: brushSelect ? "crosshair" : "auto"
    }, backgroundStyle), {
      pickable: !zoomLock && (null === (_c = backgroundStyle.pickable) || void 0 === _c || _c)
    }), "rect"), (null === (_d = backgroundChartStyle.line) || void 0 === _d ? void 0 : _d.visible) && this.setPreviewAttributes("line", group), (null === (_e = backgroundChartStyle.area) || void 0 === _e ? void 0 : _e.visible) && this.setPreviewAttributes("area", group), brushSelect && this.renderDragMask(), this._isHorizontal ? this._selectedBackground = group.createOrUpdateChild("selectedBackground", Object.assign(Object.assign({
      x: position.x + start * width,
      y: position.y,
      width: (end - start) * width,
      height,
      cursor: brushSelect ? "crosshair" : "move"
    }, selectedBackgroundStyle), {
      pickable: !zoomLock && (null === (_f = selectedBackgroundChartStyle.pickable) || void 0 === _f || _f)
    }), "rect") : this._selectedBackground = group.createOrUpdateChild("selectedBackground", Object.assign(Object.assign({
      x: position.x,
      y: position.y + start * height,
      width,
      height: (end - start) * height,
      cursor: brushSelect ? "crosshair" : "move"
    }, selectedBackgroundStyle), {
      pickable: !zoomLock && (null === (_g = selectedBackgroundStyle.pickable) || void 0 === _g || _g)
    }), "rect"), (null === (_h = selectedBackgroundChartStyle.line) || void 0 === _h ? void 0 : _h.visible) && this.setSelectedPreviewAttributes("line", group), (null === (_j = selectedBackgroundChartStyle.area) || void 0 === _j ? void 0 : _j.visible) && this.setSelectedPreviewAttributes("area", group), this._isHorizontal) {
      if (middleHandlerStyle.visible) {
        const middleHandlerBackgroundSize = (null === (_k = middleHandlerStyle.background) || void 0 === _k ? void 0 : _k.size) || 10;
        this._middleHandlerRect = group.createOrUpdateChild("middleHandlerRect", Object.assign(Object.assign({
          x: position.x + start * width,
          y: position.y - middleHandlerBackgroundSize,
          width: (end - start) * width,
          height: middleHandlerBackgroundSize
        }, null === (_l = middleHandlerStyle.background) || void 0 === _l ? void 0 : _l.style), {
          pickable: !zoomLock && (null === (_p = null === (_o = null === (_m = middleHandlerStyle.background) || void 0 === _m ? void 0 : _m.style) || void 0 === _o ? void 0 : _o.pickable) || void 0 === _p || _p)
        }), "rect"), this._middleHandlerSymbol = group.createOrUpdateChild("middleHandlerSymbol", Object.assign(Object.assign({
          x: position.x + (start + end) / 2 * width,
          y: position.y - middleHandlerBackgroundSize / 2,
          strokeBoundsBuffer: 0,
          angle: 0,
          symbolType: null !== (_r = null === (_q = middleHandlerStyle.icon) || void 0 === _q ? void 0 : _q.symbolType) && void 0 !== _r ? _r : "square"
        }, middleHandlerStyle.icon), {
          pickable: !zoomLock && (null === (_s = middleHandlerStyle.icon.pickable) || void 0 === _s || _s)
        }), "symbol");
      }
      this._startHandler = group.createOrUpdateChild("startHandler", Object.assign(Object.assign(Object.assign({
        x: position.x + start * width,
        y: position.y + height / 2,
        size: height,
        symbolType: null !== (_t = startHandlerStyle.symbolType) && void 0 !== _t ? _t : "square"
      }, DEFAULT_HANDLER_ATTR_MAP.horizontal), startHandlerStyle), {
        pickable: !zoomLock && (null === (_u = startHandlerStyle.pickable) || void 0 === _u || _u)
      }), "symbol"), this._endHandler = group.createOrUpdateChild("endHandler", Object.assign(Object.assign(Object.assign({
        x: position.x + end * width,
        y: position.y + height / 2,
        size: height,
        symbolType: null !== (_v = endHandlerStyle.symbolType) && void 0 !== _v ? _v : "square"
      }, DEFAULT_HANDLER_ATTR_MAP.horizontal), endHandlerStyle), {
        pickable: !zoomLock && (null === (_w = endHandlerStyle.pickable) || void 0 === _w || _w)
      }), "symbol");
      const startHandlerWidth = Math.max(this._startHandler.AABBBounds.width(), startHandlerMinSize), startHandlerHeight = Math.max(this._startHandler.AABBBounds.height(), startHandlerMinSize), endHandlerWidth = Math.max(this._endHandler.AABBBounds.width(), endHandlerMinSize), endHandlerHeight = Math.max(this._endHandler.AABBBounds.height(), endHandlerMinSize);
      this._startHandlerMask = group.createOrUpdateChild("startHandlerMask", Object.assign(Object.assign({
        x: position.x + start * width - startHandlerWidth / 2,
        y: position.y + height / 2 - startHandlerHeight / 2,
        width: startHandlerWidth,
        height: startHandlerHeight,
        fill: "white",
        fillOpacity: 0,
        zIndex: 999
      }, DEFAULT_HANDLER_ATTR_MAP.horizontal), {
        pickable: !zoomLock
      }), "rect"), this._endHandlerMask = group.createOrUpdateChild("endHandlerMask", Object.assign(Object.assign({
        x: position.x + end * width - endHandlerWidth / 2,
        y: position.y + height / 2 - endHandlerHeight / 2,
        width: endHandlerWidth,
        height: endHandlerHeight,
        fill: "white",
        fillOpacity: 0,
        zIndex: 999
      }, DEFAULT_HANDLER_ATTR_MAP.horizontal), {
        pickable: !zoomLock
      }), "rect");
    } else {
      if (middleHandlerStyle.visible) {
        const middleHandlerBackgroundSize = (null === (_x = middleHandlerStyle.background) || void 0 === _x ? void 0 : _x.size) || 10;
        this._middleHandlerRect = group.createOrUpdateChild("middleHandlerRect", Object.assign(Object.assign({
          x: "left" === orient ? position.x - middleHandlerBackgroundSize : position.x + width,
          y: position.y + start * height,
          width: middleHandlerBackgroundSize,
          height: (end - start) * height
        }, null === (_y = middleHandlerStyle.background) || void 0 === _y ? void 0 : _y.style), {
          pickable: !zoomLock && (null === (_1 = null === (_0 = null === (_z = middleHandlerStyle.background) || void 0 === _z ? void 0 : _z.style) || void 0 === _0 ? void 0 : _0.pickable) || void 0 === _1 || _1)
        }), "rect"), this._middleHandlerSymbol = group.createOrUpdateChild("middleHandlerSymbol", Object.assign(Object.assign({
          x: "left" === orient ? position.x - middleHandlerBackgroundSize / 2 : position.x + width + middleHandlerBackgroundSize / 2,
          y: position.y + (start + end) / 2 * height,
          angle: Math.PI / 180 * 90,
          symbolType: null !== (_3 = null === (_2 = middleHandlerStyle.icon) || void 0 === _2 ? void 0 : _2.symbolType) && void 0 !== _3 ? _3 : "square",
          strokeBoundsBuffer: 0
        }, middleHandlerStyle.icon), {
          pickable: !zoomLock && (null === (_5 = null === (_4 = middleHandlerStyle.icon) || void 0 === _4 ? void 0 : _4.pickable) || void 0 === _5 || _5)
        }), "symbol");
      }
      this._startHandler = group.createOrUpdateChild("startHandler", Object.assign(Object.assign(Object.assign({
        x: position.x + width / 2,
        y: position.y + start * height,
        size: width,
        symbolType: null !== (_6 = startHandlerStyle.symbolType) && void 0 !== _6 ? _6 : "square"
      }, DEFAULT_HANDLER_ATTR_MAP.vertical), startHandlerStyle), {
        pickable: !zoomLock && (null === (_7 = startHandlerStyle.pickable) || void 0 === _7 || _7)
      }), "symbol"), this._endHandler = group.createOrUpdateChild("endHandler", Object.assign(Object.assign(Object.assign({
        x: position.x + width / 2,
        y: position.y + end * height,
        size: width,
        symbolType: null !== (_8 = endHandlerStyle.symbolType) && void 0 !== _8 ? _8 : "square"
      }, DEFAULT_HANDLER_ATTR_MAP.vertical), endHandlerStyle), {
        pickable: !zoomLock && (null === (_9 = endHandlerStyle.pickable) || void 0 === _9 || _9)
      }), "symbol");
      const startHandlerWidth = Math.max(this._startHandler.AABBBounds.width(), startHandlerMinSize), startHandlerHeight = Math.max(this._startHandler.AABBBounds.height(), startHandlerMinSize), endHandlerWidth = Math.max(this._endHandler.AABBBounds.width(), endHandlerMinSize), endHandlerHeight = Math.max(this._endHandler.AABBBounds.height(), endHandlerMinSize);
      this._startHandlerMask = group.createOrUpdateChild("startHandlerMask", Object.assign(Object.assign({
        x: position.x + width / 2 + startHandlerWidth / 2,
        y: position.y + start * height - startHandlerHeight / 2,
        width: endHandlerHeight,
        height: endHandlerWidth,
        fill: "white",
        fillOpacity: 0,
        zIndex: 999
      }, DEFAULT_HANDLER_ATTR_MAP.vertical), {
        pickable: !zoomLock
      }), "rect"), this._endHandlerMask = group.createOrUpdateChild("endHandlerMask", Object.assign(Object.assign({
        x: position.x + width / 2 + endHandlerWidth / 2,
        y: position.y + end * height - endHandlerHeight / 2,
        width: endHandlerHeight,
        height: endHandlerWidth,
        fill: "white",
        fillOpacity: 0,
        zIndex: 999
      }, DEFAULT_HANDLER_ATTR_MAP.vertical), {
        pickable: !zoomLock
      }), "rect");
    }
    this._showText && this.renderText();
  }
  computeBasePoints() {
    const { orient } = this.attribute, { position, width, height } = this.getLayoutAttrFromConfig();
    let basePointStart, basePointEnd;
    return this._isHorizontal ? (basePointStart = [{
      x: position.x,
      y: position.y + height
    }], basePointEnd = [{
      x: position.x + width,
      y: position.y + height
    }]) : "left" === orient ? (basePointStart = [{
      x: position.x + width,
      y: position.y
    }], basePointEnd = [{
      x: position.x + width,
      y: position.y + height
    }]) : (basePointStart = [{
      x: position.x,
      y: position.y + height
    }], basePointEnd = [{
      x: position.x,
      y: position.y
    }]), {
      basePointStart,
      basePointEnd
    };
  }
  simplifyPoints(points) {
    var _a;
    if (points.length > 1e4) {
      const tolerance = null !== (_a = this.attribute.tolerance) && void 0 !== _a ? _a : this._previewData.length / 1e4;
      return flatten_simplify(points, tolerance, false);
    }
    return points;
  }
  getPreviewLinePoints() {
    let previewPoints = this._previewData.map((d) => ({
      x: this._previewPointsX && this._previewPointsX(d),
      y: this._previewPointsY && this._previewPointsY(d)
    }));
    if (0 === previewPoints.length)
      return previewPoints;
    previewPoints = this.simplifyPoints(previewPoints);
    const { basePointStart, basePointEnd } = this.computeBasePoints();
    return basePointStart.concat(previewPoints).concat(basePointEnd);
  }
  getPreviewAreaPoints() {
    let previewPoints = this._previewData.map((d) => ({
      x: this._previewPointsX && this._previewPointsX(d),
      y: this._previewPointsY && this._previewPointsY(d),
      x1: this._previewPointsX1 && this._previewPointsX1(d),
      y1: this._previewPointsY1 && this._previewPointsY1(d)
    }));
    if (0 === previewPoints.length)
      return previewPoints;
    previewPoints = this.simplifyPoints(previewPoints);
    const { basePointStart, basePointEnd } = this.computeBasePoints();
    return basePointStart.concat(previewPoints).concat(basePointEnd);
  }
  setPreviewAttributes(type, group) {
    this._previewGroup || (this._previewGroup = group.createOrUpdateChild("previewGroup", {
      pickable: false
    }, "group")), "line" === type ? this._previewLine = this._previewGroup.createOrUpdateChild("previewLine", {}, "line") : this._previewArea = this._previewGroup.createOrUpdateChild("previewArea", {
      curveType: "basis"
    }, "area");
    const { backgroundChartStyle = {} } = this.attribute;
    "line" === type && this._previewLine.setAttributes(Object.assign({
      points: this.getPreviewLinePoints(),
      curveType: "basis",
      pickable: false
    }, backgroundChartStyle.line)), "area" === type && this._previewArea.setAttributes(Object.assign({
      points: this.getPreviewAreaPoints(),
      curveType: "basis",
      pickable: false
    }, backgroundChartStyle.area));
  }
  setSelectedPreviewAttributes(type, group) {
    this._selectedPreviewGroupClip || (this._selectedPreviewGroupClip = group.createOrUpdateChild("selectedPreviewGroupClip", {
      pickable: false
    }, "group"), this._selectedPreviewGroup = this._selectedPreviewGroupClip.createOrUpdateChild("selectedPreviewGroup", {}, "group")), "line" === type ? this._selectedPreviewLine = this._selectedPreviewGroup.createOrUpdateChild("selectedPreviewLine", {}, "line") : this._selectedPreviewArea = this._selectedPreviewGroup.createOrUpdateChild("selectedPreviewArea", {
      curveType: "basis"
    }, "area");
    const { selectedBackgroundChartStyle = {} } = this.attribute, { start, end } = this.state, { position, width, height } = this.getLayoutAttrFromConfig();
    this._selectedPreviewGroupClip.setAttributes({
      x: this._isHorizontal ? position.x + start * width : position.x,
      y: this._isHorizontal ? position.y : position.y + start * height,
      width: this._isHorizontal ? (end - start) * width : width,
      height: this._isHorizontal ? height : (end - start) * height,
      clip: true,
      pickable: false
    }), this._selectedPreviewGroup.setAttributes({
      x: -(this._isHorizontal ? position.x + start * width : position.x),
      y: -(this._isHorizontal ? position.y : position.y + start * height),
      width: this._isHorizontal ? (end - start) * width : width,
      height: this._isHorizontal ? height : (end - start) * height,
      pickable: false
    }), "line" === type && this._selectedPreviewLine.setAttributes(Object.assign({
      points: this.getPreviewLinePoints(),
      curveType: "basis",
      pickable: false
    }, selectedBackgroundChartStyle.line)), "area" === type && this._selectedPreviewArea.setAttributes(Object.assign({
      points: this.getPreviewAreaPoints(),
      curveType: "basis",
      pickable: false
    }, selectedBackgroundChartStyle.area));
  }
  maybeAddLabel(container2, attributes, name) {
    let labelShape = this.find((node) => node.name === name, true);
    return labelShape ? labelShape.setAttributes(attributes) : (labelShape = new Tag(attributes), labelShape.name = name), container2.add(labelShape), labelShape;
  }
  setStartAndEnd(start, end) {
    const { start: startAttr, end: endAttr } = this.attribute;
    isValid_default(start) && isValid_default(end) && (start !== this.state.start || end !== this.state.end) && (this.state.start = start, this.state.end = end, startAttr === this.state.start && endAttr === this.state.end || (this.setStateAttr(start, end, true), this._dispatchEvent("change", {
      start,
      end,
      tag: this._activeTag
    })));
  }
  setPreviewData(data) {
    this._previewData = data;
  }
  setText(text2, tag) {
    "start" === tag ? this._startText.setAttribute("text", text2) : this._endText.setAttribute("text", text2);
  }
  getStartValue() {
    return this._startValue;
  }
  getEndTextValue() {
    return this._endValue;
  }
  getMiddleHandlerSize() {
    var _a, _b, _c, _d;
    const { middleHandlerStyle = {} } = this.attribute, middleHandlerRectSize = null !== (_b = null === (_a = middleHandlerStyle.background) || void 0 === _a ? void 0 : _a.size) && void 0 !== _b ? _b : 10, middleHandlerSymbolSize = null !== (_d = null === (_c = middleHandlerStyle.icon) || void 0 === _c ? void 0 : _c.size) && void 0 !== _d ? _d : 10;
    return Math.max(middleHandlerRectSize, ...array(middleHandlerSymbolSize));
  }
  setPreviewPointsX(callback) {
    isFunction_default(callback) && (this._previewPointsX = callback);
  }
  setPreviewPointsY(callback) {
    isFunction_default(callback) && (this._previewPointsY = callback);
  }
  setPreviewPointsX1(callback) {
    isFunction_default(callback) && (this._previewPointsX1 = callback);
  }
  setPreviewPointsY1(callback) {
    isFunction_default(callback) && (this._previewPointsY1 = callback);
  }
  setStatePointToData(callback) {
    isFunction_default(callback) && (this._statePointToData = callback);
  }
};
DataZoom.defaultAttributes = DEFAULT_DATA_ZOOM_ATTRIBUTES;

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/marker/type
var IMarkLineLabelPosition;
!function(IMarkLineLabelPosition2) {
  IMarkLineLabelPosition2.start = "start", IMarkLineLabelPosition2.startTop = "startTop", IMarkLineLabelPosition2.startBottom = "startBottom", IMarkLineLabelPosition2.insideStart = "insideStart", IMarkLineLabelPosition2.insideStartTop = "insideStartTop", IMarkLineLabelPosition2.insideStartBottom = "insideStartBottom", IMarkLineLabelPosition2.middle = "middle", IMarkLineLabelPosition2.insideMiddleTop = "insideMiddleTop", IMarkLineLabelPosition2.insideMiddleBottom = "insideMiddleBottom", IMarkLineLabelPosition2.end = "end", IMarkLineLabelPosition2.endTop = "endTop", IMarkLineLabelPosition2.endBottom = "endBottom", IMarkLineLabelPosition2.insideEnd = "insideEnd", IMarkLineLabelPosition2.insideEndTop = "insideEndTop", IMarkLineLabelPosition2.insideEndBottom = "insideEndBottom";
}(IMarkLineLabelPosition || (IMarkLineLabelPosition = {}));
var IMarkAreaLabelPosition;
!function(IMarkAreaLabelPosition2) {
  IMarkAreaLabelPosition2.left = "left", IMarkAreaLabelPosition2.right = "right", IMarkAreaLabelPosition2.top = "top", IMarkAreaLabelPosition2.bottom = "bottom", IMarkAreaLabelPosition2.middle = "middle", IMarkAreaLabelPosition2.insideLeft = "insideLeft", IMarkAreaLabelPosition2.insideRight = "insideRight", IMarkAreaLabelPosition2.insideTop = "insideTop", IMarkAreaLabelPosition2.insideBottom = "insideBottom";
}(IMarkAreaLabelPosition || (IMarkAreaLabelPosition = {}));
var IMarkCommonArcLabelPosition;
!function(IMarkCommonArcLabelPosition2) {
  IMarkCommonArcLabelPosition2.arcInnerStart = "arcInnerStart", IMarkCommonArcLabelPosition2.arcInnerEnd = "arcInnerEnd", IMarkCommonArcLabelPosition2.arcInnerMiddle = "arcInnerMiddle", IMarkCommonArcLabelPosition2.arcOuterStart = "arcOuterStart", IMarkCommonArcLabelPosition2.arcOuterEnd = "arcOuterEnd", IMarkCommonArcLabelPosition2.arcOuterMiddle = "arcOuterMiddle", IMarkCommonArcLabelPosition2.center = "center";
}(IMarkCommonArcLabelPosition || (IMarkCommonArcLabelPosition = {}));
var IMarkPointItemPosition;
!function(IMarkPointItemPosition2) {
  IMarkPointItemPosition2.top = "top", IMarkPointItemPosition2.bottom = "bottom", IMarkPointItemPosition2.middle = "middle", IMarkPointItemPosition2.insideTop = "insideTop", IMarkPointItemPosition2.insideBottom = "insideBottom", IMarkPointItemPosition2.insideMiddle = "insideMiddle";
}(IMarkPointItemPosition || (IMarkPointItemPosition = {}));

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/marker/register
function loadBaseMarker() {
  registerGroup(), loadTagComponent();
}
function loadMarkLineComponent() {
  loadBaseMarker(), loadSegmentComponent();
}
function loadMarkArcLineComponent() {
  loadBaseMarker(), loadArcSegmentComponent();
}
function loadMarkAreaComponent() {
  loadBaseMarker(), registerPolygon();
}
function loadMarkArcAreaComponent() {
  loadBaseMarker(), registerArc();
}
function loadMarkPointComponent() {
  loadBaseMarker(), loadSegmentComponent(), loadArcSegmentComponent(), registerSymbol(), registerImage(), registerLine();
}

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/util/limit-shape
function computeOffsetForlimit(shape, bounds) {
  const { x1: regionMinX, y1: regionMinY, x2: regionMaxX, y2: regionMaxY } = bounds, { x1: x14, y1: y14, x2: x23, y2: y23 } = shape.AABBBounds;
  let dx = 0, dy = 0;
  return x14 < regionMinX && (dx = regionMinX - x14), y14 < regionMinY && (dy = regionMinY - y14), x23 > regionMaxX && (dx = regionMaxX - x23), y23 > regionMaxY && (dy = regionMaxY - y23), {
    dx,
    dy
  };
}
function limitShapeInBounds(shape, bounds) {
  const { dx, dy } = computeOffsetForlimit(shape, bounds), { dx: originDx = 0, dy: originDy = 0 } = shape.attribute;
  dx && shape.setAttribute("dx", dx + originDx), dy && shape.setAttribute("dy", dy + originDy);
}

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/marker/base
var Marker = class extends AbstractComponent {
  constructor() {
    super(...arguments), this.name = "marker", this._onHover = (e) => {
      this._lastHover = dispatchHoverState(e, this._container, this._lastHover);
    }, this._onUnHover = (e) => {
      this._lastHover = dispatchUnHoverState(e, this._container, this._lastHover);
    }, this._onClick = (e) => {
      this._lastSelect = dispatchClickState(e, this._container, this._lastSelect);
    };
  }
  transAnimationConfig() {
    var _a, _b, _c;
    if (false !== this.attribute.animation) {
      const animation = isObject_default(this.attribute.animation) ? this.attribute.animation : {};
      this._animationConfig = {
        enter: merge({}, this.defaultUpdateAnimation, animation, null !== (_a = this.attribute.animationEnter) && void 0 !== _a ? _a : {}),
        exit: merge({}, this.defaultExitAnimation, animation, null !== (_b = this.attribute.animationExit) && void 0 !== _b ? _b : {}),
        update: merge({}, this.defaultUpdateAnimation, animation, null !== (_c = this.attribute.animationUpdate) && void 0 !== _c ? _c : {})
      };
    }
  }
  setAttribute(key, value, forceUpdateTag) {
    super.setAttribute(key, value, forceUpdateTag), "visible" === key && this.render();
  }
  _bindEvent() {
    var _a, _b, _c;
    if (!this.attribute.interactive)
      return;
    const { hover, select } = this.attribute;
    hover && (null === (_a = this._container) || void 0 === _a || _a.addEventListener("pointermove", this._onHover), null === (_b = this._container) || void 0 === _b || _b.addEventListener("pointerout", this._onUnHover)), select && (null === (_c = this._container) || void 0 === _c || _c.addEventListener("pointerdown", this._onClick));
  }
  _releaseEvent() {
    var _a, _b, _c;
    null === (_a = this._container) || void 0 === _a || _a.removeEventListener("pointermove", this._onHover), null === (_b = this._container) || void 0 === _b || _b.removeEventListener("pointerout", this._onUnHover), null === (_c = this._container) || void 0 === _c || _c.removeEventListener("pointerdown", this._onClick);
  }
  _initContainer() {
    var _a, _b;
    const { limitRect = {}, clipInRange } = this.attribute;
    let group;
    if (clipInRange) {
      const groupClip = graphicCreator.group(Object.assign(Object.assign({}, limitRect), {
        clip: true,
        pickable: false
      }));
      group = graphicCreator.group({
        x: -(null !== (_a = limitRect.x) && void 0 !== _a ? _a : 0),
        y: -(null !== (_b = limitRect.y) && void 0 !== _b ? _b : 0),
        pickable: false
      }), groupClip.add(group), this._containerClip = groupClip, this.add(groupClip);
    } else
      group = graphicCreator.group({
        x: 0,
        y: 0,
        pickable: false
      }), this.add(group);
    group.name = "marker-container", this._container = group;
  }
  _updateContainer() {
    var _a, _b;
    const { limitRect = {}, clipInRange } = this.attribute;
    this._containerClip && this._containerClip.setAttributes(Object.assign({}, limitRect)), this._container.setAttributes({
      x: clipInRange ? -(null !== (_a = limitRect.x) && void 0 !== _a ? _a : 0) : 0,
      y: clipInRange ? -(null !== (_b = limitRect.y) && void 0 !== _b ? _b : 0) : 0
    });
  }
  render() {
    var _a;
    this.transAnimationConfig(), this.setAttribute("pickable", false);
    const markerVisible = null === (_a = this.attribute.visible) || void 0 === _a || _a;
    false === this.attribute.interactive && this.setAttribute("childrenPickable", false), markerVisible && this.isValidPoints() ? this._container ? (this._updateContainer(), this.updateMarker(), this.markerAnimate("update")) : (this._initContainer(), this.initMarker(this._container), this.markerAnimate("enter")) : (this.markerAnimate("exit"), this._container = null, this.removeAllChild(true)), this._releaseEvent(), this._bindEvent();
  }
  release() {
    this.markerAnimate("exit"), super.release(), this._releaseEvent(), this._container = null;
  }
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/marker/animate/common
function graphicFadeIn(graphic, delay, duration, easing) {
  var _a, _b, _c, _d, _e;
  if (!graphic)
    return;
  null === (_a = null == graphic ? void 0 : graphic.animates) || void 0 === _a || _a.forEach((a3) => a3.stop("end"));
  const fillOpacityConfig = null !== (_c = null === (_b = graphic.attribute) || void 0 === _b ? void 0 : _b.fillOpacity) && void 0 !== _c ? _c : 1, strokeOpacityConfig = null !== (_e = null === (_d = graphic.attribute) || void 0 === _d ? void 0 : _d.strokeOpacity) && void 0 !== _e ? _e : 1;
  graphic.setAttributes({
    fillOpacity: 0,
    strokeOpacity: 0
  }), graphic.animate().wait(delay).to({
    fillOpacity: fillOpacityConfig,
    strokeOpacity: strokeOpacityConfig
  }, duration, easing);
}
function segmentFadeIn(segment, delay, duration, easing) {
  segment && (graphicFadeIn(segment.startSymbol, delay, duration, easing), segment.lines.forEach((line2) => graphicFadeIn(line2, delay, duration, easing)), graphicFadeIn(segment.line, delay, duration, easing), graphicFadeIn(segment.endSymbol, delay, duration, easing));
}
function tagFadeIn(tag, delay, duration, easing) {
  tag && (graphicFadeIn(tag.getTextShape(), delay, duration, easing), graphicFadeIn(tag.getBgRect(), delay, duration, easing));
}
function graphicFadeOut(graphic, delay, duration, easing) {
  var _a, _b, _c, _d;
  graphic && (graphic.setAttributes({
    fillOpacity: null !== (_b = null === (_a = graphic.attribute) || void 0 === _a ? void 0 : _a.fillOpacity) && void 0 !== _b ? _b : 1,
    strokeOpacity: null !== (_d = null === (_c = graphic.attribute) || void 0 === _c ? void 0 : _c.strokeOpacity) && void 0 !== _d ? _d : 1
  }), graphic.animate().wait(delay).to({
    fillOpacity: 0,
    strokeOpacity: 0
  }, duration, easing));
}
function segmentFadeOut(segment, delay, duration, easing) {
  segment && (graphicFadeOut(segment.startSymbol, delay, duration, easing), segment.lines.forEach((line2) => graphicFadeOut(line2, delay, duration, easing)), graphicFadeOut(segment.line, delay, duration, easing), graphicFadeOut(segment.endSymbol, delay, duration, easing));
}
function tagFadeOut(tag, delay, duration, easing) {
  tag && (graphicFadeOut(tag.getTextShape(), delay, duration, easing), graphicFadeOut(tag.getBgRect(), delay, duration, easing));
}

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/marker/animate/clip-in
function commonLineClipIn(line2, label, duration, delay, easing) {
  const startSymbolDuration = 0.1 * duration, lineDuration = 0.7 * duration, endSymbolDuration = 0.1 * duration, labelDuration = 0.1 * duration;
  graphicFadeIn(line2.startSymbol, delay, startSymbolDuration, easing), line2.lines.forEach((line3) => line3.setAttribute("clipRange", 0)), line2.lines.forEach((l, index) => {
    const stepDuration = lineDuration / line2.lines.length;
    l.animate().wait(delay + startSymbolDuration + index * stepDuration).to({
      clipRange: 1
    }, stepDuration, easing);
  }), graphicFadeIn(line2.endSymbol, delay + startSymbolDuration + lineDuration, endSymbolDuration, easing), graphicFadeIn(label.getTextShape(), delay + startSymbolDuration + lineDuration + endSymbolDuration, labelDuration, easing), graphicFadeIn(label.getBgRect(), delay + startSymbolDuration + lineDuration + endSymbolDuration, labelDuration, easing);
}

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/marker/animate/fade-in
function commonLineFadeIn(line2, label, duration, delay, easing) {
  segmentFadeIn(line2, delay, duration, easing), tagFadeIn(label, delay, duration, easing);
}
function areaFadeIn(area2, label, duration, delay, easing) {
  graphicFadeIn(area2, delay, duration, easing), tagFadeIn(label, delay, duration, easing);
}
function pointFadeIn(itemLine, decorativeLine, item, duration, delay, easing) {
  var _a;
  segmentFadeIn(itemLine, delay, duration, easing), graphicFadeIn(decorativeLine, delay, duration, easing), (null === (_a = item.getTextShape) || void 0 === _a ? void 0 : _a.call(item)) ? tagFadeIn(item, delay, duration, easing) : graphicFadeIn(item, delay, duration, easing);
}

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/marker/animate/fade-out
function commonLineFadeOut(line2, label, duration, delay, easing) {
  segmentFadeOut(line2, delay, duration, easing), tagFadeOut(label, delay, duration, easing);
}
function areaFadeOut(area2, label, duration, delay, easing) {
  graphicFadeOut(area2, delay, duration, easing), tagFadeOut(label, delay, duration, easing);
}
function pointFadeOut(itemLine, decorativeLine, item, duration, delay, easing) {
  var _a;
  segmentFadeOut(itemLine, delay, duration, easing), graphicFadeOut(decorativeLine, delay, duration, easing), (null === (_a = item.getTextShape) || void 0 === _a ? void 0 : _a.call(item)) ? tagFadeOut(item, delay, duration, easing) : graphicFadeOut(item, delay, duration, easing);
}

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/marker/animate/call-in
function pointCallIn(itemLine, decorativeLine, item, duration, delay, easing) {
  var _a;
  const startSymbolDuration = 0.1 * duration, lineDuration = 0.65 * duration, decorativeDuration = 0.05 * duration, endSymbolDuration = 0.1 * duration, labelDuration = 0.1 * duration;
  graphicFadeIn(itemLine.startSymbol, delay, startSymbolDuration, easing), itemLine.lines.forEach((line2) => line2.setAttribute("clipRange", 0)), itemLine.lines.forEach((l, index) => {
    const stepDuration = lineDuration / itemLine.lines.length;
    l.animate().wait(delay + startSymbolDuration + index * stepDuration).to({
      clipRange: 1
    }, stepDuration, easing);
  }), graphicFadeIn(decorativeLine, delay + startSymbolDuration + lineDuration, decorativeDuration, easing), graphicFadeIn(itemLine.endSymbol, delay + startSymbolDuration + lineDuration + decorativeDuration, endSymbolDuration, easing), (null === (_a = item.getTextShape) || void 0 === _a ? void 0 : _a.call(item)) ? (graphicFadeIn(item.getTextShape(), delay + startSymbolDuration + lineDuration + decorativeDuration + endSymbolDuration, labelDuration, easing), graphicFadeIn(item.getBgRect(), delay + startSymbolDuration + lineDuration + endSymbolDuration, labelDuration, easing)) : graphicFadeIn(item, delay + startSymbolDuration + lineDuration + endSymbolDuration, labelDuration, easing);
}

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/marker/animate/animate
function markCommonLineAnimate(line2, label, animationconfig, state) {
  const { enter, update: update2, exit } = animationconfig;
  if ("enter" === state) {
    const { type, duration, delay, easing } = enter;
    "clipIn" === type ? commonLineClipIn(line2, label, duration, delay, easing) : "fadeIn" === type && commonLineFadeIn(line2, label, duration, delay, easing);
  } else if ("update" === state) {
    const { type, duration, delay, easing } = update2;
    "clipIn" === type ? commonLineClipIn(line2, label, duration, delay, easing) : "fadeIn" === type && commonLineFadeIn(line2, label, duration, delay, easing);
  } else if ("exit" === state) {
    const { duration, delay, easing } = exit;
    commonLineFadeOut(line2, label, duration, delay, easing);
  }
}
function markAreaAnimate(area2, label, animationconfig, state) {
  const { enter, update: update2, exit } = animationconfig;
  if ("enter" === state) {
    const { type, duration, delay, easing } = enter;
    "fadeIn" === type && areaFadeIn(area2, label, duration, delay, easing);
  } else if ("update" === state) {
    const { type, duration, delay, easing } = update2;
    "fadeIn" === type && areaFadeIn(area2, label, duration, delay, easing);
  } else if ("exit" === state) {
    const { duration, delay, easing } = exit;
    areaFadeOut(area2, label, duration, delay, easing);
  }
}
function markPointAnimate(lines, item, animationconfig, state) {
  const [itemLine, decorativeLine] = lines, { enter, update: update2, exit } = animationconfig;
  if ("enter" === state) {
    const { type, duration, delay, easing } = enter;
    "fadeIn" === type ? pointFadeIn(itemLine, decorativeLine, item, duration, delay, easing) : "callIn" === type && pointCallIn(itemLine, decorativeLine, item, duration, delay, easing);
  } else if ("update" === state) {
    const { type, duration, delay, easing } = update2;
    "fadeIn" === type ? pointFadeIn(itemLine, decorativeLine, item, duration, delay, easing) : "callIn" === type && pointCallIn(itemLine, decorativeLine, item, duration, delay, easing);
  } else if ("exit" === state) {
    const { duration, delay, easing } = exit;
    pointFadeOut(itemLine, decorativeLine, item, duration, delay, easing);
  }
}
var DefaultUpdateMarkLineAnimation = {
  type: "clipIn",
  duration: 500,
  easing: "linear",
  delay: 0
};
var DefaultUpdateMarkAreaAnimation = {
  type: "fadeIn",
  duration: 500,
  easing: "linear",
  delay: 0
};
var DefaultUpdateMarkPointAnimation = {
  type: "callIn",
  duration: 500,
  easing: "linear",
  delay: 0
};
var DefaultExitMarkerAnimation = {
  type: "fadeOut",
  duration: 500,
  easing: "linear",
  delay: 0
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/marker/common-line
var MarkCommonLine = class extends Marker {
  constructor() {
    super(...arguments), this.name = "markCommonLine", this.defaultUpdateAnimation = DefaultUpdateMarkLineAnimation, this.defaultExitAnimation = DefaultExitMarkerAnimation;
  }
  getLine() {
    return this._line;
  }
  getLabel() {
    return this._label;
  }
  setLabelPos() {
    const { label = {}, limitRect } = this.attribute, { position, confine, autoRotate: autoRotate2 } = label, labelPoint = this.getPointAttrByPosition(position), labelAngle = position.toString().toLocaleLowerCase().includes("start") ? this._line.getStartAngle() || 0 : this._line.getEndAngle() || 0;
    if (this._label.setAttributes(Object.assign(Object.assign({}, labelPoint.position), {
      angle: autoRotate2 ? this.getRotateByAngle(labelPoint.angle) : 0,
      textStyle: Object.assign(Object.assign({}, this.getTextStyle(position, labelAngle, autoRotate2)), label.textStyle)
    })), limitRect && confine) {
      const { x, y, width, height } = limitRect;
      limitShapeInBounds(this._label, {
        x1: x,
        y1: y,
        x2: x + width,
        y2: y + height
      });
    }
  }
  initMarker(container2) {
    const { label, state } = this.attribute, line2 = this.createSegment();
    line2.name = "mark-common-line-line", this._line = line2, container2.add(line2);
    const markLabel = new Tag(Object.assign(Object.assign({}, label), {
      state: {
        panel: merge({}, DEFAULT_STATES, null == state ? void 0 : state.labelBackground),
        text: merge({}, DEFAULT_STATES, null == state ? void 0 : state.label)
      }
    }));
    markLabel.name = "mark-common-line-label", this._label = markLabel, container2.add(markLabel), this.setLabelPos();
  }
  updateMarker() {
    const { label, state } = this.attribute;
    this.setLineAttributes(), this._label && (this._label.setAttributes(Object.assign(Object.assign({
      dx: 0,
      dy: 0
    }, label), {
      state: {
        panel: merge({}, DEFAULT_STATES, null == state ? void 0 : state.labelBackground),
        text: merge({}, DEFAULT_STATES, null == state ? void 0 : state.label)
      }
    })), this.setLabelPos());
  }
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/marker/config
var FUZZY_EQUAL_DELTA = 1e-3;
var DEFAULT_MARK_LINE_THEME = {
  interactive: true,
  startSymbol: {
    visible: false,
    symbolType: "triangle",
    size: 12,
    fill: "rgba(46, 47, 50)",
    lineWidth: 0
  },
  endSymbol: {
    visible: true,
    symbolType: "triangle",
    size: 12,
    fill: "rgba(46, 47, 50)",
    lineWidth: 0
  },
  label: {
    position: IMarkLineLabelPosition.end,
    refX: 0,
    refY: 0,
    refAngle: 0,
    textStyle: {
      fill: "#fff",
      stroke: "#fff",
      lineWidth: 0,
      fontSize: 10,
      fontWeight: "normal",
      fontStyle: "normal"
    },
    padding: [2, 2, 4, 4],
    panel: {
      visible: true,
      cornerRadius: 0,
      fill: "rgb(48, 115, 242)",
      fillOpacity: 0.8
    }
  },
  lineStyle: {
    stroke: "#b2bacf",
    lineWidth: 1,
    lineDash: [2]
  }
};
var DEFAULT_CARTESIAN_MARK_LINE_TEXT_STYLE_MAP = {
  postiveXAxis: {
    start: {
      textAlign: "left",
      textBaseline: "middle"
    },
    startTop: {
      textAlign: "left",
      textBaseline: "bottom"
    },
    startBottom: {
      textAlign: "left",
      textBaseline: "top"
    },
    insideStart: {
      textAlign: "right",
      textBaseline: "middle"
    },
    insideStartTop: {
      textAlign: "right",
      textBaseline: "bottom"
    },
    insideStartBottom: {
      textAlign: "right",
      textBaseline: "top"
    },
    middle: {
      textAlign: "center",
      textBaseline: "middle"
    },
    insideMiddleTop: {
      textAlign: "center",
      textBaseline: "bottom"
    },
    insideMiddleBottom: {
      textAlign: "center",
      textBaseline: "top"
    },
    end: {
      textAlign: "left",
      textBaseline: "middle"
    },
    endTop: {
      textAlign: "left",
      textBaseline: "bottom"
    },
    endBottom: {
      textAlign: "left",
      textBaseline: "top"
    },
    insideEnd: {
      textAlign: "right",
      textBaseline: "middle"
    },
    insideEndTop: {
      textAlign: "right",
      textBaseline: "bottom"
    },
    insideEndBottom: {
      textAlign: "right",
      textBaseline: "top"
    }
  },
  negativeXAxis: {
    start: {
      textAlign: "right",
      textBaseline: "middle"
    },
    startTop: {
      textAlign: "right",
      textBaseline: "bottom"
    },
    startBottom: {
      textAlign: "right",
      textBaseline: "top"
    },
    insideStart: {
      textAlign: "left",
      textBaseline: "middle"
    },
    insideStartTop: {
      textAlign: "left",
      textBaseline: "bottom"
    },
    insideStartBottom: {
      textAlign: "left",
      textBaseline: "top"
    },
    middle: {
      textAlign: "center",
      textBaseline: "middle"
    },
    insideMiddleTop: {
      textAlign: "center",
      textBaseline: "bottom"
    },
    insideMiddleBottom: {
      textAlign: "center",
      textBaseline: "top"
    },
    end: {
      textAlign: "right",
      textBaseline: "middle"
    },
    endTop: {
      textAlign: "right",
      textBaseline: "bottom"
    },
    endBottom: {
      textAlign: "right",
      textBaseline: "top"
    },
    insideEnd: {
      textAlign: "left",
      textBaseline: "middle"
    },
    insideEndTop: {
      textAlign: "left",
      textBaseline: "bottom"
    },
    insideEndBottom: {
      textAlign: "left",
      textBaseline: "top"
    }
  }
};
var DEFAULT_MARK_ARC_LINE_THEME = {
  interactive: true,
  startSymbol: {
    visible: false,
    symbolType: "triangle",
    size: 12,
    fill: "rgba(46, 47, 50)",
    lineWidth: 0
  },
  endSymbol: {
    visible: true,
    symbolType: "triangle",
    size: 12,
    fill: "rgba(46, 47, 50)",
    lineWidth: 0
  },
  label: {
    position: IMarkCommonArcLabelPosition.arcOuterMiddle,
    refX: 0,
    refY: 0,
    refAngle: 0,
    textStyle: {
      fill: "#fff",
      stroke: "#fff",
      lineWidth: 0,
      fontSize: 10,
      fontWeight: "normal",
      fontStyle: "normal"
    },
    padding: [2, 2, 4, 4],
    panel: {
      visible: true,
      cornerRadius: 0,
      fill: "rgb(48, 115, 242)",
      fillOpacity: 0.8
    }
  },
  lineStyle: {
    stroke: "#b2bacf",
    lineWidth: 1,
    lineDash: [2]
  }
};
var DEFAULT_MARK_AREA_THEME = {
  interactive: true,
  label: {
    position: IMarkAreaLabelPosition.right,
    textStyle: {
      fill: "#fff",
      stroke: "#fff",
      lineWidth: 0,
      fontSize: 10,
      fontWeight: "normal",
      fontStyle: "normal"
    },
    padding: [2, 2, 4, 4],
    panel: {
      visible: true,
      cornerRadius: 0,
      fill: "rgb(48, 115, 242)",
      fillOpacity: 0.8
    }
  },
  areaStyle: {
    fill: "#b2bacf",
    visible: true
  }
};
var DEFAULT_MARK_ARC_AREA_THEME = {
  interactive: true,
  label: {
    position: IMarkCommonArcLabelPosition.arcOuterMiddle,
    textStyle: {
      fill: "#fff",
      stroke: "#fff",
      lineWidth: 0,
      fontSize: 10,
      fontWeight: "normal",
      fontStyle: "normal"
    },
    padding: [2, 2, 4, 4],
    panel: {
      visible: true,
      cornerRadius: 0,
      fill: "rgb(48, 115, 242)",
      fillOpacity: 0.8
    }
  },
  areaStyle: {
    fill: "#b2bacf",
    visible: true
  }
};
var DEFAULT_POLAR_MARKER_TEXT_STYLE_MAP = {
  arcInnerStart: {
    textAlign: "center",
    textBaseline: "bottom"
  },
  arcInnerEnd: {
    textAlign: "center",
    textBaseline: "bottom"
  },
  arcInnerMiddle: {
    textAlign: "center",
    textBaseline: "bottom"
  },
  arcOuterStart: {
    textAlign: "center",
    textBaseline: "top"
  },
  arcOuterEnd: {
    textAlign: "center",
    textBaseline: "top"
  },
  arcOuterMiddle: {
    textAlign: "center",
    textBaseline: "top"
  },
  center: {
    textAlign: "center",
    textBaseline: "middle"
  }
};
var DEFAULT_CARTESIAN_MARK_AREA_TEXT_STYLE_MAP = {
  left: {
    textAlign: "right",
    textBaseline: "middle"
  },
  insideLeft: {
    textAlign: "left",
    textBaseline: "middle"
  },
  right: {
    textAlign: "left",
    textBaseline: "middle"
  },
  insideRight: {
    textAlign: "right",
    textBaseline: "middle"
  },
  top: {
    textAlign: "center",
    textBaseline: "bottom"
  },
  insideTop: {
    textAlign: "center",
    textBaseline: "top"
  },
  bottom: {
    textAlign: "center",
    textBaseline: "top"
  },
  insideBottom: {
    textAlign: "center",
    textBaseline: "bottom"
  },
  middle: {
    textAlign: "center",
    textBaseline: "middle"
  }
};
var DEFAULT_MARK_POINT_THEME = {
  interactive: true,
  targetSymbol: {
    visible: false,
    offset: 0,
    style: {
      symbolType: "circle",
      size: 20,
      fill: false,
      stroke: "rgba(46, 47, 50)"
    }
  },
  itemLine: {
    visible: true,
    decorativeLine: {
      visible: false,
      length: 30
    },
    startSymbol: {
      visible: true,
      clip: true,
      symbolType: "circle",
      size: 20,
      style: {
        fill: false,
        stroke: "rgba(46, 47, 50)"
      }
    },
    endSymbol: {
      visible: false,
      clip: true,
      symbolType: "triangle",
      size: 12,
      style: {
        fill: false,
        stroke: "rgba(46, 47, 50)"
      }
    },
    lineStyle: {
      stroke: "#000",
      lineWidth: 1
    }
  },
  itemContent: {
    type: "text",
    position: "middle",
    refX: 10,
    symbolStyle: {
      symbolType: "star",
      fill: "rgb(48, 115, 242)",
      fillOpacity: 0.8,
      size: 20
    },
    textStyle: {
      dx: 0,
      dy: 0
    },
    imageStyle: {
      width: 80,
      height: 80
    },
    richTextStyle: {
      width: 100,
      height: 100
    }
  }
};
var DEFAULT_MARK_POINT_TEXT_STYLE_MAP = {
  postiveXAxis: {
    top: {
      textAlign: "left",
      textBaseline: "bottom"
    },
    bottom: {
      textAlign: "left",
      textBaseline: "top"
    },
    middle: {
      textAlign: "left",
      textBaseline: "middle"
    },
    insideTop: {
      textAlign: "right",
      textBaseline: "bottom"
    },
    insideBottom: {
      textAlign: "right",
      textBaseline: "top"
    },
    insideMiddle: {
      textAlign: "right",
      textBaseline: "middle"
    }
  },
  negativeXAxis: {
    top: {
      textAlign: "right",
      textBaseline: "bottom"
    },
    bottom: {
      textAlign: "right",
      textBaseline: "top"
    },
    middle: {
      textAlign: "right",
      textBaseline: "middle"
    },
    insideTop: {
      textAlign: "left",
      textBaseline: "bottom"
    },
    insideBottom: {
      textAlign: "left",
      textBaseline: "top"
    },
    insideMiddle: {
      textAlign: "left",
      textBaseline: "middle"
    }
  }
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/marker/line
loadMarkLineComponent();
function registerMarkLineAnimate() {
  MarkLine._animate = markCommonLineAnimate;
}
var MarkLine = class _MarkLine extends MarkCommonLine {
  markerAnimate(state) {
    _MarkLine._animate && this._animationConfig && _MarkLine._animate(this._line, this._label, this._animationConfig, state);
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _MarkLine.defaultAttributes, attributes)), this.name = "markLine";
  }
  getPointAttrByPosition(position) {
    var _a;
    const { label = {} } = this.attribute, { refX = 0, refY = 0 } = label, points = this._line.getMainSegmentPoints(), lineEndAngle = null !== (_a = this._line.getEndAngle()) && void 0 !== _a ? _a : 0, labelAngle = (isPostiveXAxis(lineEndAngle), lineEndAngle), labelOffsetX = refX * Math.cos(labelAngle) + refY * Math.cos(labelAngle - Math.PI / 2), labelOffsetY = refX * Math.sin(labelAngle) + refY * Math.sin(labelAngle - Math.PI / 2);
    return position.includes("start") || position.includes("Start") ? {
      position: {
        x: points[0].x + labelOffsetX,
        y: points[0].y + labelOffsetY
      },
      angle: labelAngle
    } : position.includes("middle") || position.includes("Middle") ? {
      position: {
        x: (points[0].x + points[points.length - 1].x) / 2 + labelOffsetX,
        y: (points[0].y + points[points.length - 1].y) / 2 + labelOffsetY
      },
      angle: labelAngle
    } : {
      position: {
        x: points[points.length - 1].x + labelOffsetX,
        y: points[points.length - 1].y + labelOffsetY
      },
      angle: labelAngle
    };
  }
  getRotateByAngle(angle2) {
    var _a;
    return (isPostiveXAxis(angle2) ? angle2 : angle2 - Math.PI) + (null !== (_a = this.attribute.label.refAngle) && void 0 !== _a ? _a : 0);
  }
  getTextStyle(position, labelAngle, autoRotate2) {
    return fuzzyEqualNumber(Math.abs(labelAngle), Math.PI / 2, FUZZY_EQUAL_DELTA) || fuzzyEqualNumber(Math.abs(labelAngle), 3 * Math.PI / 2, FUZZY_EQUAL_DELTA) ? getTextAlignAttrOfVerticalDir(autoRotate2, labelAngle, position) : isPostiveXAxis(labelAngle) ? DEFAULT_CARTESIAN_MARK_LINE_TEXT_STYLE_MAP.postiveXAxis[position] : DEFAULT_CARTESIAN_MARK_LINE_TEXT_STYLE_MAP.negativeXAxis[position];
  }
  createSegment() {
    const { points, startSymbol, endSymbol, lineStyle, mainSegmentIndex, multiSegment, state } = this.attribute;
    return new Segment({
      points,
      startSymbol,
      endSymbol,
      lineStyle,
      mainSegmentIndex,
      multiSegment,
      pickable: false,
      state: {
        line: merge({}, DEFAULT_STATES, null == state ? void 0 : state.line),
        startSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineStartSymbol),
        endSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineEndSymbol)
      }
    });
  }
  setLineAttributes() {
    const { points, startSymbol, endSymbol, lineStyle, mainSegmentIndex, multiSegment, state } = this.attribute;
    this._line && this._line.setAttributes({
      points,
      startSymbol,
      endSymbol,
      lineStyle,
      mainSegmentIndex,
      multiSegment,
      state: {
        line: merge({}, DEFAULT_STATES, null == state ? void 0 : state.line),
        startSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineStartSymbol),
        endSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineEndSymbol)
      }
    });
  }
  isValidPoints() {
    const { points } = this.attribute;
    if (!points || points.length < 2)
      return false;
    let validFlag = true;
    return points.forEach((point5) => {
      if (point5.length)
        point5.forEach((p) => {
          isValidNumber_default(p.x) && isValidNumber_default(p.y) || (validFlag = false);
        });
      else if (!isValidNumber_default(point5.x) || !isValidNumber_default(point5.y))
        return void (validFlag = false);
    }), validFlag;
  }
};
MarkLine.defaultAttributes = DEFAULT_MARK_LINE_THEME;

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/marker/area
loadMarkAreaComponent();
function registerMarkAreaAnimate() {
  MarkArea._animate = markAreaAnimate;
}
var MarkArea = class _MarkArea extends Marker {
  markerAnimate(state) {
    _MarkArea._animate && this._animationConfig && _MarkArea._animate(this._area, this._label, this._animationConfig, state);
  }
  getArea() {
    return this._area;
  }
  getLabel() {
    return this._label;
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _MarkArea.defaultAttributes, attributes)), this.name = "markArea", this.defaultUpdateAnimation = DefaultUpdateMarkAreaAnimation, this.defaultExitAnimation = DefaultExitMarkerAnimation;
  }
  getPointAttrByPosition(position) {
    const { x1: x14, x2: x23, y1: y14, y2: y23 } = this._area.AABBBounds;
    return position.includes("left") || position.includes("Left") ? {
      x: x14,
      y: (y14 + y23) / 2
    } : position.includes("right") || position.includes("Right") ? {
      x: x23,
      y: (y14 + y23) / 2
    } : position.includes("top") || position.includes("Top") ? {
      x: (x14 + x23) / 2,
      y: y14
    } : position.includes("bottom") || position.includes("Bottom") ? {
      x: (x14 + x23) / 2,
      y: y23
    } : {
      x: (x14 + x23) / 2,
      y: (y14 + y23) / 2
    };
  }
  setLabelPos() {
    var _a;
    if (this._label && this._area) {
      const { label = {} } = this.attribute, labelPosition = null !== (_a = label.position) && void 0 !== _a ? _a : "middle", labelPoint = this.getPointAttrByPosition(labelPosition);
      if (this._label.setAttributes(Object.assign(Object.assign({}, labelPoint), {
        textStyle: Object.assign(Object.assign({}, DEFAULT_CARTESIAN_MARK_AREA_TEXT_STYLE_MAP[labelPosition]), label.textStyle)
      })), this.attribute.limitRect && label.confine) {
        const { x, y, width, height } = this.attribute.limitRect;
        limitShapeInBounds(this._label, {
          x1: x,
          y1: y,
          x2: x + width,
          y2: y + height
        });
      }
    }
  }
  initMarker(container2) {
    const { points, label, areaStyle, state } = this.attribute, area2 = graphicCreator.polygon(Object.assign({
      points
    }, areaStyle));
    area2.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.area), area2.name = "mark-area-polygon", this._area = area2, container2.add(area2);
    const markLabel = new Tag(Object.assign(Object.assign({}, label), {
      state: {
        panel: merge({}, DEFAULT_STATES, null == state ? void 0 : state.labelBackground),
        text: merge({}, DEFAULT_STATES, null == state ? void 0 : state.label)
      }
    }));
    markLabel.name = "mark-area-label", this._label = markLabel, container2.add(markLabel), this.setLabelPos();
  }
  updateMarker() {
    const { points, label, areaStyle, state } = this.attribute;
    this._area && (this._area.setAttributes(Object.assign({
      points
    }, areaStyle)), this._area.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.area)), this._label && this._label.setAttributes(Object.assign(Object.assign({
      dx: 0,
      dy: 0
    }, label), {
      state: {
        panel: merge({}, DEFAULT_STATES, null == state ? void 0 : state.labelBackground),
        text: merge({}, DEFAULT_STATES, null == state ? void 0 : state.label)
      }
    })), this.setLabelPos();
  }
  isValidPoints() {
    const { points } = this.attribute;
    if (!points || points.length < 3)
      return false;
    let validFlag = true;
    return points.forEach((point5) => {
      isValidNumber_default(point5.x) && isValidNumber_default(point5.y) || (validFlag = false);
    }), validFlag;
  }
};
MarkArea.defaultAttributes = DEFAULT_MARK_AREA_THEME;

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/marker/arc-line
loadMarkArcLineComponent();
var MarkArcLine = class _MarkArcLine extends MarkCommonLine {
  markerAnimate(state) {
    _MarkArcLine._animate && this._animationConfig && _MarkArcLine._animate(this._line, this._label, this._animationConfig, state);
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _MarkArcLine.defaultAttributes, attributes, {
      label: {
        autoRotate: true
      }
    })), this.name = "markArcLine";
  }
  getPointAttrByPosition(direction2) {
    const { center: center2, radius, startAngle, endAngle, label } = this.attribute, { refX = 0, refY = 0 } = label;
    let angle2;
    switch (direction2) {
      case IMarkCommonArcLabelPosition.arcInnerStart:
        angle2 = startAngle;
      case IMarkCommonArcLabelPosition.arcOuterStart:
        angle2 = startAngle;
        break;
      case IMarkCommonArcLabelPosition.arcInnerEnd:
        angle2 = endAngle;
      case IMarkCommonArcLabelPosition.arcOuterEnd:
        angle2 = endAngle;
        break;
      case IMarkCommonArcLabelPosition.center:
      case IMarkCommonArcLabelPosition.arcInnerMiddle:
      case IMarkCommonArcLabelPosition.arcOuterMiddle:
      default:
        angle2 = (startAngle + endAngle) / 2;
    }
    return {
      position: {
        x: center2.x + (radius + refY) * Math.cos(angle2) + refX * Math.cos(angle2 - Math.PI / 2),
        y: center2.y + (radius + refY) * Math.sin(angle2) + refX * Math.sin(angle2 - Math.PI / 2)
      },
      angle: angle2
    };
  }
  getTextStyle(position) {
    return DEFAULT_POLAR_MARKER_TEXT_STYLE_MAP[position];
  }
  getRotateByAngle(angle2) {
    var _a;
    return angle2 - Math.PI / 2 + (null !== (_a = this.attribute.label.refAngle) && void 0 !== _a ? _a : 0);
  }
  createSegment() {
    const { center: center2, radius, startAngle, endAngle, startSymbol, endSymbol, lineStyle, state } = this.attribute;
    return new ArcSegment({
      center: center2,
      radius,
      startAngle,
      endAngle,
      startSymbol,
      endSymbol,
      lineStyle,
      state: {
        line: merge({}, DEFAULT_STATES, null == state ? void 0 : state.line),
        startSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineStartSymbol),
        endSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineEndSymbol)
      }
    });
  }
  setLineAttributes() {
    const { center: center2, radius, startAngle, endAngle, startSymbol, endSymbol, lineStyle, state } = this.attribute;
    this._line && this._line.setAttributes({
      center: center2,
      radius,
      startAngle,
      endAngle,
      startSymbol,
      endSymbol,
      lineStyle,
      state: {
        line: merge({}, DEFAULT_STATES, null == state ? void 0 : state.line),
        startSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineStartSymbol),
        endSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineEndSymbol)
      }
    });
  }
  isValidPoints() {
    return true;
  }
};
MarkArcLine.defaultAttributes = DEFAULT_MARK_ARC_LINE_THEME;

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/marker/arc-area
loadMarkArcAreaComponent();
var MarkArcArea = class _MarkArcArea extends Marker {
  markerAnimate(state) {
    _MarkArcArea._animate && this._animationConfig && _MarkArcArea._animate(this._area, this._label, this._animationConfig, state);
  }
  getArea() {
    return this._area;
  }
  getLabel() {
    return this._label;
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _MarkArcArea.defaultAttributes, attributes, {
      label: {
        autoRotate: true
      }
    })), this.name = "markArcArea", this.defaultUpdateAnimation = DefaultUpdateMarkAreaAnimation, this.defaultExitAnimation = DefaultExitMarkerAnimation;
  }
  getPointAttrByPosition(position) {
    const { center: center2, innerRadius, outerRadius, startAngle, endAngle, label } = this.attribute, { refX = 0, refY = 0 } = label;
    let radius, angle2;
    switch (position) {
      case IMarkCommonArcLabelPosition.center:
        radius = (innerRadius + outerRadius) / 2, angle2 = (startAngle + endAngle) / 2;
        break;
      case IMarkCommonArcLabelPosition.arcInnerStart:
        radius = innerRadius, angle2 = startAngle;
        break;
      case IMarkCommonArcLabelPosition.arcOuterStart:
        radius = outerRadius, angle2 = startAngle;
        break;
      case IMarkCommonArcLabelPosition.arcInnerEnd:
        radius = innerRadius, angle2 = endAngle;
        break;
      case IMarkCommonArcLabelPosition.arcOuterEnd:
        radius = outerRadius, angle2 = endAngle;
        break;
      case IMarkCommonArcLabelPosition.arcInnerMiddle:
        radius = innerRadius, angle2 = (startAngle + endAngle) / 2;
        break;
      case IMarkCommonArcLabelPosition.arcOuterMiddle:
        radius = outerRadius, angle2 = (startAngle + endAngle) / 2;
        break;
      default:
        radius = innerRadius, angle2 = (startAngle + endAngle) / 2;
    }
    return {
      position: {
        x: center2.x + (radius + refY) * Math.cos(angle2) + refX * Math.cos(angle2 - Math.PI / 2),
        y: center2.y + (radius + refY) * Math.sin(angle2) + refX * Math.sin(angle2 - Math.PI / 2)
      },
      angle: angle2
    };
  }
  setLabelPos() {
    var _a;
    if (this._label && this._area) {
      const { label = {} } = this.attribute, { position: labelPosition = "arcInnerMiddle", autoRotate: autoRotate2 } = label, labelAttr = this.getPointAttrByPosition(labelPosition);
      if (this._label.setAttributes(Object.assign(Object.assign({}, labelAttr.position), {
        angle: autoRotate2 ? labelAttr.angle - Math.PI / 2 + (null !== (_a = label.refAngle) && void 0 !== _a ? _a : 0) : 0,
        textStyle: Object.assign(Object.assign({}, DEFAULT_POLAR_MARKER_TEXT_STYLE_MAP[labelPosition]), label.textStyle)
      })), this.attribute.limitRect && label.confine) {
        const { x, y, width, height } = this.attribute.limitRect;
        limitShapeInBounds(this._label, {
          x1: x,
          y1: y,
          x2: x + width,
          y2: y + height
        });
      }
    }
  }
  initMarker(container2) {
    const { center: center2, innerRadius, outerRadius, startAngle, endAngle, areaStyle, label, state } = this.attribute, area2 = graphicCreator.arc(Object.assign({
      x: center2.x,
      y: center2.y,
      innerRadius,
      outerRadius,
      startAngle,
      endAngle
    }, areaStyle));
    area2.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.area), area2.name = "polar-mark-area-area", this._area = area2, container2.add(area2);
    const markLabel = new Tag(Object.assign(Object.assign({}, label), {
      state: {
        panel: merge({}, DEFAULT_STATES, null == state ? void 0 : state.labelBackground),
        text: merge({}, DEFAULT_STATES, null == state ? void 0 : state.label)
      }
    }));
    markLabel.name = "mark-area-label", this._label = markLabel, container2.add(markLabel), this.setLabelPos();
  }
  updateMarker() {
    const { center: center2, innerRadius, outerRadius, startAngle, endAngle, areaStyle, label, state } = this.attribute;
    this._area && (this._area.setAttributes(Object.assign({
      x: center2.x,
      y: center2.y,
      innerRadius,
      outerRadius,
      startAngle,
      endAngle
    }, areaStyle)), this._area.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.area)), this._label && (this._label.setAttributes(Object.assign(Object.assign({
      dx: 0,
      dy: 0
    }, label), {
      state: {
        panel: merge({}, DEFAULT_STATES, null == state ? void 0 : state.labelBackground),
        text: merge({}, DEFAULT_STATES, null == state ? void 0 : state.label)
      }
    })), this.setLabelPos());
  }
  isValidPoints() {
    return true;
  }
};
MarkArcArea.defaultAttributes = DEFAULT_MARK_ARC_AREA_THEME;

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/marker/point
loadMarkPointComponent();
function registerMarkPointAnimate() {
  MarkPoint._animate = markPointAnimate;
}
var MarkPoint = class _MarkPoint extends Marker {
  markerAnimate(state) {
    _MarkPoint._animate && this._animationConfig && _MarkPoint._animate([this._line, this._decorativeLine], this._item, this._animationConfig, state);
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _MarkPoint.defaultAttributes, attributes)), this.name = "markPoint", this.defaultUpdateAnimation = DefaultUpdateMarkPointAnimation, this.defaultExitAnimation = DefaultExitMarkerAnimation, this._isArcLine = false, this._isStraightLine = false;
  }
  setLabelPos() {
  }
  getTextAlignAttr(autoRotate2, offsetX, offsetY, lineEndAngle, itemPosition) {
    return fuzzyEqualNumber(Math.abs(lineEndAngle), Math.PI / 2, FUZZY_EQUAL_DELTA) || fuzzyEqualNumber(Math.abs(lineEndAngle), 3 * Math.PI / 2, FUZZY_EQUAL_DELTA) ? getTextAlignAttrOfVerticalDir(autoRotate2, lineEndAngle, itemPosition) : isPostiveXAxis(lineEndAngle) ? DEFAULT_MARK_POINT_TEXT_STYLE_MAP.postiveXAxis[itemPosition] : DEFAULT_MARK_POINT_TEXT_STYLE_MAP.negativeXAxis[itemPosition];
  }
  setItemAttributes(item, itemContent, newPosition, newItemPosition, itemType) {
    var _a, _b;
    if (!item)
      return;
    const { autoRotate: autoRotate2 = true, refX = 0, refY = 0, refAngle = 0, textStyle = {}, richTextStyle = {}, imageStyle = {}, position: positionType2 = IMarkPointItemPosition.middle } = itemContent, { state } = this.attribute, lineEndAngle = (null === (_a = this._line) || void 0 === _a ? void 0 : _a.getEndAngle()) || 0, itemRefOffsetX = refX * Math.cos(lineEndAngle) + refY * Math.cos(lineEndAngle - Math.PI / 2), itemRefOffsetY = refX * Math.sin(lineEndAngle) + refY * Math.sin(lineEndAngle - Math.PI / 2);
    if ("text" === itemType) {
      const offsetX = newItemPosition.x - newPosition.x, offsetY = newItemPosition.y - newPosition.y;
      item.setAttributes(Object.assign(Object.assign({}, textStyle), {
        textStyle: Object.assign(Object.assign({}, this.getTextAlignAttr(autoRotate2, offsetX, offsetY, lineEndAngle, null !== (_b = itemContent.position) && void 0 !== _b ? _b : "end")), textStyle.textStyle),
        state: {
          panel: merge({}, DEFAULT_STATES, null == state ? void 0 : state.textBackground),
          text: merge({}, DEFAULT_STATES, null == state ? void 0 : state.text)
        }
      }));
    } else
      "richText" === itemType ? (item.setAttributes({
        dx: this.getItemDx(item, positionType2, richTextStyle) + (richTextStyle.dx || 0),
        dy: this.getItemDy(item, positionType2, richTextStyle) + (richTextStyle.dy || 0)
      }), item.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.richText)) : "image" === itemType && (item.setAttributes({
        dx: this.getItemDx(item, positionType2, imageStyle) + (imageStyle.dx || 0),
        dy: this.getItemDy(item, positionType2, imageStyle) + (imageStyle.dy || 0)
      }), item.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.image));
    const itemAngle = isPostiveXAxis(lineEndAngle) ? lineEndAngle : lineEndAngle - Math.PI;
    item.setAttributes({
      x: newItemPosition.x + (itemRefOffsetX || 0),
      y: newItemPosition.y + (itemRefOffsetY || 0),
      angle: autoRotate2 && itemAngle + refAngle
    });
  }
  getItemDx(item, position, style) {
    var _a, _b;
    const width = null !== (_b = null === (_a = null == item ? void 0 : item.AABBBounds) || void 0 === _a ? void 0 : _a.width()) && void 0 !== _b ? _b : (null == style ? void 0 : style.width) || 0;
    return position.includes("inside") ? -width : 0;
  }
  getItemDy(item, position, style) {
    var _a, _b;
    const height = null !== (_b = null === (_a = null == item ? void 0 : item.AABBBounds) || void 0 === _a ? void 0 : _a.height()) && void 0 !== _b ? _b : (null == style ? void 0 : style.height) || 0;
    return position.includes("top") || position.includes("Top") ? -height : position.includes("middle") || position.includes("Middle") ? -height / 2 : 0;
  }
  initItem(itemContent, newPosition, newItemPosition) {
    const { state } = this.attribute, { type = "text", symbolStyle, richTextStyle, imageStyle, renderCustomCallback } = itemContent;
    let item;
    return "symbol" === type ? (item = graphicCreator.symbol(Object.assign(Object.assign({}, newItemPosition), symbolStyle)), item.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.symbol)) : "text" === type ? item = new Tag(Object.assign(Object.assign({}, newItemPosition), {
      state: {
        panel: merge({}, DEFAULT_STATES, null == state ? void 0 : state.textBackground),
        text: merge({}, DEFAULT_STATES, null == state ? void 0 : state.text)
      }
    })) : "richText" === type ? (item = graphicCreator.richtext(Object.assign(Object.assign({}, newItemPosition), richTextStyle)), item.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.richText)) : "image" === type ? (item = graphicCreator.image(Object.assign(Object.assign({}, newItemPosition), imageStyle)), item.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.image)) : "custom" === type && renderCustomCallback && (item = renderCustomCallback(), item.states = merge({}, DEFAULT_STATES, null == state ? void 0 : state.customMark)), item.name = `mark-point-${type}`, this.setItemAttributes(item, itemContent, newPosition, newItemPosition, type), item;
  }
  getItemLineAttr(itemLine, newPosition, newItemPosition) {
    let points = [], center2 = {
      x: 0,
      y: 0
    }, radius = 0, startAngle = 0, endAngle = 0;
    const { type = "type-s", arcRatio = 0.8 } = itemLine, itemOffsetX = newItemPosition.x - newPosition.x, itemOffsetY = newItemPosition.y - newPosition.y;
    if (this._isStraightLine = fuzzyEqualNumber(itemOffsetX, 0, FUZZY_EQUAL_DELTA) || fuzzyEqualNumber(itemOffsetY, 0, FUZZY_EQUAL_DELTA), this._isArcLine) {
      const { x: x14, y: y14 } = newPosition, { x: x23, y: y23 } = newItemPosition, x05 = (x14 + x23) / 2, y05 = (y14 + y23) / 2, k2 = y14 === y23 ? 0 : -(x14 - x23) / (y14 - y23), centerX = x05 + arcRatio * (y23 > y14 ? -1 : 1) * x05, centerY = ((x) => k2 * (x - x05) + y05)(centerX);
      startAngle = deltaXYToAngle(y14 - centerY, x14 - centerX), endAngle = deltaXYToAngle(y23 - centerY, x23 - centerX), center2 = {
        x: centerX,
        y: centerY
      }, arcRatio > 0 ? endAngle < startAngle && (endAngle += 2 * Math.PI) : startAngle < endAngle && (startAngle += 2 * Math.PI), radius = Math.sqrt((centerX - x14) * (centerX - x14) + (centerY - y14) * (centerY - y14));
    } else
      points = "type-do" !== type || this._isStraightLine ? "type-po" !== type || this._isStraightLine ? "type-op" !== type || this._isStraightLine ? [newPosition, newItemPosition] : [newPosition, {
        x: newPosition.x,
        y: newItemPosition.y
      }, newItemPosition] : [newPosition, {
        x: newItemPosition.x,
        y: newPosition.y
      }, newItemPosition] : [newPosition, {
        x: (newPosition.x + newItemPosition.x) / 2,
        y: newItemPosition.y
      }, newItemPosition];
    return points = removeRepeatPoint(points), {
      points,
      center: center2,
      radius,
      startAngle,
      endAngle
    };
  }
  reDrawLine(itemLine, pointsAttr) {
    this._line.release();
    const { startSymbol, endSymbol, lineStyle, type = "type-s" } = itemLine, { state } = this.attribute, lineConstructor = this._isArcLine ? ArcSegment : Segment;
    this._container.removeChild(this._line), this._line = new lineConstructor(Object.assign(Object.assign({}, pointsAttr), {
      pickable: false,
      startSymbol,
      endSymbol,
      lineStyle,
      visible: itemLine.visible,
      state: {
        line: merge({}, DEFAULT_STATES, null == state ? void 0 : state.line),
        startSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineStartSymbol),
        endSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineEndSymbol)
      }
    })), this._container.add(this._line);
  }
  setItemLineAttr(itemLine, newPosition, newItemPosition) {
    if (this._line) {
      const { startSymbol, endSymbol, lineStyle, type = "type-s" } = itemLine, { state } = this.attribute, pointsAttr = this.getItemLineAttr(itemLine, newPosition, newItemPosition);
      this._isArcLine && "arc-segment" === this._line.key || !this._isArcLine && "segment" === this._line.key ? this._line.setAttributes(Object.assign(Object.assign({}, pointsAttr), {
        startSymbol,
        endSymbol,
        lineStyle,
        visible: itemLine.visible,
        state: {
          line: merge({}, DEFAULT_STATES, null == state ? void 0 : state.line),
          startSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineStartSymbol),
          endSymbol: merge({}, DEFAULT_STATES, null == state ? void 0 : state.lineEndSymbol)
        }
      })) : this.reDrawLine(itemLine, pointsAttr);
    }
  }
  getDecorativeLineAttr(itemLine) {
    var _a;
    const decorativeLength = (null === (_a = null == itemLine ? void 0 : itemLine.decorativeLine) || void 0 === _a ? void 0 : _a.length) || 10, itemAngle = this._line.getEndAngle() || 0;
    return {
      startPointOffsetX: decorativeLength / 2 * Math.cos(itemAngle - Math.PI / 2),
      startPointOffsetY: decorativeLength / 2 * Math.sin(itemAngle - Math.PI / 2),
      endPointOffsetX: -decorativeLength / 2 * Math.cos(itemAngle - Math.PI / 2),
      endPointOffsetY: -decorativeLength / 2 * Math.sin(itemAngle - Math.PI / 2)
    };
  }
  setDecorativeLineAttr(itemLine, newItemPosition, visible) {
    var _a;
    if (this._decorativeLine) {
      const { lineStyle } = itemLine, { startPointOffsetX, startPointOffsetY, endPointOffsetX, endPointOffsetY } = this.getDecorativeLineAttr(itemLine);
      this._decorativeLine.setAttributes(Object.assign(Object.assign({
        points: [{
          x: newItemPosition.x + startPointOffsetX,
          y: newItemPosition.y + startPointOffsetY
        }, {
          x: newItemPosition.x + endPointOffsetX,
          y: newItemPosition.y + endPointOffsetY
        }]
      }, lineStyle), {
        visible
      })), this._decorativeLine.states = merge({}, DEFAULT_STATES, null === (_a = this.attribute.state) || void 0 === _a ? void 0 : _a.line);
    }
  }
  setTargetItemAttributes(targetItem, position) {
    var _a, _b;
    this._targetItem && (this._targetItem.setAttributes(Object.assign({
      x: position.x,
      y: position.y,
      visible: null !== (_a = targetItem.visible) && void 0 !== _a && _a
    }, targetItem.style)), this._targetItem.states = merge({}, DEFAULT_STATES, null === (_b = this.attribute.state) || void 0 === _b ? void 0 : _b.targetItem));
  }
  setAllOfItemsAttr(newPosition, newItemPosition) {
    var _a;
    const { position, itemLine = {}, itemContent = {}, limitRect, targetSymbol } = this.attribute, { type = "text", confine } = itemContent;
    if (limitRect && confine) {
      const { x, y, width, height } = limitRect, { dx, dy } = computeOffsetForlimit(this._item, {
        x1: x,
        y1: y,
        x2: x + width,
        y2: y + height
      });
      newItemPosition.x = newItemPosition.x + dx, newItemPosition.y = newItemPosition.y + dy;
    }
    this.setTargetItemAttributes(targetSymbol, position), this.setItemLineAttr(itemLine, newPosition, newItemPosition), this.setItemAttributes(this._item, itemContent, newPosition, newItemPosition, type), this.setDecorativeLineAttr(itemLine, newItemPosition, null === (_a = itemLine.decorativeLine) || void 0 === _a ? void 0 : _a.visible);
  }
  computeNewPositionAfterTargetItem(position) {
    var _a;
    const { itemContent = {}, targetSymbol } = this.attribute, { offsetX: itemContentOffsetX = 0, offsetY: itemContentOffsetY = 0 } = itemContent, { offset: targetSymbolOffset = 0, style: targetSymbolStyle, visible: targetItemvisible = false, size: targetSymbolSize } = targetSymbol, targetSize = targetItemvisible ? targetSymbolSize || (null !== (_a = targetSymbolStyle.size) && void 0 !== _a ? _a : 10) : 0, targetOffsetAngle = deltaXYToAngle(itemContentOffsetY, itemContentOffsetX);
    return {
      newPosition: {
        x: position.x + (targetSize / 2 + targetSymbolOffset) * Math.cos(targetOffsetAngle),
        y: position.y + (targetSize / 2 + targetSymbolOffset) * Math.sin(targetOffsetAngle)
      },
      newItemPosition: {
        x: position.x + (targetSize / 2 + targetSymbolOffset) * Math.cos(targetOffsetAngle) + itemContentOffsetX,
        y: position.y + (targetSize / 2 + targetSymbolOffset) * Math.sin(targetOffsetAngle) + itemContentOffsetY
      }
    };
  }
  initMarker(container2) {
    const { position, itemContent = {}, itemLine } = this.attribute, { type: itemLineType = "type-s", arcRatio = 0.8 } = itemLine, { offsetX = 0, offsetY = 0 } = itemContent;
    this._isStraightLine = fuzzyEqualNumber(offsetX, 0, FUZZY_EQUAL_DELTA) || fuzzyEqualNumber(offsetY, 0, FUZZY_EQUAL_DELTA), this._isArcLine = "type-arc" === itemLineType && 0 !== arcRatio && !this._isStraightLine;
    const { newPosition, newItemPosition } = this.computeNewPositionAfterTargetItem(position), line2 = new (this._isArcLine ? ArcSegment : Segment)({
      points: [],
      pickable: false,
      center: {
        x: 0,
        y: 0
      },
      radius: 0,
      startAngle: 0,
      endAngle: 0
    });
    line2.name = "mark-point-line", this._line = line2, container2.add(line2);
    const decorativeLine = graphicCreator.line({
      points: []
    });
    decorativeLine.name = "mark-point-decorativeLine", this._decorativeLine = decorativeLine, container2.add(decorativeLine);
    const targetItem = graphicCreator.symbol({});
    targetItem.name = "mark-point-targetItem", this._targetItem = targetItem, container2.add(this._targetItem);
    const item = this.initItem(itemContent, newPosition, newItemPosition);
    this._item = item, container2.add(item), this.setAllOfItemsAttr(newPosition, newItemPosition);
  }
  updateMarker() {
    const { position, itemContent = {}, itemLine } = this.attribute, { type = "text" } = itemContent, { type: itemLineType = "type-s", arcRatio = 0.8 } = itemLine, { offsetX = 0, offsetY = 0 } = itemContent;
    this._isStraightLine = fuzzyEqualNumber(offsetX, 0, FUZZY_EQUAL_DELTA) || fuzzyEqualNumber(offsetY, 0, FUZZY_EQUAL_DELTA);
    const isArcLine = "type-arc" === itemLineType && 0 !== arcRatio && !this._isStraightLine, { newPosition, newItemPosition } = this.computeNewPositionAfterTargetItem(position);
    isArcLine !== this._isArcLine ? (this._isArcLine = isArcLine, this.reDrawLine(itemLine, {
      points: [{
        x: 0,
        y: 0
      }],
      pickable: false,
      center: {
        x: 0,
        y: 0
      },
      radius: 0,
      startAngle: 0,
      endAngle: 0
    })) : this._isArcLine = isArcLine, this.setItemAttributes(this._item, itemContent, newPosition, newItemPosition, type), this.setAllOfItemsAttr(newPosition, newItemPosition);
  }
  isValidPoints() {
    const { position } = this.attribute;
    return !(!isValidNumber_default(position.x) || !isValidNumber_default(position.y));
  }
};
MarkPoint.defaultAttributes = DEFAULT_MARK_POINT_THEME;

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/pager/register
function loadPagerComponent() {
  registerGroup(), registerSymbol(), registerText();
}

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/pager/pager
var DEFAULT_HANDLER_STYLE = {
  space: 8,
  style: {
    fill: "rgb(47, 69, 84)",
    cursor: "pointer",
    size: 15
  },
  state: {
    disable: {
      fill: "rgb(170, 170, 170)",
      cursor: "not-allowed"
    },
    hover: {}
  }
};
loadPagerComponent();
var Pager = class _Pager extends AbstractComponent {
  getCurrent() {
    return this._current;
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Pager.defaultAttributes, attributes)), this.name = "pager", this._current = 1, this._onHover = (e) => {
      const target = e.target;
      target.hasState("disable") || target.addState("hover");
    }, this._onUnHover = (e) => {
      e.target.removeState("hover");
    }, this._onClick = (e) => {
      const target = e.target;
      if ("preHandler" === target.name) {
        if (1 === this._current)
          return;
        this._current -= 1, 1 === this._current ? target.addState("disable") : target.removeState("disable"), this._dispatchEvent("toPrev", {
          current: this._current,
          total: this._total,
          direction: "pre",
          event: e
        });
      }
      if ("nextHandler" === target.name) {
        if (this._current === this._total)
          return;
        this._current += 1, this._current === this._total ? target.addState("disable") : target.removeState("disable"), this._dispatchEvent("toNext", {
          current: this._current,
          total: this._total,
          direction: "next",
          event: e
        });
      }
      this._current > 1 && this.preHandler.removeState("disable"), this._current < this._total && this.nextHandler.removeState("disable"), this.text.setAttribute("text", this._getPageText(this._current));
    };
  }
  render() {
    var _a, _b, _c;
    this._reset();
    const { layout = "horizontal", handler = DEFAULT_HANDLER_STYLE, total, defaultCurrent = 1, textStyle, padding = 0 } = this.attribute;
    this._current = defaultCurrent;
    const parsedPadding = normalizePadding(padding), isHorizontal3 = "horizontal" === layout, container2 = graphicCreator.group({
      x: 0,
      y: 0
    }), handlerStyle = handler.style || {}, handlerSize = handlerStyle.size || 15, handlerSpace = null !== (_a = handler.space) && void 0 !== _a ? _a : 8, handlerState = handler.state || {};
    let { preShape, nextShape } = handler;
    preShape || (preShape = isHorizontal3 ? "triangleLeft" : "triangleUp"), nextShape || (nextShape = isHorizontal3 ? "triangleRight" : "triangleDown");
    const preHandler = graphicCreator.symbol(Object.assign(Object.assign({
      strokeBoundsBuffer: 0,
      pickMode: "imprecise"
    }, handlerStyle), {
      x: 0,
      y: 0,
      symbolType: preShape,
      size: handlerSize
    }));
    preHandler.states = handlerState, preHandler.name = "preHandler", this.preHandler = preHandler, container2.add(preHandler);
    const { width: maxTextWidth, height: maxTextHeight } = measureTextSize(this._getPageText(total), Object.assign({
      textAlign: "center",
      textBaseline: "middle"
    }, textStyle), null === (_c = null === (_b = this.stage) || void 0 === _b ? void 0 : _b.getTheme()) || void 0 === _c ? void 0 : _c.text), handlerSizeX = isNumber_default(handlerSize) ? handlerSize : handlerSize[0], handlerSizeY = isNumber_default(handlerSize) ? handlerSize : handlerSize[1], text2 = graphicCreator.text(Object.assign({
      x: isHorizontal3 ? handlerSizeX / 2 + handlerSpace + maxTextWidth / 2 : 0,
      y: isHorizontal3 ? 0 : handlerSizeY / 2 + handlerSpace + maxTextHeight / 2,
      text: this._getPageText(defaultCurrent),
      textAlign: "center",
      textBaseline: "middle",
      lineHeight: null == textStyle ? void 0 : textStyle.fontSize
    }, textStyle));
    this.text = text2, container2.add(text2);
    const nextHandler = graphicCreator.symbol(Object.assign(Object.assign({
      strokeBoundsBuffer: 0,
      pickMode: "imprecise"
    }, handlerStyle), {
      x: isHorizontal3 ? handlerSizeX + 2 * handlerSpace + maxTextWidth : 0,
      y: isHorizontal3 ? 0 : handlerSizeY + 2 * handlerSpace + maxTextHeight,
      symbolType: nextShape,
      size: handlerSize
    }));
    nextHandler.name = "nextHandler", nextHandler.states = handlerState, this.nextHandler = nextHandler, container2.add(nextHandler), 1 === this._total ? (preHandler.addState("disable"), nextHandler.addState("disable")) : 1 === this._current ? preHandler.addState("disable") : this._current === total && nextHandler.addState("disable");
    const containerBounds = container2.AABBBounds, width = containerBounds.width(), height = containerBounds.height();
    container2.translateTo(0 - containerBounds.x1 + parsedPadding[3], 0 - containerBounds.y1 + parsedPadding[0]), this.add(container2), this.attribute.width = width + parsedPadding[1] + parsedPadding[3], this.attribute.height = height + parsedPadding[0] + parsedPadding[2], this._bindEvents();
  }
  _bindEvents() {
    this.attribute.disableTriggerEvent || (this.preHandler && (this.preHandler.addEventListener("pointerenter", this._onHover), this.preHandler.addEventListener("pointerleave", this._onUnHover), this.preHandler.addEventListener("pointerdown", this._onClick)), this.nextHandler && (this.nextHandler.addEventListener("pointerenter", this._onHover), this.nextHandler.addEventListener("pointerleave", this._onUnHover), this.nextHandler.addEventListener("pointerdown", this._onClick)));
  }
  _reset() {
    this.removeAllChild(true), this._current = 1, this._total = this.attribute.total, this.preHandler = this.nextHandler = this.text = null;
  }
  _getPageText(current) {
    const { pageFormatter } = this.attribute;
    return pageFormatter ? isFunction_default(pageFormatter) ? pageFormatter(current, this._total) : `${pageFormatter}`.replace("{current}", `${current}`).replace("{total}", `${this._total}`) : `${current}/${this._total}`;
  }
  setTotal(total) {
    total !== this.attribute.total && (this._total = total, 1 !== this._current && this._current <= total ? this.setAttributes({
      total,
      defaultCurrent: this._current
    }) : this.setAttribute("total", total));
  }
};
Pager.defaultAttributes = {
  handler: DEFAULT_HANDLER_STYLE,
  textStyle: {
    fill: "rgb(51, 51, 51)",
    fontSize: 12
  }
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/legend/constant
var DEFAULT_SHAPE_SIZE = 10;
var DEFAULT_SHAPE_SPACE = 8;
var DEFAULT_LABEL_SPACE = 8;
var DEFAULT_VALUE_SPACE = 8;
var DEFAULT_ITEM_SPACE_COL = 16;
var DEFAULT_ITEM_SPACE_ROW = 8;
var DEFAULT_TITLE_SPACE = 12;
var DEFAULT_PAGER_SPACE = 12;
var LegendStateValue;
!function(LegendStateValue2) {
  LegendStateValue2.selected = "selected", LegendStateValue2.unSelected = "unSelected", LegendStateValue2.selectedHover = "selectedHover", LegendStateValue2.unSelectedHover = "unSelectedHover", LegendStateValue2.focus = "focus";
}(LegendStateValue || (LegendStateValue = {}));
var LegendEvent;
!function(LegendEvent2) {
  LegendEvent2.legendItemHover = "legendItemHover", LegendEvent2.legendItemUnHover = "legendItemUnHover", LegendEvent2.legendItemClick = "legendItemClick", LegendEvent2.legendItemAttributeUpdate = "legendItemAttributeUpdate";
}(LegendEvent || (LegendEvent = {}));
var LEGEND_ELEMENT_NAME;
!function(LEGEND_ELEMENT_NAME2) {
  LEGEND_ELEMENT_NAME2.innerView = "innerView", LEGEND_ELEMENT_NAME2.title = "legendTitle", LEGEND_ELEMENT_NAME2.item = "legendItem", LEGEND_ELEMENT_NAME2.itemShape = "legendItemShape", LEGEND_ELEMENT_NAME2.itemLabel = "legendItemLabel", LEGEND_ELEMENT_NAME2.itemValue = "legendItemValue", LEGEND_ELEMENT_NAME2.focus = "legendItemFocus";
}(LEGEND_ELEMENT_NAME || (LEGEND_ELEMENT_NAME = {}));

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/legend/base
var LegendBase = class extends AbstractComponent {
  constructor() {
    super(...arguments), this.name = "legend", this._title = null;
  }
  render() {
    this.removeAllChild(true);
    const { interactive = true, title: title3, padding = 0 } = this.attribute, parsedPadding = normalizePadding(padding), innerView = graphicCreator.group({
      x: parsedPadding[3],
      y: parsedPadding[0],
      pickable: interactive,
      childrenPickable: interactive
    });
    innerView.name = LEGEND_ELEMENT_NAME.innerView, this.add(innerView), this._innerView = innerView, (null == title3 ? void 0 : title3.visible) && this._renderTitle(title3), this._renderContent(), this._adjustLayout(), interactive && this._bindEvents();
    const viewBounds = this._innerView.AABBBounds;
    this.attribute.width = viewBounds.width() + parsedPadding[1] + parsedPadding[3], this.attribute.height = viewBounds.height() + parsedPadding[0] + parsedPadding[2];
  }
  _renderTitle(title3) {
    const { text: text2 = "", textStyle, padding = 0, background, minWidth, maxWidth, shape } = title3, tagAttrs = {
      x: 0,
      y: 0,
      text: text2,
      textStyle,
      padding: normalizePadding(padding),
      minWidth,
      maxWidth
    };
    shape && shape.visible && (tagAttrs.shape = Object.assign({
      visible: true
    }, shape.style), isValid_default(shape.space) && (tagAttrs.space = shape.space)), background && background.visible && (tagAttrs.panel = Object.assign({
      visible: true
    }, background.style));
    const titleTag = new Tag(tagAttrs);
    titleTag.name = LEGEND_ELEMENT_NAME.title, this._title = titleTag, this._innerView.add(titleTag);
  }
  _adjustLayout() {
    var _a;
    if (this._title) {
      const innerViewWidth = this._innerView.AABBBounds.width(), titleWidth = this._title.AABBBounds.width(), align = null === (_a = this.attribute.title) || void 0 === _a ? void 0 : _a.align;
      "center" === align ? this._title.setAttribute("x", (innerViewWidth - titleWidth) / 2) : "end" === align && this._title.setAttribute("x", innerViewWidth - titleWidth);
    }
  }
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/slider/register
function loadSliderComponent() {
  registerGroup(), registerText(), registerRect(), registerSymbol();
}

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/legend/register
function loadBaseLegend() {
  registerGroup(), loadTagComponent();
}
function loadDiscreteLegendComponent() {
  loadBaseLegend(), loadPagerComponent(), loadScrollbarComponent();
}
function loadColorContinuousLegendComponent() {
  loadBaseLegend(), loadSliderComponent();
}
function loadSizeContinuousLegendComponent() {
  loadBaseLegend(), loadSliderComponent(), registerPath();
}

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/legend/discrete/discrete
var __rest6 = function(s2, e) {
  var t = {};
  for (var p in s2)
    Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++)
      e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var DEFAULT_STATES3 = {
  [LegendStateValue.focus]: {},
  [LegendStateValue.selected]: {},
  [LegendStateValue.selectedHover]: {},
  [LegendStateValue.unSelected]: {},
  [LegendStateValue.unSelectedHover]: {}
};
loadDiscreteLegendComponent();
var DiscreteLegend = class _DiscreteLegend extends LegendBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _DiscreteLegend.defaultAttributes, attributes)), this.name = "discreteLegend", this._itemsContainer = null, this._itemHeightByUser = void 0, this._itemHeight = 0, this._itemMaxWidth = 0, this._onHover = (e) => {
      const target = e.target;
      if (target && target.name && target.name.startsWith(LEGEND_ELEMENT_NAME.item)) {
        const legendItem = target.delegate;
        if (this._lastActiveItem) {
          if (this._lastActiveItem.id === legendItem.id)
            return;
          this._unHover(this._lastActiveItem, e);
        }
        this._hover(legendItem, e);
      } else
        this._lastActiveItem && (this._unHover(this._lastActiveItem, e), this._lastActiveItem = null);
    }, this._onUnHover = (e) => {
      this._lastActiveItem && (this._unHover(this._lastActiveItem, e), this._lastActiveItem = null);
    }, this._onClick = (e) => {
      var _a, _b, _c, _d;
      const target = e.target;
      if (target && target.name && target.name.startsWith(LEGEND_ELEMENT_NAME.item)) {
        const legendItem = target.delegate, { selectMode = "multiple" } = this.attribute;
        if (target.name === LEGEND_ELEMENT_NAME.focus || "focus" === selectMode) {
          const isFocusSelected = legendItem.hasState(LegendStateValue.focus);
          legendItem.toggleState(LegendStateValue.focus), isFocusSelected ? null === (_a = this._itemsContainer) || void 0 === _a || _a.getChildren().forEach((item) => {
            this._removeLegendItemState(item, [LegendStateValue.unSelected, LegendStateValue.unSelectedHover, LegendStateValue.focus], e), this._setLegendItemState(item, LegendStateValue.selected, e);
          }) : (this._setLegendItemState(legendItem, LegendStateValue.selected, e), this._removeLegendItemState(legendItem, [LegendStateValue.unSelected, LegendStateValue.unSelectedHover], e), null === (_b = this._itemsContainer) || void 0 === _b || _b.getChildren().forEach((item) => {
            legendItem !== item && (this._removeLegendItemState(item, [LegendStateValue.selected, LegendStateValue.selectedHover, LegendStateValue.focus], e), this._setLegendItemState(item, LegendStateValue.unSelected, e));
          }));
        } else {
          null === (_c = this._itemsContainer) || void 0 === _c || _c.getChildren().forEach((item) => {
            item.removeState(LegendStateValue.focus);
          });
          const { allowAllCanceled = true } = this.attribute, isSelected = legendItem.hasState(LegendStateValue.selected), currentSelectedItems = this._getSelectedLegends();
          if ("multiple" === selectMode) {
            if (false === allowAllCanceled && isSelected && 1 === currentSelectedItems.length)
              return void this._dispatchLegendEvent(LegendEvent.legendItemClick, legendItem, e);
            isSelected ? (this._removeLegendItemState(legendItem, [LegendStateValue.selected, LegendStateValue.selectedHover], e), this._setLegendItemState(legendItem, LegendStateValue.unSelected, e)) : (this._setLegendItemState(legendItem, LegendStateValue.selected, e), this._removeLegendItemState(legendItem, [LegendStateValue.unSelected, LegendStateValue.unSelectedHover], e));
          } else
            this._setLegendItemState(legendItem, LegendStateValue.selected, e), this._removeLegendItemState(legendItem, [LegendStateValue.unSelected, LegendStateValue.unSelectedHover], e), null === (_d = this._itemsContainer) || void 0 === _d || _d.getChildren().forEach((item) => {
              legendItem !== item && (this._removeLegendItemState(item, [LegendStateValue.selected, LegendStateValue.selectedHover], e), this._setLegendItemState(item, LegendStateValue.unSelected, e));
            });
        }
        this._dispatchLegendEvent(LegendEvent.legendItemClick, legendItem, e);
      }
    };
  }
  render() {
    super.render(), this._lastActiveItem = null;
  }
  setSelected(selectedData) {
    var _a;
    (null === (_a = this._itemsContainer) || void 0 === _a ? void 0 : _a.getChildren()).forEach((item) => {
      const itemData = item.data;
      selectedData.includes(itemData.label) ? (this._setLegendItemState(item, LegendStateValue.selected), this._removeLegendItemState(item, [LegendStateValue.unSelected, LegendStateValue.unSelectedHover])) : (this._removeLegendItemState(item, [LegendStateValue.selected, LegendStateValue.selectedHover]), this._setLegendItemState(item, LegendStateValue.unSelected));
    });
  }
  _renderItems() {
    const { item: itemAttrs = {}, maxCol = 1, maxRow = 2, maxWidth, maxHeight, defaultSelected, lazyload, autoPage } = this.attribute, { spaceCol = DEFAULT_ITEM_SPACE_COL, spaceRow = DEFAULT_ITEM_SPACE_ROW } = itemAttrs, itemsContainer = this._itemsContainer, { items: legendItems, isHorizontal: isHorizontal3, startIndex, isScrollbar } = this._itemContext, maxPages = isScrollbar ? 1 : isHorizontal3 ? maxRow : maxCol;
    let item, { doWrap, maxWidthInCol, startX, startY, pages } = this._itemContext;
    for (let index = startIndex, len = legendItems.length; index < len && !(lazyload && pages > this._itemContext.currentPage * maxPages); index++) {
      lazyload && (this._itemContext.startIndex = index + 1), item = legendItems[index], item.id || (item.id = item.label), item.index = index;
      let isSelected = true;
      isArray_default(defaultSelected) && (isSelected = defaultSelected.includes(item.label));
      const itemGroup = this._renderEachItem(item, isSelected, index, legendItems), itemWidth = itemGroup.attribute.width, itemHeight = itemGroup.attribute.height;
      this._itemHeight = Math.max(this._itemHeight, itemHeight), maxWidthInCol = Math.max(itemWidth, maxWidthInCol), this._itemMaxWidth = Math.max(itemWidth, this._itemMaxWidth), isHorizontal3 ? (isValid_default(maxWidth) && (isScrollbar && autoPage ? (pages = Math.ceil((startX + itemWidth) / maxWidth), doWrap = pages > 1) : startX + itemWidth > maxWidth && (doWrap = true, startX > 0 && (pages += 1, startX = 0, startY += itemHeight + spaceRow))), 0 === startX && 0 === startY || itemGroup.setAttributes({
        x: startX,
        y: startY
      }), startX += spaceCol + itemWidth) : (isValid_default(maxHeight) && (isScrollbar && autoPage ? (pages = Math.ceil((startY + itemHeight) / maxHeight), doWrap = pages > 1) : maxHeight < startY + itemHeight && (pages += 1, doWrap = true, startY = 0, startX += maxWidthInCol + spaceCol, maxWidthInCol = 0)), 0 === startX && 0 === startY || itemGroup.setAttributes({
        x: startX,
        y: startY
      }), startY += spaceRow + itemHeight), itemsContainer.add(itemGroup);
    }
    return this._itemContext.doWrap = doWrap, this._itemContext.startX = startX, this._itemContext.startY = startY, this._itemContext.maxWidthInCol = maxWidthInCol, this._itemContext.pages = pages, this._itemContext.maxPages = maxPages, isScrollbar && (this._itemContext.totalPage = pages), lazyload || (this._itemContext.startIndex = legendItems.length), this._itemContext;
  }
  _renderContent() {
    const { item = {}, items, reversed, maxWidth } = this.attribute;
    if (false === item.visible || isEmpty_default(items))
      return;
    let legendItems = items;
    reversed && (legendItems = null == items ? void 0 : items.reverse());
    const itemsContainer = graphicCreator.group({
      x: 0,
      y: 0
    });
    this._itemsContainer = itemsContainer;
    const { layout, autoPage } = this.attribute, isHorizontal3 = "horizontal" === layout, { maxWidth: maxItemWidth, width: itemWidth, height: itemHeight } = item, widthsOptions = [];
    isValid_default(maxItemWidth) && widthsOptions.push(maxItemWidth), isValid_default(itemWidth) && widthsOptions.push(itemWidth), widthsOptions.length && (isValid_default(maxWidth) && widthsOptions.push(maxWidth), this._itemWidthByUser = minInArray(widthsOptions)), isValid_default(itemHeight) && (this._itemHeightByUser = itemHeight);
    const pager = this.attribute.pager;
    this._itemContext = {
      currentPage: pager && pager.defaultCurrent || 1,
      doWrap: false,
      maxWidthInCol: 0,
      maxPages: 1,
      pages: 1,
      startX: 0,
      startY: 0,
      startIndex: 0,
      items: legendItems,
      isHorizontal: isHorizontal3,
      totalPage: 1 / 0,
      isScrollbar: pager && "scrollbar" === pager.type
    }, this._itemContext = this._renderItems();
    let pagerRendered = false;
    this._itemContext.doWrap && autoPage && this._itemContext.pages > this._itemContext.maxPages && (pagerRendered = this._renderPagerComponent()), pagerRendered || (itemsContainer.setAttribute("y", this._title ? this._title.AABBBounds.height() + get_default(this.attribute, "title.space", 8) : 0), this._innerView.add(itemsContainer));
  }
  _bindEvents() {
    if (this.attribute.disableTriggerEvent)
      return;
    if (!this._itemsContainer)
      return;
    const { hover = true, select = true } = this.attribute;
    hover && (this._itemsContainer.addEventListener("pointermove", this._onHover), this._itemsContainer.addEventListener("pointerleave", this._onUnHover)), select && this._itemsContainer.addEventListener("pointerdown", this._onClick);
  }
  _autoEllipsis(autoEllipsisStrategy, layoutWidth, labelShape, valueShape) {
    var _a, _b;
    const { label: labelAttr, value: valueAttr } = this.attribute.item, valueBounds = valueShape.AABBBounds, labelBounds = labelShape.AABBBounds, valueWidth = valueBounds.width(), labelWidth = labelBounds.width();
    let useWidthRatio = false;
    "labelFirst" === autoEllipsisStrategy ? labelWidth > layoutWidth ? useWidthRatio = true : valueShape.setAttribute("maxLineWidth", layoutWidth - labelWidth) : "valueFirst" === autoEllipsisStrategy ? valueWidth > layoutWidth ? useWidthRatio = true : labelShape.setAttribute("maxLineWidth", layoutWidth - valueWidth) : valueWidth + labelWidth > layoutWidth && (useWidthRatio = true), useWidthRatio && (valueShape.setAttribute("maxLineWidth", Math.max(layoutWidth * (null !== (_a = labelAttr.widthRatio) && void 0 !== _a ? _a : 0.5), layoutWidth - labelWidth)), labelShape.setAttribute("maxLineWidth", Math.max(layoutWidth * (null !== (_b = valueAttr.widthRatio) && void 0 !== _b ? _b : 0.5), layoutWidth - valueWidth)));
  }
  _renderEachItem(item, isSelected, index, items) {
    var _a, _b;
    const { id: id2, label, value, shape } = item, { padding = 0, focus, focusIconStyle, align, autoEllipsisStrategy } = this.attribute.item, { shape: shapeAttr, label: labelAttr, value: valueAttr, background } = this.attribute.item, shapeStyle = this._handleStyle(shapeAttr, item, isSelected, index, items), labelStyle = this._handleStyle(labelAttr, item, isSelected, index, items), valueStyle = this._handleStyle(valueAttr, item, isSelected, index, items), backgroundStyle = this._handleStyle(background, item, isSelected, index, items), parsedPadding = normalizePadding(padding);
    let itemGroup;
    false === background.visible ? (itemGroup = graphicCreator.group({
      x: 0,
      y: 0,
      cursor: null === (_a = backgroundStyle.style) || void 0 === _a ? void 0 : _a.cursor
    }), this._appendDataToShape(itemGroup, LEGEND_ELEMENT_NAME.item, item, itemGroup)) : (itemGroup = graphicCreator.group(Object.assign({
      x: 0,
      y: 0
    }, backgroundStyle.style)), this._appendDataToShape(itemGroup, LEGEND_ELEMENT_NAME.item, item, itemGroup, backgroundStyle.state)), itemGroup.id = `${null != id2 ? id2 : label}-${index}`, itemGroup.addState(isSelected ? LegendStateValue.selected : LegendStateValue.unSelected);
    const innerGroup = graphicCreator.group({
      x: 0,
      y: 0,
      pickable: false
    });
    itemGroup.add(innerGroup);
    let focusShape, focusStartX = 0, shapeSize = 0, shapeSpace = 0;
    if (shapeAttr && false !== shapeAttr.visible) {
      const s2 = get_default(shapeStyle, "style.size", DEFAULT_SHAPE_SIZE);
      shapeSize = isArray_default(s2) ? s2[0] || 0 : s2, shapeSpace = get_default(shapeAttr, "space", DEFAULT_SHAPE_SPACE);
      const itemShape = graphicCreator.symbol(Object.assign(Object.assign({
        x: 0,
        y: 0,
        symbolType: "circle",
        strokeBoundsBuffer: 0
      }, shape), shapeStyle.style));
      Object.keys(shapeStyle.state || {}).forEach((key) => {
        const color = shapeStyle.state[key].fill || shapeStyle.state[key].stroke;
        shape.fill && isNil_default(shapeStyle.state[key].fill) && color && (shapeStyle.state[key].fill = color), shape.stroke && isNil_default(shapeStyle.state[key].stroke) && color && (shapeStyle.state[key].stroke = color);
      }), this._appendDataToShape(itemShape, LEGEND_ELEMENT_NAME.itemShape, item, itemGroup, shapeStyle.state), itemShape.addState(isSelected ? LegendStateValue.selected : LegendStateValue.unSelected), innerGroup.add(itemShape);
    }
    let focusSpace = 0;
    if (focus) {
      const focusSize = get_default(focusIconStyle, "size", DEFAULT_SHAPE_SIZE);
      focusShape = graphicCreator.symbol(Object.assign(Object.assign({
        x: 0,
        y: -focusSize / 2 - 1,
        strokeBoundsBuffer: 0
      }, focusIconStyle), {
        visible: true,
        pickMode: "imprecise",
        boundsPadding: parsedPadding
      })), this._appendDataToShape(focusShape, LEGEND_ELEMENT_NAME.focus, item, itemGroup), focusSpace = focusSize;
    }
    const text2 = labelAttr.formatMethod ? labelAttr.formatMethod(label, item, index) : label, labelAttributes = Object.assign(Object.assign({
      x: shapeSize / 2 + shapeSpace,
      y: 0,
      textAlign: "start",
      textBaseline: "middle",
      lineHeight: null === (_b = labelStyle.style) || void 0 === _b ? void 0 : _b.fontSize
    }, labelStyle.style), {
      text: text2,
      _originText: labelAttr.formatMethod ? label : void 0
    }), labelShape = createTextGraphicByType(labelAttributes);
    this._appendDataToShape(labelShape, LEGEND_ELEMENT_NAME.itemLabel, item, itemGroup, labelStyle.state), labelShape.addState(isSelected ? LegendStateValue.selected : LegendStateValue.unSelected), innerGroup.add(labelShape);
    const labelSpace = get_default(labelAttr, "space", DEFAULT_LABEL_SPACE);
    if (isValid_default(value)) {
      const valueSpace = get_default(valueAttr, "space", focus ? DEFAULT_VALUE_SPACE : 0), valueText = valueAttr.formatMethod ? valueAttr.formatMethod(value, item, index) : value, valueAttributes = Object.assign(Object.assign({
        x: 0,
        y: 0,
        textAlign: "start",
        textBaseline: "middle",
        lineHeight: valueStyle.style.fontSize
      }, valueStyle.style), {
        text: valueText,
        _originText: valueAttr.formatMethod ? value : void 0
      }), valueShape = createTextGraphicByType(valueAttributes);
      if (this._appendDataToShape(valueShape, LEGEND_ELEMENT_NAME.itemValue, item, itemGroup, valueStyle.state), valueShape.addState(isSelected ? LegendStateValue.selected : LegendStateValue.unSelected), this._itemWidthByUser) {
        const layoutWidth = this._itemWidthByUser - parsedPadding[1] - parsedPadding[3] - shapeSize - shapeSpace - labelSpace - focusSpace - valueSpace;
        this._autoEllipsis(autoEllipsisStrategy, layoutWidth, labelShape, valueShape), valueAttr.alignRight ? valueShape.setAttributes({
          textAlign: "right",
          x: this._itemWidthByUser - shapeSize / 2 - parsedPadding[1] - parsedPadding[3] - focusSpace - valueSpace
        }) : valueShape.setAttribute("x", valueSpace + (labelShape.AABBBounds.empty() ? 0 : labelShape.AABBBounds.x2));
      } else
        valueShape.setAttribute("x", valueSpace + (labelShape.AABBBounds.empty() ? 0 : labelShape.AABBBounds.x2));
      focusStartX = valueSpace + (valueShape.AABBBounds.empty() ? 0 : valueShape.AABBBounds.x2), innerGroup.add(valueShape);
    } else
      this._itemWidthByUser ? (labelShape.setAttribute("maxLineWidth", this._itemWidthByUser - parsedPadding[1] - parsedPadding[3] - shapeSize - shapeSpace - focusSpace), focusStartX = labelSpace + (labelShape.AABBBounds.empty() ? 0 : labelShape.AABBBounds.x2)) : focusStartX = labelSpace + (labelShape.AABBBounds.empty() ? 0 : labelShape.AABBBounds.x2);
    focusShape && (focusShape.setAttribute("x", focusStartX), innerGroup.add(focusShape));
    const innerGroupBounds = innerGroup.AABBBounds, innerGroupWidth = innerGroupBounds.width();
    if ("right" === align) {
      const x23 = innerGroupBounds.x2, x14 = innerGroupBounds.x1;
      innerGroup.forEachChildren((child, index2) => {
        "symbol" !== child.type && "right" !== child.attribute.textAlign || child === focusShape ? child.setAttribute("x", x14 + x23 - child.attribute.x - child.AABBBounds.width()) : "symbol" !== child.type ? child.setAttributes({
          x: x14 + x23 - child.attribute.x,
          textAlign: "left"
        }) : child.setAttribute("x", x14 + x23 - child.attribute.x);
      });
    }
    const innerGroupHeight = innerGroupBounds.height(), itemGroupWidth = isValid_default(this.attribute.item.width) ? this.attribute.item.width : innerGroupWidth + parsedPadding[1] + parsedPadding[3], itemGroupHeight = this._itemHeightByUser || innerGroupHeight + parsedPadding[0] + parsedPadding[2];
    return itemGroup.attribute.width = itemGroupWidth, itemGroup.attribute.height = itemGroupHeight, focusShape && focusShape.setAttribute("visible", false), innerGroup.translateTo(-innerGroupBounds.x1 + parsedPadding[3], -innerGroupBounds.y1 + parsedPadding[0]), itemGroup;
  }
  _createPager(compStyle) {
    var _a, _b;
    const { disableTriggerEvent, maxRow } = this.attribute;
    return this._itemContext.isHorizontal ? new Pager(Object.assign(Object.assign({
      layout: 1 === maxRow ? "horizontal" : "vertical",
      total: 99
    }, merge({
      handler: {
        preShape: "triangleUp",
        nextShape: "triangleDown"
      }
    }, compStyle)), {
      defaultCurrent: null === (_a = this.attribute.pager) || void 0 === _a ? void 0 : _a.defaultCurrent,
      disableTriggerEvent
    })) : new Pager(Object.assign({
      layout: "horizontal",
      total: 99,
      disableTriggerEvent,
      defaultCurrent: null === (_b = this.attribute.pager) || void 0 === _b ? void 0 : _b.defaultCurrent
    }, compStyle));
  }
  _createScrollbar(compStyle, compSize) {
    const { disableTriggerEvent } = this.attribute;
    return this._itemContext.isHorizontal ? new ScrollBar(Object.assign(Object.assign({
      direction: "horizontal",
      disableTriggerEvent,
      range: [0, 0.5],
      height: 12
    }, compStyle), {
      width: compSize
    })) : new ScrollBar(Object.assign(Object.assign({
      direction: "vertical",
      width: 12,
      range: [0, 0.5]
    }, compStyle), {
      height: compSize,
      disableTriggerEvent
    }));
  }
  _updatePositionOfPager(contentWidth, contentHeight, renderStartY, compWidth, compHeight) {
    const { maxHeight, pager } = this.attribute, { totalPage, isHorizontal: isHorizontal3 } = this._itemContext, position = pager && pager.position || "middle";
    if (this._pagerComponent.setTotal(totalPage), isHorizontal3) {
      let y;
      y = "start" === position ? renderStartY : "end" === position ? renderStartY + compHeight - this._pagerComponent.AABBBounds.height() / 2 : renderStartY + compHeight / 2 - this._pagerComponent.AABBBounds.height() / 2, this._pagerComponent.setAttributes({
        x: contentWidth,
        y
      });
    } else {
      let x;
      x = "start" === position ? 0 : "end" === position ? compWidth - this._pagerComponent.AABBBounds.width() : (compWidth - this._pagerComponent.AABBBounds.width()) / 2, this._pagerComponent.setAttributes({
        x,
        y: maxHeight - this._pagerComponent.AABBBounds.height()
      });
    }
  }
  _updatePositionOfScrollbar(contentWidth, contentHeight, renderStartY) {
    const { currentPage, totalPage, isHorizontal: isHorizontal3 } = this._itemContext;
    this._pagerComponent.setScrollRange([(currentPage - 1) / totalPage, currentPage / totalPage]), isHorizontal3 ? this._pagerComponent.setAttributes({
      x: 0,
      y: renderStartY + contentHeight
    }) : this._pagerComponent.setAttributes({
      x: contentWidth,
      y: renderStartY
    });
  }
  _bindEventsOfPager(pageSize, channel) {
    const pager = this.attribute.pager || {}, { animation = true, animationDuration = 450, animationEasing = "quadIn" } = pager, pageParser = this._itemContext.isScrollbar ? (e) => {
      const { value } = e.detail;
      let newPage = value[0] * this._itemContext.totalPage;
      return pager.scrollByPosition ? newPage += 1 : newPage = Math.floor(newPage) + 1, newPage;
    } : (e) => e.detail.current, onPaging = (e) => {
      const newPage = pageParser(e);
      if (newPage !== this._itemContext.currentPage) {
        if (this._itemContext.currentPage = newPage, this._itemContext && this._itemContext.startIndex < this._itemContext.items.length) {
          this._renderItems();
          const newTotalPage = Math.ceil(this._itemContext.pages / this._itemContext.maxPages);
          this._itemContext.totalPage = newTotalPage, this._pagerComponent.setScrollRange([(newPage - 1) / newTotalPage, newPage / newTotalPage]);
        }
        animation ? this._itemsContainer.animate().to({
          [channel]: -(newPage - 1) * pageSize
        }, animationDuration, animationEasing) : this._itemsContainer.setAttribute(channel, -(newPage - 1) * pageSize);
      }
    };
    this._itemContext.isScrollbar ? (this._pagerComponent.addEventListener("scrollDrag", onPaging), this._pagerComponent.addEventListener("scrollUp", onPaging)) : (this._pagerComponent.addEventListener("toPrev", onPaging), this._pagerComponent.addEventListener("toNext", onPaging));
  }
  _renderPager() {
    const renderStartY = this._title ? this._title.AABBBounds.height() + get_default(this.attribute, "title.space", 8) : 0, { maxWidth, maxHeight, maxCol = 1, maxRow = 2, item = {}, pager = {} } = this.attribute, { spaceCol = DEFAULT_ITEM_SPACE_COL, spaceRow = DEFAULT_ITEM_SPACE_ROW } = item, itemsContainer = this._itemsContainer, { space: pagerSpace = DEFAULT_PAGER_SPACE, defaultCurrent = 1 } = pager, compStyle = __rest6(pager, ["space", "defaultCurrent"]), { isHorizontal: isHorizontal3 } = this._itemContext;
    let comp, compWidth = 0, compHeight = 0, contentWidth = 0, contentHeight = 0, startX = 0, startY = 0, pages = 1;
    if (isHorizontal3) {
      if (compHeight = (maxRow - 1) * spaceRow + this._itemHeight * maxRow, compWidth = maxWidth, comp = this._createPager(compStyle), this._pagerComponent = comp, this._innerView.add(comp), contentWidth = maxWidth - comp.AABBBounds.width() - pagerSpace, contentWidth <= 0)
        return this._innerView.removeChild(comp), false;
      itemsContainer.getChildren().forEach((item2, index) => {
        const { width, height } = item2.attribute;
        contentWidth < startX + width && (startX = 0, startY += height + spaceRow, pages += 1), index > 0 && item2.setAttributes({
          x: startX,
          y: startY
        }), startX += spaceCol + width;
      }), this._itemContext.startX = startX, this._itemContext.startY = startY, this._itemContext.pages = pages;
      const total = Math.ceil(pages / maxRow);
      this._itemContext.totalPage = total, this._updatePositionOfPager(contentWidth, contentHeight, renderStartY, compWidth, compHeight);
    } else {
      if (compWidth = this._itemMaxWidth * maxCol + (maxCol - 1) * spaceCol, compHeight = maxHeight, contentWidth = compWidth, comp = this._createPager(compStyle), this._pagerComponent = comp, this._innerView.add(comp), contentHeight = maxHeight - comp.AABBBounds.height() - pagerSpace - renderStartY, contentHeight <= 0)
        return this._innerView.removeChild(comp), false;
      itemsContainer.getChildren().forEach((item2, index) => {
        const { height } = item2.attribute;
        contentHeight < startY + height && (startY = 0, startX += this._itemMaxWidth + spaceCol, pages += 1), index > 0 && item2.setAttributes({
          x: startX,
          y: startY
        }), startY += spaceRow + height;
      });
      const total = Math.ceil(pages / maxCol);
      this._itemContext.totalPage = total, this._updatePositionOfPager(contentWidth, contentHeight, renderStartY, compWidth, compHeight);
    }
    defaultCurrent > 1 && (isHorizontal3 ? itemsContainer.setAttribute("y", -(defaultCurrent - 1) * (compHeight + spaceRow)) : itemsContainer.setAttribute("x", -(defaultCurrent - 1) * (compWidth + spaceCol)));
    const clipGroup = graphicCreator.group({
      x: 0,
      y: renderStartY,
      width: isHorizontal3 ? contentWidth : compWidth,
      height: isHorizontal3 ? compHeight : contentHeight,
      clip: true,
      pickable: false
    });
    return clipGroup.add(itemsContainer), this._innerView.add(clipGroup), this._bindEventsOfPager(isHorizontal3 ? compHeight + spaceRow : compWidth + spaceCol, isHorizontal3 ? "y" : "x"), true;
  }
  _renderScrollbar() {
    const renderStartY = this._title ? this._title.AABBBounds.height() + get_default(this.attribute, "title.space", 8) : 0, { maxWidth, maxHeight, item = {}, pager = {} } = this.attribute, { spaceCol = DEFAULT_ITEM_SPACE_COL, spaceRow = DEFAULT_ITEM_SPACE_ROW } = item, itemsContainer = this._itemsContainer, { space: pagerSpace = DEFAULT_PAGER_SPACE, defaultCurrent = 1 } = pager, compStyle = __rest6(pager, ["space", "defaultCurrent"]), { isHorizontal: isHorizontal3 } = this._itemContext;
    let comp, compSize = 0, contentWidth = 0, contentHeight = 0, startY = 0, pages = 1;
    if (isHorizontal3)
      compSize = maxWidth, contentWidth = maxWidth, contentHeight = this._itemHeight, comp = this._createScrollbar(compStyle, compSize), this._pagerComponent = comp, this._innerView.add(comp), this._updatePositionOfScrollbar(contentWidth, contentHeight, renderStartY);
    else {
      if (compSize = maxHeight, comp = this._createScrollbar(compStyle, compSize), this._pagerComponent = comp, this._innerView.add(comp), contentHeight = maxHeight - renderStartY, contentWidth = this._itemMaxWidth, contentHeight <= 0)
        return this._innerView.removeChild(comp), false;
      itemsContainer.getChildren().forEach((item2, index) => {
        const { height } = item2.attribute;
        pages = Math.floor((startY + height) / contentHeight) + 1, startY += spaceRow + height;
      }), this._itemContext.totalPage = pages, this._itemContext.pages = pages, this._updatePositionOfScrollbar(contentWidth, contentHeight, renderStartY);
    }
    defaultCurrent > 1 && (isHorizontal3 ? itemsContainer.setAttribute("x", -(defaultCurrent - 1) * (contentWidth + spaceCol)) : itemsContainer.setAttribute("y", -(defaultCurrent - 1) * (contentHeight + spaceRow)));
    const clipGroup = graphicCreator.group({
      x: 0,
      y: renderStartY,
      width: contentWidth,
      height: contentHeight,
      clip: true,
      pickable: false
    });
    return clipGroup.add(itemsContainer), this._innerView.add(clipGroup), this._bindEventsOfPager(isHorizontal3 ? contentWidth : contentHeight, isHorizontal3 ? "x" : "y"), true;
  }
  _renderPagerComponent() {
    return this._itemContext.isScrollbar ? this._renderScrollbar() : this._renderPager(), true;
  }
  _hover(legendItem, e) {
    this._lastActiveItem = legendItem;
    legendItem.hasState(LegendStateValue.selected) ? this._setLegendItemState(legendItem, LegendStateValue.selectedHover, e) : this._setLegendItemState(legendItem, LegendStateValue.unSelectedHover, e);
    const focusButton = legendItem.getChildren()[0].find((node) => node.name === LEGEND_ELEMENT_NAME.focus, false);
    focusButton && focusButton.setAttribute("visible", true), this._dispatchLegendEvent(LegendEvent.legendItemHover, legendItem, e);
  }
  _unHover(legendItem, e) {
    let attributeUpdate = false;
    (legendItem.hasState(LegendStateValue.unSelectedHover) || legendItem.hasState(LegendStateValue.selectedHover)) && (attributeUpdate = true), legendItem.removeState(LegendStateValue.unSelectedHover), legendItem.removeState(LegendStateValue.selectedHover), legendItem.getChildren()[0].getChildren().forEach((child) => {
      attributeUpdate || !child.hasState(LegendStateValue.unSelectedHover) && !child.hasState(LegendStateValue.selectedHover) || (attributeUpdate = true), child.removeState(LegendStateValue.unSelectedHover), child.removeState(LegendStateValue.selectedHover);
    });
    const focusButton = legendItem.getChildren()[0].find((node) => node.name === LEGEND_ELEMENT_NAME.focus, false);
    focusButton && focusButton.setAttribute("visible", false), attributeUpdate && this._dispatchLegendEvent(LegendEvent.legendItemAttributeUpdate, legendItem, e), this._dispatchLegendEvent(LegendEvent.legendItemUnHover, legendItem, e);
  }
  _setLegendItemState(legendItem, stateName, e) {
    let attributeUpdate = false;
    legendItem.hasState(stateName) || (attributeUpdate = true), legendItem.addState(stateName, true), legendItem.getChildren()[0].getChildren().forEach((child) => {
      child.name !== LEGEND_ELEMENT_NAME.focus && (attributeUpdate || child.hasState(stateName) || (attributeUpdate = true), child.addState(stateName, true));
    }), attributeUpdate && this._dispatchLegendEvent(LegendEvent.legendItemAttributeUpdate, legendItem, e);
  }
  _removeLegendItemState(legendItem, stateNames, e) {
    let attributeUpdate = false;
    stateNames.forEach((name) => {
      !attributeUpdate && legendItem.hasState(name) && (attributeUpdate = true), legendItem.removeState(name);
    }), legendItem.getChildren()[0].getChildren().forEach((child) => {
      child.name !== LEGEND_ELEMENT_NAME.focus && stateNames.forEach((name) => {
        !attributeUpdate && child.hasState(name) && (attributeUpdate = true), child.removeState(name);
      });
    }), attributeUpdate && this._dispatchLegendEvent(LegendEvent.legendItemAttributeUpdate, legendItem, e);
  }
  _getSelectedLegends() {
    var _a;
    const selectedData = [];
    return null === (_a = this._itemsContainer) || void 0 === _a || _a.getChildren().forEach((item) => {
      item.hasState(LegendStateValue.selected) && selectedData.push(item.data);
    }), selectedData;
  }
  _appendDataToShape(shape, name, data, delegateShape, states = {}) {
    shape.name = name, shape.data = data, shape.delegate = delegateShape, shape.states = merge({}, DEFAULT_STATES3, states);
  }
  _dispatchLegendEvent(eventName, legendItem, event) {
    const currentSelectedItems = this._getSelectedLegends();
    currentSelectedItems.sort((pre, next) => pre.index - next.index);
    const currentSelected = currentSelectedItems.map((obj) => obj.label);
    this._dispatchEvent(eventName, {
      item: legendItem,
      data: legendItem.data,
      selected: legendItem.hasState(LegendStateValue.selected),
      currentSelectedItems,
      currentSelected,
      event
    });
  }
  _handleStyle(config2, item, isSelected, index, items) {
    const newConfig = {};
    return config2.style && (isFunction_default(config2.style) ? newConfig.style = config2.style(item, isSelected, index, items) : newConfig.style = config2.style), config2.state && (newConfig.state = {}, Object.keys(config2.state).forEach((key) => {
      config2.state[key] && (isFunction_default(config2.state[key]) ? newConfig.state[key] = config2.state[key](item, isSelected, index, items) : newConfig.state[key] = config2.state[key]);
    })), newConfig;
  }
};
DiscreteLegend.defaultAttributes = {
  layout: "horizontal",
  title: {
    align: "start",
    space: DEFAULT_TITLE_SPACE,
    textStyle: {
      fontSize: 12,
      fontWeight: "bold",
      fill: "#2C3542"
    }
  },
  item: {
    spaceCol: DEFAULT_ITEM_SPACE_COL,
    spaceRow: DEFAULT_ITEM_SPACE_ROW,
    shape: {
      space: DEFAULT_SHAPE_SPACE,
      style: {
        size: DEFAULT_SHAPE_SIZE,
        cursor: "pointer"
      },
      state: {
        selectedHover: {
          opacity: 0.85
        },
        unSelected: {
          opacity: 0.5
        }
      }
    },
    label: {
      space: DEFAULT_LABEL_SPACE,
      style: {
        fontSize: 12,
        fill: "#2C3542",
        cursor: "pointer"
      },
      state: {
        selectedHover: {
          opacity: 0.85
        },
        unSelected: {
          fill: "#D8D8D8"
        }
      }
    },
    value: {
      alignRight: false,
      style: {
        fontSize: 12,
        fill: "#ccc",
        cursor: "pointer"
      },
      state: {
        selectedHover: {
          opacity: 0.85
        },
        unSelected: {
          fill: "#D8D8D8"
        }
      }
    },
    background: {
      style: {
        cursor: "pointer"
      }
    },
    focus: false,
    focusIconStyle: {
      size: DEFAULT_SHAPE_SIZE,
      symbolType: "M8 1C11.866 1 15 4.13401 15 8C15 11.866 11.866 15 8 15C4.13401 15 1 11.866 1 8C1 4.13401 4.13401 1 8 1ZM8.75044 2.55077L8.75 3.75H7.25L7.25006 2.5507C4.81247 2.88304 2.88304 4.81247 2.5507 7.25006L3.75 7.25V8.75L2.55077 8.75044C2.8833 11.1878 4.81264 13.117 7.25006 13.4493L7.25 12.25H8.75L8.75044 13.4492C11.1876 13.1167 13.1167 11.1876 13.4492 8.75044L12.25 8.75V7.25L13.4493 7.25006C13.117 4.81264 11.1878 2.8833 8.75044 2.55077ZM8 5.5C9.38071 5.5 10.5 6.61929 10.5 8C10.5 9.38071 9.38071 10.5 8 10.5C6.61929 10.5 5.5 9.38071 5.5 8C5.5 6.61929 6.61929 5.5 8 5.5ZM8 7C7.44772 7 7 7.44772 7 8C7 8.55228 7.44772 9 8 9C8.55228 9 9 8.55228 9 8C9 7.44772 8.55228 7 8 7Z",
      fill: "#333",
      cursor: "pointer"
    }
  },
  autoPage: true,
  pager: {
    space: DEFAULT_PAGER_SPACE,
    handler: {
      style: {
        size: 10
      },
      space: 4
    }
  },
  hover: true,
  select: true,
  selectMode: "multiple",
  allowAllCanceled: true
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/slider/constant
var SLIDER_ELEMENT_NAME;
!function(SLIDER_ELEMENT_NAME2) {
  SLIDER_ELEMENT_NAME2.innerView = "innerView", SLIDER_ELEMENT_NAME2.railContainer = "sliderRailContainer", SLIDER_ELEMENT_NAME2.rail = "sliderRail", SLIDER_ELEMENT_NAME2.startText = "sliderStartText", SLIDER_ELEMENT_NAME2.endText = "sliderEndText", SLIDER_ELEMENT_NAME2.startHandler = "sliderStartHandler", SLIDER_ELEMENT_NAME2.startHandlerText = "startHandlerText", SLIDER_ELEMENT_NAME2.endHandler = "sliderEndHandler", SLIDER_ELEMENT_NAME2.endHandlerText = "sliderEndHandlerText", SLIDER_ELEMENT_NAME2.track = "sliderTrack", SLIDER_ELEMENT_NAME2.trackContainer = "sliderTrackContainer";
}(SLIDER_ELEMENT_NAME || (SLIDER_ELEMENT_NAME = {}));

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/slider/slider
function convertValueToRange(value) {
  return isArray_default(value) ? value : [value, value];
}
function getDefaultCursor(isHorizontal3) {
  return isHorizontal3 ? "ew-resize" : "ns-resize";
}
loadSliderComponent();
var Slider = class _Slider extends AbstractComponent {
  get track() {
    return this._track;
  }
  get currentValue() {
    return this._currentValue;
  }
  get startHandler() {
    return this._startHandler;
  }
  get endHandler() {
    return this._endHandler;
  }
  get tooltipShape() {
    return this._tooltipShape;
  }
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Slider.defaultAttributes, attributes)), this.name = "slider", this._isHorizontal = true, this._startHandler = null, this._endHandler = null, this._startHandlerText = null, this._endHandlerText = null, this._currentHandler = null, this._currentValue = {}, this._onTooltipShow = (e) => {
      this._isChanging || this._tooltipState && this._tooltipState.isActive || (this._tooltipState ? this._tooltipState.isActive = true : this._tooltipState = {
        isActive: true
      }, this._onTooltipUpdate(e), this._dispatchTooltipEvent("sliderTooltipShow"));
    }, this._onTooltipUpdate = (e) => {
      if (this._isChanging || !this._tooltipState || !this._tooltipState.isActive)
        return;
      const railLen = this._isHorizontal ? this._rail.globalAABBBounds.width() : this._rail.globalAABBBounds.height(), pos = clamp_default(this._isHorizontal ? (e.viewX - this._rail.globalAABBBounds.x1) / railLen : (e.viewY - this._rail.globalAABBBounds.y1) / railLen, 0, 1);
      pos !== this._tooltipState.pos && (this._tooltipState.pos = pos, this._tooltipState.value = this.calculateValueByPos(pos * railLen), this._updateTooltip(), this._dispatchTooltipEvent("sliderTooltipUpdate"));
    }, this._onTooltipHide = () => {
      const { tooltip: tooltip3 } = this.attribute;
      tooltip3 && tooltip3.alwaysShow || (this._tooltipState = null, this._tooltipShape && this._tooltipShape.setAttribute("visible", false), this._tooltipText && this._tooltipText.setAttribute("visible", false), this._dispatchTooltipEvent("sliderTooltipHide"));
    }, this._onHandlerPointerdown = (e) => {
      e.stopPropagation(), this._isChanging = true;
      const { x, y } = this.stage.eventPointTransform(e);
      this._currentHandler = e.target, this._prePos = this._isHorizontal ? x : y, "browser" === vglobal.env ? (vglobal.addEventListener("pointermove", this._onHandlerPointerMove, {
        capture: true
      }), vglobal.addEventListener("pointerup", this._onHandlerPointerUp)) : (this.stage.addEventListener("pointermove", this._onHandlerPointerMove, {
        capture: true
      }), this.stage.addEventListener("pointerup", this._onHandlerPointerUp), this.stage.addEventListener("pointerupoutside", this._onHandlerPointerUp));
    }, this._onHandlerPointerMove = (e) => {
      var _a, _b;
      e.stopPropagation(), this._isChanging = true;
      const { railWidth, railHeight, min: min3, max: max3 } = this.attribute;
      if (max3 === min3)
        return;
      const { x, y } = this.stage.eventPointTransform(e);
      let currentPos, originPos, railLen, delta = 0;
      this._isHorizontal ? (currentPos = x, delta = currentPos - this._prePos, originPos = null === (_b = this._currentHandler) || void 0 === _b ? void 0 : _b.attribute.x, railLen = railWidth) : (currentPos = y, delta = currentPos - this._prePos, originPos = null === (_a = this._currentHandler) || void 0 === _a ? void 0 : _a.attribute.y, railLen = railHeight);
      const newPos = clamp_default(originPos + delta, 0, railLen), currentValue = this.calculateValueByPos(newPos);
      "text" === this._currentHandler.type ? this._updateHandlerText(this._currentHandler, newPos, currentValue) : this._updateHandler(this._currentHandler, newPos, currentValue), this._updateTrack(), this._prePos = currentPos, this._dispatchChangeEvent();
    }, this._onHandlerPointerUp = (e) => {
      e.preventDefault(), this._isChanging = false, this._currentHandler = null, "browser" === vglobal.env ? (vglobal.removeEventListener("pointermove", this._onHandlerPointerMove, {
        capture: true
      }), vglobal.removeEventListener("pointerup", this._onHandlerPointerUp)) : (this.stage.removeEventListener("pointermove", this._onHandlerPointerMove, {
        capture: true
      }), this.stage.removeEventListener("pointerup", this._onHandlerPointerUp), this.stage.removeEventListener("pointerupoutside", this._onHandlerPointerUp));
    }, this._onTrackPointerdown = (e) => {
      e.stopPropagation(), this._isChanging = true;
      const { x, y } = this.stage.eventPointTransform(e);
      this._prePos = this._isHorizontal ? x : y, "browser" === vglobal.env ? (vglobal.addEventListener("pointermove", this._onTrackPointerMove, {
        capture: true
      }), vglobal.addEventListener("pointerup", this._onTrackPointerUp)) : (this.stage.addEventListener("pointermove", this._onTrackPointerMove, {
        capture: true
      }), this.stage.addEventListener("pointerup", this._onTrackPointerUp), this.stage.addEventListener("pointerupoutside", this._onTrackPointerUp));
    }, this._onTrackPointerMove = (e) => {
      e.stopPropagation(), this._isChanging = true;
      const { railWidth, railHeight, min: min3, max: max3, inverse } = this.attribute;
      if (max3 === min3)
        return;
      const { startHandler, endHandler } = this._getHandlers();
      let currentPos, trackLen, railLen;
      const { x, y } = this.stage.eventPointTransform(e);
      this._isHorizontal ? (currentPos = x, trackLen = this._track.attribute.width, railLen = railWidth) : (currentPos = y, trackLen = this._track.attribute.height, railLen = railHeight);
      const delta = currentPos - this._prePos;
      if (startHandler) {
        const originPos = this._isHorizontal ? startHandler.attribute.x : startHandler.attribute.y, newPos = inverse ? clamp_default(originPos + delta, trackLen, railLen) : clamp_default(originPos + delta, 0, railLen - trackLen), currentValue = this.calculateValueByPos(newPos);
        this._updateHandler(startHandler, newPos, currentValue);
      }
      if (endHandler) {
        const originPos = this._isHorizontal ? endHandler.attribute.x : endHandler.attribute.y, newPos = inverse ? clamp_default(originPos + delta, 0, railLen - trackLen) : clamp_default(originPos + delta, trackLen, railLen), currentValue = this.calculateValueByPos(newPos), startHandlerAttribute = null == startHandler ? void 0 : startHandler.attribute;
        this._updateHandler(endHandler, newPos, currentValue), this._track.setAttributes(this._isHorizontal ? {
          x: Math.min(startHandlerAttribute.x, endHandler.attribute.x),
          width: Math.abs(startHandlerAttribute.x - endHandler.attribute.x)
        } : {
          y: Math.min(startHandlerAttribute.y, endHandler.attribute.y),
          height: Math.abs(startHandlerAttribute.y - endHandler.attribute.y)
        });
      }
      this._prePos = currentPos, this._dispatchChangeEvent();
    }, this._onTrackPointerUp = (e) => {
      e.preventDefault(), this._isChanging = false, "browser" === vglobal.env ? (vglobal.removeEventListener("pointermove", this._onTrackPointerMove, {
        capture: true
      }), vglobal.removeEventListener("pointerup", this._onTrackPointerUp)) : (this.stage.removeEventListener("pointermove", this._onTrackPointerMove, {
        capture: true
      }), this.stage.removeEventListener("pointerup", this._onTrackPointerUp), this.stage.removeEventListener("pointerupoutside", this._onTrackPointerUp));
    }, this._onRailPointerDown = (e) => {
      e.stopPropagation(), this._isChanging = true;
      const { railWidth, railHeight, min: min3, max: max3 } = this.attribute;
      if (max3 === min3)
        return;
      const startHandler = this._startHandler, endHandler = this._endHandler;
      let currentPos, startHandlerPos, endHandlerPos, railLen;
      this._isHorizontal ? (currentPos = e.viewX - this._rail.globalAABBBounds.x1, startHandlerPos = null == startHandler ? void 0 : startHandler.attribute.x, endHandlerPos = null == endHandler ? void 0 : endHandler.attribute.x, railLen = railWidth) : (currentPos = e.viewY - this._rail.globalAABBBounds.y1, startHandlerPos = null == startHandler ? void 0 : startHandler.attribute.y, endHandlerPos = null == endHandler ? void 0 : endHandler.attribute.y, railLen = railHeight);
      const currentValue = this.calculateValueByPos(currentPos);
      if (isValid_default(endHandlerPos)) {
        const updateHandler = Math.abs(currentPos - startHandlerPos) > Math.abs(currentPos - endHandlerPos) ? endHandler : startHandler;
        this._updateHandler(updateHandler, currentPos, currentValue);
      } else
        this._updateHandler(startHandler, currentPos, currentValue);
      this._updateTrack(), this._dispatchChangeEvent();
    };
  }
  calculatePosByValue(value, pos) {
    const { layout, railWidth, railHeight, min: min3, max: max3, inverse } = this.attribute;
    let ratio = 0;
    ratio = min3 === max3 ? "start" === pos ? 0 : "end" === pos ? 1 : 0 : (value - min3) / (max3 - min3);
    return (inverse ? 1 - ratio : ratio) * ("vertical" === layout ? railHeight : railWidth);
  }
  calculateValueByPos(pos) {
    const { layout, railWidth, railHeight, min: min3, max: max3, inverse } = this.attribute, railLen = "vertical" === layout ? railHeight : railWidth;
    return min3 + (max3 - min3) * (inverse ? 1 - pos / railLen : pos / railLen);
  }
  setValue(value) {
    const { min: min3, max: max3 } = this.attribute;
    if (max3 === min3)
      return;
    const [startValue, endValue] = array(value), { startHandler, endHandler } = this._getHandlers();
    startHandler && this._updateHandler(startHandler, this.calculatePosByValue(startValue), startValue), endHandler && this._updateHandler(endHandler, this.calculatePosByValue(endValue), endValue), this._updateTrack();
  }
  render() {
    var _a, _b;
    this.removeAllChild(true);
    const { layout = "horizontal", railWidth, railHeight, startText, endText, min: min3, max: max3, showHandler = true, showTooltip: showTooltip2 } = this.attribute;
    let { value } = this.attribute;
    isNil_default(value) && (value = [min3, max3]), this._currentValue = {
      startValue: convertValueToRange(value)[0],
      endValue: convertValueToRange(value)[1]
    };
    const isHorizontal3 = "horizontal" === layout;
    this._isHorizontal = isHorizontal3;
    const innerView = graphicCreator.group({
      x: 0,
      y: 0
    });
    innerView.name = SLIDER_ELEMENT_NAME.innerView, this.add(innerView), this._innerView = innerView;
    let startTextShape, startLen = 0;
    if (startText && startText.visible) {
      startTextShape = graphicCreator.text(Object.assign({
        x: isHorizontal3 ? 0 : railWidth / 2,
        y: isHorizontal3 ? railHeight / 2 : 0,
        textAlign: isHorizontal3 ? "start" : "center",
        textBaseline: isHorizontal3 ? "middle" : "top",
        text: startText.text,
        lineHeight: null === (_a = startText.style) || void 0 === _a ? void 0 : _a.fontSize
      }, startText.style)), startTextShape.name = SLIDER_ELEMENT_NAME.startText, innerView.add(startTextShape);
      const space = isValid_default(startText.space) ? startText.space : 0;
      startLen += (isHorizontal3 ? startTextShape.AABBBounds.width() : startTextShape.AABBBounds.height()) + space;
    }
    const mainContainer = graphicCreator.group({
      x: isHorizontal3 ? startLen : 0,
      y: isHorizontal3 ? 0 : startLen
    });
    innerView.add(mainContainer);
    const railContainer = graphicCreator.group({
      x: 0,
      y: 0
    });
    let endTextShape;
    if (railContainer.name = SLIDER_ELEMENT_NAME.railContainer, this._railContainer = railContainer, mainContainer.add(railContainer), this._mainContainer = mainContainer, this._renderRail(railContainer), startLen += isHorizontal3 ? railWidth : railHeight, endText && endText.visible) {
      const space = isValid_default(endText.space) ? endText.space : 0;
      endTextShape = graphicCreator.text(Object.assign({
        x: isHorizontal3 ? startLen + space : railWidth / 2,
        y: isHorizontal3 ? railHeight / 2 : startLen + space,
        textAlign: isHorizontal3 ? "start" : "center",
        textBaseline: isHorizontal3 ? "middle" : "top",
        text: endText.text,
        lineHeight: null === (_b = endText.style) || void 0 === _b ? void 0 : _b.fontSize
      }, endText.style)), endTextShape.name = SLIDER_ELEMENT_NAME.endText, innerView.add(endTextShape);
    }
    this._renderTrack(railContainer), showHandler && (this._renderHandlers(mainContainer), this._bindEvents()), showTooltip2 && (this._renderTooltip(), this._bindTooltipEvents());
  }
  _renderRail(container2) {
    const { railWidth, railHeight, railStyle, slidable } = this.attribute;
    let cursor = "default";
    false !== slidable && (cursor = "pointer");
    const railShape = graphicCreator.rect(Object.assign({
      x: 0,
      y: 0,
      width: railWidth,
      height: railHeight,
      cursor
    }, railStyle));
    return railShape.name = SLIDER_ELEMENT_NAME.rail, container2.add(railShape), this._rail = railShape, railShape;
  }
  _renderHandlers(container2) {
    const { range: range2, min: min3, max: max3, handlerSize = 14, handlerStyle, handlerText, railHeight, railWidth, slidable } = this.attribute;
    let { value } = this.attribute;
    isNil_default(value) && (value = [min3, max3]);
    const handlerTextVisible = handlerText && handlerText.visible, isHorizontal3 = this._isHorizontal, [startValue, endValue] = convertValueToRange(value), startPos = this.calculatePosByValue(startValue, range2 ? "start" : "end"), startHandler = this._renderHandler(Object.assign({
      x: isHorizontal3 ? startPos : railWidth / 2,
      y: isHorizontal3 ? railHeight / 2 : startPos,
      size: handlerSize,
      strokeBoundsBuffer: 0,
      cursor: false === slidable ? "default" : getDefaultCursor(isHorizontal3)
    }, handlerStyle));
    if (startHandler.name = SLIDER_ELEMENT_NAME.startHandler, this._startHandler = startHandler, container2.add(startHandler), this._currentValue.startPos = startPos, handlerTextVisible) {
      const startHandlerText = this._renderHandlerText(startValue, range2 ? "start" : "end");
      startHandlerText.name = SLIDER_ELEMENT_NAME.startHandlerText, container2.add(startHandlerText), this._startHandlerText = startHandlerText;
    }
    if (range2) {
      const endPos = this.calculatePosByValue(endValue, "end"), endHandler = this._renderHandler(Object.assign({
        x: isHorizontal3 ? endPos : railWidth / 2,
        y: isHorizontal3 ? railHeight / 2 : endPos,
        size: handlerSize,
        strokeBoundsBuffer: 0,
        cursor: false === slidable ? "default" : getDefaultCursor(isHorizontal3)
      }, handlerStyle));
      if (endHandler.name = SLIDER_ELEMENT_NAME.endHandler, this._endHandler = endHandler, container2.add(endHandler), this._currentValue.endPos = endPos, handlerTextVisible) {
        const endHandlerText = this._renderHandlerText(endValue, "end");
        endHandlerText.name = SLIDER_ELEMENT_NAME.endHandlerText, container2.add(endHandlerText), this._endHandlerText = endHandlerText;
      }
    }
  }
  _renderTrack(container2) {
    const { range: range2, min: min3, max: max3, railHeight, railWidth, trackStyle, railStyle, slidable, value } = this.attribute;
    let startValue, endValue;
    if (isNil_default(value))
      range2 ? (startValue = min3, endValue = max3) : startValue = endValue = min3;
    else if (range2) {
      const clampValue = clampRange_default(value, min3, max3);
      startValue = clampValue[0], endValue = clampValue[1];
    } else
      startValue = min3, endValue = clamp_default(value, min3, max3);
    const isHorizontal3 = this._isHorizontal;
    range2 || (startValue = min3);
    const trackContainer = graphicCreator.group({
      x: 0,
      y: 0,
      width: railWidth,
      height: railHeight,
      cornerRadius: null == railStyle ? void 0 : railStyle.cornerRadius,
      clip: true,
      pickable: false
    });
    trackContainer.name = SLIDER_ELEMENT_NAME.trackContainer;
    const draggableTrack = isObject_default(range2) && true === range2.draggableTrack;
    let cursor;
    cursor = false === slidable ? "default" : false === range2 || false === draggableTrack ? "pointer" : getDefaultCursor(isHorizontal3);
    const startPos = this.calculatePosByValue(startValue, "start"), endPos = this.calculatePosByValue(endValue, range2 ? "end" : "start"), track = graphicCreator.rect(Object.assign({
      x: isHorizontal3 ? Math.min(startPos, endPos) : 0,
      y: isHorizontal3 ? 0 : Math.min(startPos, endPos),
      width: isHorizontal3 ? Math.abs(endPos - startPos) : railWidth,
      height: isHorizontal3 ? railHeight : Math.abs(endPos - startPos),
      cursor
    }, trackStyle));
    track.name = SLIDER_ELEMENT_NAME.track, this._track = track, trackContainer.add(track), container2.add(trackContainer);
  }
  _renderHandler(style) {
    return graphicCreator.symbol(style);
  }
  _renderHandlerText(value, position) {
    var _a, _b, _c;
    const { align, handlerSize = 14, handlerText = {}, railHeight, railWidth, slidable } = this.attribute, isHorizontal3 = this._isHorizontal, pos = this.calculatePosByValue(value, position), textSpace = null !== (_a = handlerText.space) && void 0 !== _a ? _a : 4, textStyle = {
      text: handlerText.formatter ? handlerText.formatter(value) : value.toFixed(null !== (_b = handlerText.precision) && void 0 !== _b ? _b : 0),
      lineHeight: null === (_c = handlerText.style) || void 0 === _c ? void 0 : _c.lineHeight,
      cursor: false === slidable ? "default" : getDefaultCursor(isHorizontal3)
    };
    isHorizontal3 ? "top" === align ? (textStyle.textBaseline = "bottom", textStyle.textAlign = "center", textStyle.x = pos, textStyle.y = (railHeight - handlerSize) / 2 - textSpace) : (textStyle.textBaseline = "top", textStyle.textAlign = "center", textStyle.x = pos, textStyle.y = (railHeight + handlerSize) / 2 + textSpace) : "left" === align ? (textStyle.textBaseline = "middle", textStyle.textAlign = "end", textStyle.x = (railWidth - handlerSize) / 2 - textSpace, textStyle.y = pos) : (textStyle.textBaseline = "middle", textStyle.textAlign = "start", textStyle.x = (railWidth + handlerSize) / 2 + textSpace, textStyle.y = pos);
    return graphicCreator.text(Object.assign(Object.assign({}, textStyle), handlerText.style));
  }
  _renderTooltip() {
    var _a;
    const { tooltip: tooltip3, railHeight, railWidth, align } = this.attribute;
    tooltip3 && tooltip3.alwaysShow ? this._tooltipState = {
      value: this._currentValue.startValue,
      pos: this._currentValue.startPos
    } : this._tooltipState = null;
    const cx = this._isHorizontal ? 0 : railWidth / 2, cy = this._isHorizontal ? railHeight / 2 : 0;
    if (tooltip3 && tooltip3.shape) {
      const shape = graphicCreator.symbol(Object.assign({
        pickable: false,
        visible: !!this._tooltipState,
        x: cx,
        y: cy,
        symbolType: "circle"
      }, tooltip3.shapeStyle));
      this._tooltipShape = shape, this._mainContainer.add(shape);
    }
    const textConfig = tooltip3 && tooltip3.text || {}, space = null !== (_a = textConfig.space) && void 0 !== _a ? _a : 6, textStyle = {
      pickable: false,
      visible: !!this._tooltipState,
      text: ""
    };
    this._isHorizontal ? (textStyle.x = cx, textStyle.y = "top" === align ? cy - railHeight / 2 - space : cy + railHeight / 2 + space, textStyle.textAlign = "center", textStyle.textBaseline = "top" === align ? "bottom" : "top") : (textStyle.y = cy, textStyle.x = "left" === align ? cx - railWidth / 2 - space : cy + railWidth / 2 + space, textStyle.textAlign = "left" === align ? "end" : "start", textStyle.textBaseline = "middle");
    const text2 = graphicCreator.text(Object.assign(Object.assign({}, textStyle), textConfig.style));
    this._mainContainer.add(text2), this._tooltipText = text2, this._tooltipState && this._updateTooltip();
  }
  _updateTooltip() {
    var _a, _b;
    if (!this._tooltipShape && !this._tooltipText || !this._tooltipState)
      return;
    const { railWidth, railHeight } = this.attribute, railLen = this._isHorizontal ? railWidth : railHeight, coord = this._tooltipState.pos * railLen, coordKey = this._isHorizontal ? "x" : "y";
    this._tooltipShape && this._tooltipShape.setAttributes({
      visible: true,
      [coordKey]: coord
    });
    const { align } = this.attribute;
    if (this._tooltipText) {
      const textConfig = this.attribute.tooltip && this.attribute.tooltip.text || {};
      this._tooltipText.setAttributes({
        visible: true,
        [coordKey]: coord,
        text: textConfig.formatter ? textConfig.formatter(this._tooltipState.value) : this._isHorizontal || "left" !== align ? `\u2248 ${this._tooltipState.value.toFixed(null !== (_b = textConfig.precision) && void 0 !== _b ? _b : 0)}` : `${this._tooltipState.value.toFixed(null !== (_a = textConfig.precision) && void 0 !== _a ? _a : 0)} \u2248`
      });
    }
  }
  _bindEvents() {
    if (this.attribute.disableTriggerEvent)
      return;
    const { slidable, range: range2 } = this.attribute;
    slidable && (this._startHandler && this._startHandler.addEventListener("pointerdown", this._onHandlerPointerdown), this._startHandlerText && this._startHandlerText.addEventListener("pointerdown", this._onHandlerPointerdown), this._endHandler && this._endHandler.addEventListener("pointerdown", this._onHandlerPointerdown), this._endHandlerText && this._endHandlerText.addEventListener("pointerdown", this._onHandlerPointerdown), isObject_default(range2) && range2.draggableTrack && this._track.addEventListener("pointerdown", this._onTrackPointerdown), this._railContainer.addEventListener("pointerdown", this._onRailPointerDown));
  }
  _bindTooltipEvents() {
    this.attribute.disableTriggerEvent || (this._mainContainer.addEventListener("pointerenter", this._onTooltipShow), this._mainContainer.addEventListener("pointermove", this._onTooltipUpdate), this._mainContainer.addEventListener("pointerleave", this._onTooltipHide));
  }
  _updateTrack() {
    const { inverse, railWidth, railHeight } = this.attribute, startHandler = this._startHandler, endHandler = this._endHandler;
    if (this._isHorizontal) {
      const startHandlerPos = null == startHandler ? void 0 : startHandler.attribute.x;
      if (endHandler) {
        const endHandlerPos = null == endHandler ? void 0 : endHandler.attribute.x;
        this._track.setAttributes({
          x: Math.min(startHandlerPos, endHandlerPos),
          width: Math.abs(startHandlerPos - endHandlerPos)
        });
      } else
        inverse ? this._track.setAttributes({
          x: startHandlerPos,
          width: railWidth - startHandlerPos
        }) : this._track.setAttributes({
          width: startHandlerPos
        });
    } else {
      const startHandlerPos = null == startHandler ? void 0 : startHandler.attribute.y;
      if (endHandler) {
        const endHandlerPos = null == endHandler ? void 0 : endHandler.attribute.y;
        this._track.setAttributes({
          y: Math.min(startHandlerPos, endHandlerPos),
          height: Math.abs(startHandlerPos - endHandlerPos)
        });
      } else
        inverse ? this._track.setAttributes({
          y: startHandlerPos,
          height: railHeight - startHandlerPos
        }) : this._track.setAttributes({
          height: startHandlerPos
        });
    }
  }
  _updateHandler(handler, position, value) {
    var _a;
    const isHorizontal3 = this._isHorizontal;
    handler.setAttribute(isHorizontal3 ? "x" : "y", position);
    const updateHandlerText = handler.name === SLIDER_ELEMENT_NAME.startHandler ? this._startHandlerText : this._endHandlerText;
    if (updateHandlerText) {
      const { handlerText = {} } = this.attribute;
      updateHandlerText.setAttributes({
        text: handlerText.formatter ? handlerText.formatter(value) : value.toFixed(null !== (_a = handlerText.precision) && void 0 !== _a ? _a : 0),
        [isHorizontal3 ? "x" : "y"]: position
      });
    }
    handler.name === SLIDER_ELEMENT_NAME.startHandler ? (this._currentValue.startValue = value, this._currentValue.startPos = position) : (this._currentValue.endValue = value, this._currentValue.endPos = position);
  }
  _updateHandlerText(handlerText, position, value) {
    var _a;
    const isHorizontal3 = this._isHorizontal, { handlerText: handlerTextAttr = {} } = this.attribute;
    handlerText.setAttributes({
      [isHorizontal3 ? "x" : "y"]: position,
      text: handlerTextAttr.formatter ? handlerTextAttr.formatter(value) : value.toFixed(null !== (_a = handlerTextAttr.precision) && void 0 !== _a ? _a : 0)
    });
    const updateHandler = handlerText.name === SLIDER_ELEMENT_NAME.startHandlerText ? this._startHandler : this._endHandler;
    updateHandler && updateHandler.setAttributes({
      [isHorizontal3 ? "x" : "y"]: position
    }), handlerText.name === SLIDER_ELEMENT_NAME.startHandlerText ? (this._currentValue.startValue = value, this._currentValue.startPos = position) : (this._currentValue.endValue = value, this._currentValue.endPos = position);
  }
  _dispatchChangeEvent() {
    const isRange = !!this.attribute.range, currentValue = this._currentValue;
    this._dispatchEvent("change", {
      value: isRange ? [Math.min(currentValue.endValue, currentValue.startValue), Math.max(currentValue.endValue, currentValue.startValue)] : currentValue.startValue,
      position: isRange ? [Math.min(currentValue.endPos, currentValue.startPos), Math.max(currentValue.endPos, currentValue.startPos)] : currentValue.startPos
    });
  }
  _dispatchTooltipEvent(type) {
    this._dispatchEvent("sliderTooltip", {
      type,
      position: this._tooltipState && this._tooltipState.pos,
      value: this._tooltipState && this._tooltipState.value
    });
  }
  _getHandlers() {
    const { inverse } = this.attribute;
    let startHandler = this._startHandler, endHandler = this._endHandler;
    return endHandler ? (this._isHorizontal ? (!inverse && endHandler.attribute.x < (null == startHandler ? void 0 : startHandler.attribute.x) || inverse && endHandler.attribute.x > (null == startHandler ? void 0 : startHandler.attribute.x)) && ([startHandler, endHandler] = [endHandler, startHandler]) : (!inverse && endHandler.attribute.y < (null == startHandler ? void 0 : startHandler.attribute.y) || inverse && endHandler.attribute.y > (null == startHandler ? void 0 : startHandler.attribute.y)) && ([startHandler, endHandler] = [endHandler, startHandler]), {
      startHandler,
      endHandler
    }) : {
      startHandler,
      endHandler
    };
  }
};
Slider.defaultAttributes = {
  slidable: true,
  layout: "horizontal",
  align: "bottom",
  height: 8,
  showHandler: true,
  handlerSize: 14,
  handlerStyle: {
    symbolType: "circle",
    fill: "#fff",
    stroke: "#91caff",
    lineWidth: 2
  },
  tooltip: {
    shapeStyle: {
      symbolType: "circle",
      fill: "#fff",
      stroke: "#91caff",
      lineWidth: 2
    },
    text: {
      style: {
        fill: "#2C3542",
        fontSize: 12
      }
    }
  },
  railStyle: {
    fill: "rgba(0,0,0,.04)"
  },
  trackStyle: {
    fill: "#91caff"
  },
  showValue: true,
  valueStyle: {
    fill: "#2C3542",
    fontSize: 12
  },
  startText: {
    style: {
      fill: "#2C3542",
      fontSize: 12
    }
  },
  endText: {
    style: {
      fill: "#2C3542",
      fontSize: 12
    }
  },
  handlerText: {
    visible: true,
    space: 4,
    precision: 0,
    style: {
      fill: "#2C3542",
      fontSize: 12
    }
  }
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/legend/color/color
loadColorContinuousLegendComponent();
var ColorContinuousLegend = class _ColorContinuousLegend extends LegendBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _ColorContinuousLegend.defaultAttributes, attributes)), this.name = "colorLegend", this._onSliderToolipChange = (e) => {
      const tooltipShape = this._slider.tooltipShape;
      if (tooltipShape && e.detail && !isNil_default(e.detail.value)) {
        const color = this._colorScale.scale(e.detail.value);
        tooltipShape.setAttribute("fill", color);
      }
      this.dispatchEvent(e);
    }, this._onSliderChange = (e) => {
      this._updateColor(), this.dispatchEvent(e);
    };
  }
  setSelected(value) {
    this._slider && (this._slider.setValue(value), this._updateColor());
  }
  _renderContent() {
    const { colors, slidable, layout, align, min: min3, max: max3, value, railWidth, railHeight, showHandler = true, handlerSize, handlerStyle, railStyle, trackStyle, startText, endText, handlerText, showTooltip: showTooltip2, tooltip: tooltip3, inverse, disableTriggerEvent } = this.attribute, domain = [], step = (max3 - min3) / (colors.length - 1);
    for (let i = 0; i < colors.length; i++)
      domain.push(min3 + step * i);
    this._colorScale = new LinearScale().domain(domain, true).range(colors), this._color = this._getTrackColor();
    const slider2 = new Slider({
      x: 0,
      y: 0,
      range: {
        draggableTrack: true
      },
      slidable,
      layout,
      align,
      min: min3,
      max: max3,
      value,
      railWidth,
      railHeight,
      showHandler,
      handlerSize,
      handlerStyle,
      railStyle,
      trackStyle: Object.assign({
        fill: this._color
      }, trackStyle),
      startText,
      endText,
      handlerText,
      showTooltip: showTooltip2,
      tooltip: tooltip3,
      disableTriggerEvent,
      inverse
    });
    this._innerView.add(slider2), this._slider = slider2, slider2.translateTo(0 - slider2.AABBBounds.x1, (this._title ? this._title.AABBBounds.height() + get_default(this.attribute, "title.space", DEFAULT_TITLE_SPACE) : 0) - slider2.AABBBounds.y1), this._updateColor();
  }
  _bindEvents() {
    this.attribute.disableTriggerEvent || this._slider && (this._slider.addEventListener("change", this._onSliderChange), this._slider.addEventListener("sliderTooltip", this._onSliderToolipChange));
  }
  _getTrackColor() {
    const { colors, layout, inverse } = this.attribute;
    if (isEmpty_default(colors))
      return;
    const count = colors.length;
    if (1 === count)
      return colors[0];
    const stops = [];
    for (let i = 0; i < count; i++) {
      const percent = i / (count - 1);
      stops.push({
        offset: percent,
        color: colors[i]
      });
    }
    const isHorizontal3 = "horizontal" === layout, res = {
      gradient: "linear",
      stops,
      x0: 0,
      y0: 0,
      x1: isHorizontal3 ? 1 : 0,
      y1: isHorizontal3 ? 0 : 1
    };
    return inverse && (isHorizontal3 ? (res.x0 = 1, res.x1 = 0) : (res.y0 = 1, res.y1 = 0)), res;
  }
  _updateColor() {
    var _a;
    const { layout = "horizontal", colors, railWidth, railHeight } = this.attribute, { startHandler, endHandler, track, attribute } = this._slider, { startValue, endValue, startPos, endPos } = this._slider.currentValue, handlerColor = null === (_a = attribute.handlerStyle) || void 0 === _a ? void 0 : _a.fill;
    if (startHandler && !handlerColor) {
      const startHandlerColor = this._colorScale.scale(startValue);
      startHandler.setAttribute("fill", startHandlerColor);
    }
    if (endHandler && !handlerColor) {
      const endHandlerColor = this._colorScale.scale(endValue);
      endHandler.setAttribute("fill", endHandlerColor);
    }
    const railLen = "horizontal" === layout ? railWidth : railHeight;
    if (Math.abs(startPos - endPos) !== railLen && colors && colors.length > 1) {
      const stops = this._color.stops, start = Math.min(startPos, endPos), end = Math.max(startPos, endPos), startRatio = start / railLen, endRatio = end / railLen, range2 = endRatio - startRatio, betweenStops = stops.filter((stop) => stop.offset > startRatio && stop.offset < endRatio), minValue = Math.min(startValue, endValue), maxValue = Math.max(startValue, endValue), startColor = this._colorScale.scale(minValue), endColor = this._colorScale.scale(maxValue), newStops = [{
        offset: 0,
        color: startColor
      }];
      betweenStops.forEach((stop) => {
        newStops.push({
          offset: (stop.offset - startRatio) / range2,
          color: stop.color
        });
      }), newStops.push({
        offset: 1,
        color: endColor
      }), track.setAttribute("fill", Object.assign(Object.assign({}, this._color), {
        stops: newStops
      }));
    }
  }
};
ColorContinuousLegend.defaultAttributes = {
  layout: "horizontal",
  title: {
    align: "start",
    space: DEFAULT_TITLE_SPACE,
    textStyle: {
      fontSize: 12,
      fontWeight: "bold",
      fill: "rgba(46, 47, 50, 1)"
    }
  },
  handlerSize: 10,
  handlerStyle: {
    fill: null,
    lineWidth: 4,
    stroke: "#fff",
    outerBorder: {
      distance: 2,
      lineWidth: 1,
      stroke: "#ccc"
    }
  },
  tooltip: {
    shapeStyle: {
      lineWidth: 4,
      stroke: "#fff"
    }
  }
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/legend/util
function getSizeHandlerPath(align = "bottom") {
  let centerX = 0;
  return "top" === align ? `
    M${centerX},-6L${centerX - 3.5},-2.5
    v5
    h7
    v-5
    Z
` : "left" === align ? (centerX = 1, `
    M${centerX - 6},0L${centerX - 6 + 2.5},-3.5
    h5
    v7
    h-5
    Z
`) : "right" === align ? (centerX = -1, `
    M${centerX + 6},0L${centerX + 6 - 2.5},-3.5
    h-5
    v7
    h5
    Z
  `) : `
    M${centerX},6L${centerX - 3.5},2.5
    v-5
    h7
    v5
    Z
`;
}

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/legend/size/size
loadSizeContinuousLegendComponent();
var SizeContinuousLegend = class _SizeContinuousLegend extends LegendBase {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _SizeContinuousLegend.defaultAttributes, attributes)), this.name = "sizeLegend", this._onSliderChange = (e) => {
      this.dispatchEvent(e);
    }, this._onSliderToolipChange = (e) => {
      this.dispatchEvent(e);
    };
  }
  setSelected(value) {
    this._slider && this._slider.setValue(value);
  }
  _renderContent() {
    const { slidable, layout, align, min: min3, max: max3, value, railWidth, railHeight, showHandler = true, handlerSize, handlerStyle, railStyle, trackStyle, startText, endText, handlerText, showTooltip: showTooltip2, tooltip: tooltip3, sizeBackground, disableTriggerEvent, inverse } = this.attribute, mainContainer = graphicCreator.group({
      x: 0,
      y: 0
    });
    this._innerView.add(mainContainer);
    const slider2 = new Slider({
      x: 0,
      y: 0,
      zIndex: 1,
      range: {
        draggableTrack: true
      },
      slidable,
      layout,
      align,
      min: min3,
      max: max3,
      value,
      railWidth,
      railHeight,
      showHandler,
      handlerSize,
      handlerStyle: Object.assign({
        symbolType: getSizeHandlerPath(align)
      }, handlerStyle),
      railStyle,
      trackStyle,
      startText,
      endText,
      handlerText,
      showTooltip: showTooltip2,
      tooltip: tooltip3,
      disableTriggerEvent,
      inverse
    });
    mainContainer.add(slider2);
    let path, start = 0;
    "horizontal" === layout ? "top" === align ? (path = `M0,0L${railWidth},0L${inverse ? 0 : railWidth},12Z`, start = railHeight) : (path = `M0,12L${railWidth},12L${inverse ? 0 : railWidth},0Z`, slider2.setAttribute("y", 12)) : "left" === align ? path = `M${railWidth},0L${railWidth + 12},${inverse ? 0 : railHeight}L${railWidth},${railHeight}Z` : (path = `M0,${inverse ? 0 : railHeight}L12,${railHeight}L12,0Z`, slider2.setAttribute("x", 12));
    const background = graphicCreator.path(Object.assign(Object.assign({
      x: 0,
      y: start,
      path
    }, sizeBackground), {
      zIndex: 0
    }));
    mainContainer.add(background);
    const titleSpace = this._title ? this._title.AABBBounds.height() + get_default(this.attribute, "title.space", DEFAULT_TITLE_SPACE) : 0;
    mainContainer.translate(0 - mainContainer.AABBBounds.x1, titleSpace - mainContainer.AABBBounds.y1), this._slider = slider2;
  }
  _bindEvents() {
    this.attribute.disableTriggerEvent || this._slider && (this._slider.addEventListener("change", this._onSliderChange), this._slider.addEventListener("sliderTooltip", this._onSliderToolipChange));
  }
};
SizeContinuousLegend.defaultAttributes = {
  layout: "horizontal",
  title: {
    align: "start",
    space: DEFAULT_TITLE_SPACE,
    textStyle: {
      fontSize: 12,
      fontWeight: "bold",
      fill: "rgba(46, 47, 50, 1)"
    }
  },
  handlerSize: 10,
  handlerStyle: {
    lineWidth: 1,
    stroke: "#ccc",
    fill: "#fff"
  },
  sizeBackground: {
    fill: "rgba(20,20,20,0.1)"
  }
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/title/register
function loadTitleComponent() {
  registerGroup(), registerText(), registerRichtext();
}

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/title/title
loadTitleComponent();
var Title = class _Title extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Title.defaultAttributes, attributes)), this.name = "title";
  }
  render() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17;
    const { textType, text: text2, subtextType, textStyle = {}, subtext, subtextStyle = {}, width, height, minWidth, maxWidth, minHeight, maxHeight, align, verticalAlign, padding = 0 } = this.attribute, parsedPadding = normalizePadding(padding), group = this.createOrUpdateChild("title-container", {
      x: parsedPadding[3],
      y: parsedPadding[0],
      zIndex: 1
    }, "group");
    if (false !== this.attribute.visible && false !== textStyle.visible)
      if ("rich" === textType || isValid_default(textStyle.character)) {
        const attr = Object.assign({
          x: null !== (_a = textStyle.x) && void 0 !== _a ? _a : 0,
          y: null !== (_b = textStyle.y) && void 0 !== _b ? _b : 0,
          width: null !== (_d = null !== (_c = textStyle.width) && void 0 !== _c ? _c : width) && void 0 !== _d ? _d : 0,
          height: null !== (_f = null !== (_e = textStyle.height) && void 0 !== _e ? _e : height) && void 0 !== _f ? _f : 0,
          ellipsis: null === (_g = textStyle.ellipsis) || void 0 === _g || _g,
          wordBreak: null !== (_h = textStyle.wordBreak) && void 0 !== _h ? _h : "break-word",
          maxHeight: textStyle.maxHeight,
          maxWidth: textStyle.maxWidth,
          textConfig: null !== (_j = textStyle.character) && void 0 !== _j ? _j : text2
        }, textStyle);
        this._mainTitle = group.createOrUpdateChild("mainTitle", attr, "richtext");
      } else if ("html" === textType) {
        const attr = Object.assign({
          html: Object.assign(Object.assign({
            dom: text2
          }, DEFAULT_HTML_TEXT_SPEC), textStyle),
          x: null !== (_k = textStyle.x) && void 0 !== _k ? _k : 0,
          y: null !== (_l = textStyle.y) && void 0 !== _l ? _l : 0,
          width: null !== (_o = null !== (_m = textStyle.width) && void 0 !== _m ? _m : width) && void 0 !== _o ? _o : 0,
          height: null !== (_q = null !== (_p = textStyle.height) && void 0 !== _p ? _p : height) && void 0 !== _q ? _q : 0,
          ellipsis: null === (_r = textStyle.ellipsis) || void 0 === _r || _r,
          wordBreak: null !== (_s = textStyle.wordBreak) && void 0 !== _s ? _s : "break-word",
          maxHeight: textStyle.maxHeight,
          maxWidth: textStyle.maxWidth,
          textConfig: []
        }, textStyle);
        this._mainTitle = group.createOrUpdateChild("mainTitle", attr, "richtext");
      } else
        isValid_default(text2) && (this._mainTitle = group.createOrUpdateChild("mainTitle", Object.assign(Object.assign({
          text: isArray_default(text2) ? text2 : [text2],
          wrap: true
        }, textStyle), {
          maxLineWidth: null !== (_t = textStyle.maxLineWidth) && void 0 !== _t ? _t : width,
          heightLimit: textStyle.heightLimit,
          lineClamp: textStyle.lineClamp,
          ellipsis: null === (_u = textStyle.ellipsis) || void 0 === _u || _u,
          x: 0,
          y: 0
        }), "text"));
    const maintextHeight = this._mainTitle ? this._mainTitle.AABBBounds.height() : 0, maintextWidth = this._mainTitle ? this._mainTitle.AABBBounds.width() : 0;
    if (false !== this.attribute.visible && false !== subtextStyle.visible)
      if ("rich" === subtextType || isValid_default(subtextStyle.character)) {
        const attr = Object.assign({
          x: null !== (_v = subtextStyle.x) && void 0 !== _v ? _v : 0,
          y: null !== (_w = subtextStyle.y) && void 0 !== _w ? _w : 0,
          width: null !== (_y = null !== (_x = subtextStyle.width) && void 0 !== _x ? _x : width) && void 0 !== _y ? _y : 0,
          height: null !== (_0 = null !== (_z = subtextStyle.height) && void 0 !== _z ? _z : height) && void 0 !== _0 ? _0 : 0,
          ellipsis: null === (_1 = subtextStyle.ellipsis) || void 0 === _1 || _1,
          wordBreak: null !== (_2 = subtextStyle.wordBreak) && void 0 !== _2 ? _2 : "break-word",
          maxHeight: subtextStyle.maxHeight,
          maxWidth: subtextStyle.maxWidth,
          textConfig: null !== (_3 = subtextStyle.character) && void 0 !== _3 ? _3 : subtext
        }, subtextStyle);
        this._subTitle = group.createOrUpdateChild("subTitle", attr, "richtext");
      } else if ("html" === subtextType) {
        const attr = Object.assign({
          html: Object.assign(Object.assign({
            dom: subtext
          }, DEFAULT_HTML_TEXT_SPEC), subtextStyle),
          x: null !== (_4 = subtextStyle.x) && void 0 !== _4 ? _4 : 0,
          y: null !== (_5 = subtextStyle.y) && void 0 !== _5 ? _5 : 0,
          width: null !== (_7 = null !== (_6 = subtextStyle.width) && void 0 !== _6 ? _6 : width) && void 0 !== _7 ? _7 : 0,
          height: null !== (_9 = null !== (_8 = subtextStyle.height) && void 0 !== _8 ? _8 : height) && void 0 !== _9 ? _9 : 0,
          ellipsis: null === (_10 = subtextStyle.ellipsis) || void 0 === _10 || _10,
          wordBreak: null !== (_11 = subtextStyle.wordBreak) && void 0 !== _11 ? _11 : "break-word",
          maxHeight: subtextStyle.maxHeight,
          maxWidth: subtextStyle.maxWidth,
          textConfig: []
        }, subtextStyle);
        this._subTitle = group.createOrUpdateChild("subTitle", attr, "richtext");
      } else
        isValid_default(subtext) && (this._subTitle = group.createOrUpdateChild("subTitle", Object.assign(Object.assign({
          text: isArray_default(subtext) ? subtext : [subtext],
          wrap: true
        }, subtextStyle), {
          maxLineWidth: null !== (_12 = subtextStyle.maxLineWidth) && void 0 !== _12 ? _12 : width,
          heightLimit: subtextStyle.heightLimit,
          lineClamp: subtextStyle.lineClamp,
          ellipsis: null === (_13 = subtextStyle.ellipsis) || void 0 === _13 || _13,
          x: 0,
          y: maintextHeight
        }), "text"));
    const subtextHeight = this._subTitle ? this._subTitle.AABBBounds.height() : 0, subtextWidth = this._subTitle ? this._subTitle.AABBBounds.width() : 0;
    let titleWidth = Math.max(maintextWidth, subtextWidth), titleHeight = maintextHeight + (null !== (_14 = subtextStyle.height) && void 0 !== _14 ? _14 : subtextHeight);
    if (isValid_default(width) && (titleWidth = width, this._mainTitle && this._mainTitle.setAttribute("maxLineWidth", width), this._subTitle && this._subTitle.setAttribute("maxLineWidth", width)), isValid_default(height) && (titleHeight = height), isValid_default(minWidth) && titleWidth < minWidth && (titleWidth = minWidth), isValid_default(maxWidth) && (this._mainTitle && this._mainTitle.setAttribute("maxLineWidth", maxWidth), this._subTitle && this._subTitle.setAttribute("maxLineWidth", maxWidth), this._mainTitle && this._mainTitle.setAttribute("maxWidth", maxWidth), this._subTitle && this._subTitle.setAttribute("maxWidth", maxWidth), titleWidth > maxWidth && (titleWidth = maxWidth)), isValid_default(minHeight) && titleHeight < minHeight && (titleHeight = minHeight), isValid_default(maxHeight) && (this._mainTitle && this._mainTitle.setAttribute("maxHeight", maxHeight), this._subTitle && this._subTitle.setAttribute("maxHeight", maxHeight - maintextHeight), titleHeight > maxHeight && (titleHeight = maxHeight)), group.attribute.width = titleWidth, group.attribute.height = titleHeight, group.attribute.boundsPadding = parsedPadding, this._mainTitle) {
      if (isValid_default(align) || isValid_default(textStyle.align)) {
        const mainTitleAlign = textStyle.align ? textStyle.align : align, mainTitleWidth = null !== (_15 = textStyle.width) && void 0 !== _15 ? _15 : maintextWidth;
        "left" === mainTitleAlign ? (this._mainTitle.setAttribute("x", 0), this._mainTitle.setAttribute("textAlign", "left")) : "center" === mainTitleAlign ? (this._mainTitle.setAttribute("x", mainTitleWidth / 2), this._mainTitle.setAttribute("textAlign", "center")) : "right" === mainTitleAlign && (this._mainTitle.setAttribute("x", mainTitleWidth), this._mainTitle.setAttribute("textAlign", "right"));
      }
      if (isValid_default(verticalAlign) || isValid_default(textStyle.verticalAlign)) {
        const mainTitleVerticalAlign = textStyle.verticalAlign ? textStyle.verticalAlign : verticalAlign, mainTitleHeight = textStyle.height ? textStyle.height : titleHeight;
        "top" === mainTitleVerticalAlign ? (this._mainTitle.setAttribute("y", 0), this._mainTitle.setAttribute("textBaseline", "top")) : "middle" === mainTitleVerticalAlign ? (this._mainTitle.setAttribute("y", mainTitleHeight / 2), this._mainTitle.setAttribute("textBaseline", "middle")) : "bottom" === mainTitleVerticalAlign && (this._mainTitle.setAttribute("y", mainTitleHeight), this._mainTitle.setAttribute("textBaseline", "bottom"));
      }
    }
    if (this._subTitle) {
      if (isValid_default(align) || isValid_default(subtextStyle.align)) {
        const subTitleAlign = subtextStyle.align ? subtextStyle.align : align, subTitleWidth = null !== (_16 = subtextStyle.width) && void 0 !== _16 ? _16 : subtextWidth;
        "left" === subTitleAlign ? (this._subTitle.setAttribute("x", 0), this._subTitle.setAttribute("textAlign", "left")) : "center" === subTitleAlign ? (this._subTitle.setAttribute("x", subTitleWidth / 2), this._subTitle.setAttribute("textAlign", "center")) : "right" === subTitleAlign && (this._subTitle.setAttribute("x", subTitleWidth), this._subTitle.setAttribute("textAlign", "right"));
      }
      if (isValid_default(verticalAlign) || isValid_default(textStyle.verticalAlign)) {
        const subTitleVerticalAlign = subtextStyle.verticalAlign ? subtextStyle.verticalAlign : verticalAlign, subTitleYStart = maintextHeight, subTitleHeight = null !== (_17 = subtextStyle.height) && void 0 !== _17 ? _17 : 0;
        "top" === subTitleVerticalAlign ? (this._subTitle.setAttribute("y", subTitleYStart), this._subTitle.setAttribute("textBaseline", "top")) : "middle" === subTitleVerticalAlign ? (this._subTitle.setAttribute("y", subTitleYStart + subTitleHeight / 2), this._subTitle.setAttribute("textBaseline", "middle")) : "bottom" === subTitleVerticalAlign && (this._subTitle.setAttribute("y", subTitleYStart + subTitleHeight), this._subTitle.setAttribute("textBaseline", "bottom"));
      }
    }
  }
};
Title.defaultAttributes = {
  textStyle: {
    ellipsis: "...",
    fill: "#333",
    fontSize: 20,
    fontWeight: "bold",
    textAlign: "left",
    textBaseline: "top"
  },
  subtextStyle: {
    ellipsis: "...",
    fill: "#6F6F6F",
    fontSize: 16,
    fontWeight: "normal",
    textAlign: "left",
    textBaseline: "top"
  }
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/indicator/config
var DEFAULT_INDICATOR_THEME = {
  title: {
    style: {
      text: "",
      fontSize: 20,
      fill: "black",
      fontWeight: "normal",
      fillOpacity: 1,
      textBaseline: "top",
      textAlign: "center"
    }
  },
  content: {
    style: {
      text: "",
      fontSize: 16,
      fill: "black",
      fontWeight: "normal",
      fillOpacity: 1,
      textBaseline: "top",
      textAlign: "center"
    }
  }
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/indicator/register
function loadIndicatorComponent() {
  registerGroup(), registerText(), registerRichtext();
}

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/indicator/indicator
loadIndicatorComponent();
var Indicator = class extends AbstractComponent {
  constructor() {
    super(...arguments), this.name = "indicator";
  }
  render() {
    var _a;
    const { visible, title: title3 = {}, content, size, limitRatio = 1 / 0 } = this.attribute, limit = Math.min(size.width, size.height) * limitRatio, group = this.createOrUpdateChild("indicator-container", {
      x: 0,
      y: 0,
      zIndex: 1
    }, "group");
    if (true !== visible)
      return void (group && group.hideAll());
    if (isValid_default(title3))
      if (false !== title3.visible) {
        const titleStyle = merge({}, get_default(DEFAULT_INDICATOR_THEME, "title.style"), title3.style);
        isRichText(titleStyle) ? this._title = group.createOrUpdateChild("indicator-title", Object.assign(Object.assign({}, richTextAttributeTransform(titleStyle)), {
          visible: title3.visible,
          x: 0,
          y: 0
        }), "richtext") : this._title = group.createOrUpdateChild("indicator-title", Object.assign(Object.assign({}, titleStyle), {
          lineHeight: isValid_default(titleStyle.lineHeight) ? titleStyle.lineHeight : titleStyle.fontSize,
          visible: title3.visible,
          x: 0,
          y: 0
        }), "text"), title3.autoFit && isValidNumber_default(limit) && this._setLocalAutoFit(limit, this._title, title3), title3.autoLimit && isValidNumber_default(limitRatio) && this._title.setAttribute("maxLineWidth", limit);
      } else {
        const titleNode = group.find((node) => "indicator-title" === node.name, false);
        titleNode && group.removeChild(titleNode), this._title = void 0;
      }
    if (isValid_default(content)) {
      const contents = array(content), contentComponents = [];
      contents.forEach((contentItem, i) => {
        if (false !== contentItem.visible) {
          const contentStyle = merge({}, get_default(DEFAULT_INDICATOR_THEME, "content.style"), contentItem.style);
          let contentComponent;
          contentComponent = isRichText(contentStyle) ? group.createOrUpdateChild("indicator-content-" + i, Object.assign(Object.assign({}, richTextAttributeTransform(contentStyle)), {
            visible: title3.visible,
            x: 0,
            y: 0
          }), "richtext") : group.createOrUpdateChild("indicator-content-" + i, Object.assign(Object.assign({}, contentStyle), {
            lineHeight: isValid_default(contentStyle.lineHeight) ? contentStyle.lineHeight : contentStyle.fontSize,
            visible: contentItem.visible,
            x: 0,
            y: 0
          }), "text"), contentItem.autoFit && isValidNumber_default(limit) && this._setLocalAutoFit(limit, contentComponent, contentItem), contentItem.autoLimit && isValidNumber_default(limitRatio) && contentComponent.setAttribute("maxLineWidth", limit), contentComponents.push(contentComponent);
        } else {
          const contentItemNode = group.find((node) => node.name === "indicator-content-" + i, false);
          contentItemNode && group.removeChild(contentItemNode);
        }
      }), this._content = contentComponents;
    }
    this._setGlobalAutoFit(limit), this._setYPosition();
    const totalHeight = null !== (_a = null == group ? void 0 : group.AABBBounds.height()) && void 0 !== _a ? _a : 0;
    group.setAttribute("y", size.height / 2 - totalHeight / 2), group.setAttribute("x", size.width / 2);
  }
  _setLocalAutoFit(limit, indicatorItem, indicatorItemSpec) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    if ("default" !== (null !== (_a = indicatorItemSpec.fitStrategy) && void 0 !== _a ? _a : "default"))
      return;
    const originWidth = measureTextSize(null !== (_c = null === (_b = indicatorItemSpec.style) || void 0 === _b ? void 0 : _b.text) && void 0 !== _c ? _c : "", null !== (_d = indicatorItemSpec.style) && void 0 !== _d ? _d : {}, null === (_f = null === (_e = this.stage) || void 0 === _e ? void 0 : _e.getTheme()) || void 0 === _f ? void 0 : _f.text).width;
    if (originWidth > 0) {
      const ratio = limit * (null !== (_g = indicatorItemSpec.fitPercent) && void 0 !== _g ? _g : 0.5) / originWidth, fontSize = Math.floor((null !== (_j = null === (_h = indicatorItemSpec.style) || void 0 === _h ? void 0 : _h.fontSize) && void 0 !== _j ? _j : 20) * ratio);
      indicatorItem.setAttribute("fontSize", fontSize), indicatorItem.setAttribute("lineHeight", isValid_default(indicatorItemSpec.style.lineHeight) ? indicatorItemSpec.style.lineHeight : fontSize);
    }
  }
  _setGlobalAutoFit(limit) {
    var _a, _b, _c, _d, _e, _f, _g;
    const r = limit / 2, autoFitTexts = [];
    let otherHeight = 0;
    const titleSpec = null !== (_a = this.attribute.title) && void 0 !== _a ? _a : {};
    titleSpec.autoFit && "inscribed" === titleSpec.fitStrategy ? (this._title.setAttribute("fontSize", 12), autoFitTexts.push({
      text: this._title,
      spec: null !== (_b = this.attribute.title) && void 0 !== _b ? _b : {}
    })) : otherHeight += null !== (_f = null === (_e = null === (_d = null === (_c = this._title) || void 0 === _c ? void 0 : _c.AABBBounds) || void 0 === _d ? void 0 : _d.height) || void 0 === _e ? void 0 : _e.call(_d)) && void 0 !== _f ? _f : 0;
    const titleSpace = null !== (_g = titleSpec.space) && void 0 !== _g ? _g : 0;
    if (otherHeight += titleSpace, array(this.attribute.content).filter((contentSpec) => false !== contentSpec.visible).forEach((contentSpec, index) => {
      var _a2, _b2, _c2, _d2;
      const contentText = this._content[index];
      contentSpec.autoFit && "inscribed" === contentSpec.fitStrategy ? (contentText.setAttribute("fontSize", 12), autoFitTexts.push({
        text: contentText,
        spec: contentSpec
      })) : otherHeight += null !== (_c2 = null === (_b2 = null === (_a2 = null == contentText ? void 0 : contentText.AABBBounds) || void 0 === _a2 ? void 0 : _a2.height) || void 0 === _b2 ? void 0 : _b2.call(_a2)) && void 0 !== _c2 ? _c2 : 0;
      const contentSpace = null !== (_d2 = contentSpec.space) && void 0 !== _d2 ? _d2 : 0;
      otherHeight += contentSpace;
    }), autoFitTexts.length <= 0)
      return;
    const ra = 12 / autoFitTexts.reduce((width, textItem) => Math.max(width, textItem.text.AABBBounds.width()), 0) * autoFitTexts.length, h = otherHeight / 2, a3 = ra ** 2 + 1, b = 2 * h * ra, c3 = h ** 2 - r ** 2, y = 2 * (ra * ((-b + Math.sqrt(b ** 2 - 4 * a3 * c3)) / (2 * a3)) + h), lineHeight = (y - otherHeight) / autoFitTexts.length;
    isValidNumber_default(y) && autoFitTexts.forEach((textItem) => {
      var _a2;
      const specLineHeight = null === (_a2 = textItem.spec.style) || void 0 === _a2 ? void 0 : _a2.lineHeight;
      textItem.text.setAttribute("fontSize", lineHeight), textItem.text.setAttribute("lineHeight", isValid_default(specLineHeight) ? specLineHeight : lineHeight);
    });
  }
  _setYPosition() {
    var _a, _b, _c, _d, _e, _f;
    let lastContentHeight = 0;
    const titleHeight = null !== (_d = null === (_c = null === (_b = null === (_a = this._title) || void 0 === _a ? void 0 : _a.AABBBounds) || void 0 === _b ? void 0 : _b.height) || void 0 === _c ? void 0 : _c.call(_b)) && void 0 !== _d ? _d : 0, titleSpace = null !== (_f = null === (_e = this.attribute.title) || void 0 === _e ? void 0 : _e.space) && void 0 !== _f ? _f : 0;
    array(this.attribute.content).filter((contentSpec) => false !== contentSpec.visible).forEach((contentSpec, index) => {
      var _a2;
      const contentText = this._content[index];
      contentText.setAttribute("y", titleHeight + titleSpace + lastContentHeight);
      const contentSpace = null !== (_a2 = contentSpec.space) && void 0 !== _a2 ? _a2 : 0;
      lastContentHeight += contentText.AABBBounds.height() + contentSpace;
    });
  }
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/player/controller/assets
var iconPlay = "M 414.5 0.0238 c 228.9128 0 414.4762 185.5634 414.4762 414.4762 s -185.5634 414.4762 -414.4762 414.4762 S 0.0238 643.4128 0.0238 414.5 S 185.5872 0.0238 414.5 0.0238 z m 0 73.1429 C 225.9865 73.1667 73.1667 225.9865 73.1667 414.5 s 152.8198 341.3333 341.3333 341.3333 s 341.3333 -152.8198 341.3333 -341.3333 S 603.0135 73.1667 414.5 73.1667 z m -73.1429 161.4994 a 48.7619 48.7619 0 0 1 25.9901 7.5093 l 201.7524 127.1223 a 48.7619 48.7619 0 0 1 0.3657 82.2613 l -201.7524 129.6335 A 48.7619 48.7619 0 0 1 292.5952 540.1838 v -256.7314 a 48.7619 48.7619 0 0 1 48.7619 -48.7619 z m 24.381 92.9402 v 167.9116 l 131.9497 -84.7726 L 365.7381 327.6063 z";
var iconPause = "M 414.5 0.0238 c 228.9128 0 414.4762 185.5634 414.4762 414.4762 s -185.5634 414.4762 -414.4762 414.4762 S 0.0238 643.4128 0.0238 414.5 S 185.5872 0.0238 414.5 0.0238 z m 0 73.1429 C 225.9865 73.1667 73.1667 225.9865 73.1667 414.5 s 152.8198 341.3333 341.3333 341.3333 s 341.3333 -152.8198 341.3333 -341.3333 S 603.0135 73.1667 414.5 73.1667 z m -48.7619 195.0476 v 316.9524 h -73.1429 V 268.2143 h 73.1429 z m 158.4762 0 v 316.9524 h -73.1429 V 268.2143 h 73.1429 z";
var iconLeft = "M 521.29 734.276 L 230.929 448.019 L 521.29 161.762 c 37.685 -37.153 38.003 -97.625 0.707 -134.384 c -37.297 -36.758 -98.646 -36.435 -136.331 0.718 l -357.43 352.378 c -0.155 0.153 -0.297 0.314 -0.451 0.468 c -0.084 0.082 -0.172 0.157 -0.256 0.239 c -18.357 18.092 -27.581 41.929 -27.743 65.902 c -0.004 0.311 -0.017 0.623 -0.018 0.934 c 0.001 0.316 0.014 0.632 0.018 0.948 c 0.165 23.97 9.389 47.803 27.743 65.892 c 0.083 0.082 0.171 0.157 0.255 0.239 c 0.154 0.154 0.296 0.315 0.452 0.468 l 357.43 352.378 c 37.685 37.153 99.034 37.476 136.331 0.718 c 37.297 -36.758 36.979 -97.231 -0.707 -134.384 z";
var iconDown = "M 734.276 28.71 L 448.019 319.071 L 161.762 28.71 c -37.153 -37.685 -97.625 -38.003 -134.384 -0.707 c -36.758 37.297 -36.435 98.646 0.718 136.331 l 352.378 357.43 c 0.153 0.155 0.314 0.297 0.468 0.451 c 0.082 0.084 0.157 0.172 0.239 0.256 c 18.092 18.357 41.929 27.581 65.902 27.743 c 0.311 0.004 0.623 0.017 0.934 0.018 c 0.316 -0.001 0.632 -0.014 0.948 -0.018 c 23.97 -0.165 47.803 -9.389 65.892 -27.743 c 0.082 -0.083 0.157 -0.171 0.239 -0.255 c 0.154 -0.154 0.315 -0.296 0.468 -0.452 l 352.378 -357.43 c 37.153 -37.685 37.476 -99.034 0.718 -136.331 c -36.758 -37.297 -97.231 -36.979 -134.384 0.707 z";
var iconUp = "m 161.724 521.29 l 286.257 -290.361 l 286.257 290.361 c 37.153 37.685 97.625 38.003 134.384 0.707 c 36.758 -37.297 36.435 -98.646 -0.718 -136.331 l -352.378 -357.43 c -0.153 -0.155 -0.314 -0.297 -0.468 -0.451 c -0.082 -0.084 -0.157 -0.172 -0.239 -0.256 c -18.092 -18.357 -41.929 -27.581 -65.902 -27.743 c -0.311 -0.004 -0.623 -0.017 -0.934 -0.018 c -0.316 0.001 -0.632 0.014 -0.948 0.018 c -23.97 0.165 -47.803 9.389 -65.892 27.743 c -0.082 0.083 -0.157 0.171 -0.239 0.255 c -0.154 0.154 -0.315 0.296 -0.468 0.452 l -352.378 357.43 c -37.153 37.685 -37.476 99.034 -0.718 136.331 c 36.758 37.297 97.231 36.979 134.384 -0.707 z";
var iconRight = "M 30 163 L 320.361 449.257 L 30 735.514 c -37.685 37.153 -38.003 97.625 -0.707 134.384 c 37.297 36.758 98.646 36.435 136.331 -0.718 l 357.43 -352.378 c 0.155 -0.153 0.297 -0.314 0.451 -0.468 c 0.084 -0.082 0.172 -0.157 0.256 -0.239 c 18.357 -18.092 27.581 -41.929 27.743 -65.902 c 0.004 -0.311 0.017 -0.623 0.018 -0.934 c -0.001 -0.316 -0.014 -0.632 -0.018 -0.948 c -0.165 -23.97 -9.389 -47.803 -27.743 -65.892 c -0.083 -0.082 -0.171 -0.157 -0.255 -0.239 c -0.154 -0.154 -0.296 -0.315 -0.452 -0.468 l -357.43 -352.378 c -37.685 -37.153 -99.034 -37.476 -136.331 -0.718 c -37.297 36.758 -36.979 97.231 0.707 134.384 z";

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/player/controller/icon/icon
var PlayerIcon = class extends Symbol2 {
  constructor(params2) {
    super(params2);
  }
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/player/controller/constant
var ControllerEventEnum;
!function(ControllerEventEnum2) {
  ControllerEventEnum2.OnPlay = "onPlay", ControllerEventEnum2.OnPause = "onPause", ControllerEventEnum2.OnForward = "onForward", ControllerEventEnum2.OnBackward = "onBackward";
}(ControllerEventEnum || (ControllerEventEnum = {}));
var ControllerTypeEnum;
!function(ControllerTypeEnum2) {
  ControllerTypeEnum2.Start = "start", ControllerTypeEnum2.Pause = "pause", ControllerTypeEnum2.Forward = "forward", ControllerTypeEnum2.Backward = "backward";
}(ControllerTypeEnum || (ControllerTypeEnum = {}));

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/player/controller/controller
var Controller = class _Controller extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Controller.defaultAttributes, attributes)), this._isPaused = true, this.updateAttributes = () => {
      this._startAttr = {
        style: Object.assign(Object.assign(Object.assign({
          symbolType: iconPlay
        }, _Controller.defaultControllerAttr), {
          visible: this.attribute.start.visible
        }), this.attribute.start.style)
      }, this._pauseAttr = {
        style: Object.assign(Object.assign(Object.assign({
          symbolType: iconPause
        }, _Controller.defaultControllerAttr), {
          visible: this.attribute.pause.visible
        }), this.attribute.pause.style)
      }, this._forwardAttr = {
        style: Object.assign(Object.assign(Object.assign({}, _Controller.defaultControllerAttr), {
          visible: this.attribute.forward.visible
        }), this.attribute.forward.style)
      }, this._backwardAttr = {
        style: Object.assign(Object.assign(Object.assign({}, _Controller.defaultControllerAttr), {
          visible: this.attribute.backward.visible
        }), this.attribute.backward.style)
      }, this.updateLayout();
    }, this.updateLayout = () => {
      var _a, _b, _c, _d;
      this._layout = this.attribute.layout, "horizontal" === this._layout ? (this._backwardAttr.style.symbolType = null !== (_a = this._backwardAttr.style.symbolType) && void 0 !== _a ? _a : iconLeft, this._forwardAttr.style.symbolType = null !== (_b = this._forwardAttr.style.symbolType) && void 0 !== _b ? _b : iconRight) : "vertical" === this._layout && (this._backwardAttr.style.symbolType = null !== (_c = this._backwardAttr.style.symbolType) && void 0 !== _c ? _c : iconUp, this._forwardAttr.style.symbolType = null !== (_d = this._forwardAttr.style.symbolType) && void 0 !== _d ? _d : iconDown);
    }, this._initPlay = () => {
      isNil_default(this._playController) && (this._playController = new PlayerIcon(Object.assign({}, this._startAttr.style)), this.add(this._playController));
    }, this._initBackward = () => {
      isNil_default(this._backwardController) && (this._backwardController = new PlayerIcon(Object.assign({}, this._backwardAttr.style)), this.add(this._backwardController));
    }, this._initForward = () => {
      isNil_default(this._forwardController) && (this._forwardController = new PlayerIcon(Object.assign({}, this._forwardAttr.style)), this.add(this._forwardController));
    }, this._initEvents = () => {
      this.attribute.disableTriggerEvent || (this._playController.addEventListener("pointerdown", (e) => {
        e.stopPropagation(), true === this._isPaused ? this.play() : this.pause();
      }), this._backwardController.addEventListener("pointerdown", (e) => {
        e.stopPropagation(), this.backward();
      }), this._forwardController.addEventListener("pointerdown", (e) => {
        e.stopPropagation(), this.forward();
      }));
    }, this.renderPlay = () => {
      this._isPaused ? this._playController.setAttributes(Object.assign({
        symbolType: this._playController.getComputedAttribute("symbolType")
      }, this._startAttr.style)) : this._playController.setAttributes(Object.assign({
        symbolType: this._playController.getComputedAttribute("symbolType")
      }, this._pauseAttr.style));
    }, this.renderBackward = () => {
      this._backwardController.setAttributes(this._backwardAttr.style);
    }, this.renderForward = () => {
      this._forwardController.setAttributes(this._forwardAttr.style);
    }, this.play = () => {
      this._dispatchEvent(ControllerEventEnum.OnPlay);
    }, this.pause = () => {
      this._dispatchEvent(ControllerEventEnum.OnPause);
    }, this.forward = () => {
      this._dispatchEvent(ControllerEventEnum.OnForward);
    }, this.backward = () => {
      this._dispatchEvent(ControllerEventEnum.OnBackward);
    }, this.togglePlay = () => {
      this._playController.setAttributes(this._startAttr.style), this._isPaused = true;
    }, this.togglePause = () => {
      this._playController.setAttributes(this._pauseAttr.style), this._isPaused = false;
    }, this.updateAttributes(), this._initPlay(), this._initBackward(), this._initForward(), this._initEvents();
  }
  render() {
    this.updateAttributes(), this.renderPlay(), this.renderBackward(), this.renderForward();
  }
};
Controller.defaultControllerAttr = {
  visible: true,
  x: 0,
  y: 0,
  size: 20,
  fill: "#91caff",
  pickMode: "imprecise",
  cursor: "pointer"
}, Controller.defaultAttributes = {
  [ControllerTypeEnum.Start]: {},
  [ControllerTypeEnum.Pause]: {},
  [ControllerTypeEnum.Backward]: {},
  [ControllerTypeEnum.Forward]: {}
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/player/constant
var defaultControllerAttributes = {
  visible: true,
  style: {
    x: 0,
    y: 0,
    dx: 0,
    dy: 0,
    size: 20
  },
  order: 0,
  space: 10
};
var RailDefaultSize = [200, 10];

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/player/type/direction
var DirectionEnum;
!function(DirectionEnum2) {
  DirectionEnum2.Default = "default", DirectionEnum2.Reverse = "reverse";
}(DirectionEnum || (DirectionEnum = {}));

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/player/type/event
var PlayerEventEnum;
!function(PlayerEventEnum2) {
  PlayerEventEnum2.change = "change", PlayerEventEnum2.play = "play", PlayerEventEnum2.pause = "pause", PlayerEventEnum2.backward = "backward", PlayerEventEnum2.forward = "forward", PlayerEventEnum2.end = "end", PlayerEventEnum2.OnChange = "change", PlayerEventEnum2.OnPlay = "play", PlayerEventEnum2.OnPause = "pause", PlayerEventEnum2.OnBackward = "backward", PlayerEventEnum2.OnForward = "forward", PlayerEventEnum2.OnEnd = "end";
}(PlayerEventEnum || (PlayerEventEnum = {}));

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/player/utils
var isReachEndByDefault = ({ direction: direction2, maxIndex, dataIndex }) => direction2 === DirectionEnum.Default && dataIndex === maxIndex;
var isReachEndByReverse = ({ direction: direction2, minIndex, dataIndex }) => direction2 === DirectionEnum.Reverse && dataIndex === minIndex;
var isReachEnd = ({ direction: direction2, maxIndex, minIndex, dataIndex }) => isReachEndByDefault({
  direction: direction2,
  maxIndex,
  dataIndex
}) || isReachEndByReverse({
  direction: direction2,
  minIndex,
  dataIndex
});
var isReachStartByDefault = ({ direction: direction2, minIndex, dataIndex }) => direction2 === DirectionEnum.Default && dataIndex === minIndex;
var isReachStartByReverse = ({ direction: direction2, maxIndex, dataIndex }) => direction2 === DirectionEnum.Reverse && dataIndex === maxIndex;
var isReachStart = ({ direction: direction2, maxIndex, minIndex, dataIndex }) => isReachStartByDefault({
  direction: direction2,
  minIndex,
  dataIndex
}) || isReachStartByReverse({
  direction: direction2,
  maxIndex,
  dataIndex
});
var isHorizontal = (orient) => "top" === orient || "bottom" === orient;
var forwardStep = (direction2, currentIndex, min3, max3) => "default" === direction2 ? Math.min(currentIndex + 1, max3) : Math.max(currentIndex - 1, min3);

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/player/base-player
var BasePlayer = class _BasePlayer extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _BasePlayer.defaultAttributes, attributes)), this._data = [], this._dataIndex = 0, this._layoutInfo = {}, this._updateSliderAttrs = () => {
      var _a, _b;
      let handlerSize;
      isValidNumber_default(this._handlerStyle.size) ? handlerSize = this._handlerStyle.size : this._handlerStyle.size && this._handlerStyle.size.length && (handlerSize = max(this._handlerStyle.size[0], this._handlerStyle.size[1]));
      const attrs = {
        visible: this._sliderVisible,
        min: this._minIndex,
        max: this._maxIndex,
        value: this._dataIndex,
        railWidth: this._railStyle.width,
        railHeight: this._railStyle.height,
        railStyle: this._railStyle,
        trackStyle: this._trackStyle,
        handlerSize: isValidNumber_default(handlerSize) ? handlerSize : void 0,
        handlerStyle: this._handlerStyle,
        dy: this.attribute.slider.dy,
        dx: this.attribute.slider.dx,
        slidable: true,
        range: false,
        handlerText: {
          visible: false
        },
        startText: {
          visible: false
        },
        endText: {
          visible: false
        },
        disableTriggerEvent: this.attribute.disableTriggerEvent
      };
      if (isHorizontal(this._orient)) {
        const railWidth = Math.max(0, this._layoutInfo.slider.size), railHeight = null !== (_a = this._railStyle.height) && void 0 !== _a ? _a : RailDefaultSize[1];
        attrs.layout = "horizontal", attrs.railHeight = railHeight, attrs.railWidth = railWidth, attrs.x = this._layoutInfo.slider.x, attrs.y = this._layoutInfo.slider.y;
      } else {
        const railHeight = Math.max(0, this._layoutInfo.slider.size), railWidth = null !== (_b = this._railStyle.width) && void 0 !== _b ? _b : RailDefaultSize[1];
        attrs.layout = "vertical", attrs.railWidth = railWidth, attrs.railHeight = railHeight, attrs.x = this._layoutInfo.slider.x, attrs.y = this._layoutInfo.slider.y;
      }
      return attrs;
    }, this._initSlider = () => {
      const attrs = this._updateSliderAttrs();
      this._slider = new Slider(attrs), this._sliderVisible && this.add(this._slider);
    }, this._updateControllerAttrs = () => {
      const attrs = {
        start: this._start,
        pause: this._pause,
        forward: this._forward,
        backward: this._backward,
        disableTriggerEvent: this.attribute.disableTriggerEvent
      };
      return isHorizontal(this._orient) ? (attrs.layout = "horizontal", attrs.start = Object.assign(Object.assign({}, attrs.start), {
        style: Object.assign(Object.assign({}, attrs.start.style), {
          x: this._layoutInfo.start.x,
          y: this._layoutInfo.start.y
        })
      }), attrs.pause = Object.assign(Object.assign({}, attrs.pause), {
        style: Object.assign(Object.assign({}, attrs.pause.style), {
          x: this._layoutInfo.start.x,
          y: this._layoutInfo.start.y
        })
      }), attrs.backward = Object.assign(Object.assign({}, attrs.backward), {
        style: Object.assign(Object.assign({}, attrs.backward.style), {
          x: this._layoutInfo.backward.x,
          y: this._layoutInfo.backward.y
        })
      }), attrs.forward = Object.assign(Object.assign({}, attrs.forward), {
        style: Object.assign(Object.assign({}, attrs.forward.style), {
          x: this._layoutInfo.forward.x,
          y: this._layoutInfo.forward.y
        })
      })) : (attrs.layout = "vertical", attrs.start = Object.assign(Object.assign({}, attrs.start), {
        style: Object.assign(Object.assign({}, attrs.start.style), {
          x: this._layoutInfo.start.x,
          y: this._layoutInfo.start.y
        })
      }), attrs.pause = Object.assign(Object.assign({}, attrs.pause), {
        style: Object.assign(Object.assign({}, attrs.pause.style), {
          x: this._layoutInfo.start.x,
          y: this._layoutInfo.start.y
        })
      }), attrs.backward = Object.assign(Object.assign({}, attrs.backward), {
        style: Object.assign(Object.assign({}, attrs.backward.style), {
          x: this._layoutInfo.backward.x,
          y: this._layoutInfo.backward.y
        })
      }), attrs.forward = Object.assign(Object.assign({}, attrs.forward), {
        style: Object.assign(Object.assign({}, attrs.forward.style), {
          x: this._layoutInfo.forward.x,
          y: this._layoutInfo.forward.y
        })
      })), attrs;
    }, this._initController = () => {
      const attrs = this._updateControllerAttrs();
      this._controller = new Controller(attrs), this._controllerVisible && this.add(this._controller);
    }, this._initAttributes(), this._initDataIndex(), this._initLayoutInfo(), this._initController(), this._initSlider();
  }
  _initAttributes() {
    this._size = this.attribute.size, this._orient = this.attribute.orient, this._data = this.attribute.data, this._minIndex = 0, this._maxIndex = this._data.length - 1;
    const { slider: slider2 = {}, controller = {} } = this.attribute;
    this._sliderVisible = slider2.visible, this._railStyle = Object.assign({}, slider2.railStyle), this._trackStyle = Object.assign({}, slider2.trackStyle), this._handlerStyle = Object.assign({}, slider2.handlerStyle), this._controllerVisible = controller.visible, this._start = Object.assign({}, controller.start), this._pause = Object.assign({}, controller.pause), this._forward = Object.assign({}, controller.forward), this._backward = Object.assign({}, controller.backward);
  }
  _initDataIndex() {
    var _a;
    this._dataIndex = null !== (_a = this.attribute.dataIndex) && void 0 !== _a ? _a : 0;
  }
  _initLayoutInfo() {
    var _a, _b, _c;
    const controllers = [this._start, this._backward, this._forward].sort((a3, b) => a3.order - b.order), startControllers = controllers.filter((d) => "end" !== d.position), endControllers = controllers.filter((d) => "end" === d.position), railSectionLength = null !== (_a = isHorizontal(this._orient) ? this._railStyle.height : this._railStyle.width) && void 0 !== _a ? _a : RailDefaultSize[1], controllerPx = controllers.reduce((len, controller) => {
      const size = controller.style.size, maxSize = isNumber_default(size) ? size : max(size[0], size[1]);
      return len + controller.space + maxSize;
    }, 0), sliderPx = this._sliderVisible ? (isHorizontal(this._orient) ? null === (_b = this._size) || void 0 === _b ? void 0 : _b.width : null === (_c = this._size) || void 0 === _c ? void 0 : _c.height) - controllerPx : 0, railPx = sliderPx - this.attribute.slider.space, startPx = startControllers.reduce((px, controller) => {
      const { key, space, style: { size } } = controller, maxSize = isNumber_default(size) ? size : max(size[0], size[1]);
      return this._layoutInfo[key] = Object.assign(Object.assign({}, this._layoutInfo[key]), {
        size: maxSize,
        x: isHorizontal(this._orient) ? px + space : (this._size.width - maxSize) / 2,
        y: isHorizontal(this._orient) ? (this._size.height - maxSize) / 2 : px + space
      }), px + space + maxSize;
    }, 0);
    this._layoutInfo.slider = Object.assign(Object.assign({}, this._layoutInfo.slider), {
      size: railPx,
      x: isHorizontal(this._orient) ? startPx + this.attribute.slider.space : (this._size.width - railSectionLength) / 2,
      y: isHorizontal(this._orient) ? (this._size.height - railSectionLength) / 2 : startPx + this.attribute.slider.space
    }), endControllers.reduce((px, controller) => {
      const { key, space, style: { size } } = controller, maxSize = isNumber_default(size) ? size : max(size[0], size[1]);
      return this._layoutInfo[key] = Object.assign(Object.assign({}, this._layoutInfo[key]), {
        size: maxSize,
        x: isHorizontal(this._orient) ? px + space : (this._size.width - maxSize) / 2,
        y: isHorizontal(this._orient) ? (this._size.height - maxSize) / 2 : px + space
      }), px + space + maxSize;
    }, startPx + sliderPx);
  }
  render() {
    this._initLayoutInfo(), this.renderSlider(), this.renderController();
  }
  renderSlider() {
    const attrs = this._updateSliderAttrs();
    this._slider.setAttributes(attrs);
  }
  renderController() {
    const attrs = this._updateControllerAttrs();
    this._controller.setAttributes(attrs);
  }
  dispatchCustomEvent(eventType, dataIndex) {
    this._dispatchEvent(eventType, {
      eventType,
      index: dataIndex,
      value: this._data[dataIndex]
    });
  }
};
BasePlayer.defaultAttributes = {
  visible: true,
  data: [],
  interval: 1e3,
  orient: "bottom",
  align: "center",
  size: {
    height: 20,
    width: 300
  },
  slider: {
    visible: true,
    space: 10,
    dx: 0,
    dy: 0,
    railStyle: {
      cornerRadius: 5
    },
    trackStyle: {},
    handlerStyle: {}
  },
  controller: {
    visible: true,
    start: Object.assign(Object.assign({}, defaultControllerAttributes), {
      key: "start",
      position: "start",
      space: 0
    }),
    pause: Object.assign(Object.assign({}, defaultControllerAttributes), {
      key: "pause",
      position: "start"
    }),
    forward: Object.assign(Object.assign({}, defaultControllerAttributes), {
      key: "forward",
      position: "end"
    }),
    backward: Object.assign(Object.assign({}, defaultControllerAttributes), {
      key: "backward",
      position: "start"
    })
  }
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/player/register
function loadBasePlayer() {
  loadSliderComponent(), registerGroup(), registerSymbol();
}
function loadDiscretePlayerComponent() {
  loadBasePlayer();
}
function loadContinuousPlayerComponent() {
  loadBasePlayer();
}

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/player/discrete-player
loadDiscretePlayerComponent();
var DiscretePlayer = class extends BasePlayer {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, attributes)), this._activeIndex = -1, this._isReachEnd = false, this._initAttributes = () => {
      var _a, _b, _c;
      super._initAttributes(), this._alternate = null !== (_a = this.attribute.alternate) && void 0 !== _a && _a, this._interval = null !== (_b = this.attribute.interval) && void 0 !== _b ? _b : 1e3, this._direction = null !== (_c = this.attribute.direction) && void 0 !== _c ? _c : DirectionEnum.Default;
    }, this._initDataIndex = () => {
      var _a;
      this._dataIndex = isNil_default(this.attribute.dataIndex) ? "default" === this._direction ? this._minIndex : this._maxIndex : null !== (_a = this.attribute.dataIndex) && void 0 !== _a ? _a : 0, this._slider.setAttribute("value", this._dataIndex);
    }, this._initEvents = () => {
      this.attribute.disableTriggerEvent || (this._controller.addEventListener(ControllerEventEnum.OnPlay, (e) => {
        e.stopPropagation(), this.play();
      }), this._controller.addEventListener(ControllerEventEnum.OnPause, (e) => {
        e.stopPropagation(), this.pause();
      }), this._controller.addEventListener(ControllerEventEnum.OnForward, (e) => {
        e.stopPropagation(), this.forward();
      }), this._controller.addEventListener(ControllerEventEnum.OnBackward, (e) => {
        e.stopPropagation(), this.backward();
      }), this._slider.addEventListener("change", (e) => {
        const middle = Math.floor(e.detail.value) + 0.5;
        this._dataIndex = e.detail.value >= middle ? Math.ceil(e.detail.value) : Math.floor(e.detail.value), this._slider.setValue(this._dataIndex), this.dispatchCustomEvent(PlayerEventEnum.change);
      }));
    }, this.play = () => {
      this._isPlaying || 1 !== this._data.length && (this._controller.togglePause(), this._isPlaying = true, (isReachEnd({
        dataIndex: this._dataIndex,
        maxIndex: this._maxIndex,
        minIndex: this._minIndex,
        direction: this._direction
      }) || isReachStart({
        dataIndex: this._dataIndex,
        maxIndex: this._maxIndex,
        minIndex: this._minIndex,
        direction: this._direction
      })) && (this._direction === DirectionEnum.Default ? this._updateDataIndex(this._minIndex) : this._updateDataIndex(this._maxIndex)), this.dispatchCustomEvent(PlayerEventEnum.play), this._isReachEnd = false, this._tickTime = Date.now(), this._rafId = vglobal.getRequestAnimationFrame()(this._play.bind(this, true)));
    }, this._play = (isFirstPlay) => {
      const now = Date.now();
      if (this._isReachEnd && now - this._tickTime >= this._interval)
        return this._isReachEnd = false, void this._playEnd();
      isFirstPlay && this._activeIndex !== this._dataIndex ? (this.dispatchCustomEvent(PlayerEventEnum.change), this._activeIndex = this._dataIndex) : now - this._tickTime >= this._interval && (this._tickTime = now, this._updateDataIndex(forwardStep(this._direction, this._dataIndex, this._minIndex, this._maxIndex)), this._activeIndex = this._dataIndex, this.dispatchCustomEvent(PlayerEventEnum.change)), ("default" === this._direction && this._dataIndex >= this._maxIndex || "reverse" === this._direction && this._dataIndex <= this._minIndex) && (this._isReachEnd = true), this._rafId = vglobal.getRequestAnimationFrame()(this._play.bind(this, false));
    }, this._updateDataIndex = (dataIndex) => {
      this._dataIndex = dataIndex, this._slider.setValue(this._dataIndex);
    }, this._playEnd = () => {
      this._isPlaying = false, this._controller.togglePlay(), vglobal.getCancelAnimationFrame()(this._rafId), this._activeIndex = -1, this.dispatchCustomEvent(PlayerEventEnum.end);
    }, this.pause = () => {
      this._isPlaying && (this._isPlaying = false, vglobal.getCancelAnimationFrame()(this._rafId), this._controller.togglePlay(), this.dispatchCustomEvent(PlayerEventEnum.pause));
    }, this.backward = () => {
      const { loop = false } = this.attribute;
      let index;
      index = loop ? this._dataIndex - 1 < this._minIndex ? this._maxIndex : this._dataIndex - 1 : Math.max(this._dataIndex - 1, this._minIndex), this._updateDataIndex(index), this.dispatchCustomEvent(PlayerEventEnum.change), this.dispatchCustomEvent(PlayerEventEnum.backward);
    }, this.forward = () => {
      const { loop = false } = this.attribute;
      let index;
      index = loop ? this._dataIndex + 1 > this._maxIndex ? this._minIndex : this._dataIndex + 1 : Math.min(this._dataIndex + 1, this._maxIndex), this._updateDataIndex(index), this.dispatchCustomEvent(PlayerEventEnum.change), this.dispatchCustomEvent(PlayerEventEnum.forward);
    }, this._initAttributes(), this._initDataIndex(), this._initEvents();
  }
  setAttributes(params2, forceUpdateTag) {
    super.setAttributes(params2, forceUpdateTag), this._initAttributes();
  }
  dispatchCustomEvent(event) {
    super.dispatchCustomEvent(event, this._dataIndex);
  }
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/player/continuous-player
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
loadContinuousPlayerComponent();
var ContinuousPlayer = class extends BasePlayer {
  constructor(attributes) {
    super(attributes), this._isPlaying = false, this._startTime = Date.now(), this._initAttributes = () => {
      var _a;
      super._initAttributes(), this._maxIndex = this._data.length, this._slider.setAttribute("max", this._maxIndex), this._isPlaying = false, this._elapsed = 0, this._interval = null !== (_a = this.attribute.interval) && void 0 !== _a ? _a : 1e3;
      const frames = this._data.length;
      this.attribute.totalDuration && this._data.length ? (this._totalDuration = this.attribute.totalDuration, this._interval = this._totalDuration / (null != frames ? frames : 1)) : (this._totalDuration = this._interval * frames, this._interval = this.attribute.interval);
    }, this._initDataIndex = () => {
      var _a;
      this._dataIndex = null !== (_a = this.attribute.dataIndex) && void 0 !== _a ? _a : this._minIndex;
    }, this._initEvents = () => {
      this.attribute.disableTriggerEvent || (this._controller.addEventListener(ControllerEventEnum.OnPlay, (e) => {
        e.stopPropagation(), this.play();
      }), this._controller.addEventListener(ControllerEventEnum.OnPause, (e) => {
        e.stopPropagation(), this.pause();
      }), this._controller.addEventListener(ControllerEventEnum.OnForward, (e) => {
        e.stopPropagation(), this.forward();
      }), this._controller.addEventListener(ControllerEventEnum.OnBackward, (e) => {
        e.stopPropagation(), this.backward();
      }), this._slider.addEventListener("change", (e) => {
        var _a;
        e.stopPropagation();
        const value = null === (_a = e.detail) || void 0 === _a ? void 0 : _a.value, progress = value / this._maxIndex;
        this._elapsed = progress * this._totalDuration, this._startTime = Date.now() - this._elapsed, this._dispatchChange(value);
      }));
    }, this._getSliderValue = () => {
      const progress = this._elapsed / this._totalDuration;
      return Math.min(progress * this._maxIndex, this._maxIndex);
    }, this._updateSlider = () => {
      const value = this._getSliderValue();
      this._dataIndex = Math.floor(value), this._slider.setValue(Math.min(value, this._maxIndex)), this._dispatchChange(Math.floor(value));
    }, this._dispatchChange = (value) => {
      const index = Math.floor(value);
      index !== this._activeIndex && (this._dataIndex = index, this._activeIndex = index, index !== this._maxIndex && this.dispatchCustomEvent(PlayerEventEnum.change));
    }, this.play = () => __awaiter6(this, void 0, void 0, function* () {
      this._isPlaying || (this._controller.togglePause(), this._isPlaying = true, this._elapsed >= this._totalDuration && (this._elapsed = 0), this._startTime = Date.now() - this._elapsed, this.dispatchCustomEvent(PlayerEventEnum.play), this._rafId = vglobal.getRequestAnimationFrame()(this._play.bind(this)));
    }), this._play = () => {
      this._elapsed = Date.now() - this._startTime;
      const value = this._getSliderValue();
      this._updateSlider(), value >= this._maxIndex ? this._playEnd() : this._rafId = vglobal.getRequestAnimationFrame()(this._play.bind(this));
    }, this._playEnd = () => {
      this._isPlaying = false, vglobal.getCancelAnimationFrame()(this._rafId), this._controller.togglePlay(), this.dispatchCustomEvent(PlayerEventEnum.end);
    }, this.pause = () => {
      this._isPlaying && (this._isPlaying = false, this._elapsed = Date.now() - this._startTime, vglobal.getCancelAnimationFrame()(this._rafId), this._controller.togglePlay(), this.dispatchCustomEvent(PlayerEventEnum.pause));
    }, this.backward = () => {
      const now = Date.now(), interval = 1 * this._interval, elapsed = this._elapsed - interval;
      elapsed <= 0 ? (this._elapsed = 0, this._startTime = now) : (this._elapsed = elapsed, this._startTime = this._startTime + this._interval), this._updateSlider(), this.dispatchCustomEvent(PlayerEventEnum.backward);
    }, this.forward = () => {
      const now = Date.now(), interval = 1 * this._interval, elapsed = this._elapsed + interval;
      elapsed >= this._totalDuration ? (this._startTime = now - this._totalDuration, this._elapsed = this._totalDuration) : (this._startTime = this._startTime - interval, this._elapsed = elapsed), this._updateSlider(), this.dispatchCustomEvent(PlayerEventEnum.forward);
    }, this._initAttributes(), this._initDataIndex(), this._initEvents();
  }
  dispatchCustomEvent(eventType) {
    super.dispatchCustomEvent(eventType, this._dataIndex);
  }
  render() {
    super.render();
  }
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/brush/type
var IOperateType;
!function(IOperateType2) {
  IOperateType2.drawStart = "drawStart", IOperateType2.drawEnd = "drawEnd", IOperateType2.drawing = "drawing", IOperateType2.moving = "moving", IOperateType2.moveStart = "moveStart", IOperateType2.moveEnd = "moveEnd", IOperateType2.brushClear = "brushClear";
}(IOperateType || (IOperateType = {}));

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/brush/config
var DEFAULT_BRUSH_ATTRIBUTES = {
  trigger: "pointerdown",
  updateTrigger: "pointermove",
  endTrigger: "pointerup",
  resetTrigger: "pointerupoutside",
  hasMask: true,
  brushMode: "single",
  brushType: "rect",
  brushStyle: {
    fill: "#B0C8F9",
    fillOpacity: 0.2,
    stroke: "#B0C8F9",
    strokeWidth: 2
  },
  brushMoved: true,
  removeOnClick: true,
  delayType: "throttle",
  delayTime: 10,
  interactiveRange: {
    y1: -1 / 0,
    y2: 1 / 0,
    x1: -1 / 0,
    x2: 1 / 0
  }
};
var DEFAULT_SIZE_THRESHOLD = 5;

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/brush/register
function loadBrushComponent() {
  registerGroup(), registerPolygon();
}

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/brush/brush
var delayMap3 = {
  debounce: debounce_default,
  throttle: throttle_default
};
loadBrushComponent();
var Brush = class _Brush extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Brush.defaultAttributes, attributes)), this.name = "brush", this._activeDrawState = false, this._cacheDrawPoints = [], this._isDrawedBeforeEnd = false, this._activeMoveState = false, this._operatingMaskMoveDx = 0, this._operatingMaskMoveDy = 0, this._operatingMaskMoveRangeX = [-1 / 0, 1 / 0], this._operatingMaskMoveRangeY = [-1 / 0, 1 / 0], this._brushMaskAABBBoundsDict = {}, this._onBrushStart = (e) => {
      var _a;
      if (this._outOfInteractiveRange(e))
        return;
      e.stopPropagation();
      const brushMoved = null === (_a = this.attribute.brushMoved) || void 0 === _a || _a;
      this._activeMoveState = brushMoved && this._isPosInBrushMask(e), this._activeDrawState = !this._activeMoveState, this._activeDrawState && this._initDraw(e), this._activeMoveState && this._initMove(e);
    }, this._onBrushing = (e) => {
      this._outOfInteractiveRange(e) || ((this._activeDrawState || this._activeMoveState) && e.stopPropagation(), this._activeDrawState && this._drawing(e), this._activeMoveState && this._moving(e));
    }, this._onBrushingWithDelay = 0 === this.attribute.delayTime ? this._onBrushing : delayMap3[this.attribute.delayType](this._onBrushing, this.attribute.delayTime), this._onBrushEnd = (e) => {
      var _a;
      if (!this._activeDrawState && !this._activeMoveState)
        return;
      e.preventDefault();
      const { removeOnClick = true } = this.attribute;
      this._activeDrawState && !this._isDrawedBeforeEnd && removeOnClick ? ((null === (_a = this._operatingMask) || void 0 === _a ? void 0 : _a._AABBBounds.empty()) && this._dispatchEvent(IOperateType.brushClear, {
        operateMask: this._operatingMask,
        operatedMaskAABBBounds: this._brushMaskAABBBoundsDict,
        event: e
      }), this._container.incrementalClearChild(), this._brushMaskAABBBoundsDict = {}) : (this._activeDrawState && this._dispatchEvent(IOperateType.drawEnd, {
        operateMask: this._operatingMask,
        operatedMaskAABBBounds: this._brushMaskAABBBoundsDict,
        event: e
      }), this._activeMoveState && this._dispatchEvent(IOperateType.moveEnd, {
        operateMask: this._operatingMask,
        operatedMaskAABBBounds: this._brushMaskAABBBoundsDict,
        event: e
      })), this._activeDrawState = false, this._activeMoveState = false, this._isDrawedBeforeEnd = false, this._operatingMask && this._operatingMask.setAttribute("pickable", false);
    };
  }
  _bindBrushEvents() {
    if (this.attribute.disableTriggerEvent)
      return;
    const { trigger = DEFAULT_BRUSH_ATTRIBUTES.trigger, updateTrigger = DEFAULT_BRUSH_ATTRIBUTES.updateTrigger, endTrigger = DEFAULT_BRUSH_ATTRIBUTES.endTrigger, resetTrigger = DEFAULT_BRUSH_ATTRIBUTES.resetTrigger } = this.attribute;
    this.stage.addEventListener(trigger, this._onBrushStart), this.stage.addEventListener(updateTrigger, this._onBrushingWithDelay), this.stage.addEventListener(endTrigger, this._onBrushEnd), this.stage.addEventListener(resetTrigger, this._onBrushEnd);
  }
  _isPosInBrushMask(e) {
    const pos = this.eventPosToStagePos(e), brushMasks = this._container.getChildren();
    for (let i = 0; i < brushMasks.length; i++) {
      const { points = [], dx = 0, dy = 0 } = brushMasks[i].attribute, pointsConsiderOffset = points.map((point5) => ({
        x: point5.x + dx,
        y: point5.y + dy
      }));
      if (polygonContainPoint(pointsConsiderOffset, pos.x, pos.y))
        return this._operatingMask = brushMasks[i], true;
    }
    return false;
  }
  _initDraw(e) {
    const { brushMode } = this.attribute, pos = this.eventPosToStagePos(e);
    this._cacheDrawPoints = [pos], this._isDrawedBeforeEnd = false, "single" === brushMode && (this._brushMaskAABBBoundsDict = {}, this._container.incrementalClearChild()), this._addBrushMask(), this._dispatchEvent(IOperateType.drawStart, {
      operateMask: this._operatingMask,
      operatedMaskAABBBounds: this._brushMaskAABBBoundsDict,
      event: e
    });
  }
  _initMove(e) {
    var _a, _b;
    this._cacheMovePoint = this.eventPosToStagePos(e), this._operatingMaskMoveDx = null !== (_a = this._operatingMask.attribute.dx) && void 0 !== _a ? _a : 0, this._operatingMaskMoveDy = null !== (_b = this._operatingMask.attribute.dy) && void 0 !== _b ? _b : 0;
    const { interactiveRange } = this.attribute, { minY = -1 / 0, maxY = 1 / 0, minX = -1 / 0, maxX = 1 / 0 } = interactiveRange, { x1: x14, x2: x23, y1: y14, y2: y23 } = this._operatingMask.globalAABBBounds, minMoveStepX = minX - x14, maxMoveStepX = maxX - x23, minMoveStepY = minY - y14, maxMoveStepY = maxY - y23;
    this._operatingMaskMoveRangeX = [minMoveStepX, maxMoveStepX], this._operatingMaskMoveRangeY = [minMoveStepY, maxMoveStepY], this._operatingMask.setAttribute("pickable", true), this._dispatchEvent(IOperateType.moveStart, {
      operateMask: this._operatingMask,
      operatedMaskAABBBounds: this._brushMaskAABBBoundsDict,
      event: e
    });
  }
  _drawing(e) {
    var _a, _b;
    const pos = this.eventPosToStagePos(e), { sizeThreshold = DEFAULT_SIZE_THRESHOLD, brushType } = this.attribute, cacheLength = this._cacheDrawPoints.length;
    if (cacheLength > 0) {
      const lastPos = null !== (_a = this._cacheDrawPoints[this._cacheDrawPoints.length - 1]) && void 0 !== _a ? _a : {};
      if (pos.x === lastPos.x && pos.y === lastPos.y)
        return;
    }
    "polygon" === brushType || cacheLength <= 1 ? this._cacheDrawPoints.push(pos) : this._cacheDrawPoints[cacheLength - 1] = pos;
    const maskPoints = this._computeMaskPoints();
    this._operatingMask.setAttribute("points", maskPoints);
    const { x1: x14 = 0, x2: x23 = 0, y1: y14 = 0, y2: y23 = 0 } = null === (_b = this._operatingMask) || void 0 === _b ? void 0 : _b._AABBBounds;
    this._isDrawedBeforeEnd = !this._operatingMask._AABBBounds.empty() && !!(Math.abs(x23 - x14) > sizeThreshold || Math.abs(y14 - y23) > sizeThreshold), this._isDrawedBeforeEnd && (this._brushMaskAABBBoundsDict[this._operatingMask.name] = this._operatingMask.AABBBounds, this._dispatchEvent(IOperateType.drawing, {
      operateMask: this._operatingMask,
      operatedMaskAABBBounds: this._brushMaskAABBBoundsDict,
      event: e
    }));
  }
  _moving(e) {
    const startPos = this._cacheMovePoint, pos = this.eventPosToStagePos(e);
    if (pos.x === (null == startPos ? void 0 : startPos.x) && pos.y === (null == startPos ? void 0 : startPos.y))
      return;
    const moveStepX = pos.x - startPos.x, moveStepY = pos.y - startPos.y, moveX = Math.min(this._operatingMaskMoveRangeX[1], Math.max(this._operatingMaskMoveRangeX[0], moveStepX)) + this._operatingMaskMoveDx, moveY = Math.min(this._operatingMaskMoveRangeY[1], Math.max(this._operatingMaskMoveRangeY[0], moveStepY)) + this._operatingMaskMoveDy;
    this._operatingMask.setAttributes({
      dx: moveX,
      dy: moveY
    }), this._brushMaskAABBBoundsDict[this._operatingMask.name] = this._operatingMask.AABBBounds, this._dispatchEvent(IOperateType.moving, {
      operateMask: this._operatingMask,
      operatedMaskAABBBounds: this._brushMaskAABBBoundsDict,
      event: e
    });
  }
  _computeMaskPoints() {
    const { brushType, xRange = [0, 0], yRange = [0, 0] } = this.attribute;
    let maskPoints = [];
    const startPoint = this._cacheDrawPoints[0], endPoint = this._cacheDrawPoints[this._cacheDrawPoints.length - 1];
    return maskPoints = "rect" === brushType ? [startPoint, {
      x: endPoint.x,
      y: startPoint.y
    }, endPoint, {
      x: startPoint.x,
      y: endPoint.y
    }] : "x" === brushType ? [{
      x: startPoint.x,
      y: yRange[0]
    }, {
      x: endPoint.x,
      y: yRange[0]
    }, {
      x: endPoint.x,
      y: yRange[1]
    }, {
      x: startPoint.x,
      y: yRange[1]
    }] : "y" === brushType ? [{
      x: xRange[0],
      y: startPoint.y
    }, {
      x: xRange[0],
      y: endPoint.y
    }, {
      x: xRange[1],
      y: endPoint.y
    }, {
      x: xRange[1],
      y: startPoint.y
    }] : cloneDeep(this._cacheDrawPoints), maskPoints;
  }
  _addBrushMask() {
    var _a;
    const { brushStyle, hasMask } = this.attribute, brushMask = graphicCreator.polygon(Object.assign(Object.assign({
      points: cloneDeep(this._cacheDrawPoints),
      cursor: "move",
      pickable: false
    }, brushStyle), {
      opacity: hasMask ? null !== (_a = brushStyle.opacity) && void 0 !== _a ? _a : 1 : 0
    }));
    brushMask.name = `brush-${Date.now()}`, this._operatingMask = brushMask, this._container.add(brushMask), this._brushMaskAABBBoundsDict[brushMask.name] = brushMask.AABBBounds;
  }
  _outOfInteractiveRange(e) {
    const { interactiveRange } = this.attribute, { minY = -1 / 0, maxY = 1 / 0, minX = -1 / 0, maxX = 1 / 0 } = interactiveRange, pos = this.eventPosToStagePos(e);
    return pos.x > maxX || pos.x < minX || pos.y > maxY || pos.y < minY;
  }
  eventPosToStagePos(e) {
    return this.stage.eventPointTransform(e);
  }
  render() {
    this._bindBrushEvents();
    const group = this.createOrUpdateChild("brush-container", {}, "group");
    this._container = group;
  }
  releaseBrushEvents() {
    const { delayType = "throttle", delayTime = 0, trigger = DEFAULT_BRUSH_ATTRIBUTES.trigger, updateTrigger = DEFAULT_BRUSH_ATTRIBUTES.updateTrigger, endTrigger = DEFAULT_BRUSH_ATTRIBUTES.endTrigger, resetTrigger = DEFAULT_BRUSH_ATTRIBUTES.resetTrigger } = this.attribute;
    this.stage.removeEventListener(trigger, this._onBrushStart), this.stage.removeEventListener(updateTrigger, this._onBrushingWithDelay), this.stage.removeEventListener(endTrigger, this._onBrushEnd), this.stage.removeEventListener(resetTrigger, this._onBrushEnd);
  }
};
Brush.defaultAttributes = DEFAULT_BRUSH_ATTRIBUTES;

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/tooltip/util
var mergeRowAttrs = (target, ...sources) => {
  const shapeList = [target.shape, ...sources.map((s2) => null == s2 ? void 0 : s2.shape)], keyList = [target.key, ...sources.map((s2) => null == s2 ? void 0 : s2.key)], valueList = [target.value, ...sources.map((s2) => null == s2 ? void 0 : s2.value)];
  return merge(target, ...sources, {
    shape: shapeList.every(isNil_default) ? void 0 : merge({}, ...shapeList),
    key: keyList.every(isNil_default) ? void 0 : merge({}, ...keyList),
    value: valueList.every(isNil_default) ? void 0 : merge({}, ...valueList)
  });
};
var getRichTextAttribute = (attr) => {
  const { width, height, wordBreak = "break-word", textAlign, textBaseline, text: text2 } = attr;
  return Array.isArray(text2) ? {
    width,
    height,
    wordBreak,
    textAlign,
    textBaseline,
    singleLine: false,
    textConfig: array(text2).map((text3) => Object.assign(Object.assign({}, attr), {
      text: text3
    }))
  } : {
    width,
    height,
    wordBreak,
    textAlign,
    textBaseline,
    singleLine: false,
    textConfig: null == text2 ? void 0 : text2.text
  };
};

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/tooltip/config
var defaultAttributes = {
  panel: {
    visible: true,
    cornerRadius: [3, 3, 3, 3],
    fill: "white",
    shadow: true,
    shadowBlur: 12,
    shadowColor: "rgba(0, 0, 0, 0.1)",
    shadowOffsetX: 0,
    shadowOffsetY: 4,
    shadowSpread: 0,
    stroke: "white"
  },
  titleStyle: {
    value: {
      fill: "#4E5969",
      fontFamily: DEFAULT_TEXT_FONT_FAMILY,
      fontSize: 14,
      lineHeight: 18,
      textAlign: "left",
      textBaseline: "middle"
    },
    spaceRow: 6
  },
  contentStyle: {
    shape: {
      fill: "black",
      size: 8,
      symbolType: "circle",
      spacing: 6
    },
    key: {
      fill: "#4E5969",
      fontFamily: DEFAULT_TEXT_FONT_FAMILY,
      fontSize: 12,
      lineHeight: 18,
      textAlign: "left",
      textBaseline: "middle",
      spacing: 26
    },
    value: {
      fill: "#4E5969",
      fontFamily: DEFAULT_TEXT_FONT_FAMILY,
      fontSize: 12,
      lineHeight: 18,
      textAlign: "right",
      textBaseline: "middle",
      spacing: 0
    },
    spaceRow: 6
  },
  padding: 10,
  positionX: "right",
  positionY: "bottom",
  offsetX: 10,
  offsetY: 10,
  parentBounds: new AABBBounds().setValue(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY),
  autoCalculatePosition: true,
  autoMeasure: true,
  pickable: false,
  childrenPickable: false,
  zIndex: 500
};
var TOOLTIP_POSITION_ATTRIBUTES = ["pointerX", "pointerY", "offsetX", "offsetY", "positionX", "positionY", "parentBounds"];

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/tooltip/register
function loadTooltipComponent() {
  registerGroup(), registerRect(), registerSymbol(), registerText(), registerRichtext();
}

// http-url:https://unpkg.com/@visactor/vrender-components@0.19.9/es/tooltip/tooltip
loadTooltipComponent();
var Tooltip = class _Tooltip extends AbstractComponent {
  constructor(attributes, options) {
    super((null == options ? void 0 : options.skipDefault) ? attributes : merge({}, _Tooltip.defaultAttributes, attributes), options), this.name = "tooltip";
  }
  render() {
    var _a;
    const { visible, content, panel, keyWidth, valueWidth, hasContentShape, autoCalculatePosition, autoMeasure } = this.attribute;
    if (!visible)
      return void this.hideAll();
    autoMeasure && _Tooltip.measureTooltip(this.attribute), autoCalculatePosition && _Tooltip.calculateTooltipPosition(this.attribute);
    const padding = normalizePadding(this.attribute.padding);
    this._tooltipPanel = this.createOrUpdateChild("tooltip-background", Object.assign({
      visible: true
    }, panel), "rect"), this._tooltipTitleContainer = this.createOrUpdateChild("tooltip-title", {
      visible: true,
      x: padding[3],
      y: padding[0]
    }, "group");
    const titleAttr = _Tooltip.getTitleAttr(this.attribute);
    this._tooltipTitleSymbol = this._tooltipTitleContainer.createOrUpdateChild("tooltip-title-shape", merge({
      symbolType: "circle"
    }, titleAttr.shape, {
      visible: isVisible(titleAttr) && isVisible(titleAttr.shape)
    }), "symbol"), "object" != typeof titleAttr.value.text || null === titleAttr.value.text || "rich" !== titleAttr.value.text.type && "html" !== titleAttr.value.text.type ? titleAttr.value.multiLine ? this._tooltipTitle = this._tooltipTitleContainer.createOrUpdateChild("tooltip-title-value", Object.assign({
      visible: isVisible(titleAttr) && isVisible(titleAttr.value)
    }, getRichTextAttribute(titleAttr.value)), "richtext") : this._tooltipTitle = this._tooltipTitleContainer.createOrUpdateChild("tooltip-title-value", Object.assign({
      text: null !== (_a = titleAttr.value.text) && void 0 !== _a ? _a : "",
      visible: isVisible(titleAttr) && isVisible(titleAttr.value)
    }, titleAttr.value), "text") : "rich" === titleAttr.value.text.type ? this._tooltipTitle = this._tooltipTitleContainer.createOrUpdateChild("tooltip-title-value", Object.assign({
      visible: isVisible(titleAttr) && isVisible(titleAttr.value)
    }, getRichTextAttribute(titleAttr.value)), "richtext") : "html" === titleAttr.value.text.type && (this._tooltipTitle = this._tooltipTitleContainer.createOrUpdateChild("tooltip-title-value", Object.assign({
      html: Object.assign(Object.assign({
        dom: titleAttr.value.text.text
      }, DEFAULT_HTML_TEXT_SPEC), titleAttr.value),
      visible: isVisible(titleAttr) && isVisible(titleAttr.value),
      width: titleAttr.value.width,
      height: titleAttr.value.height,
      wordBreak: titleAttr.value.wordBreak,
      textAlign: titleAttr.value.textAlign,
      textBaseline: titleAttr.value.textBaseline,
      singleLine: false,
      textConfig: []
    }, titleAttr.value), "richtext"));
    const titlePaddingLeft = isVisible(titleAttr.shape) ? titleAttr.shape.size + titleAttr.shape.spacing : 0, { textAlign, textBaseline } = titleAttr.value, contentWidth = panel.width - padding[3] - padding[0] - titlePaddingLeft;
    "center" === textAlign ? this._tooltipTitle.setAttribute("x", titlePaddingLeft + contentWidth / 2) : "right" === textAlign || "end" === textAlign ? this._tooltipTitle.setAttribute("x", titlePaddingLeft + contentWidth) : this._tooltipTitle.setAttribute("x", titlePaddingLeft), "bottom" === textBaseline ? this._tooltipTitle.setAttribute("y", titleAttr.height) : "middle" === textBaseline ? this._tooltipTitle.setAttribute("y", titleAttr.height / 2) : this._tooltipTitle.setAttribute("y", 0);
    const titleHeight = isVisible(titleAttr) ? titleAttr.height + titleAttr.spaceRow : 0;
    if (this._tooltipContent = this.createOrUpdateChild("tooltip-content", {
      visible: true
    }, "group"), this._tooltipContent.removeAllChild(true), content && content.length) {
      this._tooltipContent.setAttribute("x", padding[3]), this._tooltipContent.setAttribute("y", padding[0] + titleHeight);
      let lastYPos = 0;
      content.forEach((item, i) => {
        var _a2, _b, _c;
        const itemAttr = _Tooltip.getContentAttr(this.attribute, i);
        if (!isVisible(itemAttr))
          return;
        const itemGroupName = `tooltip-content-${i}`, itemGroup = this._tooltipContent.createOrUpdateChild(itemGroupName, {
          visible: true,
          x: 0,
          y: lastYPos
        }, "group");
        let x = 0;
        if (isVisible(itemAttr.shape) && itemGroup.createOrUpdateChild(`${itemGroupName}-shape`, Object.assign({
          visible: true,
          x: itemAttr.shape.size / 2,
          y: itemAttr.shape.size / 2 + ((null !== (_a2 = calculateLineHeight(itemAttr.key.lineHeight, itemAttr.key.fontSize)) && void 0 !== _a2 ? _a2 : itemAttr.key.fontSize) - itemAttr.shape.size) / 2
        }, itemAttr.shape), "symbol"), hasContentShape && (x += itemAttr.shape.size + itemAttr.shape.spacing), isVisible(itemAttr.key)) {
          let element;
          element = itemAttr.key.multiLine ? itemGroup.createOrUpdateChild(`${itemGroupName}-key`, Object.assign(Object.assign({
            visible: true
          }, getRichTextAttribute(itemAttr.key)), {
            textBaseline: "top"
          }), "richtext") : "object" != typeof itemAttr.key.text || null === itemAttr.key.text || "rich" !== itemAttr.key.text.type && "html" !== itemAttr.key.text.type ? itemGroup.createOrUpdateChild(`${itemGroupName}-key`, Object.assign(Object.assign({
            visible: true,
            text: null !== (_b = itemAttr.key.text) && void 0 !== _b ? _b : ""
          }, itemAttr.key), {
            textBaseline: "top"
          }), "text") : "rich" === itemAttr.key.text.type ? itemGroup.createOrUpdateChild(`${itemGroupName}-value`, Object.assign(Object.assign({
            visible: true
          }, getRichTextAttribute(itemAttr.key)), {
            textBaseline: "top"
          }), "richtext") : itemGroup.createOrUpdateChild(`${itemGroupName}-value`, {
            html: Object.assign(Object.assign({
              dom: itemAttr.key.text.text
            }, DEFAULT_HTML_TEXT_SPEC), itemAttr.key)
          }, "richtext");
          const { textAlign: textAlign2 } = itemAttr.key;
          "center" === textAlign2 ? element.setAttribute("x", x + keyWidth / 2) : "right" === textAlign2 || "end" === textAlign2 ? element.setAttribute("x", x + keyWidth) : element.setAttribute("x", x), element.setAttribute("y", 0), x += keyWidth + itemAttr.key.spacing;
        }
        if (isVisible(itemAttr.value)) {
          let element;
          element = itemAttr.value.multiLine ? itemGroup.createOrUpdateChild(`${itemGroupName}-value`, Object.assign(Object.assign({
            visible: true
          }, getRichTextAttribute(itemAttr.value)), {
            textBaseline: "top"
          }), "richtext") : "object" != typeof itemAttr.value.text || null === itemAttr.value.text || "rich" !== itemAttr.value.text.type && "html" !== itemAttr.value.text.type ? itemGroup.createOrUpdateChild(`${itemGroupName}-value`, Object.assign(Object.assign({
            visible: true,
            text: null !== (_c = itemAttr.value.text) && void 0 !== _c ? _c : ""
          }, itemAttr.value), {
            textBaseline: "top"
          }), "text") : "rich" === itemAttr.value.text.type ? itemGroup.createOrUpdateChild(`${itemGroupName}-value`, Object.assign(Object.assign({
            visible: true
          }, getRichTextAttribute(itemAttr.value)), {
            textBaseline: "top"
          }), "richtext") : itemGroup.createOrUpdateChild(`${itemGroupName}-value`, {
            html: Object.assign({
              dom: itemAttr.value.text.text,
              container: "",
              width: 30,
              height: 30,
              style: {}
            }, itemAttr.value)
          }, "richtext");
          let textAlign2 = "right";
          isValid_default(itemAttr.value.textAlign) ? textAlign2 = itemAttr.value.textAlign : isVisible(itemAttr.key) || (textAlign2 = "left"), element.setAttribute("textAlign", textAlign2), "center" === textAlign2 ? element.setAttribute("x", x + valueWidth / 2) : "right" === textAlign2 || "end" === textAlign2 ? element.setAttribute("x", x + valueWidth) : element.setAttribute("x", x), x += valueWidth, element.setAttribute("y", 0), itemGroup.add(element);
        }
        lastYPos += itemAttr.height + itemAttr.spaceRow;
      });
    }
  }
  setAttributes(params2, forceUpdateTag) {
    const keys2 = Object.keys(params2);
    this.attribute.autoCalculatePosition && keys2.every((key) => TOOLTIP_POSITION_ATTRIBUTES.includes(key)) ? (this._mergeAttributes(params2, keys2), isNil_default(this.attribute.panel.width) && this.attribute.autoMeasure && _Tooltip.measureTooltip(this.attribute), _Tooltip.calculateTooltipPosition(this.attribute), super.setAttributes({
      x: this.attribute.x,
      y: this.attribute.y
    }, forceUpdateTag)) : super.setAttributes(params2, forceUpdateTag);
  }
  static calculateTooltipPosition(attribute) {
    const { width: tooltipBoxWidth = 0, height: tooltipBoxHeight = 0 } = attribute.panel, { offsetX, offsetY, pointerX, pointerY, positionX, positionY, parentBounds } = attribute;
    let x = pointerX, y = pointerY;
    return "left" === positionX ? x -= tooltipBoxWidth + offsetX : "center" === positionX ? x -= tooltipBoxWidth / 2 : x += offsetX, "top" === positionY ? y -= tooltipBoxHeight + offsetY : "middle" === positionY ? y -= tooltipBoxHeight / 2 : y += offsetY, x + tooltipBoxWidth > parentBounds.x2 && (x -= tooltipBoxWidth + offsetX), y + tooltipBoxHeight > parentBounds.y2 && (y -= tooltipBoxHeight + offsetY), x < parentBounds.x1 && (x = parentBounds.x1), y < parentBounds.y1 && (y = parentBounds.y1), attribute.x = x, attribute.y = y, attribute;
  }
  static measureTooltip(attribute) {
    const { content, contentStyle } = attribute, padding = normalizePadding(attribute.padding), titleAttr = _Tooltip.getTitleAttr(attribute);
    let maxWidth = 0, containerHeight = padding[0] + padding[2], titleMaxHeight = 0;
    const { value: titleValue, shape: titleShape } = titleAttr, { visible: titleHasShape = false, symbolType: titleShapeType = "" } = null != titleShape ? titleShape : {};
    if (isValid_default(titleValue) && "object" != typeof titleAttr.value.text) {
      const { width, height } = initTextMeasure(titleValue).quickMeasure(titleValue.text);
      maxWidth = width, titleMaxHeight = height;
    }
    if (titleHasShape && builtinSymbolsMap[titleShapeType] && (maxWidth += titleShape.size + titleShape.spacing, titleMaxHeight = Math.max(titleShape.size, titleMaxHeight)), attribute.title && (attribute.title.width = maxWidth, attribute.title.height = titleMaxHeight), isVisible(titleAttr) && (containerHeight += titleMaxHeight + titleAttr.spaceRow), content && content.length) {
      const filteredContent = [];
      if (content.forEach((item, i) => {
        const itemAttr = _Tooltip.getContentAttr(attribute, i);
        (item.key || item.value) && isVisible(itemAttr) && filteredContent.push([item, itemAttr]);
      }), filteredContent.length) {
        let hasContentShape = false;
        const shapeWidths = [], keyWidths = [], valueWidths = [];
        filteredContent.forEach(([item, itemAttr], i) => {
          var _a;
          const { key, value, shape, spaceRow } = itemAttr, itemHasShape = isVisible(shape), itemShapeType = null !== (_a = null == shape ? void 0 : shape.symbolType) && void 0 !== _a ? _a : "", keyTextMeasure = initTextMeasure(key), valueTextMeasure = initTextMeasure(value);
          let itemHeight = 0;
          if (isVisible(key)) {
            const { width, height } = keyTextMeasure.quickMeasure(key.text);
            keyWidths.push(width), itemHeight = Math.max(itemHeight, height);
          }
          if (isVisible(value)) {
            const { width, height } = valueTextMeasure.quickMeasure(value.text);
            valueWidths.push(width), itemHeight = Math.max(itemHeight, height);
          }
          itemHasShape && builtinSymbolsMap[itemShapeType] && (hasContentShape = true, shapeWidths.push(shape.size), itemHeight = Math.max(shape.size, itemHeight)), item.height = itemHeight, containerHeight += itemHeight, i < filteredContent.length - 1 && (containerHeight += null != spaceRow ? spaceRow : contentStyle.spaceRow);
        });
        const maxShapeWidth = shapeWidths.length ? Math.max(...shapeWidths) : 0, maxKeyWidth = keyWidths.length ? Math.max(...keyWidths) : 0, maxValueWidth = valueWidths.length ? Math.max(...valueWidths) : 0;
        maxWidth = Math.max(maxKeyWidth + maxValueWidth + contentStyle.key.spacing + contentStyle.value.spacing + (hasContentShape ? maxShapeWidth + contentStyle.shape.spacing : 0), maxWidth), content.forEach((item) => {
          item.width = maxWidth;
        }), attribute.hasContentShape = hasContentShape, attribute.keyWidth = maxKeyWidth, attribute.valueWidth = maxValueWidth;
      }
    }
    return attribute.panel.width = maxWidth + padding[1] + padding[3], attribute.panel.height = containerHeight, attribute;
  }
  static getTitleAttr(attribute) {
    return mergeRowAttrs({}, _Tooltip.defaultAttributes.titleStyle, _Tooltip.defaultAttributes.title, attribute.titleStyle, attribute.title);
  }
  static getContentAttr(attribute, index) {
    return mergeRowAttrs({}, _Tooltip.defaultAttributes.contentStyle, attribute.contentStyle, attribute.content[index]);
  }
};
Tooltip.defaultAttributes = defaultAttributes;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/util/math
var isClose = isNumberClose;
function computeQuadrant(angle2) {
  return (angle2 = normalizeAngle(angle2)) > 0 && angle2 <= Math.PI / 2 ? 2 : angle2 > Math.PI / 2 && angle2 <= Math.PI ? 3 : angle2 > Math.PI && angle2 <= 3 * Math.PI / 2 ? 4 : 1;
}
function normalizeStartEndAngle(start, end) {
  let startAngle = 0, endAngle = 2 * Math.PI;
  const isStartValid = isValid_default(start), isEndValid = isValid_default(end);
  for (isStartValid || isEndValid ? isEndValid ? isStartValid ? (startAngle = start, endAngle = end) : (startAngle = end - 2 * Math.PI, endAngle = end) : (startAngle = start, endAngle = start + 2 * Math.PI) : (startAngle = 0, endAngle = 2 * Math.PI); endAngle <= startAngle; )
    endAngle += 2 * Math.PI;
  for (; startAngle > 2 * Math.PI; )
    startAngle -= 2 * Math.PI, endAngle -= 2 * Math.PI;
  for (; endAngle < 0; )
    startAngle += 2 * Math.PI, endAngle += 2 * Math.PI;
  return {
    startAngle,
    endAngle
  };
}
function outOfBounds(bounds, x, y) {
  return bounds.x1 > x || bounds.x2 < x || bounds.y1 > y || bounds.y2 < y;
}
function min2(data, field3) {
  const dataArray = [];
  return data.forEach((d) => {
    const value = +d[field3];
    isValidNumber_default(value) && dataArray.push(value);
  }), 0 === dataArray.length ? null : minInArray(dataArray);
}
function max2(data, field3) {
  const dataArray = [];
  return data.forEach((d) => {
    const value = +d[field3];
    isValidNumber_default(value) && dataArray.push(value);
  }), 0 === dataArray.length ? null : maxInArray(dataArray);
}
function sum2(data, field3) {
  return data.reduce((pre, _cur) => {
    const cur = field3 ? +_cur[field3] : +_cur;
    return isValidNumber_default(cur) && (pre += cur), pre;
  }, 0);
}
function average(data, field3) {
  let sum4 = 0, count = 0;
  data.forEach((x) => {
    const v = field3 ? +x[field3] : +x;
    isValidNumber_default(v) && (sum4 += v, count++);
  });
  return sum4 / count;
}
function variance(data, field3) {
  const averageNumber = average(data, field3);
  if (data.length <= 1)
    return 0;
  const total = data.reduce((sum4, cur) => sum4 + (field3 ? +cur[field3] : +cur - averageNumber) ** 2, 0);
  return total / (data.length - 1);
}
function standardDeviation(data, field3) {
  return Math.sqrt(variance(data, field3));
}
function median2(data, field3) {
  return median(data.map((datum) => datum[field3]));
}
function regression(data, fieldX, fieldY) {
  const { predict } = regressionLinear(data, (datum) => datum[fieldX], (datum) => datum[fieldY]), x14 = min2(data, fieldX), x23 = max2(data, fieldX), predict1 = predict(x14), predict2 = predict(x23);
  return [{
    [fieldX]: x14,
    [fieldY]: predict1
  }, {
    [fieldX]: x23,
    [fieldY]: predict2
  }];
}
function radiusLabelOrientAttribute(angle2) {
  let align = "center", baseline = "middle";
  return align = (angle2 = normalizeAngle(angle2)) >= Math.PI * (7 / 6) && angle2 <= Math.PI * (11 / 6) ? "right" : angle2 >= Math.PI * (1 / 6) && angle2 <= Math.PI * (5 / 6) ? "left" : "center", baseline = angle2 >= Math.PI * (5 / 3) || angle2 <= Math.PI * (1 / 3) ? "bottom" : angle2 >= Math.PI * (2 / 3) && angle2 <= Math.PI * (4 / 3) ? "top" : "middle", {
    align,
    baseline
  };
}
function vectorAngle(v1, v2) {
  const v1Length = distance(v1), v2Length = distance(v2), rho = Math.asin((v1.x * v2.y - v2.x * v1.y) / v1Length / v2Length), theta = Math.acos((v1.x * v2.x + v1.y * v2.y) / v1Length / v2Length);
  return rho < 0 ? -theta : theta;
}
function distance(p1, p2 = {
  x: 0,
  y: 0
}) {
  return PointService.distancePP(p1, p2);
}
function getPercentValue(valueList, precision = 2) {
  const sum4 = valueList.reduce((a3, c3) => a3 + (isNaN(c3) ? 0 : c3), 0);
  if (0 === sum4)
    return 0;
  const digits = Math.pow(10, precision), votesPerQuota = valueList.map((val) => (isNaN(val) ? 0 : val) / sum4 * digits * 100), targetSeats = 100 * digits, seats = votesPerQuota.map((votes) => Math.floor(votes));
  let currentSum = seats.reduce((a3, c3) => a3 + c3, 0);
  const remainder = votesPerQuota.map((votes, idx) => votes - seats[idx]);
  for (; currentSum < targetSeats; ) {
    let max3 = Number.NEGATIVE_INFINITY, maxId2 = null;
    for (let i = 0; i < remainder.length; i++)
      remainder[i] > max3 && (max3 = remainder[i], maxId2 = i);
    ++seats[maxId2], remainder[maxId2] = 0, ++currentSum;
  }
  return seats.map((entry) => entry / digits);
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/util/model
function eachSeries(regions, callback, filter2) {
  let flag = false;
  if (callback && isFunction_default(callback)) {
    for (const r of regions)
      for (const s2 of r.getSeries(filter2))
        if (flag = !!callback.call(null, s2), flag)
          return flag;
  }
  return flag;
}
function getSeries(regions, filter2) {
  const result2 = [];
  for (const r of regions)
    for (const s2 of r.getSeries(filter2))
      result2.push(s2);
  return result2;
}
var getFirstSeries = (regions, coordinateType) => {
  for (let i = 0; i < regions.length; i++) {
    const series2 = regions[i].getSeries();
    for (let j = 0; j < series2.length; j++) {
      const s2 = series2[j];
      if (coordinateType && s2 && s2.coordinate === coordinateType)
        return s2;
      if (!coordinateType && s2)
        return s2;
    }
  }
  return null;
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/util/object
function field2(f) {
  return function(datum) {
    let value;
    return value = isArray_default(f) ? f.reduce((cur, g) => null == cur ? void 0 : cur[g], datum) : null == datum ? void 0 : datum[f], value;
  };
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/interface/type
var SeriesTypeEnum;
!function(SeriesTypeEnum2) {
  SeriesTypeEnum2.area = "area", SeriesTypeEnum2.line = "line", SeriesTypeEnum2.bar = "bar", SeriesTypeEnum2.bar3d = "bar3d", SeriesTypeEnum2.rangeColumn = "rangeColumn", SeriesTypeEnum2.rangeColumn3d = "rangeColumn3d", SeriesTypeEnum2.rangeArea = "rangeArea", SeriesTypeEnum2.dot = "dot", SeriesTypeEnum2.geo = "geo", SeriesTypeEnum2.link = "link", SeriesTypeEnum2.map = "map", SeriesTypeEnum2.pie = "pie", SeriesTypeEnum2.pie3d = "pie3d", SeriesTypeEnum2.radar = "radar", SeriesTypeEnum2.rose = "rose", SeriesTypeEnum2.scatter = "scatter", SeriesTypeEnum2.circularProgress = "circularProgress", SeriesTypeEnum2.wordCloud = "wordCloud", SeriesTypeEnum2.wordCloud3d = "wordCloud3d", SeriesTypeEnum2.funnel = "funnel", SeriesTypeEnum2.funnel3d = "funnel3d", SeriesTypeEnum2.linearProgress = "linearProgress", SeriesTypeEnum2.boxPlot = "boxPlot", SeriesTypeEnum2.sankey = "sankey", SeriesTypeEnum2.gaugePointer = "gaugePointer", SeriesTypeEnum2.gauge = "gauge", SeriesTypeEnum2.treemap = "treemap", SeriesTypeEnum2.sunburst = "sunburst", SeriesTypeEnum2.circlePacking = "circlePacking", SeriesTypeEnum2.waterfall = "waterfall", SeriesTypeEnum2.heatmap = "heatmap", SeriesTypeEnum2.correlation = "correlation", SeriesTypeEnum2.liquid = "liquid", SeriesTypeEnum2.venn = "venn";
}(SeriesTypeEnum || (SeriesTypeEnum = {}));
var SeriesMarkNameEnum;
!function(SeriesMarkNameEnum2) {
  SeriesMarkNameEnum2.label = "label", SeriesMarkNameEnum2.point = "point", SeriesMarkNameEnum2.line = "line", SeriesMarkNameEnum2.area = "area", SeriesMarkNameEnum2.bar = "bar", SeriesMarkNameEnum2.bar3d = "bar3d", SeriesMarkNameEnum2.boxPlot = "boxPlot", SeriesMarkNameEnum2.outlier = "outlier", SeriesMarkNameEnum2.circlePacking = "circlePacking", SeriesMarkNameEnum2.group = "group", SeriesMarkNameEnum2.gridBackground = "gridBackground", SeriesMarkNameEnum2.grid = "grid", SeriesMarkNameEnum2.dot = "dot", SeriesMarkNameEnum2.title = "title", SeriesMarkNameEnum2.subTitle = "subTitle", SeriesMarkNameEnum2.symbol = "symbol", SeriesMarkNameEnum2.funnel = "funnel", SeriesMarkNameEnum2.funnel3d = "funnel3d", SeriesMarkNameEnum2.transform = "transform", SeriesMarkNameEnum2.transform3d = "transform3d", SeriesMarkNameEnum2.transformLabel = "transformLabel", SeriesMarkNameEnum2.outerLabel = "outerLabel", SeriesMarkNameEnum2.outerLabelLine = "outerLabelLine", SeriesMarkNameEnum2.pin = "pin", SeriesMarkNameEnum2.pinBackground = "pinBackground", SeriesMarkNameEnum2.pointer = "pointer", SeriesMarkNameEnum2.segment = "segment", SeriesMarkNameEnum2.track = "track", SeriesMarkNameEnum2.cell = "cell", SeriesMarkNameEnum2.cellBackground = "cellBackground", SeriesMarkNameEnum2.link = "link", SeriesMarkNameEnum2.arrow = "arrow", SeriesMarkNameEnum2.pie = "pie", SeriesMarkNameEnum2.pie3d = "pie3d", SeriesMarkNameEnum2.labelLine = "labelLine", SeriesMarkNameEnum2.progress = "progress", SeriesMarkNameEnum2.minLabel = "minLabel", SeriesMarkNameEnum2.maxLabel = "maxLabel", SeriesMarkNameEnum2.rose = "rose", SeriesMarkNameEnum2.node = "node", SeriesMarkNameEnum2.sunburst = "sunburst", SeriesMarkNameEnum2.nonLeaf = "nonLeaf", SeriesMarkNameEnum2.leaf = "leaf", SeriesMarkNameEnum2.nonLeafLabel = "nonLeafLabel", SeriesMarkNameEnum2.leaderLine = "leaderLine", SeriesMarkNameEnum2.stackLabel = "stackLabel", SeriesMarkNameEnum2.word = "word", SeriesMarkNameEnum2.fillingWord = "fillingWord", SeriesMarkNameEnum2.nodePoint = "nodePoint", SeriesMarkNameEnum2.ripplePoint = "ripplePoint", SeriesMarkNameEnum2.centerPoint = "centerPoint", SeriesMarkNameEnum2.centerLabel = "centerLabel", SeriesMarkNameEnum2.barBackground = "barBackground", SeriesMarkNameEnum2.lineLabel = "lineLabel", SeriesMarkNameEnum2.areaLabel = "areaLabel", SeriesMarkNameEnum2.liquid = "liquid", SeriesMarkNameEnum2.liquidBackground = "liquidBackground", SeriesMarkNameEnum2.liquidOutline = "liquidOutline", SeriesMarkNameEnum2.circle = "circle", SeriesMarkNameEnum2.overlap = "overlap", SeriesMarkNameEnum2.overlapLabel = "overlapLabel";
}(SeriesMarkNameEnum || (SeriesMarkNameEnum = {}));

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/constant/base
var PREFIX = "__VCHART";
var DEFAULT_CHART_WIDTH = 500;
var DEFAULT_CHART_HEIGHT = 500;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/constant/label
var DEFAULT_LABEL_LIMIT = `${PREFIX}_LABEL_LIMIT`;
var DEFAULT_LABEL_ALIGN = `${PREFIX}_LABEL_ALIGN`;
var DEFAULT_LABEL_TEXT = `${PREFIX}_LABEL_TEXT`;
var DEFAULT_LABEL_VISIBLE = `${PREFIX}_LABEL_VISIBLE`;
var DEFAULT_LABEL_X = `${PREFIX}_LABEL_X`;
var DEFAULT_LABEL_Y = `${PREFIX}_LABEL_Y`;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/constant/polar
var ARC_TRANSFORM_VALUE = `${PREFIX}_ARC_TRANSFORM_VALUE`;
var ARC_RATIO = `${PREFIX}_ARC_RATIO`;
var ARC_START_ANGLE = `${PREFIX}_ARC_START_ANGLE`;
var ARC_END_ANGLE = `${PREFIX}_ARC_END_ANGLE`;
var ARC_K = `${PREFIX}_ARC_K`;
var ARC_MIDDLE_ANGLE = `${PREFIX}_ARC_MIDDLE_ANGLE`;
var ARC_QUADRANT = `${PREFIX}_ARC_QUADRANT`;
var ARC_RADIAN = `${PREFIX}_ARC_RADIAN`;
var POLAR_START_RADIAN = -Math.PI / 2;
var POLAR_END_RADIAN = 3 * Math.PI / 2;
var POLAR_START_ANGLE2 = -90;
var POLAR_END_ANGLE2 = 270;
var POLAR_DEFAULT_RADIUS = 0.6;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/constant/layout
var USER_LAYOUT_RECT_LEVEL = 9;
var DEFAULT_LAYOUT_RECT_LEVEL = 0;

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/enums
var BuiltInEncodeNames;
!function(BuiltInEncodeNames2) {
  BuiltInEncodeNames2.enter = "enter", BuiltInEncodeNames2.update = "update", BuiltInEncodeNames2.exit = "exit", BuiltInEncodeNames2.group = "group", BuiltInEncodeNames2.connectNulls = "connectNulls";
}(BuiltInEncodeNames || (BuiltInEncodeNames = {}));
var DiffState;
!function(DiffState2) {
  DiffState2.enter = "enter", DiffState2.update = "update", DiffState2.exit = "exit", DiffState2.unChange = "unChange";
}(DiffState || (DiffState = {}));
var GrammarMarkType;
!function(GrammarMarkType2) {
  GrammarMarkType2.arc = "arc", GrammarMarkType2.arc3d = "arc3d", GrammarMarkType2.area = "area", GrammarMarkType2.image = "image", GrammarMarkType2.line = "line", GrammarMarkType2.path = "path", GrammarMarkType2.rect = "rect", GrammarMarkType2.rect3d = "rect3d", GrammarMarkType2.rule = "rule", GrammarMarkType2.shape = "shape", GrammarMarkType2.symbol = "symbol", GrammarMarkType2.text = "text", GrammarMarkType2.richtext = "richtext", GrammarMarkType2.polygon = "polygon", GrammarMarkType2.pyramid3d = "pyramid3d", GrammarMarkType2.circle = "circle", GrammarMarkType2.cell = "cell", GrammarMarkType2.interval = "interval", GrammarMarkType2.group = "group", GrammarMarkType2.glyph = "glyph", GrammarMarkType2.component = "component", GrammarMarkType2.largeRects = "largeRects", GrammarMarkType2.largeSymbols = "largeSymbols";
}(GrammarMarkType || (GrammarMarkType = {}));
var ComponentEnum;
!function(ComponentEnum2) {
  ComponentEnum2.axis = "axis", ComponentEnum2.grid = "grid", ComponentEnum2.legend = "legend", ComponentEnum2.slider = "slider", ComponentEnum2.label = "label", ComponentEnum2.datazoom = "datazoom", ComponentEnum2.player = "player", ComponentEnum2.title = "title", ComponentEnum2.scrollbar = "scrollbar";
}(ComponentEnum || (ComponentEnum = {}));
var DataFilterRank;
!function(DataFilterRank2) {
  DataFilterRank2[DataFilterRank2.player = 1] = "player", DataFilterRank2[DataFilterRank2.rollUp = 2] = "rollUp", DataFilterRank2[DataFilterRank2.drillDown = 3] = "drillDown", DataFilterRank2[DataFilterRank2.slider = 4] = "slider", DataFilterRank2[DataFilterRank2.datazoom = 5] = "datazoom", DataFilterRank2[DataFilterRank2.legend = 6] = "legend", DataFilterRank2[DataFilterRank2.scrollbar = 7] = "scrollbar", DataFilterRank2[DataFilterRank2.brush = 8] = "brush", DataFilterRank2[DataFilterRank2.normal = 9] = "normal";
}(DataFilterRank || (DataFilterRank = {}));
var AxisEnum;
!function(AxisEnum2) {
  AxisEnum2.lineAxis = "lineAxis", AxisEnum2.circleAxis = "circleAxis";
}(AxisEnum || (AxisEnum = {}));
var GridEnum;
!function(GridEnum2) {
  GridEnum2.lineAxisGrid = "lineAxisGrid", GridEnum2.circleAxisGrid = "circleAxisGrid";
}(GridEnum || (GridEnum = {}));
var LegendEnum;
!function(LegendEnum2) {
  LegendEnum2.discreteLegend = "discreteLegend", LegendEnum2.colorLegend = "colorLegend", LegendEnum2.sizeLegend = "sizeLegend";
}(LegendEnum || (LegendEnum = {}));
var CrosshairEnum;
!function(CrosshairEnum2) {
  CrosshairEnum2.lineCrosshair = "lineCrosshair", CrosshairEnum2.rectCrosshair = "rectCrosshair", CrosshairEnum2.sectorCrosshair = "sectorCrosshair", CrosshairEnum2.circleCrosshair = "circleCrosshair", CrosshairEnum2.polygonCrosshair = "polygonCrosshair", CrosshairEnum2.ringCrosshair = "ringCrosshair";
}(CrosshairEnum || (CrosshairEnum = {}));
var LabelEnum;
!function(LabelEnum2) {
  LabelEnum2.symbolLabel = "symbolLabel", LabelEnum2.rectLabel = "rectLabel", LabelEnum2.lineLabel = "lineLabel", LabelEnum2.dataLabel = "dataLabel";
}(LabelEnum || (LabelEnum = {}));
var PlayerEnum;
!function(PlayerEnum2) {
  PlayerEnum2.continuousPlayer = "continuousPlayer", PlayerEnum2.discretePlayer = "discretePlayer";
}(PlayerEnum || (PlayerEnum = {}));
var LayoutState;
!function(LayoutState2) {
  LayoutState2.before = "before", LayoutState2.layouting = "layouting", LayoutState2.reevaluate = "reevaluate", LayoutState2.after = "after";
}(LayoutState || (LayoutState = {}));
var HOOK_EVENT;
!function(HOOK_EVENT2) {
  HOOK_EVENT2.BEFORE_EVALUATE_DATA = "beforeEvaluateData", HOOK_EVENT2.AFTER_EVALUATE_DATA = "afterEvaluateData", HOOK_EVENT2.BEFORE_EVALUATE_SCALE = "beforeEvaluateScale", HOOK_EVENT2.AFTER_EVALUATE_SCALE = "afterEvaluateScale", HOOK_EVENT2.BEFORE_PARSE_VIEW = "beforeParseView", HOOK_EVENT2.AFTER_PARSE_VIEW = "afterParseView", HOOK_EVENT2.BEFORE_TRANSFORM = "beforeTransform", HOOK_EVENT2.AFTER_TRANSFORM = "afterTransform", HOOK_EVENT2.BEFORE_CREATE_VRENDER_STAGE = "beforeCreateVRenderStage", HOOK_EVENT2.AFTER_CREATE_VRENDER_STAGE = "afterCreateVRenderStage", HOOK_EVENT2.BEFORE_CREATE_VRENDER_LAYER = "beforeCreateVRenderLayer", HOOK_EVENT2.AFTER_CREATE_VRENDER_LAYER = "afterCreateVRenderLayer", HOOK_EVENT2.BEFORE_STAGE_RESIZE = "beforeStageResize", HOOK_EVENT2.AFTER_STAGE_RESIZE = "afterStageResize", HOOK_EVENT2.BEFORE_VRENDER_DRAW = "beforeVRenderDraw", HOOK_EVENT2.AFTER_VRENDER_DRAW = "afterVRenderDraw", HOOK_EVENT2.BEFORE_MARK_JOIN = "beforeMarkJoin", HOOK_EVENT2.AFTER_MARK_JOIN = "afterMarkJoin", HOOK_EVENT2.BEFORE_MARK_UPDATE = "beforeMarkUpdate", HOOK_EVENT2.AFTER_MARK_UPDATE = "afterMarkUpdate", HOOK_EVENT2.BEFORE_MARK_STATE = "beforeMarkState", HOOK_EVENT2.AFTER_MARK_STATE = "afterMarkState", HOOK_EVENT2.BEFORE_MARK_ENCODE = "beforeMarkEncode", HOOK_EVENT2.AFTER_MARK_ENCODE = "afterMarkEncode", HOOK_EVENT2.BEFORE_DO_LAYOUT = "beforeDoLayout", HOOK_EVENT2.AFTER_DO_LAYOUT = "afterDoLayout", HOOK_EVENT2.BEFORE_MARK_LAYOUT_END = "beforeMarkLayoutEnd", HOOK_EVENT2.AFTER_MARK_LAYOUT_END = "afterMarkLayoutEnd", HOOK_EVENT2.BEFORE_DO_RENDER = "beforeDoRender", HOOK_EVENT2.AFTER_DO_RENDER = "afterDoRender", HOOK_EVENT2.BEFORE_MARK_RENDER_END = "beforeMarkRenderEnd", HOOK_EVENT2.AFTER_MARK_RENDER_END = "afterMarkRenderEnd", HOOK_EVENT2.BEFORE_CREATE_VRENDER_MARK = "beforeCreateVRenderMark", HOOK_EVENT2.AFTER_CREATE_VRENDER_MARK = "afterCreateVRenderMark", HOOK_EVENT2.BEFORE_ADD_VRENDER_MARK = "beforeAddVRenderMark", HOOK_EVENT2.AFTER_ADD_VRENDER_MARK = "afterAddVRenderMark", HOOK_EVENT2.AFTER_VRENDER_NEXT_RENDER = "afterVRenderNextRender", HOOK_EVENT2.BEFORE_ELEMENT_UPDATE_DATA = "beforeElementUpdateData", HOOK_EVENT2.AFTER_ELEMENT_UPDATE_DATA = "afterElementUpdateData", HOOK_EVENT2.BEFORE_ELEMENT_STATE = "beforeElementState", HOOK_EVENT2.AFTER_ELEMENT_STATE = "afterElementState", HOOK_EVENT2.BEFORE_ELEMENT_ENCODE = "beforeElementEncode", HOOK_EVENT2.AFTER_ELEMENT_ENCODE = "afterElementEncode", HOOK_EVENT2.ANIMATION_START = "animationStart", HOOK_EVENT2.ANIMATION_END = "animationEnd", HOOK_EVENT2.ELEMENT_ANIMATION_START = "elementAnimationStart", HOOK_EVENT2.ELEMENT_ANIMATION_END = "elementAnimationEnd", HOOK_EVENT2.ALL_ANIMATION_START = "allAnimationStart", HOOK_EVENT2.ALL_ANIMATION_END = "allAnimationEnd";
}(HOOK_EVENT || (HOOK_EVENT = {}));
var GrammarTypeEnum;
!function(GrammarTypeEnum2) {
  GrammarTypeEnum2.signal = "signal", GrammarTypeEnum2.data = "data", GrammarTypeEnum2.scale = "scale", GrammarTypeEnum2.coordinate = "coordinate", GrammarTypeEnum2.mark = "mark";
}(GrammarTypeEnum || (GrammarTypeEnum = {}));
var InteractionStateEnum;
!function(InteractionStateEnum2) {
  InteractionStateEnum2.active = "active", InteractionStateEnum2.selected = "selected", InteractionStateEnum2.highlight = "highlight", InteractionStateEnum2.blur = "blur";
}(InteractionStateEnum || (InteractionStateEnum = {}));

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/constants
var BridgeElementKey = "__vgrammar_scene_item__";
var CollectionMarkType = [GrammarMarkType.line, GrammarMarkType.area];
var Mark3DType = [GrammarMarkType.arc3d, GrammarMarkType.rect3d, GrammarMarkType.pyramid3d];
var DefaultKey = "key";
var DefaultMarkData = [{}];
var DefaultGroupKeys = ["key"];
var DefaultReuse = true;
var DefaultMorph = true;
var DefaultMorphAll = false;
var DefaultSplitPath = null;
var DefaultEnableExitAnimation = true;
var ImmediateAnimationState = "VGRAMMAR_IMMEDIATE_ANIMATION";
var DefaultAnimationStartTime = 0;
var DefaultAnimationDuration = 1e3;
var DefaultAnimationDelay = 0;
var DefaultAnimationDelayAfter = 0;
var DefaultAnimationLoop = false;
var DefaultAnimationOneByOne = false;
var DefaultAnimationEasing = "quintInOut";
var DefaultAnimationControlOptions = {
  stopWhenStateChange: false,
  immediatelyApply: true
};
var DefaultAnimationParameters = "VGRAMMAR_ANIMATION_PARAMETERS";

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/parse/util
function parseReference(dependency, view) {
  return array(dependency).reduce((refs, dep) => {
    const ref = isString_default(dep) ? view.getGrammarById(dep) : dep;
    return ref && refs.push(ref), refs;
  }, []);
}
function isSignalReferenceType(signal) {
  return !isFunction_default(signal) && !!(null == signal ? void 0 : signal.signal);
}
function isSignalFunctionType(signal) {
  return !isFunction_default(signal) && !!(null == signal ? void 0 : signal.callback);
}
function parseFunctionType(spec, view) {
  if (isNil_default(spec))
    return [];
  if (isSignalReferenceType(spec)) {
    const signal = spec.signal;
    if (isString_default(signal))
      return array(view.getGrammarById(signal));
    if ("signal" === (null == signal ? void 0 : signal.grammarType))
      return [signal];
  } else if (isSignalFunctionType(spec))
    return parseReference(spec.dependency, view);
  return [];
}
function isFunctionType(spec) {
  return isFunction_default(spec) || (null == spec ? void 0 : spec.signal) || !!(null == spec ? void 0 : spec.callback);
}
function invokeFunctionType(spec, parameters, datumOrGrammarInstance, element) {
  if (isNil_default(spec))
    return spec;
  if (isFunction_default(spec))
    return element ? spec.call(null, datumOrGrammarInstance, element, parameters) : spec.call(null, datumOrGrammarInstance, parameters);
  if (spec.signal) {
    const signal = spec.signal;
    return isString_default(signal) ? null == parameters ? void 0 : parameters[signal] : signal.output();
  }
  return spec.callback ? element ? spec.callback.call(null, datumOrGrammarInstance, element, parameters) : spec.callback.call(null, datumOrGrammarInstance, parameters) : spec;
}
function invokeParameterFunctionType(spec, parameters) {
  if (isNil_default(spec))
    return spec;
  if (isFunction_default(spec))
    return spec.call(null, parameters);
  if (spec.signal) {
    const signal = spec.signal;
    return isString_default(signal) ? null == parameters ? void 0 : parameters[signal] : signal.output();
  }
  return spec.callback ? spec.callback.call(null, parameters) : spec;
}
function getGrammarOutput(grammar, parameters) {
  return isGrammar(grammar) ? grammar.output() : parameters[grammar];
}
function isSignal(obj) {
  return obj && (obj.signal || obj.callback);
}
var isGrammar = (el) => el && !isNil_default(el.grammarType);
var parseField = (field3) => isFunction_default(field3) ? field3 : (datum) => datum[field3];

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/parse/mark
function isScaleEncode(encode) {
  return !!(null == encode ? void 0 : encode.scale);
}
function isFieldEncode(encode) {
  return !!(null == encode ? void 0 : encode.field);
}
function parseEncodeType(encoder, view) {
  if (!encoder)
    return [];
  let dependencies = [];
  return encoder.scale && (dependencies = isGrammar(encoder.scale) ? [encoder.scale] : array(view.getScaleById(encoder.scale))), dependencies.concat(parseFunctionType(encoder, view));
}

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/attributes/helpers
function isValidPointsChannel(channels, markType) {
  switch (markType) {
    case "line":
      return channels.some((channel) => ["x", "y", "defined"].includes(channel));
    case "area":
      return channels.some((channel) => ["x", "y", "x1", "y1", "defined"].includes(channel));
    case "largeRects":
      return channels.some((channel) => ["x", "y", "width", "y1"].includes(channel));
    case "largeSymbols":
      return channels.some((channel) => ["x", "y"].includes(channel));
  }
  return false;
}
function getRulePoints(nextAttrs) {
  const { x, y, x1: x14, y1: y14 } = nextAttrs;
  return isValidNumber_default(x) && isValidNumber_default(y) && isValidNumber_default(x14) && isValidNumber_default(y14) ? [{
    x,
    y
  }, {
    x: x14,
    y: y14
  }] : [];
}
function getLinePoints(items, includeOnePoint, lastPoints, isArea) {
  if (!items || !items.length || 1 === items.length && !includeOnePoint)
    return [];
  return items.some((item) => isValidPointsChannel(Object.keys(item.nextAttrs), "line")) ? items.map((item, index) => {
    var _a;
    const attrs = item.nextAttrs, { x, y, x1: x14, y1: y14, defined } = null !== (_a = null == lastPoints ? void 0 : lastPoints[index]) && void 0 !== _a ? _a : {};
    return isNil_default(attrs.x) && (attrs.x = x), isNil_default(attrs.y) && (attrs.y = y), isNil_default(attrs.defined) && false === defined && (attrs.defined = false), attrs.context = item.key, isArea && (isNil_default(attrs.x1) && (attrs.x1 = x14), isNil_default(attrs.y1) && (attrs.y1 = y14)), attrs;
  }) : null != lastPoints ? lastPoints : [];
}
function getLargeRectsPoints(items, includeOnePoint, lastPoints = []) {
  if (!items || !items.length || 1 === items.length && !includeOnePoint)
    return [];
  const arr = new Float32Array(4 * items.length);
  return items.forEach((item, index) => {
    var _a, _b, _c, _d;
    const attrs = item.nextAttrs, x = null !== (_a = attrs.x) && void 0 !== _a ? _a : lastPoints[4 * index], y = null !== (_b = attrs.y) && void 0 !== _b ? _b : lastPoints[4 * index + 1], width = null !== (_c = attrs.width) && void 0 !== _c ? _c : lastPoints[4 * index + 2], y14 = null !== (_d = attrs.y1) && void 0 !== _d ? _d : lastPoints[4 * index + 3];
    arr[4 * index] = x, arr[4 * index + 1] = y, arr[4 * index + 2] = width, arr[4 * index + 3] = y14 - y;
  }), arr;
}
function getLargeSymbolsPoints(items, includeOnePoint, lastPoints = []) {
  if (!items || !items.length || 1 === items.length && !includeOnePoint)
    return [];
  const arr = new Float32Array(2 * items.length);
  return items.forEach((item, index) => {
    var _a, _b;
    const attrs = item.nextAttrs, x = null !== (_a = attrs.x) && void 0 !== _a ? _a : lastPoints[2 * index], y = null !== (_b = attrs.y) && void 0 !== _b ? _b : lastPoints[2 * index + 1];
    arr[2 * index] = x, arr[2 * index + 1] = y;
  }), arr;
}
function isPositionOrSizeChannel(type, channel) {
  if (["x", "y", "dx", "dy"].includes(channel))
    return true;
  switch (type) {
    case GrammarMarkType.arc:
      return ["innerRadius", "outerRadius", "startAngle", "endAngle"].includes(channel);
    case GrammarMarkType.group:
    case GrammarMarkType.rect:
    case GrammarMarkType.image:
      return ["width", "height", "y1"].includes(channel);
    case GrammarMarkType.path:
    case GrammarMarkType.shape:
      return ["path", "customPath"].includes(channel);
    case GrammarMarkType.line:
      return "defined" === channel;
    case GrammarMarkType.area:
      return ["x1", "y1", "defined"].includes(channel);
    case GrammarMarkType.rule:
      return ["x1", "y1"].includes(channel);
    case GrammarMarkType.symbol:
      return "size" === channel;
    case GrammarMarkType.polygon:
      return "points" === channel;
    case GrammarMarkType.text:
      return "text" === channel;
  }
  return false;
}
function isPointsMarkType(markType) {
  return [GrammarMarkType.line, GrammarMarkType.area, GrammarMarkType.largeRects, GrammarMarkType.largeSymbols].includes(markType);
}

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/mark/encode
function invokeEncoderToItems(element, items, encoder, parameters, onlyFullEncodeFirst) {
  encoder && (isFunctionType(encoder) ? items.forEach((item) => {
    const attributes = invokeFunctionType(encoder, parameters, item.datum, element);
    Object.assign(item.nextAttrs, attributes);
  }) : Object.keys(encoder).forEach((channel) => {
    var _a, _b;
    const encode = encoder[channel], encodeItems = onlyFullEncodeFirst && !isPositionOrSizeChannel(element.mark.markType, channel) ? [items[0]] : items;
    if (isScaleEncode(encode)) {
      const scale4 = getGrammarOutput(encode.scale, parameters), offset = null !== (_a = null == encode ? void 0 : encode.offset) && void 0 !== _a ? _a : 0, bandOffset = !isNil_default(encode.band) && scale4.bandwidth ? scale4.bandwidth() * encode.band : null, hasField = isString_default(null == encode ? void 0 : encode.field), fieldAccessor = hasField ? field(encode.field) : null;
      let to = hasField ? null : isNil_default(null == encode ? void 0 : encode.value) ? 0 : null === (_b = scale4.scale) || void 0 === _b ? void 0 : _b.call(scale4, encode.value);
      encodeItems.forEach((item) => {
        var _a2;
        hasField && (to = null === (_a2 = scale4.scale) || void 0 === _a2 ? void 0 : _a2.call(scale4, fieldAccessor(item.datum))), item.nextAttrs[channel] = isNumber_default(to) || isNumber_default(bandOffset) ? to + offset + bandOffset : to;
      });
    } else if (isFieldEncode(encode)) {
      const fieldAccessor = field(encode.field);
      encodeItems.forEach((item) => {
        item.nextAttrs[channel] = fieldAccessor(item.datum);
      });
    } else
      encodeItems.forEach((item) => {
        item.nextAttrs[channel] = invokeFunctionType(encode, parameters, item.datum, element);
      });
  }));
}
function invokeEncoder(encoder, datum, element, parameters) {
  if (!encoder)
    return null;
  if (isFunctionType(encoder))
    return invokeFunctionType(encoder, parameters, datum, element);
  const attributes = {};
  return Object.keys(encoder).forEach((channel) => {
    var _a, _b, _c;
    const encode = encoder[channel];
    if (isScaleEncode(encode)) {
      const scale4 = getGrammarOutput(encode.scale, parameters), offset = null !== (_a = null == encode ? void 0 : encode.offset) && void 0 !== _a ? _a : 0, bandOffset = !isNil_default(encode.band) && scale4.bandwidth ? scale4.bandwidth() * encode.band : null, hasField = isString_default(null == encode ? void 0 : encode.field), fieldAccessor = hasField ? field(encode.field) : null, to = hasField ? null === (_b = scale4.scale) || void 0 === _b ? void 0 : _b.call(scale4, fieldAccessor(datum)) : isNil_default(null == encode ? void 0 : encode.value) ? 0 : null === (_c = scale4.scale) || void 0 === _c ? void 0 : _c.call(scale4, encode.value);
      attributes[channel] = isNumber_default(to) || isNumber_default(bandOffset) ? to + offset + bandOffset : to;
    } else if (isFieldEncode(encode)) {
      const fieldAccessor = field(encode.field);
      attributes[channel] = fieldAccessor(datum);
    } else
      attributes[channel] = invokeFunctionType(encode, parameters, datum, element);
  }), attributes;
}

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/view/glyph-meta
var GlyphMeta = class {
  constructor(marks, encoders, defaultEncoder, progressiveChannels) {
    this.channelEncoder = {}, this.marks = marks, encoders && this.registerChannelEncoder(encoders), defaultEncoder && this.registerDefaultEncoder(defaultEncoder), this.progressiveChannels && this.registerProgressiveChannels(progressiveChannels);
  }
  getMarks() {
    return this.marks;
  }
  registerChannelEncoder(channel, encoder) {
    return isString_default(channel) ? this.channelEncoder[channel] = encoder : Object.assign(this.channelEncoder, channel), this;
  }
  registerFunctionEncoder(encoder) {
    return this.functionEncoder = encoder, this;
  }
  registerDefaultEncoder(encoder) {
    return this.defaultEncoder = encoder, this;
  }
  registerProgressiveChannels(channels) {
    return this.progressiveChannels = array(channels), this;
  }
  getChannelEncoder() {
    return this.channelEncoder;
  }
  getFunctionEncoder() {
    return this.functionEncoder;
  }
  getDefaultEncoder() {
    return this.defaultEncoder;
  }
  getProgressiveChannels() {
    return this.progressiveChannels;
  }
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/core/factory
var Factory = class _Factory {
  static registerPlotMarks(key, mark) {
    _Factory._plotMarks[key] = mark;
  }
  static createPlotMark(type, id2) {
    if (!_Factory._plotMarks[type])
      return null;
    return new (0, _Factory._plotMarks[type])(id2);
  }
  static registerMark(key, mark) {
    _Factory._marks[key] = mark;
  }
  static createMark(type, view, group) {
    if (!_Factory._marks[type])
      return null;
    return new (0, _Factory._marks[type])(view, type, group);
  }
  static hasMark(type) {
    return !!_Factory._marks[type];
  }
  static registerComponent(key, component2) {
    _Factory._components[key] = component2;
  }
  static createComponent(componentType, view, group, mode) {
    const Ctor = _Factory._components[componentType];
    return Ctor ? new Ctor(view, group, mode) : null;
  }
  static hasComponent(componentType) {
    return !!_Factory._components[componentType];
  }
  static registerGraphicComponent(key, creator) {
    _Factory._graphicComponents[key] = creator;
  }
  static createGraphicComponent(componentType, attrs, options) {
    const compCreator = _Factory._graphicComponents[componentType];
    return compCreator ? compCreator(attrs, options) : null;
  }
  static registerTransform(type, transform5, isBuiltIn) {
    _Factory._transforms[type] = Object.assign(transform5, {
      type,
      isBuiltIn: !!isBuiltIn
    });
  }
  static getTransform(type) {
    return _Factory._transforms[type];
  }
  static unregisterRuntimeTransforms() {
    Object.keys(_Factory._transforms).forEach((type) => {
      _Factory._transforms[type] && !_Factory._transforms[type].isBuiltIn && (_Factory._transforms[type] = null);
    });
  }
  static registerGrammar(type, grammarClass, specKey) {
    _Factory._grammars[type] = {
      grammarClass,
      specKey: null != specKey ? specKey : type
    };
  }
  static createGrammar(type, view, grammarType) {
    var _a;
    const Ctor = null === (_a = _Factory._grammars[type]) || void 0 === _a ? void 0 : _a.grammarClass;
    return Ctor ? new Ctor(view, grammarType) : null;
  }
  static getGrammars() {
    return this._grammars;
  }
  static getGlyph(glyphType) {
    return _Factory._glyphs[glyphType];
  }
  static createInteraction(interactionType, view, options) {
    const Ctor = _Factory._interactions[interactionType];
    return Ctor ? new Ctor(view, options) : null;
  }
  static hasInteraction(interactionType) {
    return !!_Factory._interactions[interactionType];
  }
};
Factory._plotMarks = {}, Factory._marks = {}, Factory._components = {}, Factory._graphicComponents = {}, Factory._transforms = {}, Factory._grammars = {}, Factory._glyphs = {}, Factory._animations = {}, Factory._interactions = {}, Factory._graphics = {}, Factory.registerGlyph = (glyphType, marks, encoders, defaultEncoder, progressiveChannels) => (Factory._glyphs[glyphType] = new GlyphMeta(marks, encoders, defaultEncoder, progressiveChannels), Factory._glyphs[glyphType]), Factory.registerAnimationType = (animationType, animation) => {
  Factory._animations[animationType] = animation;
}, Factory.getAnimationType = (animationType) => Factory._animations[animationType], Factory.registerInteraction = (interactionType, interaction) => {
  Factory._interactions[interactionType] = interaction;
}, Factory.registerGraphic = (graphicType, creator) => {
  Factory._graphics[graphicType] = creator;
}, Factory.getGraphicType = (graphicType) => Factory._graphics[graphicType], Factory.createGraphic = (graphicType, attributes) => {
  const creator = Factory._graphics[graphicType];
  return creator ? creator(attributes) : null;
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/util/graphic
var isMarkType = (type) => !!GrammarMarkType[type];
function createGraphicItem(mark, markType, attrs = {}) {
  var _a;
  const graphicItem = Factory.getGraphicType(markType) ? Factory.createGraphic(markType, attrs) : Factory.createGraphicComponent(markType, attrs, {
    skipDefault: null === (_a = null == mark ? void 0 : mark.spec) || void 0 === _a ? void 0 : _a.skipTheme
  });
  if (!graphicItem) {
    Logger.getInstance().error(`create ${markType} graphic failed!`);
  }
  return graphicItem;
}
function createGlyphGraphicItem(mark, glyphMeta, attrs = {}) {
  if (!Factory.getGraphicType(GrammarMarkType.glyph))
    return;
  const graphicItem = Factory.createGraphic(GrammarMarkType.glyph, attrs), glyphMarks = glyphMeta.getMarks(), subGraphics = Object.keys(glyphMarks).map((name) => {
    if (Factory.getGraphicType(glyphMarks[name])) {
      const graphic = Factory.createGraphic(glyphMarks[name]);
      if (graphic)
        return graphic.name = name, graphic;
    }
  });
  return graphicItem.setSubGraphic(subGraphics), graphicItem;
}
var removeGraphicItem = (graphicItem) => {
  graphicItem && (graphicItem[BridgeElementKey] = null, graphicItem.release(), graphicItem.parent && graphicItem.parent.removeChild(graphicItem));
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/attributes/common
var commonAttributes = ["fillOpacity"];
var transformCommonAttribute = (graphicAttributes, changedKey, nextAttrs) => {
  var _a;
  return "fillOpacity" === changedKey ? (graphicAttributes.fillOpacity = null !== (_a = nextAttrs.fillOpacity) && void 0 !== _a ? _a : 1, ["fillOpacity"]) : [];
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/attributes/transform
function storeOriginAttributes(name, channels, graphicAttributes, nextAttrs, element, markName) {
  const prevStoredAttrs = element.getGraphicAttribute(name, false, markName);
  if (prevStoredAttrs)
    return channels.forEach((channel) => {
      channel in nextAttrs && (prevStoredAttrs[channel] = nextAttrs[channel]);
    }), prevStoredAttrs;
  const storedAttrs = {};
  return channels.forEach((channel) => {
    storedAttrs[channel] = nextAttrs[channel];
  }), graphicAttributes[name] = storedAttrs, storedAttrs;
}
var transformsByType = {
  rect3d: [{
    channels: ["x", "y", "z", "x1", "y1", "width", "height", "length"],
    transform: (graphicAttributes, nextAttrs, storedAttrs) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      isValidNumber_default(nextAttrs.width) || !isValidNumber_default(nextAttrs.x1) && isValidNumber_default(storedAttrs.width) ? (graphicAttributes.x = Math.min(null !== (_a = storedAttrs.x) && void 0 !== _a ? _a : 0, null !== (_b = storedAttrs.x1) && void 0 !== _b ? _b : 1 / 0), graphicAttributes.width = storedAttrs.width) : isValidNumber_default(nextAttrs.x1) || !isValidNumber_default(nextAttrs.width) && isValidNumber_default(storedAttrs.x1) ? (graphicAttributes.x = Math.min(storedAttrs.x, storedAttrs.x1), graphicAttributes.width = Math.abs(storedAttrs.x1 - storedAttrs.x)) : (graphicAttributes.x = Math.min(null !== (_c = storedAttrs.x) && void 0 !== _c ? _c : 0, null !== (_d = storedAttrs.x1) && void 0 !== _d ? _d : 1 / 0), graphicAttributes.width = storedAttrs.width), isValidNumber_default(nextAttrs.height) || !isValidNumber_default(nextAttrs.y1) && isValidNumber_default(storedAttrs.height) ? (graphicAttributes.y = Math.min(null !== (_e = storedAttrs.y) && void 0 !== _e ? _e : 0, null !== (_f = storedAttrs.y1) && void 0 !== _f ? _f : 1 / 0), graphicAttributes.height = storedAttrs.height) : isValidNumber_default(nextAttrs.y1) || !isValidNumber_default(nextAttrs.height) && isValidNumber_default(storedAttrs.y1) ? (graphicAttributes.y = Math.min(storedAttrs.y, storedAttrs.y1), graphicAttributes.height = Math.abs(storedAttrs.y1 - storedAttrs.y)) : (graphicAttributes.y = Math.min(null !== (_g = storedAttrs.y) && void 0 !== _g ? _g : 0, null !== (_h = storedAttrs.y1) && void 0 !== _h ? _h : 1 / 0), graphicAttributes.height = storedAttrs.height), isValidNumber_default(nextAttrs.length) || !isValidNumber_default(nextAttrs.z1) && isValidNumber_default(storedAttrs.length) ? (graphicAttributes.z = Math.min(null !== (_j = storedAttrs.z) && void 0 !== _j ? _j : 0, null !== (_k = storedAttrs.z1) && void 0 !== _k ? _k : 1 / 0), graphicAttributes.length = storedAttrs.length) : isValidNumber_default(nextAttrs.z1) || !isValidNumber_default(nextAttrs.length) && isValidNumber_default(storedAttrs.z1) ? (graphicAttributes.z = Math.min(storedAttrs.z, storedAttrs.z1), graphicAttributes.length = Math.abs(storedAttrs.z1 - storedAttrs.z)) : (graphicAttributes.z = Math.min(null !== (_l = storedAttrs.z) && void 0 !== _l ? _l : 0, null !== (_m = storedAttrs.z1) && void 0 !== _m ? _m : 1 / 0), graphicAttributes.length = storedAttrs.length);
    },
    storedAttrs: "sizeAttrs"
  }],
  [GrammarMarkType.text]: [{
    channels: ["text", "limit", "autoLimit", "maxLineWidth", "textType"],
    transform: (graphicAttributes, nextAttrs, storedAttrs) => {
      var _a, _b;
      const limit = null !== (_a = storedAttrs.limit) && void 0 !== _a ? _a : 1 / 0, autoLimit2 = null !== (_b = storedAttrs.autoLimit) && void 0 !== _b ? _b : 1 / 0, maxWidth = Math.min(limit, autoLimit2), isTextConfig = isPlainObject_default(storedAttrs.text) && !isNil_default(storedAttrs.text.text), text2 = isTextConfig ? storedAttrs.text.text : storedAttrs.text;
      Array.isArray(text2), graphicAttributes.maxLineWidth = maxWidth === 1 / 0 ? storedAttrs.maxLineWidth : maxWidth, (isTextConfig || storedAttrs.textType) && ("rich" === storedAttrs.text.type || "rich" === storedAttrs.textType) ? graphicAttributes.textConfig = text2 : graphicAttributes.text = text2;
    },
    storedAttrs: "limitAttrs"
  }],
  [GrammarMarkType.rule]: [{
    channels: ["x", "y", "x1", "y1"],
    transform: (graphicAttributes, nextAttrs, storedAttrs) => {
      const points = getRulePoints(storedAttrs);
      graphicAttributes.points = points, graphicAttributes.x = 0, graphicAttributes.y = 0;
    },
    storedAttrs: "pointAttrs"
  }],
  [GrammarMarkType.symbol]: [{
    channels: ["shape", "symbolType"],
    transform: (graphicAttributes, nextAttrs, storedAttrs) => {
      var _a;
      graphicAttributes.symbolType = null !== (_a = nextAttrs.shape) && void 0 !== _a ? _a : nextAttrs.symbolType;
    }
  }, {
    channels: ["image", "fill", "background"],
    transform: (graphicAttributes, nextAttrs, storedAttrs) => {
      nextAttrs.image ? (graphicAttributes.background = nextAttrs.image, graphicAttributes.fill = false) : storedAttrs.image ? (graphicAttributes.background = storedAttrs.image, graphicAttributes.fill = false) : (graphicAttributes.fill = storedAttrs.fill, graphicAttributes.background = storedAttrs.background);
    },
    storedAttrs: "imageAttrs"
  }]
};
function cloneTransformAttributes(markType, attributes) {
  var _a;
  return (null !== (_a = transformsByType[markType]) && void 0 !== _a ? _a : []).reduce((clonedAttributes, transform5) => (transform5.channels.forEach((channel) => {
    has_default(attributes, channel) && (clonedAttributes[channel] = attributes[channel]);
  }), clonedAttributes), {});
}
var transformAttributes = (markType, nextAttrs, element, markName) => {
  const graphicAttributes = {}, changedKeys = nextAttrs ? Object.keys(nextAttrs) : [], transforms = isString_default(markType) ? transformsByType[markType] : markType;
  if (transforms && transforms.length) {
    const tags = [];
    changedKeys.forEach((key) => {
      let isTransformed = false;
      transforms.forEach((transform5, index) => {
        if (transform5.channels.includes(key)) {
          if (!tags[index])
            if (transform5.storedAttrs) {
              const storedAttrs = storeOriginAttributes(transform5.storedAttrs, transform5.channels, graphicAttributes, nextAttrs, element, markName);
              transform5.transform(graphicAttributes, nextAttrs, storedAttrs);
            } else
              transform5.transform(graphicAttributes, nextAttrs, null);
          tags[index] = true, isTransformed = true;
        }
      }), isTransformed || (commonAttributes.includes(key) ? transformCommonAttribute(graphicAttributes, key, nextAttrs) : graphicAttributes[key] = nextAttrs[key]);
    });
  } else
    changedKeys.forEach((key) => {
      commonAttributes.includes(key) ? transformCommonAttribute(graphicAttributes, key, nextAttrs) : graphicAttributes[key] = nextAttrs[key];
    });
  return graphicAttributes;
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/attributes/line
var isStopsEqual = (prev, next) => {
  var _a, _b;
  if (prev === next)
    return true;
  const prevLength = null !== (_a = prev && prev.length) && void 0 !== _a ? _a : 0;
  return prevLength === (null !== (_b = next && next.length) && void 0 !== _b ? _b : 0) && 0 !== prevLength && prev.every((prevEntry, prevIndex) => !prevEntry && !next[prevIndex] || prevEntry && next[prevIndex] && prevEntry.color === next[prevIndex].color && prevEntry.offset === next[prevIndex].offset);
};
var isColorAttrEqual = (prev, next) => {
  if (prev === next)
    return true;
  if (typeof prev != typeof next)
    return false;
  if (isString_default(prev))
    return false;
  if (prev.gradient !== next.gradient)
    return false;
  const prevKeys = Object.keys(prev), nextKeys = Object.keys(next);
  return prevKeys.length === nextKeys.length && prevKeys.every((key) => "stops" === key ? isStopsEqual(prev[key], next[key]) : prev[key] === next[key]);
};
var isLineDashEqual = (prev, next) => prev.length === next.length && prev.join("-") === next.join("-");
var isSegmentAttrEqual = (prev, next, key) => !(!isNil_default(prev) || !isNil_default(next)) || !isNil_default(prev) && (!isNil_default(next) && ("lineDash" === key ? isLineDashEqual(prev, next) : "stroke" === key || "fill" === key ? isColorAttrEqual(prev, next) : prev === next));
var fillAttrs = ["fill", "fillOpacity", "background", "texture", "texturePadding", "textureSize", "textureColor"];
var strokeAttrs = ["stroke", "strokeOpacity", "lineDash", "lineDashOffset", "lineCap", "lineJoin", "lineWidth", "miterLimit"];
var areaAttrs = fillAttrs.concat(strokeAttrs);
function getLineSegmentConfigs(items, points, element) {
  var _a;
  if (!items || items.length <= 1)
    return null;
  const checkAttributes = "area" === (null === (_a = null == element ? void 0 : element.mark) || void 0 === _a ? void 0 : _a.markType) ? areaAttrs : strokeAttrs, segments2 = [];
  let prevSegmentAttrs = null;
  return items.forEach((item, index) => {
    prevSegmentAttrs && checkAttributes.every((key) => isSegmentAttrEqual(prevSegmentAttrs[key], item[key], key)) || (segments2.length && (segments2[segments2.length - 1].endIndex = index), prevSegmentAttrs = item, segments2.push({
      attrs: prevSegmentAttrs,
      startIndex: index
    }));
  }), segments2.length >= 2 ? segments2.map((entry) => {
    const res = parseCollectionMarkAttributes(entry.attrs);
    return res.points = points.slice(entry.startIndex, isNil_default(entry.endIndex) ? points.length : entry.endIndex), res;
  }) : null;
}
function getConnectLineSegmentConfigs(items, points, element) {
  if (!items || items.length <= 1)
    return null;
  const enableSegments = !!element && element.mark.getSpec().enableSegments;
  let isPrevDefined, curSegment, segments2 = [], point5 = null;
  if (items.forEach((item, index) => {
    point5 = points[index], point5 && false !== point5.defined ? (isPrevDefined || (curSegment = {
      items: [],
      points: []
    }, segments2.push(curSegment)), curSegment.points.push(point5), curSegment.items.push(item), false === isPrevDefined && (curSegment.isConnect = true, curSegment = {
      items: [],
      points: []
    }, segments2.push(curSegment)), isPrevDefined = true) : isPrevDefined = false;
  }), segments2 = segments2.filter((seg) => seg.points.length > 0), segments2.length >= 2) {
    const res = [];
    return segments2.forEach((entry) => {
      if (entry.isConnect)
        return void res.push({
          points: entry.points,
          isConnect: true
        });
      if (enableSegments) {
        const subSegments = getLineSegmentConfigs(entry.items, entry.points, element);
        if (subSegments)
          return void subSegments.forEach((subSeg) => {
            res.push(subSeg);
          });
      }
      const seg = parseCollectionMarkAttributes(entry.items[0]);
      seg.points = entry.points, res.push(seg);
    }), res;
  }
  return enableSegments ? getLineSegmentConfigs(items, points, element) : null;
}
function getLinePointsFromSegments(segments2) {
  return segments2 ? segments2.reduce((points, segment) => points.concat(segment.points), []) : null;
}
function parseCollectionMarkAttributes(itemNextAttrs) {
  const result2 = {};
  return itemNextAttrs ? (Object.keys(itemNextAttrs).forEach((key) => {
    "x" !== key && "y" !== key && "x1" !== key && "y1" !== key && "defined" !== key && "size" !== key && "width" !== key && "height" !== key && "context" !== key && (result2[key] = itemNextAttrs[key]);
  }), result2) : result2;
}

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/element
var Element2 = class {
  constructor(mark) {
    this.data = null, this.states = [], this.diffState = DiffState.enter, this.isReserved = false, this.runtimeStatesEncoder = null, this.items = [], this.getStateAttrs = (stateName, nextStates) => {
      var _a, _b, _c, _d;
      const isRuntimeState = !isNil_default(null === (_a = this.runtimeStatesEncoder) || void 0 === _a ? void 0 : _a[stateName]), encoder = isRuntimeState ? Object.assign(Object.assign({}, null === (_b = this.mark.getSpec().encode) || void 0 === _b ? void 0 : _b[stateName]), this.runtimeStatesEncoder[stateName]) : null === (_c = this.mark.getSpec().encode) || void 0 === _c ? void 0 : _c[stateName];
      if (!encoder)
        return {};
      if (isFunction_default(encoder))
        return encoder(this.getDatum(), this, stateName, nextStates);
      if (!isRuntimeState && (null === (_d = this.graphicItem.states) || void 0 === _d ? void 0 : _d[stateName]))
        return this.graphicItem.states[stateName];
      const stateItems = this.items.map((item) => Object.assign({}, item, {
        nextAttrs: {}
      }));
      invokeEncoderToItems(this, stateItems, encoder, this.mark.parameters());
      const graphicAttributes = this.transformElementItems(stateItems, this.mark.markType);
      return this.graphicItem.states ? this.graphicItem.states[stateName] || (this.graphicItem.states[stateName] = graphicAttributes) : this.graphicItem.states = {
        [stateName]: graphicAttributes
      }, graphicAttributes;
    }, this.mark = mark;
  }
  initGraphicItem(attributes = {}) {
    if (this.graphicItem)
      return;
    const attrTransforms = this.mark.getAttributeTransforms();
    this.graphicItem = this.mark.addGraphicItem(attrTransforms ? transformAttributes(attrTransforms, attributes, this) : attributes, this.groupKey), this.graphicItem && (this.graphicItem[BridgeElementKey] = this, attrTransforms && (this.graphicItem.onBeforeAttributeUpdate = (attributes2) => {
      if (!this.mark)
        return attributes2;
      return transformAttributes(attrTransforms, attributes2, this);
    }), this.clearGraphicAttributes(), this.mark.needAnimate() && (this.setPrevGraphicAttributes(null), this.setNextGraphicAttributes(attributes), this.setFinalGraphicAttributes(attributes)));
  }
  updateGraphicItem() {
    if (!this.graphicItem)
      return;
    this.diffState === DiffState.exit ? this.graphicItem.releaseStatus = "willRelease" : this.graphicItem.releaseStatus = void 0;
    const stateAnimation = this.mark.animate.getAnimationConfigs("state");
    0 !== stateAnimation.length && (this.graphicItem.stateAnimateConfig = stateAnimation[0].originConfig);
  }
  getGraphicItem() {
    return this.graphicItem;
  }
  removeGraphicItem() {
    var _a, _b;
    this.graphicItem && (null === (_b = null === (_a = this.graphicItem.animates) || void 0 === _a ? void 0 : _a.forEach) || void 0 === _b || _b.call(_a, (animate) => animate.stop())), this.graphicItem && (removeGraphicItem(this.graphicItem), this.graphicItem[BridgeElementKey] = null, this.graphicItem = null);
  }
  resetGraphicItem() {
    this.graphicItem && (this.graphicItem = null);
  }
  getBounds() {
    var _a;
    return null === (_a = this.graphicItem) || void 0 === _a ? void 0 : _a.AABBBounds;
  }
  getStates() {
    return this.states;
  }
  updateData(groupKey, data, key) {
    var _a;
    this.mark.emit(HOOK_EVENT.BEFORE_ELEMENT_UPDATE_DATA, {
      groupKey,
      data,
      key
    }, this), this.data = data;
    const keyGetter = parseField(key);
    return this.items = data.map((datum) => ({
      datum,
      key: keyGetter(datum),
      view: this.mark.view,
      nextAttrs: {}
    })), this.groupKey = groupKey, this.key = this.mark.isCollectionMark() ? groupKey : null === (_a = this.items) || void 0 === _a ? void 0 : _a[0].key, this.mark.emit(HOOK_EVENT.AFTER_ELEMENT_UPDATE_DATA, {
      groupKey,
      data,
      key
    }, this), this.items;
  }
  state(markState, parameters) {
    var _a;
    const isCollectionMark = this.mark.isCollectionMark(), prevStateValues = this.states, newStateValues = array(invokeFunctionType(markState, parameters, this.getDatum(), this)), stateSort = null === (_a = this.mark.getSpec()) || void 0 === _a ? void 0 : _a.stateSort;
    stateSort && newStateValues.length && newStateValues.sort(stateSort);
    const isStateChanged = newStateValues.length !== prevStateValues.length || newStateValues.some((newState, index) => newState !== prevStateValues[index]);
    this.states = newStateValues, !isCollectionMark && isStateChanged && this.diffState === DiffState.unChange && (this.diffState = DiffState.update);
  }
  encodeGraphic(attrs) {
    this.coordinateTransformEncode(this.items);
    const graphicAttributes = this.transformElementItems(this.items, this.mark.markType);
    attrs && (this.mark.isCollectionMark() && delete attrs.defined, Object.assign(graphicAttributes, attrs)), this.graphicItem ? (this.graphicItem.clearStates(), this.graphicItem.states = {}, this.graphicItem.stateProxy = null, this.applyGraphicAttributes(graphicAttributes)) : this.initGraphicItem(graphicAttributes), this.diffState !== DiffState.enter && this.diffState !== DiffState.update || !this.states.length || this.useStates(this.states), this.mark.markType === GrammarMarkType.shape && (this.graphicItem.datum = this.items[0].datum), this.items.forEach((item) => {
      item.nextAttrs = {};
    }), this._setCustomizedShape();
  }
  _setCustomizedShape() {
    var _a;
    if (!this.graphicItem)
      return;
    const setCustomizedShape = null === (_a = this.mark.getSpec()) || void 0 === _a ? void 0 : _a.setCustomizedShape;
    setCustomizedShape && (this.graphicItem.pathProxy = (attrs) => setCustomizedShape(this.data, attrs, new CustomPath2D()));
  }
  encodeItems(items, encoders, isReentered = false, parameters) {
    const isCollectionMark = this.mark.isCollectionMark(), updateEncoder = encoders[BuiltInEncodeNames.update], enterEncoder = encoders[BuiltInEncodeNames.enter], exitEncoder = encoders[BuiltInEncodeNames.exit], onlyFullEncodeFirst = this.mark.isLargeMode() || isCollectionMark && !this.mark.getSpec().enableSegments;
    this.diffState === DiffState.enter ? (enterEncoder && invokeEncoderToItems(this, items, enterEncoder, parameters, onlyFullEncodeFirst), updateEncoder && invokeEncoderToItems(this, items, updateEncoder, parameters, onlyFullEncodeFirst)) : this.diffState === DiffState.update ? ((isCollectionMark && enterEncoder || isReentered) && invokeEncoderToItems(this, items, enterEncoder, parameters, onlyFullEncodeFirst), updateEncoder && invokeEncoderToItems(this, items, updateEncoder, parameters, onlyFullEncodeFirst)) : this.diffState === DiffState.exit && exitEncoder && (isReentered && invokeEncoderToItems(this, items, enterEncoder, parameters, onlyFullEncodeFirst), invokeEncoderToItems(this, items, exitEncoder, parameters, onlyFullEncodeFirst));
  }
  coordinateTransformEncode(items) {
    if (!this.mark.coord || "arc" === this.mark.markType || true === this.mark.disableCoordinateTransform)
      return;
    const coord = this.mark.coord.output();
    items.forEach((item) => {
      const nextAttrs = item.nextAttrs, convertedPoint = coord.convert(nextAttrs);
      Object.assign(nextAttrs, convertedPoint);
    });
  }
  clearStates(hasAnimation) {
    const stateAnimationEnable = isBoolean_default(hasAnimation) ? hasAnimation : 0 !== this.mark.animate.getAnimationConfigs("state").length;
    this.states = [], this.graphicItem && this.graphicItem.clearStates(stateAnimationEnable), this.runtimeStatesEncoder && (this.runtimeStatesEncoder = {});
  }
  _updateRuntimeStates(state, attrs) {
    this.runtimeStatesEncoder || (this.runtimeStatesEncoder = {}), this.runtimeStatesEncoder[state] = attrs;
  }
  hasState(state) {
    return this.states && state && this.states.includes(state);
  }
  updateStates(states) {
    if (!this.graphicItem)
      return false;
    let nextStates = this.states.slice();
    const encode = this.mark.getSpec().encode;
    let forceClearState = false, hasUpdate = false;
    return Object.keys(states).forEach((stateKey) => {
      var _a;
      if (!stateKey)
        return;
      const stateValue = states[stateKey];
      if (isObject_default(stateValue) && !isEqual(stateValue, null === (_a = this.runtimeStatesEncoder) || void 0 === _a ? void 0 : _a[stateKey]))
        nextStates.includes(stateKey) ? forceClearState = true : nextStates.push(stateKey), this._updateRuntimeStates(stateKey, stateValue), hasUpdate = true;
      else if (stateValue)
        !nextStates.includes(stateKey) && (null == encode ? void 0 : encode[stateKey]) && (nextStates.push(stateKey), hasUpdate = true);
      else if (nextStates.length) {
        const newNextStates = nextStates.filter((state) => state !== stateKey);
        newNextStates.length !== nextStates.length && (hasUpdate = true, nextStates = newNextStates), this.runtimeStatesEncoder && this.runtimeStatesEncoder[stateKey] && (this.runtimeStatesEncoder[stateKey] = null);
      }
    }), forceClearState && this.graphicItem.clearStates(), !!hasUpdate && (this.useStates(nextStates), true);
  }
  addState(state, attrs) {
    var _a;
    if (!this.graphicItem)
      return false;
    if (attrs && isString_default(state) && !isEqual(attrs, null === (_a = this.runtimeStatesEncoder) || void 0 === _a ? void 0 : _a[state])) {
      const nextStates2 = this.states.slice();
      return nextStates2.includes(state) ? this.graphicItem.clearStates() : nextStates2.push(state), this._updateRuntimeStates(state, attrs), this.useStates(nextStates2), true;
    }
    const encode = this.mark.getSpec().encode, nextStates = array(state).reduce((nextStates2, stateName) => (stateName && !nextStates2.includes(stateName) && (null == encode ? void 0 : encode[stateName]) && nextStates2.push(stateName), nextStates2), this.states.slice());
    return nextStates.length !== this.states.length && (this.useStates(nextStates), true);
  }
  removeState(state) {
    if (!this.graphicItem)
      return false;
    const states = array(state);
    if (!states.length)
      return false;
    const nextStates = this.states.filter((state2) => !states.includes(state2));
    return nextStates.length !== this.states.length && (this.runtimeStatesEncoder && states.forEach((state2) => {
      this.runtimeStatesEncoder[state2] = null;
    }), this.useStates(nextStates), true);
  }
  useStates(states, hasAnimation) {
    var _a;
    if (!this.graphicItem)
      return false;
    this.mark.emit(HOOK_EVENT.BEFORE_ELEMENT_STATE, {
      states
    }, this);
    const stateSort = null === (_a = this.mark.getSpec()) || void 0 === _a ? void 0 : _a.stateSort;
    stateSort && states.sort(stateSort), this.states = states;
    const stateAnimationEnable = isBoolean_default(hasAnimation) ? hasAnimation : 0 !== this.mark.animate.getAnimationConfigs("state").length;
    return this.graphicItem.stateProxy = this.getStateAttrs, this.graphicItem.useStates(this.states, stateAnimationEnable), this.mark.emit(HOOK_EVENT.AFTER_ELEMENT_STATE, {
      states
    }, this), true;
  }
  diffAttributes(graphicAttributes) {
    const diffResult = {}, finalGraphicAttributes = this.getFinalGraphicAttributes();
    for (const key in graphicAttributes)
      isEqual2(key, finalGraphicAttributes, graphicAttributes) && has_default(finalGraphicAttributes, key) || (diffResult[key] = graphicAttributes[key]);
    return diffResult;
  }
  transformElementItems(items, markType, computePoints) {
    var _a, _b, _c, _d, _e;
    const item = items[0];
    if (!item.nextAttrs || 0 === Object.keys(item.nextAttrs).length)
      return {};
    let nextAttrs = item.nextAttrs;
    if (isPointsMarkType(markType) && items && items.length && isNil_default(null === (_a = item.nextAttrs) || void 0 === _a ? void 0 : _a.points) && (true === computePoints || isValidPointsChannel(Object.keys(item.nextAttrs), this.mark.markType))) {
      const markSpec = this.mark.getSpec(), lastPoints = this.getGraphicAttribute("points", false), lastSegments = this.getGraphicAttribute("segments", false), enableSegments = markSpec.enableSegments, connectNullsEncoder = null === (_b = this.mark.getSpec().encode) || void 0 === _b ? void 0 : _b[BuiltInEncodeNames.connectNulls], itemNextAttrs = items.map((item2) => item2.nextAttrs), isProgressive = this.mark.isProgressive();
      if (nextAttrs = parseCollectionMarkAttributes(nextAttrs), markType === GrammarMarkType.line || markType === GrammarMarkType.area) {
        const linePoints = getLinePoints(items, true, lastPoints, markType === GrammarMarkType.area);
        if (isProgressive)
          nextAttrs.segments = (null !== (_e = null === (_d = null === (_c = this.graphicItem) || void 0 === _c ? void 0 : _c.attribute) || void 0 === _d ? void 0 : _d.segments) && void 0 !== _e ? _e : []).concat([{
            points: linePoints
          }]);
        else if (connectNullsEncoder) {
          if (nextAttrs.segments = getConnectLineSegmentConfigs(itemNextAttrs, linePoints, this), nextAttrs.segments && nextAttrs.segments.some((seg) => seg.isConnect)) {
            const connectStyle = invokeEncoder(connectNullsEncoder, this.getDatum(), this, this.mark.parameters());
            connectStyle && nextAttrs.segments.forEach((seg) => {
              seg.isConnect && Object.assign(seg, connectStyle);
            });
          }
          nextAttrs.points = linePoints;
        } else if (enableSegments) {
          const points = linePoints && 0 !== linePoints.length ? linePoints : getLinePointsFromSegments(lastSegments), segments2 = getLineSegmentConfigs(itemNextAttrs, points, this);
          segments2 ? (nextAttrs.segments = segments2, nextAttrs.points = null) : (nextAttrs.segments = null, nextAttrs.points = points);
        } else
          nextAttrs.points = linePoints, nextAttrs.segments = null;
      } else
        markType === GrammarMarkType.largeRects ? nextAttrs.points = getLargeRectsPoints(items, true, lastPoints) : markType === GrammarMarkType.largeSymbols && (nextAttrs.points = getLargeSymbolsPoints(items, true, lastPoints));
    }
    return nextAttrs;
  }
  applyGraphicAttributes(graphicAttributes) {
    var _a, _b;
    if (!isEmpty_default(graphicAttributes))
      if (this.mark.needAnimate()) {
        const nextGraphicAttributes = this.diffAttributes(graphicAttributes), prevGraphicAttributes = null !== (_a = this.getPrevGraphicAttributes()) && void 0 !== _a ? _a : {}, finalGraphicAttributes = null !== (_b = this.getFinalGraphicAttributes()) && void 0 !== _b ? _b : {};
        Object.keys(nextGraphicAttributes).forEach((channel) => {
          prevGraphicAttributes[channel] = this.getGraphicAttribute(channel), finalGraphicAttributes[channel] = nextGraphicAttributes[channel];
        }), this.setNextGraphicAttributes(nextGraphicAttributes), this.setPrevGraphicAttributes(prevGraphicAttributes), this.setFinalGraphicAttributes(finalGraphicAttributes);
        const animateGraphicAttributes = this.mark.animate.getElementAnimators(this).reduce((attributes, animator) => Object.assign(attributes, animator.getEndAttributes()), {}), currentGraphicAttributes = Object.assign({}, animateGraphicAttributes, finalGraphicAttributes);
        this.graphicItem.setAttributes(currentGraphicAttributes);
      } else
        this.graphicItem.setAttributes(graphicAttributes);
  }
  getGraphicAttribute(channel, prev = false) {
    var _a;
    if (!this.graphicItem)
      return;
    if (prev) {
      let value;
      const prevGraphicAttributes = this.getPrevGraphicAttributes();
      if (!isNil_default(value = get_default(prevGraphicAttributes, channel)))
        return value;
    }
    const trans = this.mark.getAttributeTransforms();
    let getKey = [channel];
    if (trans && trans.length) {
      const channelTransform = trans.find((entry) => entry.storedAttrs && entry.channels.includes(channel));
      channelTransform && (getKey = [channelTransform.storedAttrs, channel]);
    }
    return get_default(null === (_a = this.graphicItem) || void 0 === _a ? void 0 : _a.attribute, getKey);
  }
  setGraphicAttribute(channel, value, final = true) {
    if (!this.graphicItem)
      return;
    const finalGraphicAttributes = this.getFinalGraphicAttributes(), prevGraphicAttributes = this.getPrevGraphicAttributes();
    final && finalGraphicAttributes && (finalGraphicAttributes[channel] = value), prevGraphicAttributes && !has_default(prevGraphicAttributes, channel) && (prevGraphicAttributes[channel] = this.graphicItem.attribute[channel]), this.graphicItem.setAttribute(channel, value);
  }
  setGraphicAttributes(attributes, final = true) {
    if (!this.graphicItem)
      return;
    const finalGraphicAttributes = this.getFinalGraphicAttributes(), prevGraphicAttributes = this.getPrevGraphicAttributes();
    Object.keys(attributes).forEach((key) => {
      finalGraphicAttributes && final && (finalGraphicAttributes[key] = attributes[key]), prevGraphicAttributes && !has_default(prevGraphicAttributes, key) && (prevGraphicAttributes[key] = this.graphicItem.attribute[key]);
    }), this.graphicItem.setAttributes(attributes);
  }
  getFinalGraphicAttributes() {
    return this.graphicItem.finalAttrs;
  }
  setFinalGraphicAttributes(attributes) {
    this.graphicItem.finalAttrs = attributes;
  }
  getPrevGraphicAttributes() {
    return this.graphicItem.prevAttrs;
  }
  setPrevGraphicAttributes(attributes) {
    this.graphicItem.prevAttrs = attributes;
  }
  getNextGraphicAttributes() {
    return this.graphicItem.nextAttrs;
  }
  setNextGraphicAttributes(attributes) {
    this.graphicItem.nextAttrs = attributes;
  }
  clearChangedGraphicAttributes() {
    this.graphicItem && (this.setPrevGraphicAttributes(null), this.setNextGraphicAttributes(null));
  }
  clearGraphicAttributes() {
    this.graphicItem && (this.graphicItem.prevAttrs && this.setPrevGraphicAttributes(null), this.graphicItem.nextAttrs && this.setNextGraphicAttributes(null), this.graphicItem.finalAttrs && this.setFinalGraphicAttributes(null));
  }
  remove() {
    this.graphicItem && (removeGraphicItem(this.graphicItem), this.graphicItem = null);
  }
  release() {
    this.removeGraphicItem(), this.mark = null, this.data = null, this.items = null;
  }
  getItemAttribute(channel) {
    var _a, _b;
    if (null === (_a = this.items) || void 0 === _a ? void 0 : _a.length)
      return this.mark.isCollectionMark() ? isNil_default(channel) ? this.items.map((item) => item.nextAttrs) : this.items.map((item) => {
        var _a2;
        return null === (_a2 = item.nextAttrs) || void 0 === _a2 ? void 0 : _a2[channel];
      }) : isNil_default(channel) ? this.items[0].nextAttrs : null === (_b = this.items[0].nextAttrs) || void 0 === _b ? void 0 : _b[channel];
  }
  setItemAttributes(attributes) {
    var _a;
    (null === (_a = this.items) || void 0 === _a ? void 0 : _a.length) && (this.mark.isCollectionMark() ? isArray_default(attributes) && this.items.forEach((item, index) => {
      Object.assign(item.nextAttrs, attributes[index]);
    }) : Object.assign(this.items[0].nextAttrs, attributes));
  }
  getItem() {
    var _a, _b;
    return this.mark && this.mark.isCollectionMark() ? null !== (_a = this.items) && void 0 !== _a ? _a : [] : null === (_b = this.items) || void 0 === _b ? void 0 : _b[0];
  }
  getDatum() {
    var _a, _b;
    return this.mark && this.mark.isCollectionMark() ? null !== (_a = this.data) && void 0 !== _a ? _a : [] : null === (_b = this.data) || void 0 === _b ? void 0 : _b[0];
  }
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/interactions/base
var BaseInteraction = class {
  constructor(view, options) {
    this.references = /* @__PURE__ */ new Map(), this.view = view, this.depend(null == options ? void 0 : options.dependency);
  }
  getStartState() {
    return null;
  }
  depend(grammar) {
    this.references.clear(), array(grammar).map((grammar2) => isString_default(grammar2) ? this.view.getGrammarById(grammar2) : grammar2).filter((ref) => !isNil_default(ref)).forEach((ref) => {
      var _a;
      this.references.set(ref, (null !== (_a = this.references.get(ref)) && void 0 !== _a ? _a : 0) + 1);
    });
  }
  parameters() {
    const params2 = {};
    return this.references.forEach((count, ref) => {
      isValid_default(ref.id()) && (params2[ref.id()] = ref.output());
    }), params2;
  }
  bind() {
    const events = this.getEvents();
    (null != events ? events : []).forEach((evt) => {
      evt.type && evt.handler && (isArray_default(evt.type) ? evt.type.forEach((evtType) => {
        evtType && "none" !== evtType && this.view.addEventListener(evtType, evt.handler);
      }) : "none" !== evt.type && this.view.addEventListener(evt.type, evt.handler));
    });
  }
  unbind() {
    const events = this.getEvents();
    (null != events ? events : []).forEach((evt) => {
      evt.type && evt.handler && (isArray_default(evt.type) ? evt.type.forEach((evtType) => {
        evtType && "none" !== evtType && this.view.removeEventListener(evtType, evt.handler);
      }) : "none" !== evt.type && this.view.removeEventListener(evt.type, evt.handler));
    });
  }
  start(element) {
  }
  reset(element) {
  }
  dispatchEvent(type, params2) {
    this.view.emit(`${this.type}:${type}`, params2), "start" === type && this.options.onStart ? this.options.onStart(params2) : "reset" === type && this.options.onReset ? this.options.onReset(params2) : "update" === type && this.options.onUpdate ? this.options.onUpdate(params2) : "end" === type && this.options.onEnd && this.options.onEnd(params2);
  }
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/interactions/element-active
var ElementActive = class _ElementActive extends BaseInteraction {
  constructor(view, options) {
    super(view, options), this.type = _ElementActive.type, this.handleStart = (e) => {
      this.start(e.element);
    }, this.handleReset = (e) => {
      this.reset(e.element);
    }, this.options = Object.assign({}, _ElementActive.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.selector);
  }
  getEvents() {
    return [{
      type: this.options.trigger,
      handler: this.handleStart
    }, {
      type: this.options.triggerOff,
      handler: this.handleReset
    }];
  }
  getStartState() {
    return this.options.state;
  }
  start(element) {
    element && this._marks && this._marks.includes(element.mark) && element.addState(this.options.state);
  }
  reset(element) {
    element && this._marks && this._marks.includes(element.mark) && element.removeState(this.options.state);
  }
};
ElementActive.type = "element-active", ElementActive.defaultOptions = {
  state: InteractionStateEnum.active,
  trigger: "pointerover",
  triggerOff: "pointerout"
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/interactions/utils
var generateFilterValue = (options) => options.filterField ? (el) => {
  var _a;
  return null === (_a = el.getDatum()) || void 0 === _a ? void 0 : _a[options.filterField];
} : (el) => el[options.filterType];
var groupMarksByState = (marks, states) => {
  if (!states || !marks)
    return null;
  const res = {};
  return marks.forEach((mark) => {
    const markSpec = mark && mark.getSpec(), encode = markSpec && markSpec.encode;
    encode && states.forEach((state) => {
      state && encode[state] && (res[state] || (res[state] = []), res[state].push(mark));
    });
  }), res;
};
var parseTriggerOffOfSelect = (triggerOff) => {
  const triggerOffArray = array(triggerOff), resetType = [], eventNames = [];
  return triggerOffArray.forEach((off) => {
    "empty" === off ? resetType.push("view") : isString_default(off) && "none" !== off ? off.includes("view:") ? (eventNames.push(off.replace("view:", "")), resetType.push("view")) : (eventNames.push(off), resetType.push("self")) : isNumber_default(off) && resetType.push("timeout");
  }), {
    eventNames,
    resetType
  };
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/interactions/element-select
var ElementSelect = class _ElementSelect extends BaseInteraction {
  constructor(view, options) {
    super(view, options), this.type = _ElementSelect.type, this._resetType = [], this.clearPrevElements = () => {
      const { state, reverseState } = this.options;
      this._statedElements && this._statedElements.length && (this.clearAllStates(state, reverseState), this.dispatchEvent("reset", {
        elements: this._statedElements,
        options: this.options
      }), this._statedElements = []);
    }, this.handleStart = (e) => {
      this.start(e.element);
    }, this.handleReset = (e) => {
      this.reset(e.element);
    }, this.options = Object.assign({}, _ElementSelect.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.selector), this._stateMarks = groupMarksByState(this._marks, [this.options.state, this.options.reverseState]);
  }
  getStartState() {
    return this.options.state;
  }
  getEvents() {
    const triggerOff = this.options.triggerOff, trigger = this.options.trigger, events = [{
      type: trigger,
      handler: this.handleStart
    }], { eventNames, resetType } = parseTriggerOffOfSelect(triggerOff);
    return eventNames.forEach((evt) => {
      evt && (isArray_default(trigger) ? !trigger.includes(evt) : evt !== trigger) && events.push({
        type: evt,
        handler: this.handleReset
      });
    }), this._resetType = resetType, events;
  }
  start(element) {
    const { state, reverseState, isMultiple } = this.options;
    if (element && this._marks && this._marks.includes(element.mark))
      if (element.hasState(state)) {
        if (this._resetType.includes("self")) {
          const newStatedElements = this._statedElements && this._statedElements.filter((el) => el !== element);
          newStatedElements && newStatedElements.length ? this._statedElements = this.updateStates(newStatedElements, this._statedElements, state, reverseState) : this.clearPrevElements();
        }
      } else
        this._timer && clearTimeout(this._timer), element.addState(state), this._statedElements = this.updateStates(isMultiple && this._statedElements ? [...this._statedElements, element] : [element], this._statedElements, state, reverseState), this.dispatchEvent("start", {
          elements: this._statedElements,
          options: this.options
        }), this._resetType.includes("timeout") && (this._timer = setTimeout(() => {
          this.clearPrevElements();
        }, this.options.triggerOff));
    else
      this._resetType.includes("view") && this._statedElements && this._statedElements.length && this.clearPrevElements();
  }
  reset(element) {
    if (!this._statedElements || !this._statedElements.length)
      return;
    const hasActiveElement = element && this._marks && this._marks.includes(element.mark);
    (this._resetType.includes("view") && !hasActiveElement || this._resetType.includes("self") && hasActiveElement) && this.clearPrevElements();
  }
};
ElementSelect.type = "element-select", ElementSelect.defaultOptions = {
  state: InteractionStateEnum.selected,
  trigger: "click"
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/interactions/element-highlight
var ElementHighlight = class _ElementHighlight extends BaseInteraction {
  constructor(view, options) {
    super(view, options), this.type = _ElementHighlight.type, this.handleStart = (e) => {
      this.start(e.element);
    }, this.handleReset = (e) => {
      this.reset(e.element);
    }, this.options = Object.assign({}, _ElementHighlight.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.selector), this._stateMarks = groupMarksByState(this._marks, [this.options.highlightState, this.options.blurState]);
  }
  getStartState() {
    return this.options.highlightState;
  }
  getEvents() {
    const triggerOff = this.options.triggerOff, events = [{
      type: this.options.trigger,
      handler: this.handleStart
    }];
    let eventName = triggerOff;
    return isString_default(triggerOff) && triggerOff.includes("view:") ? (eventName = triggerOff.replace("view:", ""), this._resetType = "view") : this._resetType = "self", events.push({
      type: eventName,
      handler: this.handleReset
    }), events;
  }
  clearPrevElements() {
    const { highlightState, blurState } = this.options;
    this._lastElement && (this.clearAllStates(highlightState, blurState), this.dispatchEvent("reset", {
      elements: [this._lastElement],
      options: this.options
    }), this._lastElement = null, this._statedElements = null);
  }
  start(element) {
    if (element && this._marks && this._marks.includes(element.mark)) {
      const { highlightState, blurState } = this.options;
      if (this._lastElement === element)
        return;
      this._statedElements = this.updateStates([element], this._statedElements, highlightState, blurState), this._lastElement = element, this.dispatchEvent("start", {
        elements: [element],
        options: this.options
      });
    } else
      this._lastElement && "view" === this._resetType && this.clearPrevElements();
  }
  reset(element) {
    if (!this._statedElements || !this._statedElements.length)
      return;
    const hasActiveElement = element && this._marks && this._marks.includes(element.mark);
    "view" !== this._resetType || hasActiveElement ? "self" === this._resetType && hasActiveElement && this.clearPrevElements() : this.clearPrevElements();
  }
};
ElementHighlight.type = "element-highlight", ElementHighlight.defaultOptions = {
  highlightState: InteractionStateEnum.highlight,
  blurState: InteractionStateEnum.blur,
  trigger: "pointerover",
  triggerOff: "pointerout"
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/interactions/element-highlight-by-key
var ElementHighlightByKey = class _ElementHighlightByKey extends BaseInteraction {
  constructor(view, options) {
    super(view, options), this.type = _ElementHighlightByKey.type, this.handleStart = (e) => {
      this.start(e.element);
    }, this.handleReset = (e) => {
      e.element && this._marks && this._marks.includes(e.element.mark) && this.clearPrevElements();
    }, this.options = Object.assign({}, _ElementHighlightByKey.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.selector);
  }
  getStartState() {
    return this.options.highlightState;
  }
  getEvents() {
    return [{
      type: this.options.trigger,
      handler: this.handleStart
    }, {
      type: this.options.triggerOff,
      handler: this.handleReset
    }];
  }
  clearPrevElements() {
    const states = [this.options.highlightState, this.options.blurState];
    this._marks.forEach((mark) => {
      mark.elements.forEach((el) => {
        el.removeState(states);
      });
    });
  }
  start(element) {
    if (element && this._marks && this._marks.includes(element.mark)) {
      const highlightKey = element.key;
      if (isNil_default(highlightKey))
        return;
      this._marks.forEach((mark) => {
        mark.elements.forEach((el) => {
          el.key === highlightKey ? el.updateStates({
            [this.options.blurState]: false,
            [this.options.highlightState]: true
          }) : el.updateStates({
            [this.options.blurState]: true,
            [this.options.highlightState]: false
          });
        });
      });
    }
  }
  reset(element) {
    if (element && this._marks && this._marks.includes(element.mark)) {
      const highlightKey = element.key;
      if (isNil_default(highlightKey))
        return;
      this._marks.forEach((mark) => {
        mark.elements.forEach((el) => {
          el.key === highlightKey ? el.updateStates({
            [this.options.blurState]: false,
            [this.options.highlightState]: true
          }) : el.updateStates({
            [this.options.blurState]: true,
            [this.options.highlightState]: false
          });
        });
      });
    }
  }
};
ElementHighlightByKey.type = "element-highlight-by-key", ElementHighlightByKey.defaultOptions = {
  highlightState: InteractionStateEnum.highlight,
  blurState: InteractionStateEnum.blur,
  trigger: "pointerover",
  triggerOff: "pointerout"
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/interactions/element-highlight-by-group
var ElementHighlightByGroup = class _ElementHighlightByGroup extends BaseInteraction {
  constructor(view, options) {
    super(view, options), this.type = _ElementHighlightByGroup.type, this.handleStart = (e) => {
      this.start(e.element);
    }, this.handleReset = (e) => {
      this.reset(e.element);
    }, this.options = Object.assign({}, _ElementHighlightByGroup.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.selector);
  }
  getStartState() {
    return this.options.highlightState;
  }
  getEvents() {
    return [{
      type: this.options.trigger,
      handler: this.handleStart
    }, {
      type: this.options.triggerOff,
      handler: this.handleReset
    }];
  }
  clearPrevElements() {
    const states = [this.options.highlightState, this.options.blurState];
    this._marks.forEach((mark) => {
      mark.elements.forEach((el) => {
        el.removeState(states);
      });
    });
  }
  start(element) {
    if (element && this._marks && this._marks.includes(element.mark)) {
      const highlightKey = element.groupKey;
      if (isNil_default(highlightKey))
        return;
      this._marks.forEach((mark) => {
        mark.elements.forEach((el) => {
          el.groupKey === highlightKey ? el.updateStates({
            [this.options.blurState]: false,
            [this.options.highlightState]: true
          }) : el.updateStates({
            [this.options.blurState]: true,
            [this.options.highlightState]: false
          });
        });
      });
    }
  }
  reset(element) {
    element && this._marks && this._marks.includes(element.mark) && this.clearPrevElements();
  }
};
ElementHighlightByGroup.type = "element-highlight-by-group", ElementHighlightByGroup.defaultOptions = {
  highlightState: InteractionStateEnum.highlight,
  blurState: InteractionStateEnum.blur,
  trigger: "pointerover",
  triggerOff: "pointerout"
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/interactions/element-active-by-legend
var ElementActiveByLegend = class _ElementActiveByLegend extends BaseInteraction {
  constructor(view, options) {
    super(view, options), this.type = _ElementActiveByLegend.type, this.handleStart = (e) => {
      var _a, _b;
      this.start(null === (_b = null === (_a = e.detail) || void 0 === _a ? void 0 : _a.data) || void 0 === _b ? void 0 : _b.id);
    }, this.handleReset = (e) => {
      this.reset();
    }, this.options = Object.assign({}, _ElementActiveByLegend.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.selector);
  }
  getEvents() {
    return [{
      type: LegendEvent.legendItemHover,
      handler: this.handleStart
    }, {
      type: LegendEvent.legendItemUnHover,
      handler: this.handleReset
    }];
  }
  getStartState() {
    return this.options.state;
  }
  start(element) {
    const itemKey = element;
    if (isNil_default(itemKey))
      return;
    const filterValue = generateFilterValue(this.options);
    this._marks.forEach((mark) => {
      mark.elements.forEach((el) => {
        filterValue(el) === itemKey ? el.addState(this.options.state) : el.removeState(this.options.state);
      });
    });
  }
  reset() {
    this._marks.forEach((mark) => {
      mark.elements.forEach((el) => {
        el.removeState(this.options.state);
      });
    });
  }
};
ElementActiveByLegend.type = "element-active-by-legend", ElementActiveByLegend.defaultOptions = {
  state: InteractionStateEnum.active,
  filterType: "groupKey"
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/interactions/element-highlight-by-legend
var ElementHighlightByLegend = class _ElementHighlightByLegend extends BaseInteraction {
  constructor(view, options) {
    super(view, options), this.type = _ElementHighlightByLegend.type, this.handleStart = (e, element) => {
      var _a, _b;
      this.start(null === (_b = null === (_a = e.detail) || void 0 === _a ? void 0 : _a.data) || void 0 === _b ? void 0 : _b.id);
    }, this.handleReset = (e) => {
      this.reset();
    }, this.options = Object.assign({}, _ElementHighlightByLegend.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.selector);
  }
  getStartState() {
    return this.options.highlightState;
  }
  getEvents() {
    return [{
      type: LegendEvent.legendItemHover,
      handler: this.handleStart
    }, {
      type: LegendEvent.legendItemUnHover,
      handler: this.handleReset
    }];
  }
  start(itemKey) {
    if (isNil_default(itemKey))
      return;
    const filterValue = generateFilterValue(this.options);
    this._marks.forEach((mark) => {
      mark.elements.forEach((el) => {
        filterValue(el) === itemKey ? el.updateStates({
          [this.options.blurState]: false,
          [this.options.highlightState]: true
        }) : el.updateStates({
          [this.options.blurState]: true,
          [this.options.highlightState]: false
        });
      });
    });
  }
  reset() {
    const states = [this.options.blurState, this.options.highlightState];
    this._marks.forEach((mark) => {
      mark.elements.forEach((el) => {
        el.removeState(states);
      });
    });
  }
};
ElementHighlightByLegend.type = "element-highlight-by-legend", ElementHighlightByLegend.defaultOptions = {
  highlightState: InteractionStateEnum.highlight,
  blurState: InteractionStateEnum.blur,
  filterType: "groupKey"
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/interactions/element-highlight-by-name
var ElementHighlightByName = class _ElementHighlightByName extends BaseInteraction {
  constructor(view, options) {
    super(view, options), this.type = _ElementHighlightByName.type, this.handleStart = (e, element) => {
      if (this.options.shouldStart ? this.options.shouldStart(e) : this._filterByName(e)) {
        const itemKey = this._parseTargetKey(e, element);
        this.start(itemKey);
      }
    }, this.handleReset = (e) => {
      (this.options.shouldReset ? this.options.shouldReset(e) : this._filterByName(e)) && this.reset();
    }, this.options = Object.assign({}, _ElementHighlightByName.defaultOptions, options), this._marks = view.getMarksBySelector(this.options.selector);
  }
  getStartState() {
    return this.options.highlightState;
  }
  getEvents() {
    return [{
      type: this.options.trigger,
      handler: this.handleStart
    }, {
      type: this.options.triggerOff,
      handler: this.handleReset
    }];
  }
  _filterByName(e) {
    var _a;
    const names = array(this.options.graphicName);
    return (null === (_a = null == e ? void 0 : e.target) || void 0 === _a ? void 0 : _a.name) && names.includes(e.target.name);
  }
  _parseTargetKey(e, element) {
    return this.options.parseData ? this.options.parseData(e) : "text" === e.target.type ? e.target.attribute.text : null;
  }
  start(itemKey) {
    if (isNil_default(itemKey))
      return;
    const filterValue = generateFilterValue(this.options);
    this._marks.forEach((mark) => {
      mark.elements.forEach((el) => {
        filterValue(el) === itemKey ? el.updateStates({
          [this.options.blurState]: false,
          [this.options.highlightState]: true
        }) : el.updateStates({
          [this.options.blurState]: true,
          [this.options.highlightState]: false
        });
      });
    });
  }
  reset() {
    const states = [this.options.blurState, this.options.highlightState];
    this._marks.forEach((mark) => {
      mark.elements.forEach((el) => {
        el.removeState(states);
      });
    });
  }
};
ElementHighlightByName.type = "element-highlight-by-name", ElementHighlightByName.defaultOptions = {
  trigger: "pointerover",
  triggerOff: "pointerout",
  highlightState: InteractionStateEnum.highlight,
  blurState: InteractionStateEnum.blur,
  filterType: "groupKey"
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/interactions/toggle-state-mixin
var ToggleStateMixin = class {
  updateStates(newStatedElements, prevStatedElements, state, reverseState) {
    return newStatedElements && newStatedElements.length ? (state && reverseState ? prevStatedElements && prevStatedElements.length ? (this.toggleReverseStateOfElements(newStatedElements, prevStatedElements, reverseState), this.toggleStateOfElements(newStatedElements, prevStatedElements, state)) : this.addBothStateOfElements(newStatedElements, state, reverseState) : state && (prevStatedElements && prevStatedElements.length ? this.toggleStateOfElements(newStatedElements, prevStatedElements, state) : this.addStateOfElements(newStatedElements, state)), newStatedElements) : null;
  }
  toggleReverseStateOfElements(newStatedElements, prevStatedElements, reverseState) {
    prevStatedElements.forEach((element) => {
      reverseState && this._stateMarks[reverseState] && this._stateMarks[reverseState].includes(element.mark) && element.addState(reverseState);
    }), newStatedElements.forEach((element) => {
      reverseState && this._stateMarks[reverseState] && this._stateMarks[reverseState].includes(element.mark) && element.removeState(reverseState);
    });
  }
  toggleStateOfElements(newStatedElements, prevStatedElements, state) {
    prevStatedElements.forEach((element) => {
      state && this._stateMarks[state] && this._stateMarks[state].includes(element.mark) && element.removeState(state);
    }), newStatedElements.forEach((element) => {
      state && this._stateMarks[state] && this._stateMarks[state].includes(element.mark) && element.addState(state);
    });
  }
  addBothStateOfElements(statedElements, state, reverseState) {
    this._marks.forEach((mark) => {
      const hasReverse = reverseState && this._stateMarks[reverseState] && this._stateMarks[reverseState].includes(mark), hasState = state && this._stateMarks[state] && this._stateMarks[state].includes(mark);
      (hasReverse || hasState) && mark.elements.forEach((el) => {
        statedElements && statedElements.includes(el) ? hasState && el.addState(state) : hasReverse && el.addState(reverseState);
      });
    });
  }
  addStateOfElements(statedElements, state) {
    this._marks.forEach((mark) => {
      const hasState = state && this._stateMarks[state] && this._stateMarks[state].includes(mark);
      hasState && mark.elements.forEach((el) => {
        statedElements && statedElements.includes(el) && hasState && el.addState(state);
      });
    });
  }
  clearAllStates(state, reverseState) {
    this._statedElements && this._statedElements.length && this._marks.forEach((mark) => {
      reverseState && this._stateMarks[reverseState] && this._stateMarks[reverseState].includes(mark) && mark.elements.forEach((el) => {
        el.removeState(reverseState);
      }), state && this._stateMarks[state] && this._stateMarks[state].includes(mark) && mark.elements.forEach((el) => {
        this._statedElements.includes(el) && el.removeState(state);
      });
    });
  }
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/interactions
var registerElementActive = () => {
  Factory.registerInteraction(ElementActive.type, ElementActive);
};
var registerElementSelect = () => {
  mixin(ElementSelect, ToggleStateMixin), Factory.registerInteraction(ElementSelect.type, ElementSelect);
};
var registerElementHighlight = () => {
  mixin(ElementHighlight, ToggleStateMixin), Factory.registerInteraction(ElementHighlight.type, ElementHighlight);
};
var registerElementHighlightByKey = () => {
  Factory.registerInteraction(ElementHighlightByKey.type, ElementHighlightByKey);
};
var registerElementHighlightByGroup = () => {
  Factory.registerInteraction(ElementHighlightByGroup.type, ElementHighlightByGroup);
};
var registerElementActiveByLegend = () => {
  Factory.registerInteraction(ElementActiveByLegend.type, ElementActiveByLegend);
};
var registerElementHighlightByLegend = () => {
  Factory.registerInteraction(ElementHighlightByLegend.type, ElementHighlightByLegend);
};
var registerElementHighlightByName = () => {
  Factory.registerInteraction(ElementHighlightByName.type, ElementHighlightByName);
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/parse/option
var parseOptionValue = (value, params2) => isGrammar(value) ? value.output() : value && isObject_default(value) ? isFunction_default(value.callback) ? (datum) => value.callback(datum, params2) : isFunction_default(value.value) ? value.value(params2) : value : value;
var parseOptions = (options, params2) => options ? isObject_default(options) ? Object.keys(options).reduce((res, key) => {
  const option = options[key];
  return res[key] = parseOptionValue(option, params2), res;
}, {}) : options.map((option) => parseOptionValue(option, params2)) : options;

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/view/grammar-base
var grammarBaseId = -1;
var GrammarBase = class extends import_eventemitter3.default {
  constructor(view) {
    super(), this.spec = {}, this.references = /* @__PURE__ */ new Map(), this.targets = [], this.transforms = [], this.view = view, this.uid = ++grammarBaseId;
  }
  parse(spec) {
    return this.id(spec.id), this.name(spec.name), this.depend(spec.dependency), this;
  }
  depend(grammars) {
    var _a;
    if (null === (_a = this.spec) || void 0 === _a ? void 0 : _a.dependency) {
      const lastGrammars = array(this.spec.dependency).map((grammar) => isString_default(grammar) ? this.view.getGrammarById(grammar) : grammar);
      this.detach(lastGrammars);
    }
    this.spec.dependency = grammars;
    const currentGrammars = array(grammars).map((grammar) => isString_default(grammar) ? this.view.getGrammarById(grammar) : grammar);
    return this.attach(currentGrammars), this.commit(), this;
  }
  addEventListener(type, handler, options) {
    let callback = handler;
    return options && false === options.trap || (callback = handler, callback.raw = handler), options && options.target && (callback.target = options.target), this.on(type, callback), this;
  }
  removeEventListener(type, handler) {
    return handler ? this.off(type, handler) : this.off(type), this;
  }
  emit(event, ...args) {
    var _a, _b;
    return null === (_b = null === (_a = this.view) || void 0 === _a ? void 0 : _a.emit) || void 0 === _b || _b.call(_a, event, ...args), super.emit(event, ...args);
  }
  emitGrammarEvent(event, ...args) {
    return super.emit(event, ...args);
  }
  evaluateTransform(transforms, upstream, parameters) {
    if (!transforms || !transforms.length)
      return upstream;
    let currentUpstreamData = upstream, i = 0;
    const n = transforms.length;
    for (; i < n; ) {
      const task = transforms[i];
      this.emit(HOOK_EVENT.BEFORE_TRANSFORM, task.type), currentUpstreamData = task.transform(task.isRawOptions ? task.options : parseOptions(task.options, parameters), currentUpstreamData, parameters, this.view), i++, this.emit(HOOK_EVENT.AFTER_TRANSFORM, task.type);
    }
    return currentUpstreamData;
  }
  set(value) {
    return false;
  }
  id(id2) {
    return arguments.length ? (this.view.grammars.unrecord(this), this._id = id2, this.view.grammars.record(this), this) : this._id;
  }
  name(name) {
    return arguments.length ? (this._name = name, this) : this._name;
  }
  attach(reference, count = 1) {
    return array(reference).filter((ref) => !isNil_default(ref)).forEach((ref) => {
      var _a;
      isNil_default(reference) || (ref.targets.includes(this) || ref.targets.push(this), this.references.set(ref, (null !== (_a = this.references.get(ref)) && void 0 !== _a ? _a : 0) + count));
    }), this;
  }
  detach(reference, count = 1) {
    return array(reference).filter((ref) => !isNil_default(ref)).forEach((ref) => {
      const refCount = this.references.get(ref) - count;
      refCount > 0 ? this.references.set(ref, refCount - 1) : (this.references.delete(ref), ref.targets.includes(this) && (ref.targets = ref.targets.filter((target) => target !== this)));
    }), this;
  }
  detachAll() {
    this.references.forEach((count, ref) => {
      this.detach(ref, count);
    });
  }
  link(source) {
    this.grammarSource = source;
  }
  run() {
    var _a;
    const upstream = null === (_a = this.grammarSource) || void 0 === _a ? void 0 : _a.output(), parameters = this.parameters();
    return this.evaluate(upstream, parameters);
  }
  commit() {
    this.view.commit(this);
  }
  parameters() {
    const params2 = {};
    return this.references.forEach((count, ref) => {
      isValid_default(ref.id()) && (params2[ref.id()] = ref.output());
    }), params2;
  }
  getSpec() {
    return this.spec;
  }
  reuse(grammar) {
    return this;
  }
  clear() {
    this.spec = null, this.view = null;
  }
  release() {
    this.clear();
  }
  setFunctionSpec(spec, specField) {
    return isNil_default(this.spec[specField]) || this.detach(parseFunctionType(this.spec[specField], this.view)), this.spec[specField] = spec, this.attach(parseFunctionType(spec, this.view)), this.commit(), this;
  }
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/parse/transform
var parseSimpleOptionValue = (key, transformSpecValue, view) => {
  var _a;
  if ("callback" === key && isFunction_default(transformSpecValue))
    return {
      references: [],
      value: {
        callback: transformSpecValue,
        dependency: []
      }
    };
  if (!isNil_default(transformSpecValue.data)) {
    const grammarInstance = view.getDataById(transformSpecValue.data);
    return {
      references: [grammarInstance],
      value: grammarInstance
    };
  }
  if (!isNil_default(transformSpecValue.customized)) {
    const grammarInstance = view.getCustomizedById(transformSpecValue.customized);
    return {
      references: [grammarInstance],
      value: grammarInstance
    };
  }
  if (!isNil_default(transformSpecValue.scale)) {
    const grammarInstance = view.getScaleById(transformSpecValue.scale);
    return {
      references: [grammarInstance],
      value: grammarInstance
    };
  }
  if (isSignal(transformSpecValue)) {
    const references = parseFunctionType(transformSpecValue, view);
    return {
      references,
      value: transformSpecValue.callback ? {
        value: transformSpecValue.callback,
        dependency: references
      } : null !== (_a = null == references ? void 0 : references[0]) && void 0 !== _a ? _a : transformSpecValue
    };
  }
  return {
    value: transformSpecValue
  };
};
var parseTransformOption = (key, transformSpecValue, view) => {
  if (isNil_default(transformSpecValue))
    return {
      value: transformSpecValue
    };
  if (isArray_default(transformSpecValue)) {
    const values = transformSpecValue.map((v) => parseSimpleOptionValue(key, v, view));
    return {
      references: values.reduce((res, val) => (val.references && res.concat(val.references), res), []),
      value: values.map((entry) => entry.value)
    };
  }
  return parseSimpleOptionValue(key, transformSpecValue, view);
};
var parseTransform = (transformSpec, view) => {
  const transformDef = Factory.getTransform(transformSpec.type);
  if (!transformDef)
    return;
  const options = {};
  let references = [];
  return Object.keys(transformSpec).forEach((specKey) => {
    var _a;
    if ("type" === specKey)
      return;
    const specValue = transformSpec[specKey];
    if ("dependency" === specKey)
      return void ((null == specValue ? void 0 : specValue.length) && (references = references.concat(parseReference(specValue, view))));
    const res = parseTransformOption(specKey, specValue, view);
    res && ((null === (_a = res.references) || void 0 === _a ? void 0 : _a.length) && (references = references.concat(res.references)), options[specKey] = res.value);
  }), {
    markPhase: transformDef.markPhase,
    transform: transformDef.transform,
    canProgressive: transformDef.canProgressive,
    type: transformDef.type,
    options,
    references
  };
};
var parseTransformSpec = (spec, view) => {
  if (null == spec ? void 0 : spec.length) {
    const transforms = [];
    let refs = [];
    return spec.forEach((transformSpec) => {
      var _a;
      const transform5 = parseTransform(transformSpec, view);
      transform5 && ((null === (_a = transform5.references) || void 0 === _a ? void 0 : _a.length) && (refs = refs.concat(transform5.references)), transforms.push(transform5));
    }), {
      transforms,
      refs
    };
  }
  return null;
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/util/data
var jsonParser = (data, options = {}, dataView) => {
  if (!isString_default(data))
    return array(data);
  try {
    return array(JSON.parse(data));
  } catch (e) {
    return [];
  }
};
var parsers = {
  csv: csvParser,
  dsv: dsvParser,
  tsv: tsvParser,
  json: jsonParser
};
var parseFormat = (data, format) => {
  if (!format || !parsers[format.type])
    return array(data);
  const options = "dsv" === format.type ? {
    delimiter: format.delimiter
  } : {};
  return parsers[format.type](data, options, new DataView(new DataSet()));
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/view/data
var Data = class extends GrammarBase {
  constructor(view, values, format) {
    super(view), this.grammarType = "data", this.spec = {}, this._dataIDKey = `VGRAMMAR_DATA_ID_KEY_${this.uid}`, this._loadTasks = [], this._postFilters = [], this.ingest = (options) => {
      const format2 = invokeParameterFunctionType(options.format, this.parameters());
      return this._input = parseFormat(options.values, format2), this._input;
    }, this.load = (options) => {
      if (options.values)
        return this.ingest(options);
    }, this.relay = (options) => options[0], this._loadTasks = [], isNil_default(values) || this.values(values, format);
  }
  parse(spec) {
    return super.parse(spec), this._isLoaded = false, this.source(spec.source, spec.format, false), this.url(spec.url, spec.format, false), this.values(spec.values, spec.format, false), this.transform(spec.transform), this.parseLoad(spec), this.commit(), this;
  }
  parseDataSource(spec) {
    const refs = [], transforms = [], formatRef = spec.format ? parseFunctionType(spec.format, this.view)[0] : null;
    if (formatRef && refs.push(formatRef), spec.values) {
      const valuesRef = parseFunctionType(spec.values, this.view)[0];
      valuesRef && refs.push(valuesRef), transforms.push({
        type: "ingest",
        transform: this.ingest,
        isRawOptions: true,
        options: {
          values: spec.values,
          format: spec.format
        }
      });
    } else if (spec.url) {
      const urlRef = parseFunctionType(spec.url, this.view)[0];
      urlRef && refs.push(urlRef), transforms.push({
        type: "load",
        transform: this.load,
        options: {
          url: null != urlRef ? urlRef : spec.url,
          format: null != formatRef ? formatRef : spec.format
        }
      });
    } else if (spec.source) {
      const upstreamData = [];
      array(spec.source).forEach((sourceId) => {
        const sourceData = isGrammar(sourceId) ? sourceId : this.view.getDataById(sourceId);
        sourceData && (refs.push(sourceData), upstreamData.push(sourceData));
      }), upstreamData.length && (transforms.push({
        type: "relay",
        transform: this.relay,
        options: upstreamData
      }), this.grammarSource = upstreamData[0]);
    }
    return {
      transforms,
      refs
    };
  }
  evaluate(upstream, parameters) {
    this.view.emit(HOOK_EVENT.BEFORE_EVALUATE_DATA);
    const tasks = this._isLoaded ? this.transforms : this._loadTasks.concat(this.transforms);
    this.grammarSource && (this._input = upstream);
    const values = this.evaluateTransform(tasks, this._input, parameters), filteredValues = this._evaluateFilter(values, parameters);
    return this.setValues(filteredValues), this._isLoaded = true, this.view.emit(HOOK_EVENT.AFTER_EVALUATE_DATA), this;
  }
  output() {
    return this._values;
  }
  getDataIDKey() {
    return this._dataIDKey;
  }
  values(values, format, load3 = true) {
    const spec = Object.assign({}, this.spec, {
      values,
      format
    });
    return isNil_default(values) || (spec.url = void 0, spec.source = void 0), load3 ? this.parseLoad(spec) : this;
  }
  url(url, format, load3 = true) {
    const spec = Object.assign({}, this.spec, {
      url,
      format
    });
    return isNil_default(url) || (spec.values = void 0, spec.source = void 0), load3 ? this.parseLoad(spec) : this;
  }
  source(source, format, load3 = true) {
    const spec = Object.assign({}, this.spec, {
      source,
      format
    });
    return isNil_default(source) || (spec.values = void 0, spec.url = void 0), load3 ? this.parseLoad(spec) : this;
  }
  parseLoad(spec) {
    this.detach(this.parseDataSource(this.spec).refs), this.spec = spec;
    const dataSourceResult = this.parseDataSource(this.spec);
    return this.attach(dataSourceResult.refs), this._loadTasks = dataSourceResult.transforms, this._isLoaded = false, this.commit(), this;
  }
  setValues(data) {
    this._values = array(data).map((entry, index) => {
      const datum = entry === Object(entry) ? entry : {
        data: entry
      };
      return datum[this._dataIDKey] = index, datum;
    });
  }
  field(field3) {
    return this._values.map((value) => value[field3]);
  }
  transform(transforms) {
    const prevTransforms = parseTransformSpec(this.spec.transform, this.view);
    prevTransforms && (this.detach(prevTransforms.refs), this.transforms = []), this.spec.transform = transforms;
    const nextTransforms = parseTransformSpec(this.spec.transform, this.view);
    return nextTransforms && (this.attach(nextTransforms.refs), this.transforms = nextTransforms.transforms), this.commit(), this;
  }
  getValue() {
    return this._values;
  }
  getInput() {
    return this._input;
  }
  addDataFilter(filter2) {
    return this._postFilters = this._postFilters.concat(array(filter2)), this._postFilters.sort((filterA, filterB) => {
      var _a, _b;
      return (null !== (_a = filterA.rank) && void 0 !== _a ? _a : 0) - (null !== (_b = filterB.rank) && void 0 !== _b ? _b : 0);
    }), this;
  }
  removeDataFilter(filter2) {
    const filters = array(filter2);
    return this._postFilters = this._postFilters.filter((filter3) => !filters.includes(filter3)), this;
  }
  _evaluateFilter(value, parameters) {
    return this._postFilters.reduce((result2, filter2) => filter2.filter(result2, parameters), value);
  }
  reuse(grammar) {
    return grammar.grammarType !== this.grammarType || (this._isLoaded = false, this._values = grammar.output()), this;
  }
  clear() {
    super.clear(), this._input = null, this._values = null;
  }
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/view/constants
var EVENT_SOURCE_WINDOW = "window";
var EVENT_SOURCE_VIEW = "view";
var BROWSER = "browser";
var NO_TRAP = {
  trap: false
};
var SIGNAL_WIDTH = "width";
var SIGNAL_HEIGHT = "height";
var SIGNAL_VIEW_WIDTH = "viewWidth";
var SIGNAL_VIEW_HEIGHT = "viewHeight";
var SIGNAL_PADDING = "padding";
var SIGNAL_VIEW_BOX = "viewBox";
var SIGNAL_AUTOFIT = "autoFit";

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/view/events
function initializeEventConfig(config2) {
  const eventsConfig = Object.assign({
    defaults: {}
  }, config2), unpack = (obj, keys2) => {
    keys2.forEach((k2) => {
      isArray_default(obj[k2]) && (obj[k2] = obj[k2].reduce((set, key) => (set[key] = true, set), {}));
    });
  };
  return unpack(eventsConfig.defaults, ["prevent", "allow"]), unpack(eventsConfig, [EVENT_SOURCE_VIEW, EVENT_SOURCE_WINDOW]), eventsConfig;
}
function prevent(eventConfig, type) {
  const def = eventConfig.defaults, prevent2 = def.prevent, allow = def.allow;
  return false !== prevent2 && true !== allow && (true === prevent2 || false === allow || (prevent2 ? prevent2[type] : !!allow && !allow[type]));
}
function permit(eventConfig, key, type) {
  const rule = null == eventConfig ? void 0 : eventConfig[key];
  return !(false === rule || isObject_default(rule) && !rule[type]);
}

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/util/grammar-heap
function moveToHead(array3, idx, start, cmp) {
  let parent, pidx;
  const item = array3[idx];
  for (; idx > start && (pidx = Math.floor((idx - 1) / 2), parent = array3[pidx], item && parent && cmp(item, parent) < 0); )
    array3[idx] = parent, idx = pidx;
  return array3[idx] = item;
}
function moveToTail(array3, idx, end, cmp) {
  const start = idx, endIdx = null != end ? end : array3.length, item = array3[idx];
  let ridx, cidx = 2 * idx + 1;
  for (; cidx < endIdx; )
    ridx = cidx + 1, ridx < endIdx && cmp(array3[cidx], array3[ridx]) >= 0 && (cidx = ridx), array3[idx] = array3[cidx], cidx = 2 * (idx = cidx) + 1;
  return array3[idx] = item, moveToHead(array3, idx, start, cmp);
}
var Heap = class {
  constructor(compare) {
    this.compare = compare, this.nodes = [];
  }
  size() {
    return this.nodes.length;
  }
  last() {
    return this.nodes[0];
  }
  validate() {
    for (let i = this.nodes.length - 1; i > 0; i -= 1) {
      const parentIndex = Math.floor((i - 1) / 2);
      if (this.compare(this.nodes[parentIndex], this.nodes[i]) > 0)
        return false;
    }
    return true;
  }
  push(node) {
    if (this.nodes.includes(node)) {
      const index = this.nodes.indexOf(node);
      return moveToHead(this.nodes, index, 0, this.compare), moveToTail(this.nodes, index, null, this.compare);
    }
    return this.nodes.push(node), moveToHead(this.nodes, this.nodes.length - 1, 0, this.compare);
  }
  remove(node) {
    if (this.nodes.includes(node)) {
      const index = this.nodes.indexOf(node);
      this.nodes = this.nodes.slice(0, index).concat(this.nodes.slice(index + 1)), moveToHead(this.nodes, index, 0, this.compare), moveToTail(this.nodes, index, null, this.compare);
    }
  }
  pop() {
    const last2 = this.nodes.pop();
    let item;
    return this.nodes.length ? (item = this.nodes[0], this.nodes[0] = last2, moveToTail(this.nodes, 0, null, this.compare)) : item = last2, item;
  }
  clear() {
    this.nodes = [];
  }
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/util/unique-list
var UniqueList = class {
  constructor(idFunc) {
    this.list = [], this.ids = {}, this.idFunc = idFunc || identity2;
  }
  add(element) {
    const id2 = this.idFunc(element);
    return this.ids[id2] || (this.ids[id2] = 1, this.list.push(element)), this;
  }
  remove(element) {
    const id2 = this.idFunc(element);
    return this.ids[id2] && (this.ids[id2] = 0, this.list = this.list.filter((entry) => entry !== element)), this;
  }
  forEach(callback, reverse) {
    reverse ? this.list.slice().reverse().forEach(callback) : this.list.forEach(callback);
  }
  filter(callback) {
    return this.list.filter(callback);
  }
  get length() {
    return this.list.length;
  }
  getElementByIndex(index) {
    return this.list[index];
  }
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/view/dataflow
var Dataflow = class {
  constructor() {
    this.grammars = [], this.logger = Logger.getInstance(), this._curRank = 0, this._committed = new UniqueList((grammar) => grammar.uid), this._heap = new Heap((a3, b) => (null == a3 ? void 0 : a3.qrank) - (null == b ? void 0 : b.qrank)), this._beforeRunner = null, this._afterRunner = null, this._updateCounter = 0, this._finishFirstRender = false;
  }
  add(grammar) {
    if (grammar)
      return this._setRankOfGrammar(grammar), this.commit(grammar), !this.grammars.includes(grammar) && (this.grammars.push(grammar), true);
  }
  remove(grammar) {
    grammar && (this._committed.remove(grammar), this._heap.remove(grammar), this.grammars = this.grammars.filter((storedGrammar) => storedGrammar !== grammar));
  }
  _setRankOfGrammar(grammar) {
    grammar && (grammar.rank = ++this._curRank);
  }
  _reRank(grammar) {
    const queue = [grammar];
    for (; queue.length; ) {
      const cur = queue.pop();
      this._setRankOfGrammar(cur);
      const list = cur.targets;
      list && list.forEach((entry) => {
        queue.push(entry), entry === grammar && this.logger.error("Cycle detected in dataflow graph.");
      });
    }
  }
  _enqueue(grammar) {
    grammar && (grammar.qrank = grammar.rank, this._heap.push(grammar));
  }
  _logGrammarRunInfo(grammar) {
    if (this.logger.canLogError()) {
      const debugStr = [{
        key: "id",
        value: grammar.id()
      }, {
        key: "name",
        value: grammar.name()
      }].reduce((str, entry, index) => isNil_default(entry.value) ? str : `${str}${index ? " , " : ""}${entry.key}: ${entry.value}`, "");
      this.logger.debug("Run Operator: ", grammar, debugStr);
    }
  }
  hasCommitted() {
    return !!this._committed.length;
  }
  commit(grammar) {
    return this._committed.add(grammar), this;
  }
  _beforeEvaluate() {
    this.grammars.forEach((grammar) => {
      grammar.targets.some((target) => (null == target ? void 0 : target.rank) < (null == grammar ? void 0 : grammar.rank)) && this._reRank(grammar);
    }), this._committed.forEach((grammar) => this._enqueue(grammar)), this._committed = new UniqueList((grammar) => grammar.uid);
  }
  _enqueueTargets(grammar) {
    grammar.targets && grammar.targets.length && this._finishFirstRender && grammar.targets.forEach((target) => this._enqueue(target));
  }
  evaluate() {
    if (this._beforeRunner && this._beforeRunner(this), !this._committed.length)
      return this.logger.info("Dataflow invoked, but nothing to do."), false;
    this._updateCounter += 1;
    let grammar, dt, count = 0;
    for (this.logger.canLogInfo() && (dt = Date.now(), this.logger.debug(`-- START PROPAGATION (${this._updateCounter}) -----`)), this._beforeEvaluate(); this._heap.size() > 0; )
      grammar = this._heap.pop(), grammar && (grammar.rank === grammar.qrank ? (grammar.run(), this._logGrammarRunInfo(grammar), this._enqueueTargets(grammar), count += 1) : this._enqueue(grammar));
    return this.logger.canLogInfo() && (dt = Date.now() - dt, this.logger.info(`> ${count} grammars updated; ${dt} ms`)), this._afterRunner && this._afterRunner(this), this._finishFirstRender = true, true;
  }
  runBefore(callback) {
    this._beforeRunner = callback;
  }
  runAfter(callback) {
    this._afterRunner = callback;
  }
  release() {
    this._heap && (this._heap.clear(), this._heap = null), this.logger = null, this._committed = null;
  }
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/mark-tree
var traverseMarkTree = (rootMark, childrenKey, apply, filter2, leafFirst) => {
  const traverse = (mark) => {
    if (leafFirst || !mark || filter2 && !filter2(mark) || apply.call(null, mark), mark.markType === GrammarMarkType.group) {
      const children = mark[childrenKey];
      children && children.forEach((child) => {
        traverse(child);
      });
    }
    leafFirst && (!mark || filter2 && !filter2(mark) || apply.call(null, mark));
  };
  traverse(rootMark);
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/canvas-renderer
var CanvasRenderer = class {
  constructor(view) {
    this.handleAfterNextRender = () => {
      this._stage && !this._viewOptions.disableDirtyBounds && this._stage.enableDirtyBounds(), this._view.emit(HOOK_EVENT.AFTER_VRENDER_DRAW), this._view.emit(HOOK_EVENT.AFTER_VRENDER_NEXT_RENDER);
    }, this._view = view;
  }
  initialize(width, height, options, eventConfig) {
    return this._width = width, this._height = height, this._viewOptions = options, this._eventConfig = eventConfig, this.initStage(), this;
  }
  stage() {
    var _a;
    return null !== (_a = this._stage) && void 0 !== _a ? _a : null;
  }
  gestureController() {
    var _a;
    return null !== (_a = this._gestureController) && void 0 !== _a ? _a : null;
  }
  canvas() {
    return this._stage ? this._stage.window.getNativeHandler().nativeCanvas : null;
  }
  context() {
    return this._stage ? this._stage.window.getContext().nativeContext : null;
  }
  combineIncrementalLayers() {
    return this._stage && waitForAllSubLayers(this._stage).then(() => {
      this._stage && this._stage.defaultLayer.combineSubLayer();
    }), this;
  }
  background(color) {
    if (this._stage)
      return this._stage.background = color, this;
  }
  setDpr(resolution, redraw) {
    var _a, _b;
    return null === (_b = null === (_a = this._stage) || void 0 === _a ? void 0 : _a.setDpr) || void 0 === _b || _b.call(_a, resolution), redraw && this.renderNextFrame(), this;
  }
  shouldResize(width, height) {
    return width !== this._width || height !== this._height;
  }
  resize(width, height) {
    return this._view.emit(HOOK_EVENT.BEFORE_STAGE_RESIZE), this.shouldResize(width, height) && (this._width = width, this._height = height, this._stage && this._stage.resize(width, height)), this._view.emit(HOOK_EVENT.AFTER_STAGE_RESIZE), this;
  }
  setViewBox(viewBox, rerender = true) {
    return this._stage ? (!viewBox || this._viewBox && viewBox.x1 === this._viewBox.x1 && viewBox.x2 === this._viewBox.x2 && viewBox.y1 === this._viewBox.y1 && viewBox.y2 === this._viewBox.y2 || (this._viewBox = viewBox, this._stage.setViewBox(viewBox.x1, viewBox.y1, viewBox.x2 - viewBox.x1, viewBox.y2 - viewBox.y1, rerender)), this) : this;
  }
  render(immediately = false) {
    return this._view.emit(HOOK_EVENT.BEFORE_VRENDER_DRAW), this.initStage(), this._stage.disableDirtyBounds(), this._stage.afterNextRender(this.handleAfterNextRender), immediately && (this._stage.render(), this._view.emit(HOOK_EVENT.AFTER_VRENDER_DRAW)), this;
  }
  renderNextFrame() {
    return this.initStage(), this._stage.renderNextFrame(), this;
  }
  toCanvas() {
    return this._stage ? this._stage.toCanvas() : null;
  }
  preventRender(tag) {
    this._stage && this._stage.preventRender(tag);
  }
  release() {
    var _a;
    this._view.traverseMarkTree((mark) => {
      mark.release();
    }), this._dragController && this._dragController.release(), this._gestureController && this._gestureController.release(), this._stage !== (null === (_a = this._viewOptions) || void 0 === _a ? void 0 : _a.stage) && this._stage.release(), this._stage = null, this._layer = null, this._dragController = null, this._gestureController = null;
  }
  createStage() {
    var _a, _b, _c, _d, _e;
    this._view.emit(HOOK_EVENT.BEFORE_CREATE_VRENDER_STAGE);
    const viewOptions = this._viewOptions, stage = null !== (_a = viewOptions.stage) && void 0 !== _a ? _a : createStage({
      width: this._width,
      height: this._height,
      renderStyle: viewOptions.renderStyle,
      viewBox: viewOptions.viewBox,
      dpr: viewOptions.dpr,
      canvas: viewOptions.renderCanvas,
      canvasControled: viewOptions.canvasControled,
      container: viewOptions.container,
      title: viewOptions.rendererTitle,
      beforeRender: viewOptions.beforeRender,
      afterRender: viewOptions.afterRender,
      disableDirtyBounds: true,
      autoRender: true,
      pluginList: viewOptions.pluginList,
      enableHtmlAttribute: viewOptions.enableHtmlAttribute,
      optimize: viewOptions.optimize,
      ticker: viewOptions.ticker,
      supportsTouchEvents: viewOptions.supportsTouchEvents,
      supportsPointerEvents: viewOptions.supportsPointerEvents,
      ReactDOM: viewOptions.ReactDOM
    });
    (null === (_b = viewOptions.options3d) || void 0 === _b ? void 0 : _b.enable) && stage.set3dOptions(viewOptions.options3d), stage.enableIncrementalAutoRender(), this._viewBox = viewOptions.viewBox, this._view.emit(HOOK_EVENT.AFTER_CREATE_VRENDER_STAGE), this._view.emit(HOOK_EVENT.BEFORE_CREATE_VRENDER_LAYER);
    const layer = null !== (_c = viewOptions.layer) && void 0 !== _c ? _c : stage.defaultLayer;
    if (this._view.emit(HOOK_EVENT.AFTER_CREATE_VRENDER_LAYER), (null === (_d = this._eventConfig) || void 0 === _d ? void 0 : _d.drag) && (this._dragController = new DragNDrop(stage)), null === (_e = this._eventConfig) || void 0 === _e ? void 0 : _e.gesture) {
      const gestureConfig = isObject_default(this._eventConfig.gesture) ? this._eventConfig.gesture : {};
      this._gestureController = new Gesture(stage, gestureConfig);
    }
    return {
      stage,
      layer
    };
  }
  initStage() {
    if (!this._stage) {
      const { stage, layer } = this.createStage();
      this._stage = stage, this._layer = layer;
      const background = this._view.background();
      this.background(background);
    }
  }
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/util/point
function point4(event) {
  ["touches", "changedTouches", "targetTouches"].forEach((touchKey) => {
    event[touchKey] && event[touchKey].length && Array.from(event[touchKey]).forEach((touch) => {
      defineSrPosition(touch, clientToLocal(touch), false);
    });
  });
  const pos = clientToLocal(event);
  return defineSrPosition(event, pos);
}
function clientToLocal(e) {
  return isNil_default(e.offsetX) ? isNil_default(e.x) ? e.changedTouches && e.changedTouches.length ? getChangedTouchesPos(e) : {
    canvasX: 0,
    canvasY: 0
  } : getXYPos(e) : getOffsetPos(e);
}
function getOffsetPos(e) {
  return {
    canvasX: e.offsetX,
    canvasY: e.offsetY
  };
}
function getXYPos(e) {
  return {
    canvasX: e.x,
    canvasY: e.y
  };
}
function getChangedTouchesPos(e) {
  return {
    canvasX: e.changedTouches[0].x,
    canvasY: e.changedTouches[0].y
  };
}
function defineSrPosition(event, pos, client = true) {
  return isValidNumber_default(pos.canvasX) && Object.defineProperty(event, "canvasX", {
    value: pos.canvasX,
    writable: true
  }), isValidNumber_default(pos.canvasY) && Object.defineProperty(event, "canvasY", {
    value: pos.canvasY,
    writable: true
  }), client && isValidNumber_default(pos.clientX) && Object.defineProperty(event, "clientX", {
    value: pos.clientX,
    writable: true
  }), client && isValidNumber_default(pos.clientY) && Object.defineProperty(event, "clientY", {
    value: pos.clientY,
    writable: true
  }), [pos.canvasX, pos.canvasY];
}

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/util/events-extend
function getExtendedEvents(view, event, item, type, source) {
  if (source === EVENT_SOURCE_WINDOW) {
    const e = event.changedTouches ? event.changedTouches[0] : event;
    point4(e);
  }
  return event.element = item, event;
}

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/view/signal
var Signal = class extends GrammarBase {
  constructor() {
    super(...arguments), this.grammarType = "signal", this.spec = {
      value: null,
      update: null
    };
  }
  parse(spec) {
    return super.parse(spec), this.value(spec.value), this.update(spec.update), this.commit(), this;
  }
  evaluate(upstream, parameters) {
    return this._signal = this.spec.update ? invokeFunctionType(this.spec.update, parameters, this._signal) : this.spec.value, this.spec.value = this._signal, this;
  }
  output() {
    return this._signal;
  }
  getValue() {
    return this.output();
  }
  set(value) {
    if (isArray_default(value) && isArray_default(this.value) && value.length === this.value.length) {
      for (let i = 0; i < value.length; i++)
        if (this.value[i] !== value[i])
          return this._signal = value, this.spec.value = value, true;
      return false;
    }
    return this._signal !== value && (this._signal = value, this.spec.value = value, true);
  }
  update(update2) {
    return isNil_default(update2) || this.value(void 0), this.setFunctionSpec(update2, "update");
  }
  value(value) {
    return isNil_default(value) || this.update(void 0), this.spec.value = value, this.commit(), this;
  }
  reuse(grammar) {
    return grammar.grammarType !== this.grammarType || (this._signal = grammar.output()), this;
  }
  clear() {
    super.clear(), this._signal = null;
  }
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/parse/view
var markBaseId = -1;
var BuiltInSignalID = [SIGNAL_WIDTH, SIGNAL_HEIGHT, SIGNAL_PADDING, SIGNAL_VIEW_WIDTH, SIGNAL_VIEW_HEIGHT, SIGNAL_VIEW_BOX, SIGNAL_AUTOFIT];
var builtInSignals = (option, config2, theme2) => {
  var _a, _b, _c, _d, _e;
  return [{
    id: SIGNAL_WIDTH,
    value: null !== (_a = option[SIGNAL_WIDTH]) && void 0 !== _a ? _a : 0
  }, {
    id: SIGNAL_HEIGHT,
    value: null !== (_b = option[SIGNAL_HEIGHT]) && void 0 !== _b ? _b : 0
  }, {
    id: SIGNAL_PADDING,
    value: normalizePadding2(null !== (_d = null !== (_c = option[SIGNAL_PADDING]) && void 0 !== _c ? _c : config2[SIGNAL_PADDING]) && void 0 !== _d ? _d : null == theme2 ? void 0 : theme2.padding)
  }, {
    id: SIGNAL_VIEW_WIDTH,
    update: {
      callback: (signal, params2) => {
        const padding = normalizePadding2(params2[SIGNAL_PADDING]);
        return params2[SIGNAL_WIDTH] - padding.left - padding.right;
      },
      dependency: [SIGNAL_WIDTH, SIGNAL_PADDING]
    }
  }, {
    id: SIGNAL_VIEW_HEIGHT,
    update: {
      callback: (signal, params2) => {
        const padding = normalizePadding2(params2[SIGNAL_PADDING]);
        return params2[SIGNAL_HEIGHT] - padding.top - padding.bottom;
      },
      dependency: [SIGNAL_HEIGHT, SIGNAL_PADDING]
    }
  }, {
    id: SIGNAL_VIEW_BOX,
    update: {
      callback: (signal, params2) => {
        const padding = normalizePadding2(params2[SIGNAL_PADDING]);
        return (signal || new Bounds()).setValue(padding.left, padding.top, padding.left + params2[SIGNAL_VIEW_WIDTH], padding.top + params2[SIGNAL_VIEW_HEIGHT]);
      },
      dependency: [SIGNAL_VIEW_WIDTH, SIGNAL_VIEW_HEIGHT, SIGNAL_PADDING]
    }
  }, {
    id: SIGNAL_AUTOFIT,
    value: null !== (_e = option[SIGNAL_AUTOFIT]) && void 0 !== _e ? _e : config2[SIGNAL_AUTOFIT]
  }];
};
var normalizePadding2 = (value) => {
  var _a, _b, _c, _d;
  return isNumber_default(value) ? {
    top: value,
    bottom: value,
    left: value,
    right: value
  } : {
    top: null !== (_a = null == value ? void 0 : value.top) && void 0 !== _a ? _a : 0,
    bottom: null !== (_b = null == value ? void 0 : value.bottom) && void 0 !== _b ? _b : 0,
    left: null !== (_c = null == value ? void 0 : value.left) && void 0 !== _c ? _c : 0,
    right: null !== (_d = null == value ? void 0 : value.right) && void 0 !== _d ? _d : 0
  };
};
var normalizeMarkTree = (spec) => {
  var _a;
  const traverse = (spec2, group) => {
    var _a2, _b;
    spec2.group = group;
    const id2 = null !== (_a2 = spec2.id) && void 0 !== _a2 ? _a2 : "VGRAMMAR_MARK_" + ++markBaseId;
    spec2.id = id2, (null !== (_b = spec2.marks) && void 0 !== _b ? _b : []).forEach((child) => traverse(child, id2));
  };
  return (null !== (_a = spec.marks) && void 0 !== _a ? _a : []).forEach((mark) => traverse(mark, "root")), spec;
};
var normalizeRunningConfig = (runningConfig) => {
  var _a, _b, _c, _d, _e;
  const { reuse = DefaultReuse, morph = DefaultMorph, morphAll = DefaultMorphAll, animation = {}, enableExitAnimation = DefaultEnableExitAnimation } = null != runningConfig ? runningConfig : {};
  return {
    reuse,
    morph,
    morphAll,
    animation: {
      easing: null !== (_a = animation.easing) && void 0 !== _a ? _a : DefaultAnimationEasing,
      delay: null !== (_b = animation.delay) && void 0 !== _b ? _b : DefaultAnimationDelay,
      duration: null !== (_c = animation.duration) && void 0 !== _c ? _c : DefaultAnimationDuration,
      oneByOne: null !== (_d = animation.oneByOne) && void 0 !== _d ? _d : DefaultAnimationOneByOne,
      splitPath: null !== (_e = animation.splitPath) && void 0 !== _e ? _e : DefaultSplitPath
    },
    enableExitAnimation
  };
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/parse/event
var generateFilterByMark = (evtSpec) => isNil_default(evtSpec.markId) ? (el) => el && el.mark.id() === evtSpec.markId : isNil_default(evtSpec.markName) ? (el) => el && el.mark.name() === evtSpec.markName : isNil_default(evtSpec.type) ? (el) => el && el.mark.markType === evtSpec.type : () => true;
var parseHandler = (callback, config2) => config2 && config2.debounce ? debounce_default(callback, config2.debounce) : config2 && config2.throttle ? throttle_default(callback, config2.throttle) : callback;
var NAME_PREFIX = "@";
var ID_PREFIX = "#";
var parseEventSelector = (selector, source = EVENT_SOURCE_VIEW) => {
  const spec = {}, splitArr = selector.split(":");
  if (2 === splitArr.length) {
    const [space, eventType] = splitArr;
    "#" === space[0] ? (spec.markId = space.slice(1), spec.source = source) : "@" === space[0] ? (spec.markName = space.slice(1), spec.source = source) : isMarkType(space) ? (spec.markType = space, spec.source = source) : spec.source = space === EVENT_SOURCE_WINDOW ? EVENT_SOURCE_WINDOW : source, spec.type = eventType;
  } else
    1 === splitArr.length && (spec.type = selector, spec.source = source);
  return spec;
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/util/env
function configureEnvironment(options) {
  options.mode && vglobal.setEnv(options.mode, options.modeParams || {});
}

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/glyph-element
var GlyphElement = class extends Element2 {
  constructor(mark) {
    super(mark), this.getStateAttrs = (stateName, nextStates) => {
      var _a, _b, _c, _d;
      const isRuntimeState = !isNil_default(null === (_a = this.runtimeStatesEncoder) || void 0 === _a ? void 0 : _a[stateName]), encoder = isRuntimeState ? Object.assign(Object.assign({}, null === (_b = this.mark.getSpec().encode) || void 0 === _b ? void 0 : _b[stateName]), this.runtimeStatesEncoder[stateName]) : null === (_c = this.mark.getSpec().encode) || void 0 === _c ? void 0 : _c[stateName], glyphStateAttributes = {};
      if (!encoder)
        return glyphStateAttributes;
      if (isFunction_default(encoder))
        return glyphStateAttributes.attributes = encoder(this.getDatum(), this, stateName, nextStates), glyphStateAttributes;
      if (!isRuntimeState && (null === (_d = this.graphicItem.glyphStates) || void 0 === _d ? void 0 : _d[stateName]))
        return this.graphicItem.glyphStates[stateName];
      if (encoder) {
        const item = this.items[0], targetItems = [Object.assign({}, item, {
          nextAttrs: {}
        })];
        return invokeEncoderToItems(this, targetItems, encoder, this.mark.parameters()), this.coordinateTransformEncode(targetItems), glyphStateAttributes.attributes = targetItems[0].nextAttrs, this.graphicItem.glyphStates ? this.graphicItem.glyphStates[stateName] || (this.graphicItem.glyphStates[stateName] = glyphStateAttributes) : this.graphicItem.glyphStates = {
          [stateName]: glyphStateAttributes
        }, glyphStateAttributes;
      }
      return glyphStateAttributes;
    }, this.glyphMeta = this.mark.getGlyphMeta();
  }
  getGlyphGraphicItems() {
    return this.glyphGraphicItems;
  }
  initGraphicItem(attributes = {}) {
    if (this.graphicItem)
      return;
    this.graphicItem = this.mark.addGraphicItem(attributes, this.groupKey), this.graphicItem[BridgeElementKey] = this, this.graphicItem.onBeforeAttributeUpdate = this._onGlyphAttributeUpdate(false);
    const glyphMarks = this.glyphMeta.getMarks();
    this.glyphGraphicItems = {}, this.graphicItem.getSubGraphic().forEach((graphic) => {
      const markType = glyphMarks[graphic.name];
      this.glyphGraphicItems[graphic.name] = graphic, graphic.onBeforeAttributeUpdate = (attributes2) => {
        if (!this.mark)
          return attributes2;
        return transformAttributes(markType, attributes2, this, graphic.name);
      };
    }), this.clearGraphicAttributes();
  }
  useStates(states, hasAnimation) {
    if (!this.graphicItem)
      return false;
    this.mark.emit(HOOK_EVENT.BEFORE_ELEMENT_STATE, {
      states
    }, this), this.states = states.slice();
    const stateAnimationEnable = isBoolean_default(hasAnimation) ? hasAnimation : 0 !== this.mark.animate.getAnimationConfigs("state").length;
    return this.graphicItem.glyphStateProxy = this.getStateAttrs, this.graphicItem.useStates(this.states, stateAnimationEnable), this.mark.emit(HOOK_EVENT.AFTER_ELEMENT_STATE, {
      states
    }, this), true;
  }
  encodeGraphic() {
    this.coordinateTransformEncode(this.items);
    const graphicAttributes = this.transformElementItems(this.items, this.mark.markType);
    this.graphicItem || this.initGraphicItem(), this.diffState === DiffState.enter ? (this.graphicItem.onBeforeAttributeUpdate = this._onGlyphAttributeUpdate(true), this.applyGraphicAttributes(graphicAttributes), this.graphicItem.onBeforeAttributeUpdate = this._onGlyphAttributeUpdate(false)) : this.applyGraphicAttributes(graphicAttributes), this.diffState !== DiffState.enter && this.diffState !== DiffState.update || !this.states.length || (Object.values(this.glyphGraphicItems).forEach((graphicItem) => {
      graphicItem.states = {};
    }), this.useStates(this.states)), this.items.map((item) => {
      item.nextAttrs = {};
    });
  }
  encodeCustom(nextAttrs) {
    var _a;
    let customEncodeValues = {};
    const channelEncoder = this.glyphMeta.getChannelEncoder(), functionEncoder = this.glyphMeta.getFunctionEncoder();
    if (functionEncoder && (customEncodeValues = functionEncoder.call(null, Object.assign({}, null === (_a = this.graphicItem) || void 0 === _a ? void 0 : _a.attribute, nextAttrs), this.getDatum(), this, this.mark.getGlyphConfig())), channelEncoder) {
      let allAttrs;
      Object.keys(channelEncoder).forEach((channel) => {
        var _a2;
        if (!isNil_default(nextAttrs[channel])) {
          allAttrs || (allAttrs = Object.assign({}, null === (_a2 = this.graphicItem) || void 0 === _a2 ? void 0 : _a2.attribute, nextAttrs));
          const encodeResult = channelEncoder[channel].call(null, channel, nextAttrs[channel], allAttrs, this.getDatum(), this, this.mark.getGlyphConfig());
          Object.keys(null != encodeResult ? encodeResult : {}).forEach((markName) => {
            var _a3;
            customEncodeValues[markName] = Object.assign(null !== (_a3 = customEncodeValues[markName]) && void 0 !== _a3 ? _a3 : {}, encodeResult[markName]);
          });
        }
      });
    }
    return customEncodeValues;
  }
  encodeDefault() {
    const defaultEncodeValues = {};
    if (this.diffState === DiffState.enter && this.glyphMeta.getDefaultEncoder()) {
      const defaultEncodeResult = this.glyphMeta.getDefaultEncoder().call(null, this.getDatum(), this, this.mark.getGlyphConfig());
      Object.assign(defaultEncodeValues, defaultEncodeResult);
    }
    return defaultEncodeValues;
  }
  _onGlyphAttributeUpdate(first = false) {
    return (attributes) => {
      if (!this.mark)
        return attributes;
      const glyphMarks = this.glyphMeta.getMarks(), graphicAttributes = transformAttributes(this.mark.getAttributeTransforms(), attributes, this), defaultEncodeValues = first ? this.encodeDefault() : null, customEncodeValues = this.encodeCustom(attributes);
      return Object.keys(glyphMarks).forEach((markName) => {
        const markType = glyphMarks[markName], graphicItem = this.glyphGraphicItems[markName], customAttributes = null == customEncodeValues ? void 0 : customEncodeValues[markName], additionalAttributes = Object.assign({}, customAttributes);
        if (first) {
          const defaultAttributes2 = null == defaultEncodeValues ? void 0 : defaultEncodeValues[markName];
          Object.keys(null != defaultAttributes2 ? defaultAttributes2 : {}).forEach((key) => {
            has_default(this.items[0].nextAttrs, key) || has_default(additionalAttributes, key) || (additionalAttributes[key] = defaultAttributes2[key]);
          });
        }
        const glyphAttributes = Object.assign({}, cloneTransformAttributes(markType, attributes), additionalAttributes), glyphItems = this._generateGlyphItems(markType, this.items, glyphAttributes);
        this.coordinateTransformEncode(glyphItems);
        const graphicAttributes2 = this.transformElementItems(glyphItems, markType);
        this.applyGlyphGraphicAttributes(graphicAttributes2, markName, graphicItem), markType === GrammarMarkType.shape && (graphicItem.datum = glyphItems[0].datum);
      }), graphicAttributes;
    };
  }
  _generateGlyphItems(markType, items, additionalAttributes) {
    const glyphItems = items.map((item) => Object.assign({}, item, {
      nextAttrs: additionalAttributes
    }));
    return CollectionMarkType.includes(markType) && this.mark.getSpec().enableSegments && glyphItems.forEach((glyphItem, index) => {
      glyphItem.nextAttrs = Object.assign({}, items[index].nextAttrs, additionalAttributes);
    }), glyphItems;
  }
  getGraphicAttribute(channel, prev = false, markName) {
    if (!this.graphicItem)
      return;
    const prevGraphicAttributes = this.getPrevGraphicAttributes(markName);
    if (prev && has_default(prevGraphicAttributes, channel))
      return prevGraphicAttributes[channel];
    return (markName ? this.glyphGraphicItems[markName] : this.graphicItem).attribute[channel];
  }
  setGraphicAttribute(channel, value, final = true, markName) {
    if (!this.graphicItem)
      return;
    const graphicItem = markName ? this.glyphGraphicItems[markName] : this.graphicItem, finalGraphicAttributes = this.getFinalGraphicAttributes(markName), prevGraphicAttributes = this.getPrevGraphicAttributes(markName);
    final && (finalGraphicAttributes[channel] = value), has_default(prevGraphicAttributes, channel) || (prevGraphicAttributes[channel] = graphicItem.attribute[channel]), graphicItem.setAttribute(channel, value);
  }
  setGraphicAttributes(attributes, final = true, markName) {
    if (!this.graphicItem)
      return;
    const graphicItem = markName ? this.glyphGraphicItems[markName] : this.graphicItem, finalGraphicAttributes = this.getFinalGraphicAttributes(markName), prevGraphicAttributes = this.getPrevGraphicAttributes(markName);
    Object.keys(attributes).forEach((key) => {
      final && (finalGraphicAttributes[key] = attributes[key]), has_default(prevGraphicAttributes, key) || (prevGraphicAttributes[key] = graphicItem.attribute[key]);
    }), graphicItem.setAttributes(attributes);
  }
  diffAttributes(graphicAttributes, markName) {
    const diffResult = {}, finalGraphicAttributes = this.getFinalGraphicAttributes(markName);
    for (const key in graphicAttributes)
      isEqual2(key, finalGraphicAttributes, graphicAttributes) || (diffResult[key] = graphicAttributes[key]);
    return diffResult;
  }
  applyGlyphGraphicAttributes(graphicAttributes, markName, graphicItem) {
    var _a, _b;
    if (this.mark.needAnimate()) {
      const nextGraphicAttributes = this.diffAttributes(graphicAttributes, markName), prevGraphicAttributes = null !== (_a = this.getPrevGraphicAttributes(markName)) && void 0 !== _a ? _a : {}, finalGraphicAttributes = null !== (_b = this.getFinalGraphicAttributes(markName)) && void 0 !== _b ? _b : {};
      Object.keys(nextGraphicAttributes).forEach((channel) => {
        prevGraphicAttributes[channel] = graphicItem.attribute[channel], finalGraphicAttributes[channel] = nextGraphicAttributes[channel];
      }), this.setNextGraphicAttributes(nextGraphicAttributes, markName), this.setPrevGraphicAttributes(prevGraphicAttributes, markName), this.setFinalGraphicAttributes(finalGraphicAttributes, markName), graphicItem.setAttributes(nextGraphicAttributes);
    } else
      graphicItem.setAttributes(graphicAttributes);
  }
  getFinalGraphicAttributes(markName) {
    return (markName ? this.glyphGraphicItems[markName] : this.graphicItem).finalAttrs;
  }
  setFinalGraphicAttributes(attributes, markName) {
    (markName ? this.glyphGraphicItems[markName] : this.graphicItem).finalAttrs = attributes;
  }
  getPrevGraphicAttributes(markName) {
    return (markName ? this.glyphGraphicItems[markName] : this.graphicItem).prevAttrs;
  }
  setPrevGraphicAttributes(attributes, markName) {
    (markName ? this.glyphGraphicItems[markName] : this.graphicItem).prevAttrs = attributes;
  }
  getNextGraphicAttributes(markName) {
    return (markName ? this.glyphGraphicItems[markName] : this.graphicItem).nextAttrs;
  }
  setNextGraphicAttributes(attributes, markName) {
    (markName ? this.glyphGraphicItems[markName] : this.graphicItem).nextAttrs = attributes;
  }
  clearChangedGraphicAttributes() {
    this.setPrevGraphicAttributes(null), this.setNextGraphicAttributes(null), Object.keys(this.glyphGraphicItems).forEach((markName) => {
      this.setPrevGraphicAttributes(null, markName), this.setNextGraphicAttributes(null, markName);
    });
  }
  clearGraphicAttributes() {
    this.setPrevGraphicAttributes(null), this.setNextGraphicAttributes(null), this.setFinalGraphicAttributes(null), Object.keys(this.glyphGraphicItems).forEach((markName) => {
      this.setPrevGraphicAttributes(null, markName), this.setNextGraphicAttributes(null, markName), this.setFinalGraphicAttributes(null, markName);
    });
  }
  remove() {
    this.glyphGraphicItems = null, super.remove();
  }
  release() {
    this.glyphGraphicItems && (Object.values(this.glyphGraphicItems).forEach((graphicItem) => {
      graphicItem[BridgeElementKey] = null;
    }), this.glyphGraphicItems = null), super.release();
  }
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/util/element
var createElement = (mark) => mark.markType === GrammarMarkType.glyph ? new GlyphElement(mark) : new Element2(mark);

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/mark/differ
function groupData(data, key, sort) {
  const groupedData = /* @__PURE__ */ new Map();
  if (!data || 0 === data.length)
    return {
      keys: [],
      data: groupedData
    };
  if (!key)
    return groupedData.set(DefaultKey, sort ? data.slice().sort(sort) : data.slice()), {
      keys: DefaultGroupKeys,
      data: groupedData
    };
  const keyGetter = parseField(key);
  if (1 === data.length) {
    const key2 = keyGetter(data[0]);
    return groupedData.set(key2, [data[0]]), {
      keys: [key2],
      data: groupedData
    };
  }
  const keys2 = /* @__PURE__ */ new Set();
  return data.forEach((entry) => {
    var _a;
    const key2 = keyGetter(entry), lastData = null !== (_a = groupedData.get(key2)) && void 0 !== _a ? _a : [];
    lastData.push(entry), groupedData.set(key2, lastData), keys2.add(key2);
  }), sort && keys2.forEach((key2) => {
    groupedData.get(key2).sort(sort);
  }), {
    keys: Array.from(keys2),
    data: groupedData
  };
}
var Differ = class {
  constructor(data, key, sort) {
    this.prevData = (null == data ? void 0 : data.length) ? groupData(data, null != key ? key : null, sort) : null;
  }
  setCurrentData(currentData) {
    this.currentData = currentData;
  }
  getCurrentData() {
    return this.currentData;
  }
  doDiff() {
    if (this.callback)
      if (this.currentData && this.prevData) {
        const prevMap = new Map(this.prevData.data);
        this.currentData.keys.forEach((key) => {
          this.callback(key, this.currentData.data.get(key), prevMap.get(key)), prevMap.delete(key);
        }), this.prevData.keys.forEach((key) => {
          prevMap.has(key) && this.callback(key, null, prevMap.get(key));
        });
      } else if (this.currentData) {
        this.currentData.keys.forEach((key) => {
          this.callback(key, this.currentData.data.get(key), null);
        });
      } else
        this.prevData && this.prevData.keys.forEach((key) => {
          this.callback(key, null, this.prevData.data.get(key));
        });
  }
  setCallback(callback) {
    this.callback = callback;
  }
  updateToCurrent() {
    this.prevData = this.currentData, this.currentData = null;
  }
  reset() {
    this.prevData = null;
  }
};
function diffSingle(prev, next, key) {
  const result2 = {
    enter: [],
    exit: [],
    update: []
  }, differ = new Differ(prev, key);
  return differ.setCallback((key2, data, prevData) => {
    isNil_default(data) ? result2.exit.push({
      prev: prevData[0]
    }) : isNil_default(prevData) ? result2.enter.push({
      next: data[0]
    }) : result2.update.push({
      next: data[0],
      prev: prevData[0]
    });
  }), differ.setCurrentData(groupData(next, key)), differ.doDiff(), result2;
}
function diffMultiple(prev, next, key) {
  const result2 = {
    enter: [],
    exit: [],
    update: []
  }, differ = new Differ(prev, key);
  return differ.setCallback((key2, data, prevData) => {
    isNil_default(data) ? result2.exit.push({
      prev: prevData
    }) : isNil_default(prevData) ? result2.enter.push({
      next: data
    }) : result2.update.push({
      next: data,
      prev: prevData
    });
  }), differ.setCurrentData(groupData(next, key)), differ.doDiff(), result2;
}

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/animation/attribute
var transformAnimationAttributes = (attributes, element) => {
  if (!attributes)
    return null;
  if (attributes.from) {
    const from = attributes.from, fromKeys = Object.keys(from);
    fromKeys.forEach((channel) => {
      isNil_default(from[channel]) && delete from[channel];
    });
    const computePoints = isValidPointsChannel(fromKeys, element.mark.markType) && !isValid_default(from.segments);
    if (computePoints) {
      const items = element.items.map((item) => Object.assign({}, item, {
        nextAttrs: Object.assign({}, from)
      }));
      attributes.from = element.transformElementItems(items, element.mark.markType, computePoints);
    }
  }
  if (attributes.to) {
    const to = attributes.to, toKeys = Object.keys(to);
    toKeys.forEach((channel) => {
      isNil_default(to[channel]) && delete to[channel];
    });
    const computePoints = isValidPointsChannel(toKeys, element.mark.markType) && !isValid_default(to.segments);
    if (computePoints) {
      const items = element.items.map((item) => Object.assign({}, item, {
        nextAttrs: Object.assign({}, to)
      }));
      attributes.to = element.transformElementItems(items, element.mark.markType, computePoints);
    }
  }
  return attributes;
};
function typeAnimationAttributes(element, effect, animationParameters, parameters) {
  const options = isFunction_default(effect.options) ? effect.options.call(null, element.getDatum(), element, parameters) : effect.options;
  if (!effect.type || !Factory.getAnimationType(effect.type))
    return null;
  const attributes = Factory.getAnimationType(effect.type)(element, options, animationParameters);
  return transformAnimationAttributes(attributes, element);
}
var parseChannelValue = (element, channel, channelValue, animationParameters, parameters) => isFunction_default(channelValue) ? channelValue(element.getDatum(), element, parameters) : channelValue;
function channelAnimationAttributes(element, effect, animationParameters, parameters) {
  const channel = effect.channel;
  let attributes = null;
  return isArray_default(channel) ? attributes = channel.reduce((res, key) => (res.from[key] = element.getGraphicAttribute(key, true), res.to[key] = element.getGraphicAttribute(key, false), res), {
    from: {},
    to: {}
  }) : isObject_default(channel) && (attributes = Object.keys(channel).reduce((res, key) => {
    var _a, _b;
    const hasFrom = !isNil_default(null === (_a = channel[key]) || void 0 === _a ? void 0 : _a.from), hasTo = !isNil_default(null === (_b = channel[key]) || void 0 === _b ? void 0 : _b.to);
    return (hasFrom || hasTo) && (res.from[key] = hasFrom ? parseChannelValue(element, 0, channel[key].from, 0, parameters) : void 0, res.to[key] = hasTo ? parseChannelValue(element, 0, channel[key].to, 0, parameters) : element.getGraphicAttribute(key, false)), res;
  }, {
    from: {},
    to: {}
  })), transformAnimationAttributes(attributes, element);
}
var CustomInterpolator = class extends ACustomAnimate {
  constructor(from, to, duration, easing, params2) {
    super(from, to, duration, easing, params2), this._interpolator = null == params2 ? void 0 : params2.interpolator, this._element = null == params2 ? void 0 : params2.element;
  }
  onBind() {
    var _a, _b;
    this.from = null !== (_a = this.from) && void 0 !== _a ? _a : {}, this.to = null !== (_b = this.to) && void 0 !== _b ? _b : {};
  }
  getEndProps() {
    return this.to;
  }
  onUpdate(end, ratio, out) {
    this._interpolator && this._element && this._interpolator.call(this, ratio, this.from, this.to, out, this._element.getDatum(), this._element, this.params.parameters);
  }
};
var AttributeAnimate = class extends ACustomAnimate {
  getEndProps() {
    return this.to;
  }
  onBind() {
    var _a;
    const excludedChannelMap = null !== (_a = this.target.constructor.NOWORK_ANIMATE_ATTR) && void 0 !== _a ? _a : NOWORK_ANIMATE_ATTR, excludedChannels = Object.keys(excludedChannelMap).filter((channel) => 0 !== excludedChannelMap[channel]);
    this.subAnimate.animate.preventAttrs(excludedChannels);
    const from = Object.assign({}, this.from), to = Object.assign({}, this.to), animatedChannels = [];
    Object.keys(to).forEach((k2) => {
      excludedChannels.includes(k2) ? (from[k2] = to[k2], this.from[k2] = to[k2]) : isNil_default(from[k2]) ? from[k2] = this.target.getComputedAttribute(k2) : animatedChannels.push(k2);
    }), this.target.animates.forEach((a3) => {
      a3 !== this.subAnimate.animate && a3.preventAttrs(animatedChannels);
    }), this._fromAttribute = from, this._toAttribute = to;
  }
  onStart() {
    if (this._fromAttribute) {
      const from = {};
      Object.keys(this._fromAttribute).forEach((key) => {
        this.subAnimate.animate.validAttr(key) && (from[key] = this._fromAttribute[key]);
      }), this.target.setAttributes(from, false, {
        type: AttributeUpdateType.ANIMATE_UPDATE,
        animationState: {
          ratio: 0,
          end: false
        }
      });
    }
  }
  onEnd() {
    if (this._toAttribute) {
      const out = {};
      Object.keys(this._toAttribute).forEach((key) => {
        this.subAnimate.animate.validAttr(key) && (out[key] = this._toAttribute[key]);
      }), this.target.setAttributes(out, false, {
        type: AttributeUpdateType.ANIMATE_END
      });
    }
  }
  update(end, ratio, out) {
    0 === this.updateCount && this.onFirstRun(), this.updateCount += 1;
    const lastProps = this.step.getLastProps();
    Object.keys(lastProps).forEach((key) => {
      this.subAnimate.animate.validAttr(key) && (out[key] = lastProps[key]);
    }), this.onUpdate(end, ratio, out), end && this.onEnd();
  }
  onUpdate(end, ratio, out) {
    this.target.stepInterpolate(this.subAnimate, this.subAnimate.animate, out, this.step, ratio, end, this._toAttribute, this._fromAttribute);
  }
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/animation/animator
Animate.mode |= AnimateMode.SET_ATTR_IMMEDIATELY;
var GlobalAnimatorId = 0;
var isCustomAnimateCtor = (custom) => !isNil_default(custom) && (custom.prototype instanceof ACustomAnimate || "onBind" in custom.prototype && "onStart" in custom.prototype && "onEnd" in custom.prototype && "onUpdate" in custom.prototype);
var Animator = class {
  constructor(element, unit, animationOptions) {
    this.id = GlobalAnimatorId++, this.isAnimating = false, this.runnings = [], this.element = element, this.animationOptions = animationOptions, this.unit = unit;
  }
  callback(callbackFunction) {
    return this.callbackFunction = callbackFunction, this;
  }
  animate(animationParameters, parameters) {
    return this.isAnimating = true, this.animateElement(animationParameters, parameters), 0 === this.runnings.length && this.animationEnd(), this;
  }
  stop(stopState = "end", invokeCallback = true) {
    return this.runnings.forEach((running) => running.stop(stopState)), this.animationEnd(invokeCallback), this;
  }
  pause() {
    return this.runnings.forEach((running) => running.pause()), this;
  }
  resume() {
    return this.runnings.forEach((running) => running.resume()), this;
  }
  startAt(startTime) {
    return this.runnings.forEach((running) => {
      const initialDelay = this.unit.initialDelay;
      running.startAt(initialDelay + startTime);
    }), this;
  }
  getTotalAnimationTime() {
    var _a;
    const timeLineDuration = this.unit.initialDelay + this.unit.loopDuration * this.unit.loopCount;
    return null !== (_a = this.unit.totalTime) && void 0 !== _a ? _a : timeLineDuration;
  }
  getEndAttributes() {
    return this.runnings.reduce((attributes, running) => Object.assign(attributes, running.getEndProps()), {});
  }
  animationEnd(invokeCallback = true) {
    var _a;
    this.isAnimating = false, this.runnings = null, invokeCallback && (null === (_a = this.callbackFunction) || void 0 === _a || _a.call(null));
  }
  animateElement(animationParameters, parameters) {
    const graphicItem = this.element.getGraphicItem();
    if (!graphicItem)
      return;
    const graphicAnimate = graphicItem.animate();
    this.runnings.push(graphicAnimate), graphicAnimate.startAt(this.unit.initialDelay), graphicAnimate.wait(this.unit.loopDelay), this.unit.timeSlices.forEach((timeSlice) => {
      this.animateTimeSlice(graphicAnimate, timeSlice, animationParameters, parameters);
    }), graphicAnimate.wait(this.unit.loopDelayAfter), graphicAnimate.loop(this.unit.loopCount - 1), isValidNumber_default(this.unit.totalTime) && setTimeout(() => {
      graphicAnimate && graphicAnimate.stop("end");
    }, this.unit.totalTime), graphicAnimate.onEnd(() => {
      this.runnings = this.runnings.filter((running) => running !== graphicAnimate), 0 === this.runnings.length && this.animationEnd();
    });
  }
  animateTimeSlice(graphicAnimate, timeSlice, animationParameters, parameters) {
    const delay = timeSlice.delay, delayAfter = timeSlice.delayAfter, duration = timeSlice.duration, effects = timeSlice.effects;
    if (delay > 0 && graphicAnimate.wait(delay), effects.length < 0)
      graphicAnimate.wait(duration);
    else {
      const customAnimates = effects.map((effect, index) => {
        var _a;
        const attributes = null !== (_a = effect.type ? typeAnimationAttributes(this.element, effect, animationParameters, parameters) : effect.channel ? channelAnimationAttributes(this.element, effect, animationParameters, parameters) : void 0) && void 0 !== _a ? _a : {}, customOption = attributes.custom || (null == effect ? void 0 : effect.custom), customParametersOption = (null == attributes ? void 0 : attributes.customParameters) || (null == effect ? void 0 : effect.customParameters);
        attributes.from && Object.keys(attributes.from).length && this.unit && this.animationOptions.timeline.controlOptions.immediatelyApply && "component" !== this.element.mark.markType && this.element.getGraphicItem().setAttributes(attributes.from);
        const isCustomAnimate = isCustomAnimateCtor(customOption);
        return !isNil_default(customOption) && !isCustomAnimateCtor(customOption) ? new CustomInterpolator(attributes.from, attributes.to, duration, effect.easing, {
          interpolator: customOption,
          element: this.element,
          parameters: customParametersOption
        }) : isCustomAnimate ? new customOption(attributes.from, attributes.to, duration, effect.easing, customParametersOption) : attributes.to ? new AttributeAnimate(attributes.from, attributes.to, duration, effect.easing) : void 0;
      }).filter((animate) => !isNil_default(animate));
      1 === customAnimates.length ? graphicAnimate.play(customAnimates[0]) : customAnimates.length > 1 && graphicAnimate.play(new AnimateGroup(duration, customAnimates));
    }
    delayAfter > 0 && graphicAnimate.wait(delayAfter);
  }
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/animation/config
function transformToTimelineConfig(animationConfig2) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
  if (isNil_default(animationConfig2.timeSlices)) {
    const typeConfig = animationConfig2;
    return {
      startTime: null !== (_a = typeConfig.startTime) && void 0 !== _a ? _a : DefaultAnimationStartTime,
      totalTime: typeConfig.totalTime,
      oneByOne: null !== (_b = typeConfig.oneByOne) && void 0 !== _b ? _b : DefaultAnimationOneByOne,
      loop: null !== (_c = typeConfig.loop) && void 0 !== _c ? _c : DefaultAnimationLoop,
      controlOptions: merge({}, DefaultAnimationControlOptions, null !== (_d = typeConfig.controlOptions) && void 0 !== _d ? _d : {}),
      timeSlices: [{
        duration: null !== (_e = typeConfig.duration) && void 0 !== _e ? _e : DefaultAnimationDuration,
        delay: null !== (_f = typeConfig.delay) && void 0 !== _f ? _f : DefaultAnimationDelay,
        delayAfter: null !== (_g = typeConfig.delayAfter) && void 0 !== _g ? _g : DefaultAnimationDelayAfter,
        effects: [{
          type: typeConfig.type,
          channel: typeConfig.channel,
          custom: typeConfig.custom,
          easing: null !== (_h = typeConfig.easing) && void 0 !== _h ? _h : DefaultAnimationEasing,
          customParameters: typeConfig.customParameters,
          options: typeConfig.options
        }]
      }]
    };
  }
  const formattedTimeSlices = array(animationConfig2.timeSlices).filter((timeSlice) => timeSlice.effects && array(timeSlice.effects).filter((effect) => effect.channel || effect.type).length);
  if (formattedTimeSlices.length)
    return {
      startTime: null !== (_j = animationConfig2.startTime) && void 0 !== _j ? _j : DefaultAnimationStartTime,
      totalTime: animationConfig2.totalTime,
      oneByOne: null !== (_k = animationConfig2.oneByOne) && void 0 !== _k ? _k : DefaultAnimationOneByOne,
      loop: null !== (_l = animationConfig2.loop) && void 0 !== _l ? _l : DefaultAnimationLoop,
      controlOptions: merge({}, DefaultAnimationControlOptions, null !== (_m = animationConfig2.controlOptions) && void 0 !== _m ? _m : {}),
      timeSlices: formattedTimeSlices.map((timeSlice) => {
        var _a2, _b2;
        return {
          duration: timeSlice.duration,
          delay: null !== (_a2 = timeSlice.delay) && void 0 !== _a2 ? _a2 : DefaultAnimationDelay,
          delayAfter: null !== (_b2 = timeSlice.delayAfter) && void 0 !== _b2 ? _b2 : DefaultAnimationDelayAfter,
          effects: array(timeSlice.effects).filter((effect) => effect.channel || effect.type).map((effect) => {
            var _a3;
            return {
              type: effect.type,
              channel: effect.channel,
              custom: effect.custom,
              easing: null !== (_a3 = effect.easing) && void 0 !== _a3 ? _a3 : DefaultAnimationEasing,
              customParameters: effect.customParameters,
              options: effect.options
            };
          })
        };
      }),
      partitioner: animationConfig2.partitioner,
      sort: animationConfig2.sort
    };
}
function normalizeAnimationConfig(config2) {
  let normalizedConfig = [];
  return Object.keys(config2).forEach((state) => {
    normalizedConfig = normalizedConfig.concat(normalizeStateAnimationConfig(state, config2[state]));
  }), normalizedConfig;
}
function normalizeStateAnimationConfig(state, config2, initialIndex = 0) {
  const normalizedConfig = [];
  let index = initialIndex;
  return array(config2).forEach((animationConfig2) => {
    var _a;
    const timelineConfig = transformToTimelineConfig(animationConfig2);
    timelineConfig && (normalizedConfig.push({
      state,
      id: null !== (_a = timelineConfig.id) && void 0 !== _a ? _a : `${state}-${index}`,
      timeline: timelineConfig,
      originConfig: animationConfig2
    }), index += 1);
  }), normalizedConfig;
}
function invokeAnimateSpec(spec, element, parameters) {
  return isFunction_default(spec) ? spec.call(null, element.getDatum(), element, parameters) : spec;
}

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/animation/arranger
var Arranger = class {
  constructor(animators) {
    this.parallelArrangers = [this], this.totalTime = 0, this.startTime = 0, this.endTime = 0, this.animators = animators.filter((animator) => !isNil_default(animator)), this.totalTime = this.animators.reduce((time, animator) => Math.max(time, animator.getTotalAnimationTime()), 0);
  }
  parallel(arranger) {
    const parallelArrangers = Array.from(new Set(this.parallelArrangers.concat(arranger.parallelArrangers)));
    return parallelArrangers.forEach((arranger2) => {
      arranger2.parallelArrangers = parallelArrangers;
    }), this.arrangeTime(), this;
  }
  after(arranger) {
    return this.afterArranger = arranger, this.arrangeTime(), this;
  }
  arrangeTime() {
    const parallelTime = this.parallelArrangers.reduce((time, arranger) => Math.max(time, arranger.totalTime), this.totalTime), startTime = this.parallelArrangers.reduce((time, arranger) => {
      var _a, _b;
      return Math.max(time, null !== (_b = null === (_a = arranger.afterArranger) || void 0 === _a ? void 0 : _a.endTime) && void 0 !== _b ? _b : 0);
    }, 0);
    this.parallelArrangers.forEach((arranger) => {
      arranger.startTime = startTime, arranger.endTime = startTime + parallelTime, arranger.animators.forEach((animator) => {
        animator.startAt(startTime);
      });
    });
  }
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/animation/animate
var Animate2 = class {
  constructor(mark, config2) {
    this.state = null, this.immediateConfigs = [], this.isEnabled = true, this.disabledStates = [], this.animators = /* @__PURE__ */ new Map(), this.elementRecorder = /* @__PURE__ */ new WeakMap(), this.timelineCount = {}, this.mark = mark, this.configs = normalizeAnimationConfig(null != config2 ? config2 : {});
  }
  getAnimationConfigs(animationState) {
    var _a;
    return this.isEnabled ? (null !== (_a = this.configs) && void 0 !== _a ? _a : []).filter((config2) => config2.state === animationState) : [];
  }
  updateConfig(config2) {
    this.configs = normalizeAnimationConfig(null != config2 ? config2 : {});
  }
  updateState(state) {
    this.state = state;
  }
  animate() {
    if (!this.isEnabled || !this.configs || !this.configs.length)
      return;
    const elements = this.mark.getAllElements(), parameters = this.mark.parameters();
    return elements.forEach((element) => {
      var _a;
      element.isReserved && element.diffState !== DiffState.exit && (element.isReserved = false);
      const prevElementState = null === (_a = this.elementRecorder.get(element)) || void 0 === _a ? void 0 : _a.prevState;
      this.configs.some((config2) => prevElementState !== element.diffState && config2.state === prevElementState && config2.timeline.controlOptions.stopWhenStateChange) && this.clearElementAnimation(element, false);
    }), this.configs.forEach((config2) => {
      this.animateByTimeline(config2, elements, parameters);
    }), this.mark.cleanExitElements(), this;
  }
  runAnimationByState(animationState) {
    if (!this.isEnabled)
      return;
    const stateConfigs = this.configs.filter((config2) => config2.state === animationState), elements = this.mark.getAllElements(), parameters = this.mark.parameters(), animators = stateConfigs.reduce((animators2, config2) => animators2.concat(this.animateByTimeline(config2, elements, parameters, true)), []);
    return new Arranger(animators);
  }
  stopAnimationByState(animationState) {
    const animators = this.animators.get(animationState);
    return animators && animators.forEach((animator) => animator.stop()), this;
  }
  pauseAnimationByState(animationState) {
    const animators = this.animators.get(animationState);
    return animators && animators.forEach((animator) => animator.pause()), this;
  }
  resumeAnimationByState(animationState) {
    const animators = this.animators.get(animationState);
    return animators && animators.forEach((animator) => animator.resume()), this;
  }
  run(config2) {
    if (!this.isEnabled)
      return;
    const parsedConfigs = normalizeStateAnimationConfig(ImmediateAnimationState, config2, this.immediateConfigs.length);
    this.immediateConfigs = this.immediateConfigs.concat(parsedConfigs);
    const elements = this.mark.getAllElements(), parameters = this.mark.parameters(), animators = parsedConfigs.reduce((animators2, config3) => animators2.concat(this.animateByTimeline(config3, elements, parameters, true)), []);
    return new Arranger(animators);
  }
  stop() {
    return this.animators.forEach((animators) => {
      animators.forEach((animator) => animator.stop());
    }), this;
  }
  pause() {
    return this.animators.forEach((stateAnimators) => stateAnimators.forEach((animator) => animator.pause())), this;
  }
  resume() {
    return this.animators.forEach((stateAnimators) => stateAnimators.forEach((animator) => animator.resume())), this;
  }
  reverse() {
    return this;
  }
  restart() {
    return this;
  }
  record() {
    return this;
  }
  recordEnd() {
    return this;
  }
  isAnimating() {
    let isAnimating = false;
    return this.animators.forEach((animators) => {
      isAnimating = isAnimating || animators.some((animator) => animator.isAnimating);
    }), isAnimating;
  }
  isElementAnimating(element) {
    var _a;
    const stateAnimationCounts = null === (_a = this.elementRecorder.get(element)) || void 0 === _a ? void 0 : _a.count;
    return isNil_default(stateAnimationCounts) || Object.values(stateAnimationCounts).every((count) => 0 === count);
  }
  getAnimatorCount() {
    let count = 0;
    return this.animators.forEach((animators) => count += animators.length), count;
  }
  getAllAnimators() {
    const allAnimators = [];
    return this.animators.forEach((animators) => {
      allAnimators.push(...animators);
    }), allAnimators;
  }
  getElementAnimators(element, animationState) {
    var _a;
    const elements = array(element);
    let animators = [];
    return animationState ? animators = null !== (_a = this.animators.get(animationState)) && void 0 !== _a ? _a : [] : this.animators.forEach((stateAnimators) => {
      animators = animators.concat(stateAnimators);
    }), animators.filter((animator) => elements.includes(animator.element));
  }
  enable() {
    return this.isEnabled = true, this;
  }
  disable() {
    return this.isEnabled = false, this.stop(), this.animators.clear(), this;
  }
  enableAnimationState(state) {
    const states = array(state);
    return this.disabledStates = this.disabledStates.filter((state2) => !states.includes(state2)), this;
  }
  disableAnimationState(state) {
    const states = array(state);
    return this.disabledStates = this.disabledStates.concat(states), this;
  }
  release() {
    this.stop(), this.animators.clear(), this.configs = null, this.animators = null, this.elementRecorder = null, this.timelineCount = null;
  }
  animateByTimeline(config2, elements, parameters, forceState = false) {
    var _a;
    const animators = [], animatedElements = elements.filter((element) => {
      const checkExit = !(element.isReserved && element.diffState === DiffState.exit), state = this.getAnimationState(element), checkDisabled = !this.disabledStates.includes(state), checkState = forceState || state === config2.state, checkPartitioner = !config2.timeline.partitioner || config2.timeline.partitioner(element.getDatum(), element, parameters);
      return checkExit && checkDisabled && checkState && checkPartitioner;
    });
    if (animatedElements.length) {
      isNil_default(this.timelineCount[config2.id]) && (this.timelineCount[config2.id] = 0), config2.timeline.sort && animatedElements.sort((elementA, elementB) => config2.timeline.sort(elementA.getDatum(), elementB.getDatum(), elementA, elementB, parameters));
      const animationParameters = {
        width: this.mark.view.width(),
        height: this.mark.view.height(),
        group: null !== (_a = this.mark.group) && void 0 !== _a ? _a : null,
        mark: this.mark,
        view: this.mark.view,
        elementCount: animatedElements.length,
        elementIndex: 0
      };
      animatedElements.forEach((element, index) => {
        animationParameters.elementIndex = index;
        const mergedParameters = Object.assign({
          [DefaultAnimationParameters]: animationParameters
        }, parameters), animationUnit = this.getAnimationUnit(config2.timeline, element, index, animatedElements.length, mergedParameters);
        animators.push(this.animateElement(config2, animationUnit, element, animationParameters, mergedParameters));
      });
    }
    return animators;
  }
  animateElement(config2, animationUnit, element, animationParameters, parameters) {
    var _a, _b;
    const animator = new Animator(element, animationUnit, config2);
    if (animator.animate(animationParameters, parameters), !animator.isAnimating)
      return;
    element.diffState === DiffState.exit && (element.isReserved = true);
    const isFirstAnimator = 0 === this.timelineCount[config2.id];
    this.timelineCount[config2.id] += 1;
    const elementRecord = null !== (_a = this.elementRecorder.get(element)) && void 0 !== _a ? _a : {
      prevState: config2.state,
      count: {}
    };
    elementRecord.prevState = config2.state, elementRecord.count[config2.state] = (null !== (_b = elementRecord.count[config2.state]) && void 0 !== _b ? _b : 0) + 1, this.elementRecorder.set(element, elementRecord);
    const stateData = this.animators.get(config2.state);
    stateData ? stateData.push(animator) : this.animators.set(config2.state, [animator]), animator.callback(() => {
      this.handleAnimatorEnd(animator);
    });
    const animationEvent = {
      mark: this.mark,
      animationState: config2.state,
      animationConfig: config2.originConfig
    };
    return isFirstAnimator && this.mark.emit(HOOK_EVENT.ANIMATION_START, animationEvent), this.mark.emit(HOOK_EVENT.ELEMENT_ANIMATION_START, animationEvent, element), animator;
  }
  getAnimationState(element) {
    const customState = invokeFunctionType(this.state, this.mark.parameters(), element.getDatum(), element);
    return null != customState ? customState : element.diffState;
  }
  getAnimationUnit(timeline, element, index, elementCount, parameters) {
    const timeSlices = [], startTime = invokeAnimateSpec(timeline.startTime, element, parameters), totalTime = invokeAnimateSpec(timeline.totalTime, element, parameters), oneByOne = invokeAnimateSpec(timeline.oneByOne, element, parameters), loop = invokeAnimateSpec(timeline.loop, element, parameters);
    let loopTime = 0;
    timeline.timeSlices.forEach((timeSlice) => {
      var _a;
      const delay = invokeAnimateSpec(timeSlice.delay, element, parameters), delayAfter = invokeAnimateSpec(timeSlice.delayAfter, element, parameters), duration = null !== (_a = invokeAnimateSpec(timeSlice.duration, element, parameters)) && void 0 !== _a ? _a : totalTime / elementCount, effects = array(timeSlice.effects).map((effect) => Object.assign({}, effect, {
        customParameters: invokeAnimateSpec(effect.customParameters, element, parameters)
      }));
      timeSlices.push({
        effects,
        duration,
        delay,
        delayAfter
      }), loopTime += delay + duration + delayAfter;
    });
    const oneByOneDelay = isNumber_default(oneByOne) ? oneByOne : true === oneByOne ? loopTime : 0;
    return {
      initialDelay: startTime,
      loopCount: isNumber_default(loop) ? loop : true === loop ? 1 / 0 : 1,
      loopDelay: oneByOneDelay * index,
      loopDelayAfter: oneByOneDelay * (elementCount - index - 1),
      loopAnimateDuration: loopTime,
      loopDuration: loopTime + oneByOneDelay * (elementCount - 1),
      totalTime,
      timeSlices
    };
  }
  clearElementAnimation(element, clearElement = true) {
    this.animators.forEach((animators) => {
      animators.forEach((animator) => {
        animator.element === element && (animator.animationOptions.state === DiffState.exit ? animator.stop("start", false) : animator.stop("end", false), this.handleAnimatorEnd(animator, clearElement));
      });
    }), this.elementRecorder.delete(element);
  }
  clearAllElements() {
    const elements = this.mark.getAllElements();
    elements && elements.forEach((element, i) => {
      this.clearElement(element, i === elements.length - 1);
    });
  }
  clearElement(element, updateMark = true) {
    this.clearElementAnimation(element), element.getGraphicItem() && (element.clearGraphicAttributes(), element.diffState === DiffState.exit && (element.isReserved = false), updateMark && this.mark.cleanExitElements());
  }
  handleAnimatorEnd(animator, clearElement = true) {
    const element = animator.element, animationOptions = animator.animationOptions, animationState = animationOptions.state, isImmediateAnimation = animationState === ImmediateAnimationState, stateAnimationCounts = this.elementRecorder.get(element).count;
    stateAnimationCounts[animationState] -= 1, this.animators.set(animationState, this.animators.get(animationState).filter((ani) => ani !== animator)), 0 === this.animators.get(animationState).length && this.animators.delete(animationState), this.timelineCount[animationOptions.id] -= 1;
    const isLastAnimator = 0 === this.timelineCount[animationOptions.id], originAnimationConfig = isImmediateAnimation ? this.immediateConfigs.find((config2) => config2.id === animationOptions.id).originConfig : this.configs.find((config2) => config2.id === animationOptions.id).originConfig;
    isLastAnimator && (delete this.timelineCount[animationOptions.id], isImmediateAnimation && (this.immediateConfigs = this.immediateConfigs.filter((config2) => config2.id !== animationOptions.id))), clearElement && (0 === Object.keys(this.timelineCount).length ? this.clearAllElements() : animationState === DiffState.exit && 0 === stateAnimationCounts[DiffState.exit] && this.clearElement(element));
    const animationEvent = {
      mark: this.mark,
      animationState,
      animationConfig: originAnimationConfig
    };
    isLastAnimator && this.mark.emit(HOOK_EVENT.ANIMATION_END, animationEvent), this.mark.emit(HOOK_EVENT.ELEMENT_ANIMATION_END, animationEvent, element);
  }
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/view/mark
var Mark = class extends GrammarBase {
  constructor(view, markType, group) {
    super(view), this.grammarType = "mark", this.elements = [], this.elementMap = /* @__PURE__ */ new Map(), this.isUpdated = true, this._isReentered = false, this.animate = new Animate2(this, {}), this.differ = new Differ([]), this.markType = markType, this.spec.type = markType, this.spec.encode = {
      update: {}
    }, this.spec.group = group, group && (this.group = group, this.attach(group), group.appendChild(this));
  }
  parse(spec) {
    var _a, _b, _c;
    if (super.parse(spec), this.spec.group) {
      const groupMark2 = isString_default(this.spec.group) ? this.view.getMarkById(this.spec.group) : this.spec.group;
      this.detach(groupMark2);
    }
    const groupMark = isString_default(spec.group) ? this.view.getMarkById(spec.group) : spec.group;
    return this.attach(groupMark), this.join(null === (_a = spec.from) || void 0 === _a ? void 0 : _a.data, spec.key, spec.sort, spec.groupBy, spec.groupSort), this.coordinate(spec.coordinate), this.state(spec.state, this.spec.stateSort), Object.keys(null !== (_b = this.spec.encode) && void 0 !== _b ? _b : {}).forEach((state) => {
      this.encodeState(state, {}, true);
    }), Object.keys(null !== (_c = spec.encode) && void 0 !== _c ? _c : {}).forEach((state) => {
      this.encodeState(state, spec.encode[state]);
    }), this.animation(spec.animation), this.animationState(spec.animationState), this.morph(spec.morph, spec.morphKey, spec.morphElementKey), this.layout(spec.layout), this.configure(spec), this.transform(spec.transform), this.parseAddition(spec), this.spec = spec, this.markType = spec.type, this.commit(), this;
  }
  parameters() {
    var _a;
    return null !== (_a = this._finalParameters) && void 0 !== _a ? _a : super.parameters();
  }
  parseAddition(spec) {
    return this;
  }
  reuse(grammar) {
    if (grammar.grammarType !== this.grammarType)
      return this;
    const mark = grammar;
    return this.markType = mark.markType, this.coord = mark.coord, this.elementMap = mark.elementMap, this.elements = mark.elements, this.elementMap.forEach((element) => element.mark = this), this.differ = mark.differ, this.animate = mark.animate, this.animate.mark = this, this._context = mark._context, this.graphicItem = mark.graphicItem, this.graphicIndex = mark.graphicIndex, this.graphicParent = mark.graphicParent, this.needClear = mark.needClear, this.isUpdated = mark.isUpdated, this;
  }
  needLayout() {
    return !isNil_default(this.spec.layout);
  }
  handleLayoutEnd() {
  }
  handleRenderEnd() {
    this.needClear && (this.cleanExitElements(), this.elementMap.forEach((element) => {
      element.diffState === DiffState.exit ? element.clearGraphicAttributes() : element.clearChangedGraphicAttributes();
    }), this.differ.updateToCurrent(), this.needClear = false);
  }
  evaluateMainTasks(data, parameters) {
    var _a;
    if (this.needSkipBeforeLayout() && this.view.getLayoutState() === LayoutState.before)
      return this;
    const stage = null === (_a = this.view.renderer) || void 0 === _a ? void 0 : _a.stage();
    this.init(stage, parameters);
    const transformData = this.evaluateTransform(this._getTransformsBeforeJoin(), null != data ? data : DefaultMarkData, parameters);
    let inputData = (null == transformData ? void 0 : transformData.progressive) ? data : transformData;
    return this.evaluateGroup(inputData), this.renderContext = this.parseRenderContext(inputData, parameters), this.renderContext.progressive ? (this.differ.reset(), this.elementMap.clear(), this.evaluateProgressive()) : ((null == transformData ? void 0 : transformData.progressive) && (this.renderContext.parameters = parameters, this.renderContext.beforeTransformProgressive = transformData.progressive, inputData = transformData.progressive.output()), this.emit(HOOK_EVENT.BEFORE_MARK_JOIN), this.evaluateJoin(inputData), this.emit(HOOK_EVENT.AFTER_MARK_JOIN), this.emit(HOOK_EVENT.BEFORE_MARK_STATE), this.evaluateState(this.elements, this.spec.state, parameters), this.emit(HOOK_EVENT.AFTER_MARK_STATE), this.emit(HOOK_EVENT.BEFORE_MARK_ENCODE), this.evaluateEncode(this.elements, this._getEncoders(), parameters), this.emit(HOOK_EVENT.AFTER_MARK_ENCODE)), this.emit(HOOK_EVENT.BEFORE_MARK_UPDATE), this.update(this.spec), this.emit(HOOK_EVENT.AFTER_MARK_UPDATE), this;
  }
  evaluateGroup(data) {
    if (this.markType === GrammarMarkType.group)
      return;
    const res = groupData(null != data ? data : DefaultMarkData, this.spec.groupBy, this.spec.groupSort), groupKeys = res.keys;
    this._groupKeys = groupKeys, this._groupEncodeResult = null, this.differ.setCurrentData(res);
  }
  _getTransformsAfterEncodeItems() {
    return this.transforms && this.transforms.filter((entry) => "afterEncodeItems" === entry.markPhase);
  }
  _getTransformsAfterEncode() {
    return this.transforms && this.transforms.filter((entry) => isNil_default(entry.markPhase) || "afterEncode" === entry.markPhase);
  }
  _getTransformsBeforeJoin() {
    return this.transforms ? this.transforms.filter((entry) => "beforeJoin" === entry.markPhase) : [];
  }
  evaluate(data, parameters) {
    var _a;
    return this.evaluateMainTasks(data, parameters), (null === (_a = this.renderContext) || void 0 === _a ? void 0 : _a.progressive) || this.evaluateTransform(this._getTransformsAfterEncode(), this.elements, parameters), this;
  }
  output() {
    return this;
  }
  join(data, key, sort, groupBy2, groupSort) {
    return this.grammarSource && (this.detach(this.grammarSource), this.grammarSource = null), this.spec.from = null, isNil_default(data) || (isString_default(data) ? this.grammarSource = this.view.getDataById(data) : this.grammarSource = data, this.spec.from = {
      data
    }, this.attach(this.grammarSource)), this.spec.key = key, this.spec.sort = sort, this.spec.groupBy = groupBy2, this.spec.groupSort = groupSort, this.commit(), this;
  }
  coordinate(coordinate) {
    return isString_default(coordinate) ? this.coord = this.view.getCoordinateById(coordinate) : this.coord = coordinate, this.attach(this.coord), this.commit(), this;
  }
  state(state, stateSort) {
    return this.spec.stateSort = stateSort, this.setFunctionSpec(state, "state");
  }
  encode(channel, value, clear) {
    return this.encodeState(DiffState.update, channel, value, clear);
  }
  encodeState(state, channel, value, clear) {
    if (state === DiffState.enter && (this._isReentered = true), this.spec.encode[state]) {
      const lastEncoder = this.spec.encode[state];
      if (isFunctionType(lastEncoder))
        this.detach(parseEncodeType(lastEncoder, this.view));
      else {
        const isSingleChannel = isString_default(channel);
        isSingleChannel && clear || !isSingleChannel && value ? (Object.keys(lastEncoder).forEach((c3) => {
          this.detach(parseEncodeType(lastEncoder[c3], this.view));
        }), this.spec.encode[state] = {}) : isSingleChannel ? this.detach(parseEncodeType(lastEncoder[channel], this.view)) : Object.keys(channel).forEach((c3) => {
          this.detach(parseEncodeType(lastEncoder[c3], this.view));
        });
      }
    }
    return channel && (this.spec.encode[state] || (this.spec.encode[state] = {}), isString_default(channel) ? (this.spec.encode[state][channel] = value, this.attach(parseEncodeType(value, this.view))) : isFunctionType(channel) ? (this.spec.encode[state] = channel, this.attach(parseEncodeType(channel, this.view))) : channel && (Object.assign(this.spec.encode[state], channel), Object.values(channel).forEach((channelEncoder) => {
      this.attach(parseEncodeType(channelEncoder, this.view));
    }))), this.commit(), this;
  }
  _getEncoders() {
    var _a;
    return null !== (_a = this.spec.encode) && void 0 !== _a ? _a : {};
  }
  animation(animationConfig2) {
    return this.spec.animation = animationConfig2, this;
  }
  animationState(animationState) {
    return this.setFunctionSpec(animationState, "animationState");
  }
  layout(layout) {
    return this.spec.layout = layout, this.commit(), this;
  }
  morph(enableMorph, morphKey, morphElementKey) {
    return this.spec.morph = enableMorph, this.spec.morphKey = morphKey, this.spec.morphElementKey = morphElementKey, this;
  }
  transform(transforms) {
    const prevTransforms = parseTransformSpec(this.spec.transform, this.view);
    prevTransforms && (this.detach(prevTransforms.refs), this.transforms = []);
    const nextTransforms = parseTransformSpec(transforms, this.view);
    return nextTransforms && (this.attach(nextTransforms.refs), this.transforms = nextTransforms.transforms), this.spec.transform = transforms, this.commit(), this;
  }
  configure(config2) {
    const keys2 = ["clip", "clipPath", "zIndex", "interactive", "context", "setCustomizedShape", "large", "largeThreshold", "progressiveStep", "progressiveThreshold", "support3d", "morph", "morphKey", "morphElementKey", "attributeTransforms", "skipTheme", "enableSegments", "stateSort"];
    return null === config2 ? (keys2.forEach((key) => {
      isNil_default(this.spec[key]) || (this.spec[key] = void 0);
    }), this) : (keys2.forEach((key) => {
      isNil_default(config2[key]) || (this.spec[key] = config2[key]);
    }), this);
  }
  context(context) {
    return this.spec.context = context, this._context = context, this;
  }
  isCollectionMark() {
    return CollectionMarkType.includes(this.markType);
  }
  needAnimate() {
    var _a;
    return !(null === (_a = this.renderContext) || void 0 === _a ? void 0 : _a.progressive) && !isNil_default(this.spec.animation);
  }
  getAllElements() {
    const elements = this.elements.slice();
    return this.elementMap.forEach((element) => {
      element.diffState !== DiffState.exit || elements.includes(element) || elements.push(element);
    }), this.spec.sort && elements.sort((elementA, elementB) => this.spec.sort(elementA.getDatum(), elementB.getDatum())), elements;
  }
  getScales() {
    const scales = {};
    return this.references.forEach((count, ref) => {
      ref.grammarType === GrammarTypeEnum.scale && (scales[ref.id()] = ref.output());
    }), scales;
  }
  getScalesByChannel() {
    const encoders = this.spec.encode;
    if (!encoders)
      return {};
    const res = {}, params2 = this.parameters();
    return Object.keys(encoders).forEach((state) => {
      const useEncoders = encoders[state];
      useEncoders && !isFunctionType(useEncoders) && Object.keys(useEncoders).forEach((channel) => {
        isScaleEncode(useEncoders[channel]) && (res[channel] = getGrammarOutput(useEncoders[channel].scale, params2));
      });
    }), res;
  }
  getFieldsByChannel() {
    const encoders = this.spec.encode;
    if (!encoders)
      return {};
    const res = {};
    return Object.keys(encoders).forEach((state) => {
      const useEncoders = encoders[state];
      isFunctionType(useEncoders) || Object.keys(useEncoders).forEach((channel) => {
        isFieldEncode(useEncoders[channel]) && (res[channel] = useEncoders[channel].field);
      });
    }), res;
  }
  init(stage, parameters) {
    var _a, _b, _c, _d;
    if (this._delegateEvent || (this._delegateEvent = (event, type) => {
      var _a2;
      const activeElement = null === (_a2 = event.target) || void 0 === _a2 ? void 0 : _a2[BridgeElementKey];
      if ((null == activeElement ? void 0 : activeElement.mark) === this) {
        const extendedEvt = getExtendedEvents(this.view, event, activeElement, type, EVENT_SOURCE_VIEW);
        this.emitGrammarEvent(type, extendedEvt, activeElement);
      }
    }, this.initEvent()), this.animate || (this.animate = new Animate2(this, this.spec.animation), this.needAnimate() && this.animate.updateState(this.spec.animationState)), !this.group) {
      const group = getGrammarOutput(this.spec.group, parameters);
      this.group = group, group && group.appendChild(this);
    }
    const groupGraphicItem = this.group ? this.group.getGroupGraphicItem() : stage.defaultLayer, markIndex = null !== (_c = null === (_b = null === (_a = this.group) || void 0 === _a ? void 0 : _a.children) || void 0 === _b ? void 0 : _b.indexOf(this)) && void 0 !== _c ? _c : 0;
    if (this.markType !== GrammarMarkType.group) {
      if (!this.graphicItem) {
        const graphicItem = createGraphicItem(this, GrammarMarkType.group, {
          pickable: false,
          zIndex: null !== (_d = this.spec.zIndex) && void 0 !== _d ? _d : 0
        });
        (this.spec.support3d || Mark3DType.includes(this.markType)) && graphicItem.setMode("3d"), graphicItem.name = `${this.id() || this.markType}`, this.graphicItem = graphicItem;
      }
      this.graphicParent = this.graphicItem, !groupGraphicItem || this.graphicIndex === markIndex && this.graphicItem.parent === groupGraphicItem || groupGraphicItem.insertIntoKeepIdx(this.graphicItem, markIndex);
    } else
      this.graphicParent = groupGraphicItem;
    this.graphicIndex = markIndex;
  }
  update(spec) {
    if (this._context = this.spec.context, this.isUpdated = true, this.renderContext.progressive || (spec.animation && this.animate.updateConfig(spec.animation), this.animate.updateState(spec.animationState)), this.markType !== GrammarMarkType.group) {
      if (isNil_default(spec.zIndex) || this.graphicItem.setAttribute("zIndex", spec.zIndex), isNil_default(spec.clip) || this.graphicItem.setAttribute("clip", spec.clip), !isNil_default(spec.clipPath)) {
        const paths = isArray_default(spec.clipPath) ? spec.clipPath : spec.clipPath(this.elements);
        paths && paths.length ? this.graphicItem.setAttribute("path", paths) : this.graphicItem.setAttributes({
          path: paths,
          clip: false
        });
      }
      this.elementMap.forEach((element) => {
        element.updateGraphicItem();
      });
    } else
      this.elementMap.forEach((element) => {
        element.updateGraphicItem();
      });
  }
  evaluateJoin(data) {
    var _a, _b, _c, _d;
    this.needClear = true;
    const keyGetter = parseField(null !== (_c = null !== (_a = this.spec.key) && void 0 !== _a ? _a : null === (_b = this.grammarSource) || void 0 === _b ? void 0 : _b.getDataIDKey()) && void 0 !== _c ? _c : () => DefaultKey), groupKeyGetter = parseField(null !== (_d = this.spec.groupBy) && void 0 !== _d ? _d : () => DefaultKey), sort = this.spec.sort, isCollectionMark = this.isCollectionMark(), enterElements = new Set(this.elements.filter((element) => element.diffState === DiffState.enter)), elements = [];
    this.differ.setCallback((key, data2, prevData) => {
      const elementKey = key;
      let element;
      if (isNil_default(data2))
        element = this.elementMap.get(elementKey), element && (element.diffState = DiffState.exit);
      else if (isNil_default(prevData)) {
        if (element = this.elementMap.has(elementKey) ? this.elementMap.get(elementKey) : createElement(this), element.diffState === DiffState.exit) {
          element.diffState = DiffState.enter;
          this.animate.getElementAnimators(element, DiffState.exit).forEach((animator) => animator.stop("start"));
        }
        element.diffState = DiffState.enter;
        const groupKey = isCollectionMark ? key : groupKeyGetter(data2[0]);
        element.updateData(groupKey, data2, keyGetter, this.view), this.elementMap.set(elementKey, element), elements.push(element);
      } else if (element = this.elementMap.get(elementKey), element) {
        element.diffState = DiffState.update;
        const groupKey = isCollectionMark ? key : groupKeyGetter(data2[0]);
        element.updateData(groupKey, data2, keyGetter, this.view), elements.push(element);
      }
      enterElements.delete(element);
    });
    const currentData = null != data ? data : DefaultMarkData;
    isCollectionMark || this.differ.setCurrentData(groupData(currentData, (datum) => `${groupKeyGetter(datum)}-${keyGetter(datum)}`, void 0)), this.differ.doDiff(), enterElements.forEach((element) => {
      this.elementMap.delete(isCollectionMark ? element.groupKey : `${element.groupKey}-${element.key}`), element.remove(), element.release();
    }), this.elements = elements, sort && this.elements.length >= 2 && this.elements.sort((elementA, elementB) => sort(elementA.getDatum(), elementB.getDatum()));
  }
  evaluateState(elements, stateSpec, parameters) {
    stateSpec && elements.forEach((element) => {
      element.state(stateSpec, parameters);
    });
  }
  evaluateGroupEncode(elements, groupEncode, parameters) {
    if (!this._groupKeys || !groupEncode)
      return;
    const res = {};
    return this._groupKeys.forEach((key) => {
      const el = elements.find((el2) => el2.groupKey === key);
      el && (res[key] = invokeEncoder(groupEncode, el.items && el.items[0] && el.items[0].datum, el, parameters));
    }), this._groupEncodeResult = res, res;
  }
  getChannelsFromConfig(element) {
    const spec = this.spec;
    return isNil_default(spec.interactive) ? null : {
      pickable: spec.interactive
    };
  }
  evaluateEncode(elements, encoders, parameters, noGroupEncode) {
    const initAttrs = this.getChannelsFromConfig();
    if (encoders) {
      this.emit(HOOK_EVENT.BEFORE_ELEMENT_ENCODE, {
        encoders,
        parameters
      }, this);
      const groupEncodeAttrs = noGroupEncode ? null : this.evaluateGroupEncode(elements, encoders[BuiltInEncodeNames.group], parameters);
      elements.forEach((element) => {
        this.markType === GrammarMarkType.glyph && this._groupEncodeResult ? element.items.forEach((item) => {
          item.nextAttrs = Object.assign(item.nextAttrs, initAttrs, this._groupEncodeResult[element.groupKey]);
        }) : (null == groupEncodeAttrs ? void 0 : groupEncodeAttrs[element.groupKey]) && !this.isCollectionMark() ? element.items.forEach((item) => {
          item.nextAttrs = Object.assign(item.nextAttrs, initAttrs, groupEncodeAttrs[element.groupKey]);
        }) : initAttrs && element.items.forEach((item) => {
          item.nextAttrs = Object.assign(item.nextAttrs, initAttrs);
        }), element.encodeItems(element.items, encoders, this._isReentered, parameters);
      }), this._isReentered = false, this.evaluateTransform(this._getTransformsAfterEncodeItems(), elements, parameters), elements.forEach((element) => {
        element.encodeGraphic(this.isCollectionMark() ? null == groupEncodeAttrs ? void 0 : groupEncodeAttrs[element.groupKey] : null);
      }), this.emit(HOOK_EVENT.AFTER_ELEMENT_ENCODE, {
        encoders,
        parameters
      }, this);
    } else
      elements.forEach((element) => {
        element.initGraphicItem(initAttrs);
      });
  }
  addGraphicItem(attrs, groupKey, newGraphicItem) {
    var _a;
    const graphicItem = null != newGraphicItem ? newGraphicItem : createGraphicItem(this, this.markType, attrs);
    if (graphicItem) {
      if (null === (_a = this.renderContext) || void 0 === _a ? void 0 : _a.progressive) {
        let group;
        if (this._groupKeys) {
          const index = this._groupKeys.indexOf(groupKey);
          index >= 0 && (group = this.graphicParent.getChildAt(index));
        } else
          group = this.graphicParent.at(0);
        this.isCollectionMark() ? (graphicItem.incremental = 1, group.appendChild(graphicItem)) : group.incrementalAppendChild(graphicItem);
      } else
        this.graphicParent.appendChild(graphicItem);
      return graphicItem;
    }
  }
  parseRenderContext(data, parameters) {
    const enableProgressive = this.markType !== GrammarMarkType.group && this.spec.progressiveStep > 0 && this.spec.progressiveThreshold > 0 && this.spec.progressiveStep < this.spec.progressiveThreshold, large = this.spec.large && this.spec.largeThreshold > 0 && data.length >= this.spec.largeThreshold;
    if (enableProgressive) {
      const groupedData = this.differ.getCurrentData();
      return groupedData && groupedData.keys && groupedData.keys.some((key) => groupedData.data.get(key).length > this.spec.progressiveThreshold) ? {
        large,
        parameters,
        progressive: {
          data,
          step: this.spec.progressiveStep,
          currentIndex: 0,
          totalStep: groupedData.keys.reduce((total, key) => Math.max(Math.ceil(groupedData.data.get(key).length / this.spec.progressiveStep), total), 1),
          groupedData: groupedData.data
        }
      } : {
        large
      };
    }
    return {
      large
    };
  }
  isProgressive() {
    return this.renderContext && (!!this.renderContext.progressive || !!this.renderContext.beforeTransformProgressive);
  }
  isDoingProgressive() {
    return this.renderContext && (this.renderContext.progressive && this.renderContext.progressive.currentIndex < this.renderContext.progressive.totalStep || this.renderContext.beforeTransformProgressive && this.renderContext.beforeTransformProgressive.unfinished());
  }
  clearProgressive() {
    this.renderContext && this.renderContext.progressive && (this.elements = [], this.graphicParent.children.forEach((group) => {
      group.incrementalClearChild();
    }), this.graphicParent.removeAllChild()), this.renderContext && this.renderContext.beforeTransformProgressive && this.renderContext.beforeTransformProgressive.release(), this.renderContext = null;
  }
  restartProgressive() {
    this.renderContext && this.renderContext.progressive && (this.renderContext.progressive.currentIndex = 0);
  }
  evaluateJoinProgressive() {
    var _a, _b, _c;
    const currentIndex = this.renderContext.progressive.currentIndex, keyGetter = parseField(null !== (_c = null !== (_a = this.spec.key) && void 0 !== _a ? _a : null === (_b = this.grammarSource) || void 0 === _b ? void 0 : _b.getDataIDKey()) && void 0 !== _c ? _c : () => DefaultKey), elements = [];
    if (this.isCollectionMark())
      return this._groupKeys.forEach((key, index) => {
        const data = this.renderContext.progressive.groupedData.get(key), groupStep = this.renderContext.progressive.step, dataSlice = data.slice(currentIndex * groupStep, (currentIndex + 1) * groupStep);
        if (0 === currentIndex) {
          const element = createElement(this);
          element.diffState = DiffState.enter, element.updateData(key, dataSlice, keyGetter, this.view), elements.push(element);
        } else {
          const element = this.elements[index];
          element.updateData(key, dataSlice, keyGetter, this.view), elements.push(element);
        }
      }), elements;
    const groupElements = {};
    return this._groupKeys.forEach((key) => {
      const data = this.renderContext.progressive.groupedData.get(key), groupStep = this.renderContext.progressive.step, dataSlice = data.slice(currentIndex * groupStep, (currentIndex + 1) * groupStep), group = [];
      dataSlice.forEach((entry) => {
        const element = createElement(this);
        element.diffState = DiffState.enter, element.updateData(key, [entry], keyGetter, this.view), group.push(element), elements.push(element);
      }), groupElements[key] = group;
    }), {
      groupElements,
      elements
    };
  }
  evaluateEncodeProgressive(elements, encoders, parameters) {
    const progressiveIndex = this.renderContext.progressive.currentIndex;
    if (0 === progressiveIndex) {
      if (this.evaluateEncode(elements, encoders, parameters), 0 === progressiveIndex && this._groupEncodeResult && !this.isCollectionMark() && this.markType !== GrammarMarkType.glyph) {
        const firstElement = elements[0], firstChild = firstElement.getGraphicItem(), group = null == firstChild ? void 0 : firstChild.parent;
        group && this._groupEncodeResult[firstElement.groupKey] && group.setTheme({
          common: this._groupEncodeResult[firstElement.groupKey]
        });
      }
    } else
      this.evaluateEncode(elements, encoders, parameters, true);
  }
  evaluateProgressive() {
    var _a, _b, _c;
    if (null === (_a = this.renderContext) || void 0 === _a ? void 0 : _a.beforeTransformProgressive) {
      this.renderContext.beforeTransformProgressive.progressiveRun();
      const output = this.renderContext.beforeTransformProgressive.output();
      return this.emit(HOOK_EVENT.BEFORE_MARK_JOIN), this.evaluateJoin(output), this.emit(HOOK_EVENT.AFTER_MARK_JOIN), this.emit(HOOK_EVENT.BEFORE_MARK_STATE), this.evaluateState(this.elements, this.spec.state, this.renderContext.parameters), this.emit(HOOK_EVENT.AFTER_MARK_STATE), this.emit(HOOK_EVENT.BEFORE_MARK_ENCODE), this.evaluateEncode(this.elements, this._getEncoders(), this.renderContext.parameters), void this.emit(HOOK_EVENT.AFTER_MARK_ENCODE);
    }
    if (!(null === (_b = this.renderContext) || void 0 === _b ? void 0 : _b.progressive))
      return;
    const parameters = this.renderContext.parameters;
    this.emit(HOOK_EVENT.BEFORE_MARK_JOIN);
    const result2 = this.evaluateJoinProgressive(), elements = Array.isArray(result2) ? result2 : result2.elements;
    if (this.emit(HOOK_EVENT.AFTER_MARK_JOIN), 0 === this.renderContext.progressive.currentIndex ? (this.graphicParent.removeAllChild(), this._groupKeys.forEach((key) => {
      const graphicItem = createGraphicItem(this, GrammarMarkType.group, {
        pickable: false,
        zIndex: this.spec.zIndex
      });
      graphicItem.incremental = this.renderContext.progressive.step, this.graphicParent.appendChild(graphicItem);
    }), this.elements = elements) : this.elements = this.elements.concat(elements), this.emit(HOOK_EVENT.BEFORE_MARK_STATE), this.evaluateState(elements, this.spec.state, parameters), this.emit(HOOK_EVENT.AFTER_MARK_STATE), this.emit(HOOK_EVENT.BEFORE_MARK_ENCODE), Array.isArray(result2))
      this.evaluateEncodeProgressive(elements, this._getEncoders(), parameters);
    else {
      const groupElements = result2.groupElements;
      Object.keys(groupElements).forEach((key) => {
        this.evaluateEncodeProgressive(groupElements[key], this._getEncoders(), parameters);
      });
    }
    this.emit(HOOK_EVENT.AFTER_MARK_ENCODE);
    const progressiveTransforms = null === (_c = this._getTransformsAfterEncode()) || void 0 === _c ? void 0 : _c.filter((entry) => true === entry.canProgressive);
    (null == progressiveTransforms ? void 0 : progressiveTransforms.length) && this.evaluateTransform(progressiveTransforms, this.elements, parameters), this.renderContext.progressive.currentIndex += 1;
  }
  isLargeMode() {
    return this.renderContext && this.renderContext.large;
  }
  cleanExitElements() {
    this.elementMap.forEach((element, key) => {
      element.diffState !== DiffState.exit || element.isReserved || (this.elementMap.delete(key), element.remove(), element.release());
    });
  }
  getGroupGraphicItem() {
    if (this.elements && this.elements[0] && this.elements[0].getGraphicItem)
      return this.elements[0].getGraphicItem();
  }
  getBounds() {
    var _a;
    return this.graphicItem ? this.graphicItem.AABBBounds : null === (_a = this.getGroupGraphicItem()) || void 0 === _a ? void 0 : _a.AABBBounds;
  }
  getMorphConfig() {
    var _a;
    return {
      morph: null !== (_a = this.spec.morph) && void 0 !== _a && _a,
      morphKey: this.spec.morphKey,
      morphElementKey: this.spec.morphElementKey
    };
  }
  getAttributeTransforms() {
    var _a;
    return null !== (_a = this.spec.attributeTransforms) && void 0 !== _a ? _a : transformsByType[this.markType];
  }
  getContext() {
    return this._context;
  }
  needSkipBeforeLayout() {
    var _a, _b;
    if (true === (null === (_a = this.spec.layout) || void 0 === _a ? void 0 : _a.skipBeforeLayouted))
      return true;
    let group = this.group;
    for (; group; ) {
      if (true === (null === (_b = group.getSpec().layout) || void 0 === _b ? void 0 : _b.skipBeforeLayouted))
        return true;
      group = group.group;
    }
    return false;
  }
  initEvent() {
    if (this._delegateEvent) {
      const stage = this.view.renderer.stage();
      stage && stage.on("*", this._delegateEvent);
    }
  }
  releaseEvent() {
    if (this._delegateEvent) {
      const stage = this.view.renderer.stage();
      stage && stage.off("*", this._delegateEvent);
    }
  }
  clear() {
    var _a;
    this.releaseEvent(), this.transforms = null, this.elementMap = null, this.elements = null, this.graphicItem = null, this.animate = null, null === (_a = this.group) || void 0 === _a || _a.removeChild(this), this.group = null, super.clear();
  }
  prepareRelease() {
    this.animate.stop(), this.elementMap.forEach((element) => element.diffState = DiffState.exit), this._finalParameters = this.parameters();
  }
  release() {
    this.releaseEvent(), this.elements.forEach((element) => element.release()), this.elementMap.clear(), this._finalParameters = null, this.animate && this.animate.release(), this.graphicItem && removeGraphicItem(this.graphicItem), this.detachAll(), super.release();
  }
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/view/group
var GroupMark = class extends Mark {
  constructor(view, group) {
    super(view, GrammarMarkType.group, group), this.children = [];
  }
  parseRenderContext() {
    return {
      large: false
    };
  }
  appendChild(mark) {
    return this.children.push(mark), this;
  }
  removeChild(mark) {
    return this.children = this.children.filter((child) => child !== mark), this;
  }
  includesChild(mark, descendant = true) {
    return !!this.children.includes(mark) || !!descendant && this.children.some((child) => child.markType === GrammarMarkType.group && child.includesChild(mark, true));
  }
  updateLayoutChildren() {
    return this.children.length ? (this.layoutChildren || (this.layoutChildren = []), this.layoutChildren = this.children.filter((child) => child.needLayout()), this) : this;
  }
  getAttributeTransforms() {
    return transformsByType.rect;
  }
  evaluateJoin(data) {
    if (!this.elements.length) {
      const el = createElement(this);
      el.updateData(DefaultKey, DefaultMarkData, () => "", this.view), this.elements = [el], this.elementMap.set(DefaultKey, el);
    }
  }
  getChannelsFromConfig(element) {
    const spec = this.spec, initAttrs = {};
    if (isNil_default(spec.clip) || (initAttrs.clip = spec.clip), isNil_default(spec.zIndex) || (initAttrs.zIndex = spec.zIndex), !isNil_default(spec.clipPath)) {
      const paths = isFunction_default(spec.clipPath) ? spec.clipPath([element]) : spec.clipPath;
      paths && paths.length ? initAttrs.path = paths : (initAttrs.path = null, initAttrs.clip = false);
    }
    return isNil_default(spec.interactive) || (initAttrs.pickable = spec.interactive), initAttrs;
  }
  evaluateGroupEncode(elements, groupEncode, parameters) {
    var _a;
    const el = this.elements[0], nextAttrs = {}, items = [Object.assign({}, null === (_a = el.items) || void 0 === _a ? void 0 : _a[0], {
      nextAttrs
    })];
    return invokeEncoderToItems(el, items, groupEncode, parameters), this._groupEncodeResult = nextAttrs, nextAttrs;
  }
  evaluateEncode(elements, encoders, parameters, noGroupEncode) {
    const initAttrs = this.getChannelsFromConfig();
    if (encoders) {
      this.emit(HOOK_EVENT.BEFORE_ELEMENT_ENCODE, {
        encoders,
        parameters
      }, this);
      const groupEncodeAttrs = noGroupEncode ? null : this.evaluateGroupEncode(elements, encoders[BuiltInEncodeNames.group], parameters);
      elements.forEach((element) => {
        element.items.forEach((item) => {
          item.nextAttrs = Object.assign(item.nextAttrs, initAttrs, groupEncodeAttrs);
        }), element.encodeItems(element.items, encoders, this._isReentered, parameters);
      }), this._isReentered = false, this.evaluateTransform(this._getTransformsAfterEncodeItems(), elements, parameters), elements.forEach((element) => {
        element.encodeGraphic();
      }), this.emit(HOOK_EVENT.AFTER_ELEMENT_ENCODE, {
        encoders,
        parameters
      }, this);
    } else
      elements.forEach((element) => {
        element.initGraphicItem(initAttrs);
      });
  }
  addGraphicItem(attrs, groupKey, newGraphicItem) {
    const graphicItem = null != newGraphicItem ? newGraphicItem : createGraphicItem(this, this.markType, attrs);
    if (graphicItem)
      return this.emit(HOOK_EVENT.BEFORE_ADD_VRENDER_MARK, {
        graphicItem
      }), graphicItem.name = `${this.id() || this.markType}`, this.graphicParent.insertIntoKeepIdx(graphicItem, this.graphicIndex), this.emit(HOOK_EVENT.AFTER_ADD_VRENDER_MARK, {
        graphicItem
      }), graphicItem;
  }
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/layout/grid
function parseTemplate(template, total) {
  if (isValidNumber_default(template))
    return template;
  const trimmedTemplate = template.trim();
  if ("auto" === trimmedTemplate)
    return 0;
  if (trimmedTemplate.endsWith("%")) {
    const percent = parseFloat(trimmedTemplate.substring(0, trimmedTemplate.length - 1));
    return isValidNumber_default(percent) ? percent * total : 0;
  }
  return 0;
}
function computeGrid(layout, width, height) {
  var _a, _b, _c, _d;
  const templateRows = null !== (_a = layout.gridTemplateRows) && void 0 !== _a ? _a : [height], templateColumns = null !== (_b = layout.gridTemplateColumns) && void 0 !== _b ? _b : [width], rowGap = null !== (_c = layout.gridRowGap) && void 0 !== _c ? _c : 0, columnGap = null !== (_d = layout.gridColumnGap) && void 0 !== _d ? _d : 0, rows = templateRows.map((row) => parseTemplate(row, height)), columns = templateColumns.map((column) => parseTemplate(column, width)), rowAuto = Math.max(0, rows.reduce((left2, row) => left2 - row, height) - rows.length * rowGap) / templateRows.filter((row) => "auto" === row).length, columnAuto = Math.max(0, columns.reduce((left2, column) => left2 - column, width) - columns.length * columnGap) / templateColumns.filter((column) => "auto" === column).length;
  let lastRow = 0;
  const accumulateRows = rows.map((row, index) => {
    const finalRow = "auto" === templateRows[index] ? rowAuto : row, last2 = lastRow;
    return lastRow += finalRow + rowGap, last2;
  });
  accumulateRows.push(lastRow);
  let lastColumn = 0;
  const accumulateColumns = columns.map((column, index) => {
    const finalColumn = "auto" === templateColumns[index] ? columnAuto : column, last2 = lastColumn;
    return lastColumn += finalColumn + columnGap, last2;
  });
  return accumulateColumns.push(lastColumn), {
    rows: accumulateRows,
    columns: accumulateColumns,
    rowGap,
    columnGap
  };
}
function normalizeIndex(index, count) {
  return Math.min(index < 0 ? index + count : index - 1, count);
}
function normalizeStartEndIndex(start, end, count) {
  let finalStart = normalizeIndex(start, count), finalEnd = normalizeIndex(end, count);
  if (isValidNumber_default(start) || isValidNumber_default(end) ? isValidNumber_default(start) ? isValidNumber_default(end) || (finalStart = normalizeIndex(Math.max(0, finalEnd - 1), count)) : finalEnd = normalizeIndex(finalStart + 1, count) : (finalStart = 1, finalEnd = 2), finalStart > finalEnd) {
    const temp3 = finalEnd;
    finalEnd = finalStart, finalStart = temp3;
  }
  return {
    start: finalStart,
    end: finalEnd
  };
}
function getCellBounds(grid2, rowStart, rowEnd, columnStart, columnEnd) {
  const rowCount = grid2.rows.length, columnCount = grid2.columns.length, { start: finalRowStart, end: finalRowEnd } = normalizeStartEndIndex(rowStart, rowEnd, rowCount), { start: finalColumnStart, end: finalColumnEnd } = normalizeStartEndIndex(columnStart, columnEnd, columnCount), x14 = grid2.columns[finalRowStart], x23 = grid2.columns[finalRowEnd] - (finalColumnEnd === columnCount ? 0 : grid2.columnGap), y14 = grid2.rows[finalColumnStart], y23 = grid2.rows[finalColumnEnd] - (finalRowEnd === rowCount ? 0 : grid2.rowGap);
  return new Bounds().set(x14, y14, x23, y23);
}
var doGridLayout = (group, children, parentLayoutBounds, options) => {
  const grid2 = computeGrid(group.getSpec().layout, parentLayoutBounds.width(), parentLayoutBounds.height());
  children && children.forEach((mark) => {
    const markLayout = mark.getSpec().layout;
    mark.layoutBounds = getCellBounds(grid2, markLayout.gridRowStart, markLayout.gridRowEnd, markLayout.gridColumnStart, markLayout.gridColumnEnd), mark.commit();
  });
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/layout/relative
var defaultLayoutOrder = {
  [ComponentEnum.axis]: 0,
  [ComponentEnum.legend]: 1,
  [ComponentEnum.slider]: 2,
  [ComponentEnum.player]: 3,
  [ComponentEnum.datazoom]: 4
};
var getLayoutOrderOfMark = (mark) => {
  var _a, _b, _c;
  return null !== (_b = null === (_a = mark.getSpec().layout) || void 0 === _a ? void 0 : _a.order) && void 0 !== _b ? _b : "component" === mark.markType && null !== (_c = defaultLayoutOrder[mark.componentType]) && void 0 !== _c ? _c : 1 / 0;
};
var doRelativeLayout = (group, children, parentLayoutBounds, options) => {
  const viewBounds = parentLayoutBounds.clone(), groupLayoutSpec = group.getSpec().layout, maxChildWidth = toPercent(groupLayoutSpec.maxChildWidth, viewBounds.width()), maxChildHeight = toPercent(groupLayoutSpec.maxChildHeight, viewBounds.width());
  let minDeltaX1 = 0, minDeltaX2 = 0, minDeltaY1 = 0, minDeltaY2 = 0;
  children.forEach((child) => {
    const layoutSpec = child.getSpec().layout, padding = normalizePadding2(layoutSpec.padding), bounds = options.parseMarkBounds ? options.parseMarkBounds(child.getBounds(), child) : child.getBounds();
    if ("top" === layoutSpec.position || "bottom" === layoutSpec.position) {
      const childHeight = Math.min(bounds.height() + padding.top + padding.bottom, maxChildHeight);
      "top" === layoutSpec.position ? viewBounds.y1 += childHeight : viewBounds.y2 -= childHeight, bounds.x1 < parentLayoutBounds.x1 && (minDeltaX1 = Math.max(minDeltaX1, parentLayoutBounds.x1 - bounds.x1)), bounds.x2 > parentLayoutBounds.x2 && (minDeltaX2 = Math.max(minDeltaX2, bounds.x2 - parentLayoutBounds.x2));
    }
    if ("left" === layoutSpec.position || "right" === layoutSpec.position) {
      const childWidth = Math.min(bounds.width() + padding.left + padding.right, maxChildWidth);
      "left" === layoutSpec.position ? viewBounds.x1 += childWidth : viewBounds.x2 -= childWidth, bounds.y1 < parentLayoutBounds.y1 && (minDeltaY1 = Math.max(minDeltaY1, parentLayoutBounds.y1 - bounds.y1)), bounds.y2 > parentLayoutBounds.y2 && (minDeltaY2 = Math.max(minDeltaY2, bounds.y2 - parentLayoutBounds.y2));
    }
    "outside" === layoutSpec.position && (viewBounds.x1 += Math.max(parentLayoutBounds.x1 - bounds.x1, 0) + padding.left, viewBounds.x2 -= Math.max(bounds.x2 - parentLayoutBounds.x2, 0) + padding.right, viewBounds.y1 += Math.max(parentLayoutBounds.y1 - bounds.y1, 0) + padding.top, viewBounds.y2 -= Math.max(bounds.y2 - parentLayoutBounds.y2) + padding.bottom);
  }), minDeltaX1 > viewBounds.x1 - parentLayoutBounds.x1 && minDeltaX1 < parentLayoutBounds.width() && (viewBounds.x1 = parentLayoutBounds.x1 + minDeltaX1), minDeltaX2 > parentLayoutBounds.x2 - viewBounds.x2 && minDeltaX2 < parentLayoutBounds.width() && (viewBounds.x2 = parentLayoutBounds.x2 - minDeltaX2), minDeltaY1 > viewBounds.y1 - parentLayoutBounds.y1 && minDeltaY1 < parentLayoutBounds.height() && (viewBounds.y1 = parentLayoutBounds.y1 + minDeltaY1), minDeltaY2 > parentLayoutBounds.y2 - viewBounds.y2 && minDeltaY2 < parentLayoutBounds.height() && (viewBounds.y2 = parentLayoutBounds.y2 - minDeltaY2);
  let curTopY = viewBounds.y1, curBottomY = viewBounds.y2, curLeftX = viewBounds.x1, curRightX = viewBounds.x2;
  const sortedChildren = children.slice().sort((markA, markB) => getLayoutOrderOfMark(markA) - getLayoutOrderOfMark(markB));
  for (let i = 0, len = sortedChildren.length; i < len; i++) {
    const child = sortedChildren[i], layoutSpec = child.getSpec().layout, padding = normalizePadding2(layoutSpec.padding), bounds = options.parseMarkBounds ? options.parseMarkBounds(child.getBounds(), child) : child.getBounds();
    if ("top" === layoutSpec.position || "bottom" === layoutSpec.position) {
      const childHeight = Math.min(bounds.height() + padding.top + padding.bottom, maxChildHeight);
      if ("top" === layoutSpec.position ? (child.layoutBounds = new Bounds().set(viewBounds.x1, curTopY - childHeight, viewBounds.x2, curTopY), curTopY -= childHeight) : (child.layoutBounds = new Bounds().set(viewBounds.x1, curBottomY, viewBounds.x2, curBottomY + childHeight), curBottomY += childHeight), child.relativePosition = {
        top: child.layoutBounds.y1 - viewBounds.y1,
        bottom: child.layoutBounds.y1 - viewBounds.y2
      }, layoutSpec.align) {
        const childWidth = bounds.width() + padding.left + padding.right;
        childWidth < viewBounds.width() && ("center" === layoutSpec.align ? (child.layoutBounds.x1 = (viewBounds.x1 + viewBounds.x2) / 2 - childWidth / 2, child.layoutBounds.x2 = child.layoutBounds.x1 + childWidth, child.relativePosition.left = child.relativePosition.right = (viewBounds.width() - childWidth) / 2) : "right" === layoutSpec.align ? (child.layoutBounds.x1 = viewBounds.x2 - childWidth, child.layoutBounds.x2 = viewBounds.x2, child.relativePosition.right = 0, child.relativePosition.left = viewBounds.width() - childWidth) : "left" === layoutSpec.align && (child.layoutBounds.x1 = viewBounds.x1, child.layoutBounds.x2 = viewBounds.x1 + childWidth, child.relativePosition.left = 0, child.relativePosition.right = viewBounds.width() - childWidth));
      }
    } else if ("left" === layoutSpec.position || "right" === layoutSpec.position) {
      const childWidth = Math.min(bounds.width() + padding.left + padding.right, maxChildWidth);
      if ("left" === layoutSpec.position ? (child.layoutBounds = new Bounds().set(curLeftX - childWidth, viewBounds.y1, curLeftX, viewBounds.y2), curLeftX -= childWidth) : (child.layoutBounds = new Bounds().set(curRightX, viewBounds.y1, curRightX + childWidth, viewBounds.y2), curRightX += childWidth), child.relativePosition = {
        left: child.layoutBounds.x1 - viewBounds.x1,
        right: child.layoutBounds.x1 - viewBounds.x2
      }, layoutSpec.align) {
        const childHeight = bounds.height() + padding.top + padding.bottom;
        childWidth < viewBounds.width() && ("middle" === layoutSpec.align ? (child.layoutBounds.y1 = (viewBounds.y1 + viewBounds.y2) / 2 - childHeight / 2, child.layoutBounds.y2 = child.layoutBounds.y1 + childHeight, child.relativePosition.top = child.relativePosition.bottom = (viewBounds.height() - childHeight) / 2) : "bottom" === layoutSpec.align ? (child.layoutBounds.y1 = viewBounds.y2 - childHeight, child.layoutBounds.y2 = viewBounds.y2, child.relativePosition.top = viewBounds.height() - childHeight, child.relativePosition.bottom = 0) : "top" === layoutSpec.align && (child.layoutBounds.y1 = viewBounds.y1, child.layoutBounds.y2 = viewBounds.y1 + childHeight, child.relativePosition.bottom = viewBounds.height() - childHeight, child.relativePosition.top = 0));
      }
    } else
      "outside" === layoutSpec.position ? (curLeftX -= Math.max(parentLayoutBounds.x1 - bounds.x1, 0) + padding.left, curRightX -= Math.max(bounds.x2 - parentLayoutBounds.x2, 0) + padding.right, curTopY -= Math.max(parentLayoutBounds.y1 - bounds.y1, 0) + padding.top, curBottomY += Math.max(bounds.y2 - parentLayoutBounds.y2) + padding.bottom) : child.layoutBounds = viewBounds;
  }
  return viewBounds;
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/layout/layout
var defaultDoLayout = (layoutMarks, options, view) => {
  null == layoutMarks || layoutMarks.forEach((mark) => {
    var _a;
    if (mark.markType !== GrammarMarkType.group)
      return;
    const layoutChildren = mark.layoutChildren, layoutSpec = mark.getSpec().layout, bounds = null !== (_a = mark.layoutBounds) && void 0 !== _a ? _a : mark.getBounds();
    if (bounds) {
      if (isFunction_default(layoutSpec))
        layoutSpec.call(null, mark, layoutChildren, bounds, options);
      else if (isFunction_default(layoutSpec.callback))
        layoutSpec.callback.call(null, mark, layoutChildren, bounds, options);
      else if ("relative" === layoutSpec.display)
        if (layoutSpec.updateViewSignals) {
          const oldViewBox = view.getViewBox();
          oldViewBox && bounds.intersect(oldViewBox);
          const viewBounds = doRelativeLayout(mark, layoutChildren, bounds, options), viewWidth = viewBounds.width(), viewHeight = viewBounds.height(), padding = {
            top: viewBounds.y1,
            right: view.width() - viewBounds.x2,
            left: viewBounds.x1,
            bottom: view.height() - viewBounds.y2
          };
          view.updateSignal(SIGNAL_VIEW_WIDTH, viewWidth), view.updateSignal(SIGNAL_VIEW_HEIGHT, viewHeight), view.updateSignal(SIGNAL_PADDING, padding);
        } else
          doRelativeLayout(mark, layoutChildren, bounds, options);
      else
        "grid" === layoutSpec.display && doGridLayout(mark, layoutChildren, bounds, options);
      defaultDoLayout(layoutChildren, options, view);
    }
  });
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/view/glyph
var GlyphMark = class extends Mark {
  constructor(view, glyphType, group) {
    super(view, GrammarMarkType.glyph, group), this.glyphType = glyphType, this.glyphMeta = Factory.getGlyph(glyphType);
  }
  configureGlyph(config2) {
    return this.spec.glyphConfig = config2, this.commit(), this;
  }
  getGlyphMeta() {
    return this.glyphMeta;
  }
  getGlyphConfig() {
    return this.spec.glyphConfig;
  }
  addGraphicItem(attrs, groupKey) {
    const graphicItem = createGlyphGraphicItem(this, this.glyphMeta, attrs);
    return super.addGraphicItem(attrs, groupKey, graphicItem);
  }
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/animation/morph
var EmptyKey = Symbol.for("key");
var Morph = class {
  diffGrammar(prevGrammars, nextGrammars) {
    return diffSingle(prevGrammars, nextGrammars, (grammar) => {
      var _a;
      return null !== (_a = grammar.id()) && void 0 !== _a ? _a : Symbol();
    });
  }
  diffMark(prevMarks, nextMarks, runningConfig) {
    const diffResult = {
      enter: [],
      exit: [],
      update: []
    };
    let prevDiffMarks = [], nextDiffMarks = [];
    prevMarks.forEach((mark) => {
      mark.markType !== GrammarMarkType.group && (runningConfig.morph && mark.getMorphConfig().morph || runningConfig.morphAll || runningConfig.reuse) ? prevDiffMarks.push(mark) : diffResult.exit.push({
        prev: [mark]
      });
    }), nextMarks.forEach((mark) => {
      mark.markType !== GrammarMarkType.group && (runningConfig.morph && mark.getMorphConfig().morph || runningConfig.morphAll || runningConfig.reuse) ? nextDiffMarks.push(mark) : diffResult.enter.push({
        next: [mark]
      });
    });
    const keyDiffResult = this.diffUpdateByGroup(prevDiffMarks, nextDiffMarks, (mark) => mark.getMorphConfig().morphKey, (mark) => mark.getMorphConfig().morphKey);
    prevDiffMarks = keyDiffResult.prev, nextDiffMarks = keyDiffResult.next, diffResult.update = diffResult.update.concat(keyDiffResult.update);
    const nameDiffResult = this.diffUpdateByGroup(prevDiffMarks, nextDiffMarks, (mark) => mark.id(), (mark) => mark.id());
    prevDiffMarks = nameDiffResult.prev, nextDiffMarks = nameDiffResult.next, diffResult.update = diffResult.update.concat(nameDiffResult.update);
    const prevParentGroup = groupData(prevDiffMarks, (mark) => {
      var _a, _b;
      return null === (_b = null === (_a = mark.group) || void 0 === _a ? void 0 : _a.id) || void 0 === _b ? void 0 : _b.call(_a);
    }), nextParentGroup = groupData(nextDiffMarks, (mark) => {
      var _a, _b;
      return null === (_b = null === (_a = mark.group) || void 0 === _a ? void 0 : _a.id) || void 0 === _b ? void 0 : _b.call(_a);
    });
    return Object.keys(nextParentGroup).forEach((groupName) => {
      const prevChildren = prevParentGroup.data.get(groupName), nextChildren = nextParentGroup.data.get(groupName);
      if (prevChildren && nextChildren) {
        for (let i = 0; i < Math.max(prevChildren.length, nextChildren.length); i += 1) {
          const prevChild = prevChildren[i], nextChild = nextChildren[i];
          prevChild && nextChild ? diffResult.update.push({
            prev: [prevChild],
            next: [nextChild]
          }) : prevChild ? diffResult.exit.push({
            prev: [prevChild]
          }) : nextChild && diffResult.enter.push({
            next: [nextChild]
          });
        }
        prevDiffMarks = prevDiffMarks.filter((mark) => !prevChildren.includes(mark)), nextDiffMarks = nextDiffMarks.filter((mark) => !nextChildren.includes(mark));
      }
    }), prevDiffMarks.forEach((mark) => diffResult.exit.push({
      prev: [mark]
    })), nextDiffMarks.forEach((mark) => diffResult.enter.push({
      next: [mark]
    })), diffResult;
  }
  _appendMorphKeyToElements(mark) {
    const config2 = mark.getMorphConfig();
    if (!isNil_default(config2.morphElementKey)) {
      const getter2 = parseField(config2.morphElementKey);
      mark.elements && mark.elements.forEach((el) => {
        el.morphKey = getter2(el.getDatum());
      });
    }
  }
  morph(prevMarks, nextMarks, runningConfig) {
    const prevElements = prevMarks.reduce((elements, mark) => (this._appendMorphKeyToElements(mark), elements.concat(mark.elements)), []), nextElements = nextMarks.reduce((elements, mark) => (this._appendMorphKeyToElements(mark), elements.concat(mark.elements)), []), diffResult = diffMultiple(prevElements, nextElements, (element) => {
      var _a;
      return null !== (_a = element.morphKey) && void 0 !== _a ? _a : element.key;
    });
    prevMarks.forEach((mark) => {
      var _a, _b;
      return null === (_b = null === (_a = mark.animate) || void 0 === _a ? void 0 : _a.disable) || void 0 === _b ? void 0 : _b.call(_a);
    }), nextMarks.forEach((mark) => {
      var _a, _b;
      return null === (_b = null === (_a = mark.animate) || void 0 === _a ? void 0 : _a.disable) || void 0 === _b ? void 0 : _b.call(_a);
    });
    const parameters = prevMarks.concat(nextMarks).reduce((parameters2, mark) => (Object.assign(parameters2, mark.parameters()), parameters2), {});
    let morphCount = 0;
    const onMorphEnd = () => {
      morphCount -= 1, 0 === morphCount && nextMarks.forEach((mark) => {
        var _a, _b;
        null === (_b = null === (_a = mark.animate) || void 0 === _a ? void 0 : _a.enable) || void 0 === _b || _b.call(_a);
      });
    };
    diffResult.enter.forEach((diff) => {
      diff.next.forEach((element) => {
        this.doMorph([], [element], runningConfig, onMorphEnd, parameters);
      }), morphCount += 1;
    }), diffResult.update.forEach((diff) => {
      const divideCount = Math.min(diff.prev.length, diff.next.length), prevDivide = this.divideElements(diff.prev, divideCount), nextDivide = this.divideElements(diff.next, divideCount);
      for (let i = 0; i < divideCount; i++)
        this.doMorph(prevDivide[i], nextDivide[i], runningConfig, onMorphEnd, parameters), morphCount += 1;
    });
  }
  diffUpdateByGroup(prev, next, prevKey, nextKey) {
    const prevGroup = groupData(prev, (datum) => {
      var _a;
      return null !== (_a = prevKey(datum)) && void 0 !== _a ? _a : EmptyKey;
    }), nextGroup = groupData(next, (datum) => {
      var _a;
      return null !== (_a = nextKey(datum)) && void 0 !== _a ? _a : EmptyKey;
    });
    let prevAfterDiff = prev, nextAfterDiff = next;
    const update2 = [];
    return nextGroup.keys.forEach((key) => {
      if (key !== EmptyKey) {
        const prevKeyData = prevGroup.data.get(key), nextKeyData = nextGroup.data.get(key);
        prevKeyData && nextKeyData && (update2.push({
          prev: prevKeyData,
          next: nextKeyData
        }), prevAfterDiff = prevAfterDiff.filter((datum) => !prevKeyData.includes(datum)), nextAfterDiff = nextAfterDiff.filter((datum) => !nextKeyData.includes(datum)));
      }
    }), {
      prev: prevAfterDiff,
      next: nextAfterDiff,
      update: update2
    };
  }
  doMorph(prev, next, runningConfig, onEnd, parameters) {
    var _a, _b;
    const morphData = {
      prev: prev.map((element) => element.getDatum()),
      next: next.map((element) => element.getDatum())
    }, morphElements = {
      prev: prev.slice(),
      next: next.slice()
    }, easing = runningConfig.animation.easing, delay = invokeFunctionType(runningConfig.animation.delay, parameters, morphData, morphElements), duration = invokeFunctionType(runningConfig.animation.duration, parameters, morphData, morphElements), oneByOne = invokeFunctionType(runningConfig.animation.oneByOne, parameters, morphData, morphElements), splitPath2 = invokeFunctionType(runningConfig.animation.splitPath, parameters, morphData, morphElements), individualDelay = isValidNumber_default(oneByOne) && oneByOne > 0 ? (index) => isNumber_default(oneByOne) ? index * oneByOne : true === oneByOne ? index * duration : 0 : void 0;
    1 !== prev.length && 0 !== prev.length || 1 !== next.length ? 1 === prev.length && next.length > 1 ? oneToMultiMorph(prev[0].getGraphicItem(), next.map((element) => element.getGraphicItem()), {
      delay,
      duration,
      easing,
      onEnd,
      individualDelay,
      splitPath: splitPath2
    }) : prev.length > 1 && 1 === next.length && multiToOneMorph(prev.map((element) => element.getGraphicItem()), next[0].getGraphicItem(), {
      delay,
      duration,
      easing,
      onEnd,
      individualDelay,
      splitPath: splitPath2
    }) : morphPath(null === (_b = null === (_a = prev[0]) || void 0 === _a ? void 0 : _a.getGraphicItem) || void 0 === _b ? void 0 : _b.call(_a), next[0].getGraphicItem(), {
      delay,
      duration,
      easing,
      onEnd
    });
  }
  divideElements(elements, count) {
    const divideLength = Math.floor(elements.length / count);
    return new Array(count).fill(0).map((i, index) => elements.slice(divideLength * index, index === count - 1 ? elements.length : divideLength * (index + 1)));
  }
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/view/grammar-record
var RecordedGrammars = class {
  constructor(mapKey, warningWhenDuplicated) {
    this._grammars = {
      signal: [],
      data: [],
      scale: [],
      coordinate: [],
      mark: [],
      customized: []
    }, this._grammarMap = {
      signal: {},
      data: {},
      scale: {},
      coordinate: {},
      mark: {},
      customized: {}
    }, this._size = 0, this._mapKey = isString_default(mapKey) ? (grammar) => grammar[mapKey] : mapKey, this._warning = warningWhenDuplicated;
  }
  record(grammar) {
    var _a, _b;
    const grammarType = grammar.grammarType, key = this._mapKey(grammar);
    return this._grammarMap[grammarType] ? (this._grammars[grammarType].push(grammar), isNil_default(key) || (this._grammarMap[grammarType][key] ? null === (_a = this._warning) || void 0 === _a || _a.call(this, key, grammar) : this._grammarMap[grammarType][key] = grammar)) : (this._grammars.customized.push(grammar), isNil_default(key) || (this._grammarMap.customized[key] ? null === (_b = this._warning) || void 0 === _b || _b.call(this, key, grammar) : this._grammarMap.customized[key] = grammar)), this._size += 1, this;
  }
  unrecord(grammar) {
    const grammarType = grammar.grammarType, key = this._mapKey(grammar);
    return this._grammarMap[grammarType] ? (this._grammars[grammarType] = this._grammars[grammarType].filter((storedGrammar) => storedGrammar !== grammar), isNil_default(key) || this._grammarMap[grammarType][key] !== grammar || delete this._grammarMap[grammarType][key]) : (this._grammars.customized = this._grammars.customized.filter((storedGrammar) => storedGrammar !== grammar), isNil_default(key) || this._grammarMap.customized[key] !== grammar || delete this._grammarMap.customized[key]), this._size -= 1, this;
  }
  size() {
    return this._size;
  }
  getSignal(key) {
    var _a;
    return null !== (_a = this._grammarMap.signal[key]) && void 0 !== _a ? _a : null;
  }
  getData(key) {
    var _a;
    return null !== (_a = this._grammarMap.data[key]) && void 0 !== _a ? _a : null;
  }
  getScale(key) {
    var _a;
    return null !== (_a = this._grammarMap.scale[key]) && void 0 !== _a ? _a : null;
  }
  getCoordinate(key) {
    var _a;
    return null !== (_a = this._grammarMap.coordinate[key]) && void 0 !== _a ? _a : null;
  }
  getMark(key) {
    var _a;
    return null !== (_a = this._grammarMap.mark[key]) && void 0 !== _a ? _a : null;
  }
  getCustomized(key) {
    var _a;
    return null !== (_a = this._grammarMap.customized[key]) && void 0 !== _a ? _a : null;
  }
  getGrammar(key) {
    return this._grammarMap.data[key] ? this._grammarMap.data[key] : this._grammarMap.signal[key] ? this._grammarMap.signal[key] : this._grammarMap.scale[key] ? this._grammarMap.scale[key] : this._grammarMap.coordinate[key] ? this._grammarMap.coordinate[key] : this._grammarMap.mark[key] ? this._grammarMap.mark[key] : this._grammarMap.customized[key] ? this._grammarMap.customized[key] : null;
  }
  getAllSignals() {
    return this._grammars.signal;
  }
  getAllData() {
    return this._grammars.data;
  }
  getAllScales() {
    return this._grammars.scale;
  }
  getAllCoordinates() {
    return this._grammars.coordinate;
  }
  getAllMarks() {
    return this._grammars.mark;
  }
  getAllCustomized() {
    return this._grammars.customized;
  }
  traverse(func) {
    var _a;
    Object.values(null !== (_a = this._grammars) && void 0 !== _a ? _a : {}).forEach((grammars) => (null != grammars ? grammars : []).forEach((grammar) => {
      func.call(null, grammar);
    }));
  }
  find(func) {
    let targetGrammar = null;
    return this.traverse((grammar) => true === func.call(null, grammar) && (targetGrammar = grammar, true)), targetGrammar;
  }
  filter(func) {
    const targetGrammars = [];
    return this.traverse((grammar) => {
      true === func.call(null, grammar) && targetGrammars.push(grammar);
    }), targetGrammars;
  }
  clear() {
    this._size = 0, this._grammars = {
      signal: [],
      data: [],
      scale: [],
      coordinate: [],
      mark: [],
      customized: []
    }, this._grammarMap = {
      signal: {},
      data: {},
      scale: {},
      coordinate: {},
      mark: {},
      customized: {}
    };
  }
  release() {
    this._size = 0, this._grammars = null, this._grammarMap = null;
  }
};
var RecordedTreeGrammars = class extends RecordedGrammars {
  constructor() {
    super(...arguments), this._markNodes = [];
  }
  record(grammar) {
    if (super.record(grammar), "mark" === grammar.grammarType) {
      const mark = grammar, currentNode = {
        mark,
        parent: null,
        children: []
      };
      this._markNodes.forEach((node) => {
        const targetMark = node.mark;
        targetMark.markType === GrammarMarkType.group && targetMark.includesChild(mark, false) ? (node.children.push(currentNode), currentNode.parent = node) : mark.markType === GrammarMarkType.group && mark.includesChild(targetMark, false) && (currentNode.children.push(node), node.parent = currentNode);
      }), this._markNodes.push(currentNode);
    }
    return this;
  }
  unrecord(grammar) {
    if (super.unrecord(grammar), "mark" === grammar.grammarType) {
      const mark = grammar, currentNode = this._markNodes.find((node) => node.mark === mark);
      this._markNodes.forEach((node) => {
        const targetMark = node.mark;
        targetMark.markType === GrammarMarkType.group && targetMark.includesChild(mark, false) ? (node.children = node.children.filter((n) => n !== currentNode), currentNode.parent = null) : mark.markType === GrammarMarkType.group && mark.includesChild(targetMark, false) && (currentNode.children = currentNode.children.filter((n) => n !== node), node.parent = null);
      }), this._markNodes = this._markNodes.filter((n) => n !== currentNode);
    }
    return this;
  }
  getAllMarkNodes() {
    return this._markNodes;
  }
  clear() {
    super.clear(), this._markNodes = [];
  }
  release() {
    super.release(), this._markNodes = null;
  }
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/view/animate
var ViewAnimate = class {
  constructor(view) {
    this._animations = [], this._additionalAnimateMarks = [], this.isEnabled = true, this._onAnimationStart = (event) => {
      this._additionalAnimateMarks = this._additionalAnimateMarks.filter((mark) => {
        var _a;
        return null === (_a = null == mark ? void 0 : mark.animate) || void 0 === _a ? void 0 : _a.isAnimating();
      }), 0 === this._animations.length && 0 === this._additionalAnimateMarks.length && this._view.emit(HOOK_EVENT.ALL_ANIMATION_START, {}), this._animations = this._animations.concat({
        config: event.animationConfig,
        mark: event.mark
      });
    }, this._onAnimationEnd = (event) => {
      this._additionalAnimateMarks = this._additionalAnimateMarks.filter((mark) => {
        var _a;
        return null === (_a = null == mark ? void 0 : mark.animate) || void 0 === _a ? void 0 : _a.isAnimating();
      }), this._animations = this._animations.filter((animation) => animation.config !== event.animationConfig || animation.mark !== event.mark), 0 === this._animations.length && 0 === this._additionalAnimateMarks.length && this._view.emit(HOOK_EVENT.ALL_ANIMATION_END, {});
    }, this._view = view, this._view.addEventListener(HOOK_EVENT.ANIMATION_START, this._onAnimationStart), this._view.addEventListener(HOOK_EVENT.ANIMATION_END, this._onAnimationEnd);
  }
  stop() {
    return this._view.traverseMarkTree((mark) => {
      var _a, _b;
      mark.animate && (null === (_b = (_a = mark.animate).stop) || void 0 === _b || _b.call(_a));
    }), this._additionalAnimateMarks.forEach((mark) => {
      var _a, _b;
      mark.view && mark.animate && (null === (_b = (_a = mark.animate).stop) || void 0 === _b || _b.call(_a));
    }), this._additionalAnimateMarks = [], this;
  }
  pause() {
    return this._view.traverseMarkTree((mark) => {
      var _a, _b;
      mark.animate && (null === (_b = (_a = mark.animate).pause) || void 0 === _b || _b.call(_a));
    }), this._additionalAnimateMarks.forEach((mark) => {
      var _a, _b;
      mark.view && mark.animate && (null === (_b = (_a = mark.animate).pause) || void 0 === _b || _b.call(_a));
    }), this;
  }
  resume() {
    return this._view.traverseMarkTree((mark) => {
      var _a, _b;
      mark.animate && (null === (_b = (_a = mark.animate).resume) || void 0 === _b || _b.call(_a));
    }), this._additionalAnimateMarks.forEach((mark) => {
      var _a, _b;
      mark.view && mark.animate && (null === (_b = (_a = mark.animate).resume) || void 0 === _b || _b.call(_a));
    }), this;
  }
  enable() {
    return this.isEnabled = true, this._view.traverseMarkTree((mark) => {
      var _a, _b;
      mark.animate && (null === (_b = (_a = mark.animate).enable) || void 0 === _b || _b.call(_a));
    }), this;
  }
  disable() {
    return this.isEnabled = false, this._view.traverseMarkTree((mark) => {
      var _a, _b;
      mark.animate && (null === (_b = (_a = mark.animate).disable) || void 0 === _b || _b.call(_a));
    }), this._additionalAnimateMarks.forEach((mark) => {
      var _a, _b;
      mark.view && mark.animate && (null === (_b = (_a = mark.animate).stop) || void 0 === _b || _b.call(_a));
    }), this._additionalAnimateMarks = [], this;
  }
  enableAnimationState(state) {
    return this._view.traverseMarkTree((mark) => {
      var _a, _b;
      mark.animate && (null === (_b = (_a = mark.animate).enableAnimationState) || void 0 === _b || _b.call(_a, state));
    }), this;
  }
  disableAnimationState(state) {
    return this._view.traverseMarkTree((mark) => {
      var _a, _b;
      mark.animate && (null === (_b = (_a = mark.animate).disableAnimationState) || void 0 === _b || _b.call(_a, state));
    }), this;
  }
  isAnimating() {
    return 0 !== this._animations.length || this._additionalAnimateMarks.some((mark) => {
      var _a;
      return (null === (_a = null == mark ? void 0 : mark.animate) || void 0 === _a ? void 0 : _a.isAnimating()) || false;
    });
  }
  animate() {
    return this.isEnabled ? (this._view.traverseMarkTree((mark) => {
      mark.isUpdated && mark.animate && mark.animate.animate(), mark.cleanExitElements(), mark.isUpdated = false;
    }, null, true), this) : this;
  }
  animateAddition(additionMark) {
    const animate = additionMark.animate.animate();
    return animate && animate.isAnimating() && this._additionalAnimateMarks.push(additionMark), this;
  }
  release() {
    this._additionalAnimateMarks = [], this._animations = [], this._view.removeEventListener(HOOK_EVENT.ALL_ANIMATION_START, this._onAnimationStart), this._view.removeEventListener(HOOK_EVENT.ALL_ANIMATION_END, this._onAnimationEnd), this._view = null;
  }
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/semantic-marks/text
var Text2 = class extends Mark {
  addGraphicItem(initAttrs, groupKey) {
    const originalAttrs = initAttrs && initAttrs.limitAttrs, isRich = originalAttrs && ("rich" === originalAttrs.textType || originalAttrs.text && "rich" === originalAttrs.text.type), graphicItem = createGraphicItem(this, isRich ? GrammarMarkType.richtext : GrammarMarkType.text, initAttrs);
    return super.addGraphicItem(initAttrs, groupKey, graphicItem);
  }
  release() {
    super.release();
  }
};
Text2.markType = GrammarMarkType.text;

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/theme/common/component
var axis = {
  label: {
    visible: true,
    inside: false,
    space: 4,
    style: {
      fontSize: 12,
      fill: "#89909d",
      fontWeight: "normal",
      fillOpacity: 1
    }
  },
  tick: {
    visible: true,
    inside: false,
    alignWithLabel: true,
    length: 4,
    style: {
      lineWidth: 1,
      stroke: "#D9DDE4",
      strokeOpacity: 1
    }
  },
  subTick: {
    visible: false,
    inside: false,
    count: 4,
    length: 2,
    style: {
      lineWidth: 1,
      stroke: "#D9DDE4",
      strokeOpacity: 1
    }
  },
  line: {
    visible: true,
    style: {
      lineWidth: 1,
      stroke: "#D9DDE4",
      strokeOpacity: 1
    }
  },
  items: [],
  start: {
    x: 0,
    y: 0
  },
  end: {
    x: 100,
    y: 0
  },
  x: 0,
  y: 0
};
var circleAxis = {
  title: {
    space: 4,
    padding: [0, 0, 0, 0],
    textStyle: {
      fontSize: 12,
      fill: "#333333",
      fontWeight: "normal",
      fillOpacity: 1
    },
    text: "theta"
  },
  label: {
    visible: true,
    inside: false,
    space: 4,
    style: {
      fontSize: 12,
      fill: "#6F6F6F",
      fontWeight: "normal",
      fillOpacity: 1
    }
  },
  tick: {
    visible: true,
    inside: false,
    alignWithLabel: true,
    length: 4,
    style: {
      lineWidth: 1,
      stroke: "#D9DDE4",
      strokeOpacity: 1
    }
  },
  subTick: {
    visible: false,
    inside: false,
    count: 4,
    length: 2,
    style: {
      lineWidth: 1,
      stroke: "#D9DDE4",
      strokeOpacity: 1
    }
  },
  line: {
    visible: true,
    style: {
      lineWidth: 1,
      stroke: "#D9DDE4",
      strokeOpacity: 1
    }
  },
  items: [],
  startAngle: 0,
  endAngle: 2 * Math.PI,
  radius: 100,
  innerRadius: 0,
  center: {
    x: 0,
    y: 0
  },
  x: 0,
  y: 0
};
var grid = {
  style: {
    stroke: "#f1f2f5"
  }
};
var circleGrid = {
  style: {
    stroke: "#f1f2f5"
  }
};
var discreteLegend = {
  layout: "vertical",
  title: {
    align: "start",
    space: 12,
    textStyle: {
      fontSize: 12,
      fontWeight: "bold",
      fill: "#2C3542"
    }
  },
  item: {
    spaceCol: 10,
    spaceRow: 10,
    shape: {
      space: 4,
      style: {
        size: 10,
        cursor: "pointer"
      },
      state: {
        selectedHover: {
          opacity: 0.85
        },
        unSelected: {
          fill: "#D8D8D8",
          stroke: "#D8D8D8",
          fillOpacity: 0.5
        }
      }
    },
    label: {
      space: 4,
      style: {
        fontSize: 12,
        fill: "black",
        cursor: "pointer"
      },
      state: {
        selectedHover: {
          opacity: 0.85
        },
        unSelected: {
          fill: "#D8D8D8",
          fillOpacity: 0.5
        }
      }
    },
    value: {
      alignRight: false,
      style: {
        fontSize: 12,
        fill: "#ccc",
        cursor: "pointer"
      },
      state: {
        selectedHover: {
          opacity: 0.85
        },
        unSelected: {
          fill: "#D8D8D8"
        }
      }
    },
    background: {
      style: {
        cursor: "pointer"
      },
      state: {
        selectedHover: {
          fillOpacity: 0.7,
          fill: "gray"
        },
        unSelectedHover: {
          fillOpacity: 0.2,
          fill: "gray"
        }
      }
    },
    focus: false,
    focusIconStyle: {
      size: 10,
      fill: "#333",
      cursor: "pointer"
    },
    visible: true,
    padding: {
      top: 2,
      bottom: 2,
      left: 2,
      right: 2
    }
  },
  autoPage: true,
  pager: {
    space: 12,
    handler: {
      style: {
        size: 10
      },
      space: 4
    }
  },
  hover: true,
  select: true,
  selectMode: "multiple",
  allowAllCanceled: false,
  items: [{
    index: 0,
    id: "",
    label: "",
    shape: {
      fill: "#6690F2",
      stroke: "#6690F2",
      symbolType: "circle"
    }
  }]
};
var colorLegend = {
  title: {
    visible: false,
    text: ""
  },
  colors: [],
  layout: "horizontal",
  railWidth: 200,
  railHeight: 8,
  railStyle: {
    cornerRadius: 5
  }
};
var sizeLegend = {
  title: {
    visible: false,
    text: ""
  },
  trackStyle: {
    fill: "#ccc"
  },
  layout: "horizontal",
  align: "bottom",
  railWidth: 200,
  railHeight: 6,
  min: 0,
  max: 1,
  value: [0, 1]
};
var lineCrosshair = {
  start: {
    x: 0,
    y: 0
  },
  end: {
    x: 0,
    y: 0
  }
};
var rectCrosshair = {
  start: {
    x: 0,
    y: 0
  },
  end: {
    x: 0,
    y: 0
  },
  rectStyle: {
    width: 10,
    height: 10
  }
};
var sectorCrosshair = {
  center: {
    x: 0,
    y: 0
  },
  radius: 100,
  startAngle: 0,
  endAngle: Math.PI / 6
};
var circleCrosshair = {
  center: {
    x: 0,
    y: 0
  },
  radius: 100,
  startAngle: 0,
  endAngle: 2 * Math.PI
};
var polygonCrosshair = {
  center: {
    x: 0,
    y: 0
  },
  radius: 100,
  startAngle: 0,
  endAngle: 2 * Math.PI,
  sides: 6
};
var slider = {
  layout: "horizontal",
  railWidth: 200,
  railHeight: 10,
  railStyle: {
    cornerRadius: 5
  },
  range: {
    draggableTrack: true
  },
  startText: {
    visible: true,
    text: "",
    space: 8
  },
  endText: {
    visible: true,
    text: "",
    space: 8
  },
  min: 0,
  max: 1,
  value: [0, 1]
};
var dataLabel = {
  size: {
    width: 400,
    height: 400
  },
  dataLabels: []
};
var lineDataLabel = {
  type: "line-data",
  data: [{
    text: ""
  }],
  position: "top",
  overlap: {
    avoidBaseMark: false,
    clampForce: false
  },
  smartInvert: false
};
var lineLabel = {
  type: "line",
  data: [{
    text: "",
    data: {}
  }],
  position: "start",
  overlap: {
    avoidBaseMark: false,
    clampForce: false,
    size: {
      width: 1e3,
      height: 1e3
    }
  },
  smartInvert: false
};
var areaLabel = {
  type: "area",
  data: [{
    text: "",
    data: {}
  }],
  position: "end",
  overlap: {
    avoidBaseMark: false,
    clampForce: false,
    size: {
      width: 1e3,
      height: 1e3
    }
  },
  smartInvert: false
};
var rectLabel = {
  type: "rect",
  data: [{
    text: "",
    fill: "#606773",
    data: {}
  }],
  position: "top",
  overlap: {
    size: {
      width: 1e3,
      height: 1e3
    },
    strategy: [{
      type: "position"
    }]
  },
  smartInvert: false
};
var symbolLabel = {
  type: "symbol",
  data: [{
    text: "",
    fill: "#606773",
    data: {}
  }],
  position: "top",
  overlap: {
    avoidBaseMark: true,
    size: {
      width: 1e3,
      height: 1e3
    },
    strategy: [{
      type: "position"
    }]
  },
  smartInvert: false
};
var arcLabel = {
  type: "arc",
  data: [{
    text: "",
    fill: "#606773",
    data: {}
  }],
  width: 800,
  height: 600,
  position: "outside",
  zIndex: 302
};
var pointLabel = {
  data: [{
    text: "",
    fill: "#606773",
    data: {}
  }],
  overlap: {
    avoidBaseMark: false,
    clampForce: false,
    size: {
      width: 1e3,
      height: 1e3
    }
  },
  smartInvert: false
};
var datazoom = {
  orient: "bottom",
  showDetail: "auto",
  brushSelect: true,
  start: 0,
  end: 1,
  position: {
    x: 0,
    y: 0
  },
  size: {
    width: 500,
    height: 40
  },
  previewData: []
};
var continuousPlayer = {};
var discretePlayer = {};
var tooltip = {};
var title = {
  textStyle: {
    fill: "#21252c"
  },
  subtextStyle: {
    fill: "#606773"
  }
};
var scrollbar = {
  width: 12,
  height: 12,
  padding: [2, 2],
  railStyle: {
    fill: "rgba(0, 0, 0, .1)"
  }
};
var defaultComponentTheme = {
  axis,
  circleAxis,
  grid,
  circleGrid,
  discreteLegend,
  colorLegend,
  sizeLegend,
  lineCrosshair,
  rectCrosshair,
  sectorCrosshair,
  circleCrosshair,
  polygonCrosshair,
  slider,
  dataLabel,
  pointLabel,
  lineLabel,
  areaLabel,
  rectLabel,
  symbolLabel,
  arcLabel,
  lineDataLabel,
  datazoom,
  continuousPlayer,
  discretePlayer,
  tooltip,
  title,
  scrollbar
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/theme/common/constants
var DEFAULT_PADDING = 5;

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/theme/common/mark
var defaultMarkTheme = {
  symbol: {
    shape: "circle",
    size: 8
  },
  text: {
    fontSize: 14,
    fill: "#000000"
  }
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/theme/dark
var darkComponents = Object.assign({}, defaultComponentTheme);
darkComponents.axis = Object.assign({}, darkComponents.axis, {
  label: {
    style: {
      fill: "#bbbdc3"
    }
  },
  line: {
    style: {
      stroke: "#4b4f54"
    }
  },
  tick: {
    style: {
      stroke: "#4b4f54"
    }
  },
  subTick: {
    style: {
      stroke: "#4b4f54"
    }
  }
}), darkComponents.circleAxis = Object.assign({}, darkComponents.circleAxis, {
  label: {
    style: {
      fill: "#bbbdc3"
    }
  },
  line: {
    style: {
      stroke: "#4b4f54"
    }
  },
  tick: {
    style: {
      stroke: "#4b4f54"
    }
  },
  subTick: {
    style: {
      stroke: "#4b4f54"
    }
  }
}), darkComponents.grid = Object.assign({}, darkComponents.grid, {
  style: {
    stroke: "#404349"
  }
}), darkComponents.circleGrid = Object.assign({}, darkComponents.circleGrid, {
  style: {
    stroke: "#404349"
  }
}), darkComponents.rectLabel = Object.assign({}, darkComponents.rectLabel, {
  data: [{
    text: "",
    fill: "#888c93",
    data: {}
  }]
}), darkComponents.lineLabel = Object.assign({}, darkComponents.lineLabel, {
  data: [{
    text: "",
    fill: "#888c93",
    data: {}
  }]
}), darkComponents.symbolLabel = Object.assign({}, darkComponents.symbolLabel, {
  data: [{
    text: "",
    fill: "#888c93",
    data: {}
  }]
}), darkComponents.title = Object.assign({}, darkComponents.title, {
  textStyle: {
    fill: "#fdfdfd"
  },
  subtextStyle: {
    fill: "#888c93"
  }
});
var darkTheme = {
  name: "dark",
  padding: DEFAULT_PADDING,
  background: "#202226",
  palette: {
    default: ["#5383F4", "#7BCF8E", "#FF9D2C", "#FFDB26", "#7568D9", "#80D8FB", "#1857A3", "#CAB0E8", "#FF8867", "#B9E493", "#2CB4A8", "#B9E4E3"]
  },
  marks: defaultMarkTheme,
  components: darkComponents
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/theme/default
var defaultTheme = {
  name: "default",
  padding: DEFAULT_PADDING,
  palette: {
    default: ["#6690F2", "#70D6A3", "#B4E6E2", "#63B5FC", "#FF8F62", "#FFDC83", "#BCC5FD", "#A29BFE", "#63C4C7", "#F68484"]
  },
  marks: defaultMarkTheme,
  components: defaultComponentTheme
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/theme/theme-manager
var ThemeManager = class _ThemeManager {
  static registerTheme(name, theme2) {
    name && _ThemeManager._themes.set(name, theme2);
  }
  static unregisterTheme(name) {
    _ThemeManager._themes.delete(name);
  }
  static getTheme(name) {
    return _ThemeManager._themes.get(name);
  }
  static getDefaultTheme() {
    return _ThemeManager.getTheme("default");
  }
};
ThemeManager._themes = /* @__PURE__ */ new Map(), ThemeManager.registerTheme("default", defaultTheme), ThemeManager.registerTheme("dark", darkTheme);

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/view/component
var Component = class extends Mark {
  constructor(view, componentType, group, mode) {
    super(view, GrammarMarkType.component, group), this._componentDatum = {
      [DefaultKey]: 0
    }, this.componentType = componentType, this.spec.type = "component", this.spec.componentType = componentType, this.mode = mode, this._updateComponentEncoders();
  }
  configureComponent(config2) {
    return this.spec.componentConfig = config2, this.commit(), this;
  }
  addGraphicItem(attrs, groupKey, newGraphicItem) {
    const graphicItem = null != newGraphicItem ? newGraphicItem : Factory.createGraphicComponent(this.componentType, attrs, {
      mode: this.mode,
      skipDefault: this.spec.skipTheme
    });
    return graphicItem && (this.emit(HOOK_EVENT.BEFORE_ADD_VRENDER_MARK, {
      graphicItem
    }), this.graphicParent.appendChild(graphicItem), this.emit(HOOK_EVENT.AFTER_ADD_VRENDER_MARK, {
      graphicItem
    })), graphicItem;
  }
  join(data) {
    return super.join(data, DefaultKey);
  }
  encodeState(state, channel, value) {
    return super.encodeState(state, channel, value), this._updateComponentEncoders(), this;
  }
  parseRenderContext() {
    return {
      large: false
    };
  }
  _prepareRejoin() {
    this._componentDatum[DefaultKey] += 1;
  }
  evaluateJoin(data) {
    return this.spec.key = DefaultKey, data ? (data[DefaultKey] = this._componentDatum[DefaultKey], this._componentDatum = data) : this._componentDatum = {
      [DefaultKey]: this._componentDatum[DefaultKey]
    }, super.evaluateJoin([this._componentDatum]);
  }
  _updateComponentEncoders() {
    this._encoders = this.spec.encode;
  }
  _getEncoders() {
    var _a;
    return null !== (_a = this._encoders) && void 0 !== _a ? _a : {};
  }
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/view/View
var View = class extends import_eventemitter3.default {
  static useRegisters(comps) {
    comps.forEach((fn) => {
      fn();
    });
  }
  constructor(options = {}, config2 = {}) {
    super(), this._observer = null, this._onResize = debounce_default((...args) => {
      const size = this._getContainerSize();
      size && this.resize(size.width, size.height);
    }, 100), this.delegateEvent = (event, type) => {
      var _a;
      const activeElement = null === (_a = event.target) || void 0 === _a ? void 0 : _a[BridgeElementKey], extendedEvt = getExtendedEvents(this, event, activeElement, type, EVENT_SOURCE_VIEW);
      this.emit(type, extendedEvt, activeElement);
    }, this.handleProgressiveFrame = () => {
      this._progressiveMarks.length && this._progressiveMarks.forEach((mark) => {
        mark.isDoingProgressive() && mark.evaluateProgressive();
      }), this.doPreProgressive();
    }, this._config = config2, this._options = Object.assign({
      mode: BROWSER
    }, options), this.initialize();
  }
  getGrammarById(id2) {
    return this.grammars.getGrammar(id2);
  }
  getSignalById(id2) {
    return this.grammars.getSignal(id2);
  }
  getDataById(id2) {
    return this.grammars.getData(id2);
  }
  getScaleById(id2) {
    return this.grammars.getScale(id2);
  }
  getCoordinateById(id2) {
    return this.grammars.getCoordinate(id2);
  }
  getMarkById(id2) {
    return this.grammars.getMark(id2);
  }
  getCustomizedById(id2) {
    return this.grammars.getCustomized(id2);
  }
  getGrammarsByName(name) {
    return this.grammars.filter((grammar) => grammar.name() === name);
  }
  getGrammarsByType(grammarType) {
    return this.grammars.filter((grammar) => grammar.grammarType === grammarType);
  }
  getMarksByType(markType) {
    return this.grammars.getAllMarks().filter((mark) => mark.markType === markType);
  }
  getMarksByName(name) {
    return this.grammars.getAllMarks().filter((mark) => mark.name() === name);
  }
  getMarksBySelector(selector) {
    if (!selector)
      return null;
    const selectors = array(selector), res = [];
    return selectors.forEach((selectorStr) => {
      if (isGrammar(selectorStr))
        return void res.push(selectorStr);
      if (selectorStr[0] === ID_PREFIX) {
        const mark = this.getMarkById(selectorStr.slice(1));
        return void (mark && res.push(mark));
      }
      const marks = selectorStr[0] === NAME_PREFIX ? this.getMarksByName(selectorStr.slice(1)) : isMarkType(selectorStr) ? this.getMarksByType(selectorStr) : null;
      marks && marks.length && marks.forEach((mark) => {
        res.push(mark);
      });
    }), res;
  }
  updateSignal(signal, value) {
    isString_default(signal) && (signal = this.getSignalById(signal)), signal.set(value), this.commit(signal);
  }
  signal(value, update2) {
    const signal = new Signal(this);
    return arguments.length >= 1 && signal.value(value), arguments.length >= 2 && signal.update(update2), this.grammars.record(signal), this._dataflow.add(signal), signal;
  }
  data(values) {
    const data = new Data(this, values);
    return this.grammars.record(data), this._dataflow.add(data), data;
  }
  scale(type) {
    const scale4 = Factory.createGrammar("scale", this, type);
    return scale4 && (this.grammars.record(scale4), this._dataflow.add(scale4)), scale4;
  }
  coordinate(type) {
    const coordinate = Factory.createGrammar("coordinate", this, type);
    return coordinate && (this.grammars.record(coordinate), this._dataflow.add(coordinate)), coordinate;
  }
  mark(type, group, markOptions) {
    const groupMark = isString_default(group) ? this.getMarkById(group) : group;
    let mark;
    switch (type) {
      case GrammarMarkType.group:
        mark = new GroupMark(this, groupMark);
        break;
      case GrammarMarkType.glyph:
        mark = new GlyphMark(this, null == markOptions ? void 0 : markOptions.glyphType, groupMark);
        break;
      case GrammarMarkType.component:
        mark = Factory.hasComponent(null == markOptions ? void 0 : markOptions.componentType) ? Factory.createComponent(null == markOptions ? void 0 : markOptions.componentType, this, groupMark, null == markOptions ? void 0 : markOptions.mode) : new Component(this, null == markOptions ? void 0 : markOptions.componentType, groupMark, null == markOptions ? void 0 : markOptions.mode);
        break;
      case GrammarMarkType.text:
        mark = new Text2(this, type, groupMark);
        break;
      default:
        mark = Factory.hasMark(type) ? Factory.createMark(type, this, groupMark) : new Mark(this, type, groupMark);
    }
    return this.grammars.record(mark), this._dataflow.add(mark), mark;
  }
  group(group) {
    return this.mark(GrammarMarkType.group, group);
  }
  glyph(glyphType, group) {
    return this.mark(GrammarMarkType.glyph, group, {
      glyphType
    });
  }
  component(componentType, group, mode = "2d") {
    return this.mark(GrammarMarkType.component, group, {
      componentType,
      mode
    });
  }
  axis(group, mode = "2d") {
    return this.mark(GrammarMarkType.component, group, {
      componentType: ComponentEnum.axis,
      mode
    });
  }
  grid(group, mode = "2d") {
    return this.mark(GrammarMarkType.component, group, {
      componentType: ComponentEnum.grid,
      mode
    });
  }
  legend(group) {
    return this.mark(GrammarMarkType.component, group, {
      componentType: ComponentEnum.legend
    });
  }
  slider(group) {
    return this.mark(GrammarMarkType.component, group, {
      componentType: ComponentEnum.slider
    });
  }
  label(group) {
    return this.mark(GrammarMarkType.component, group, {
      componentType: ComponentEnum.label
    });
  }
  datazoom(group) {
    return this.mark(GrammarMarkType.component, group, {
      componentType: ComponentEnum.datazoom
    });
  }
  player(group) {
    return this.mark(GrammarMarkType.component, group, {
      componentType: ComponentEnum.player
    });
  }
  title(group) {
    return this.mark(GrammarMarkType.component, group, {
      componentType: ComponentEnum.title
    });
  }
  scrollbar(group) {
    return this.mark(GrammarMarkType.component, group, {
      componentType: ComponentEnum.scrollbar
    });
  }
  customized(type, spec) {
    const grammar = Factory.createGrammar(type, this, null == spec ? void 0 : spec.type);
    if (grammar)
      return grammar.parse(spec), this.grammars.record(grammar), this._dataflow.add(grammar), grammar;
  }
  addGrammar(grammar) {
    return this.grammars.find((storedGrammar) => storedGrammar.uid === grammar.uid) || (this.grammars.record(grammar), this._dataflow.add(grammar), grammar.parse(grammar.getSpec()), this._needBuildLayoutTree = true), this;
  }
  removeGrammar(grammar) {
    const recordedGrammar = isString_default(grammar) ? this.getGrammarById(grammar) : grammar;
    return recordedGrammar && this.grammars.find((storedGrammar) => storedGrammar.uid === recordedGrammar.uid) ? ("mark" === recordedGrammar.grammarType && recordedGrammar.prepareRelease(), this._cachedGrammars.record(recordedGrammar), this._dataflow.remove(recordedGrammar), this.grammars.unrecord(recordedGrammar), this._needBuildLayoutTree = true, this) : this;
  }
  removeAllGrammars() {
    return this.grammars.traverse((grammar) => {
      "signal" === grammar.grammarType && BuiltInSignalID.includes(grammar.id()) || "mark" === grammar.grammarType && "root" === grammar.id() || this.removeGrammar(grammar);
    }), this;
  }
  removeAllGraphicItems() {
    return this.traverseMarkTree((mark) => {
      mark.graphicItem && (removeGraphicItem(mark.graphicItem), mark.elementMap.forEach((element) => {
        element.resetGraphicItem();
      }), mark.graphicItem = null);
    }), this;
  }
  parseSpec(spec) {
    var _a, _b, _c, _d, _e, _f;
    if (this.emit(HOOK_EVENT.BEFORE_PARSE_VIEW), this._spec = spec, normalizeMarkTree(spec), spec.theme ? this.theme(spec.theme) : this.theme(ThemeManager.getDefaultTheme()), spec.width && this.width(spec.width), spec.height && this.height(spec.height), this.padding(null !== (_b = null !== (_a = spec.padding) && void 0 !== _a ? _a : this._options.padding) && void 0 !== _b ? _b : this._theme.padding), !this.width() || !this.height()) {
      const size = this._getContainerSize();
      size && (this.updateSignal(SIGNAL_WIDTH, size.width), this.updateSignal(SIGNAL_HEIGHT, size.height));
    }
    (null === (_c = spec.signals) || void 0 === _c ? void 0 : _c.length) && spec.signals.forEach((signal) => {
      this.signal().parse(signal);
    }), (null === (_d = spec.data) || void 0 === _d ? void 0 : _d.length) && spec.data.forEach((data) => {
      this.data(null).parse(data);
    }), (null === (_e = spec.coordinates) || void 0 === _e ? void 0 : _e.length) && spec.coordinates.forEach((coordinate) => {
      var _a2;
      null === (_a2 = this.coordinate(coordinate.type)) || void 0 === _a2 || _a2.parse(coordinate);
    }), (null === (_f = spec.scales) || void 0 === _f ? void 0 : _f.length) && spec.scales.forEach((scale4) => {
      var _a2;
      null === (_a2 = this.scale(scale4.type)) || void 0 === _a2 || _a2.parse(scale4);
    });
    const customizedGrammars = Factory.getGrammars();
    return Object.keys(customizedGrammars).forEach((key) => {
      const { specKey } = customizedGrammars[key];
      spec[specKey] && spec[specKey].length && spec[specKey].forEach((specValue) => {
        this.customized(key, specValue);
      });
    }), spec.marks && spec.marks.length && spec.marks.forEach((mark) => {
      this.parseMarkSpec(mark);
    }), spec.events && spec.events.length && spec.events.forEach((eventConfig) => {
      this.event(eventConfig);
    }), spec.interactions && spec.interactions.length && spec.interactions.forEach((interaction) => {
      this.interaction(interaction.type, interaction);
    }), false === spec.animation ? this.animate.disable() : this.animate.enable(), this.emit(HOOK_EVENT.AFTER_PARSE_VIEW), this._needBuildLayoutTree = true, this._layoutState = LayoutState.before, this;
  }
  updateSpec(spec) {
    return this.removeAllInteractions(), this.removeAllGrammars(), this.parseSpec(spec);
  }
  parseBuiltIn() {
    builtInSignals(this._options, this._config, this.getCurrentTheme()).forEach((signalSpec) => {
      const signal = this.signal().parse(signalSpec);
      signalSpec.value && signal.set(signalSpec.value);
    });
    this.parseMarkSpec({
      id: "root",
      type: "group",
      encode: {
        enter: {
          x: 0,
          y: 0
        },
        update: {
          width: {
            signal: "width"
          },
          height: {
            signal: "height"
          }
        }
      }
    }), this.rootMark = this.getMarkById("root");
  }
  parseMarkSpec(spec) {
    var _a;
    const markOptions = spec.type === GrammarMarkType.glyph ? {
      glyphType: spec.glyphType
    } : spec.type === GrammarMarkType.component ? {
      componentType: spec.componentType,
      mode: spec.mode
    } : null;
    this.mark(spec.type, spec.group, markOptions).parse(spec), null === (_a = spec.marks) || void 0 === _a || _a.forEach((childSpec) => {
      this.parseMarkSpec(childSpec);
    });
  }
  theme(theme2) {
    var _a, _b, _c, _d, _e, _f;
    isString_default(theme2) ? this._theme = null !== (_a = ThemeManager.getTheme(theme2)) && void 0 !== _a ? _a : ThemeManager.getDefaultTheme() : this._theme = theme2;
    const { background, padding } = null !== (_b = this._spec) && void 0 !== _b ? _b : {};
    return this._theme ? (this.background(null !== (_c = null != background ? background : this._options.background) && void 0 !== _c ? _c : this._theme.background), this.padding(null !== (_d = null != padding ? padding : this._options.padding) && void 0 !== _d ? _d : this._theme.padding), null === (_f = null === (_e = this.renderer.stage()) || void 0 === _e ? void 0 : _e.setTheme) || void 0 === _f || _f.call(_e, Object.assign({}, this._theme.marks))) : (this.background(null != background ? background : this._options.background), this.padding(null != padding ? padding : this._options.padding)), this;
  }
  getCurrentTheme() {
    return this._theme;
  }
  setCurrentTheme(theme2, render = true) {
    return this.theme(theme2), this.grammars.getAllMarks().forEach((mark) => {
      mark.commit();
    }), render ? (this.evaluate(), this.renderer.render(true)) : this._dataflow.evaluate(), this;
  }
  background(value) {
    return arguments.length ? (this._background = value, this.renderer.background(value), value) : this._background;
  }
  width(value) {
    const signal = this.getSignalById(SIGNAL_WIDTH);
    return arguments.length ? (this._options.width = value, this.updateSignal(signal, value), value) : signal.output();
  }
  height(value) {
    const signal = this.getSignalById(SIGNAL_HEIGHT);
    return arguments.length ? (this._options.height = value, this.updateSignal(signal, value), value) : signal.output();
  }
  viewWidth(value) {
    const signal = this.getSignalById(SIGNAL_VIEW_WIDTH);
    if (arguments.length) {
      const padding = this.padding();
      return this.width(value + padding.left + padding.right), value;
    }
    return signal.output();
  }
  viewHeight(value) {
    const signal = this.getSignalById(SIGNAL_VIEW_HEIGHT);
    if (arguments.length) {
      const padding = this.padding();
      return this.height(value + padding.top + padding.bottom), value;
    }
    return signal.output();
  }
  padding(value) {
    const signal = this.getSignalById(SIGNAL_PADDING);
    if (arguments.length) {
      const padding = normalizePadding2(value);
      return this.updateSignal(signal, padding), padding;
    }
    return normalizePadding2(signal.output());
  }
  autoFit(value) {
    const signal = this.getSignalById(SIGNAL_AUTOFIT);
    return arguments.length ? (this.updateSignal(signal, value), value) : signal.output();
  }
  getViewBox() {
    const signal = this.getSignalById(SIGNAL_VIEW_BOX);
    return null == signal ? void 0 : signal.output();
  }
  updateLayoutTag() {
    return this._layoutState = LayoutState.before, this;
  }
  getLayoutState() {
    return this._layoutState;
  }
  buildLayoutTree() {
    const markMap = {}, rootMarks = [];
    this.traverseMarkTree((mark) => {
      markMap[mark.id()] = true, mark.group && markMap[mark.group.id()] || rootMarks.push(mark), mark.markType === GrammarMarkType.group && mark.updateLayoutChildren();
    }, (mark) => mark.needLayout()), this._layoutMarks = rootMarks;
  }
  doLayout() {
    var _a;
    const doLayout = this._options.doLayout || defaultDoLayout;
    doLayout && (null === (_a = this._layoutMarks) || void 0 === _a ? void 0 : _a.length) && (this.emit(HOOK_EVENT.BEFORE_DO_LAYOUT), doLayout(this._layoutMarks, this._options, this), this.emit(HOOK_EVENT.AFTER_DO_LAYOUT));
  }
  handleLayoutEnd() {
    this.emit(HOOK_EVENT.BEFORE_MARK_LAYOUT_END), this._layoutMarks.forEach((layoutMark) => {
      traverseMarkTree(layoutMark, "layoutChildren", (mark) => {
        mark.handleLayoutEnd();
      }, (mark) => mark !== layoutMark);
    }), this.emit(HOOK_EVENT.AFTER_MARK_LAYOUT_END);
  }
  handleRenderEnd() {
    this.emit(HOOK_EVENT.BEFORE_MARK_RENDER_END), traverseMarkTree(this.rootMark, "children", (mark) => {
      mark.handleRenderEnd();
    }), this.emit(HOOK_EVENT.AFTER_MARK_RENDER_END);
  }
  commit(grammar) {
    return this._dataflow.commit(grammar), this;
  }
  run(runningConfig) {
    return this.evaluate(runningConfig), this;
  }
  doRender(immediately) {
    this.emit(HOOK_EVENT.BEFORE_DO_RENDER), this.renderer && (this._progressiveMarks || this.animate.animate(), this.renderer.render(immediately), this.handleRenderEnd()), this.emit(HOOK_EVENT.AFTER_DO_RENDER);
  }
  evaluate(runningConfig) {
    var _a, _b;
    const normalizedRunningConfig = normalizeRunningConfig(runningConfig), grammarWillDetach = this._cachedGrammars.size() > 0;
    grammarWillDetach && (this.reuseCachedGrammars(normalizedRunningConfig), this.detachCachedGrammar());
    const hasResize = this._resizeRenderer(), hasUpdate = this._dataflow.hasCommitted();
    return grammarWillDetach || hasUpdate || this._layoutState || hasResize ? (this.clearProgressive(), this._dataflow.evaluate(), this._needBuildLayoutTree && (this.buildLayoutTree(), this._needBuildLayoutTree = false), this._layoutState && (this._layoutState = LayoutState.layouting, this.doLayout(), this._dataflow.hasCommitted() && (this._layoutState = LayoutState.reevaluate, this._dataflow.evaluate()), this._layoutState = LayoutState.after, (null === (_a = this._layoutMarks) || void 0 === _a ? void 0 : _a.length) && this.handleLayoutEnd()), this._layoutState = null, this.findProgressiveMarks(), this._resizeRenderer(), null === (_b = this._willMorphMarks) || void 0 === _b || _b.forEach((morphMarks) => {
      this._morph.morph(morphMarks.prev, morphMarks.next, normalizedRunningConfig);
    }), this._willMorphMarks = null, this.releaseCachedGrammars(normalizedRunningConfig), this.doRender(true), this.doPreProgressive(), this) : this;
  }
  reuseCachedGrammars(runningConfig) {
    if (this._willMorphMarks || (this._willMorphMarks = []), runningConfig.reuse) {
      const reuseDiffUpdate = (diff) => {
        diff.next.reuse(diff.prev), diff.prev.detachAll(), diff.prev.clear(), this._cachedGrammars.unrecord(diff.prev);
      };
      this._morph.diffGrammar(this._cachedGrammars.getAllSignals(), this.grammars.getAllSignals().filter((signal) => !BuiltInSignalID.includes(signal.id()))).update.forEach(reuseDiffUpdate);
      this._morph.diffGrammar(this._cachedGrammars.getAllData(), this.grammars.getAllData()).update.forEach(reuseDiffUpdate);
      this._morph.diffGrammar(this._cachedGrammars.getAllScales(), this.grammars.getAllScales()).update.forEach(reuseDiffUpdate);
      this._morph.diffGrammar(this._cachedGrammars.getAllCoordinates(), this.grammars.getAllCoordinates()).update.forEach(reuseDiffUpdate);
    }
    this._morph.diffMark(this._cachedGrammars.getAllMarks(), this.grammars.getAllMarks().filter((mark) => "root" !== mark.id()), runningConfig).update.forEach((diff) => {
      const matched = 1 === diff.prev.length && 1 === diff.next.length && diff.prev[0].markType === diff.next[0].markType, enableMarkMorphConfig = diff.prev.every((mark) => mark.getMorphConfig().morph) && diff.next.every((mark) => mark.getMorphConfig().morph);
      matched && runningConfig.reuse ? (diff.next[0].reuse(diff.prev[0]), diff.prev[0].detachAll(), diff.prev[0].clear(), this._cachedGrammars.unrecord(diff.prev[0])) : (runningConfig.morph && enableMarkMorphConfig || runningConfig.morphAll) && this._willMorphMarks.push({
        prev: diff.prev,
        next: diff.next
      });
    });
  }
  detachCachedGrammar() {
    this._cachedGrammars.traverse((grammar) => {
      var _a, _b;
      if (grammar.detachAll(), "mark" === grammar.grammarType) {
        const mark = grammar;
        null === (_b = null === (_a = mark.group) || void 0 === _a ? void 0 : _a.removeChild) || void 0 === _b || _b.call(_a, mark);
      }
    });
  }
  releaseCachedGrammars(runningConfig) {
    this._cachedGrammars.traverse((grammar) => {
      "mark" !== grammar.grammarType && grammar.release();
    });
    const markNodes = this._cachedGrammars.getAllMarkNodes();
    markNodes.forEach((node) => {
      node.mark.animate.stop(), runningConfig.enableExitAnimation && this.animate.animateAddition(node.mark);
    });
    const releaseUp = (node) => {
      if (node.mark.view && 0 === node.mark.animate.getAnimatorCount() && (!node.children || 0 === node.children.length)) {
        node.mark.release();
        const parent = node.parent;
        parent && (node.parent.children = node.parent.children.filter((n) => n !== node), node.parent = null, releaseUp(parent));
      }
    };
    markNodes.forEach((node) => {
      const mark = node.mark;
      0 === mark.animate.getAnimatorCount() ? releaseUp(node) : mark.addEventListener("animationEnd", () => {
        0 === mark.animate.getAnimatorCount() && releaseUp(node);
      });
    }), this._cachedGrammars.clear();
  }
  runAfter(callback) {
    return this._dataflow.runAfter(() => {
      callback.call(null, this);
    }), this;
  }
  runBefore(callback) {
    return this._dataflow.runBefore(() => {
      callback.call(null, this);
    }), this;
  }
  getImageBuffer() {
    var _a, _b;
    if ("node" !== this._options.mode)
      return void this.logger.error(new TypeError("getImageBuffer() now only support node environment."));
    const stage = null === (_b = null === (_a = this.renderer) || void 0 === _a ? void 0 : _a.stage) || void 0 === _b ? void 0 : _b.call(_a);
    if (stage) {
      stage.render();
      return stage.window.getImageBuffer();
    }
    return this.logger.error(new ReferenceError("render is not defined")), null;
  }
  traverseMarkTree(apply, filter2, leafFirst) {
    return traverseMarkTree(this.rootMark, "children", apply, filter2, leafFirst), this;
  }
  _bindResizeEvent() {
    var _a, _b, _c, _d, _e, _f;
    if (this.autoFit()) {
      const container2 = null === (_e = null === (_d = null === (_c = null === (_b = null === (_a = this.renderer) || void 0 === _a ? void 0 : _a.stage) || void 0 === _b ? void 0 : _b.call(_a)) || void 0 === _c ? void 0 : _c.window) || void 0 === _d ? void 0 : _d.getContainer) || void 0 === _e ? void 0 : _e.call(_d);
      if (container2) {
        const ResizeObserverWindow = window.ResizeObserver;
        this._observer = new ResizeObserverWindow(this._onResize), null === (_f = this._observer) || void 0 === _f || _f.observe(container2);
      }
      window.addEventListener("resize", this._onResize);
    }
  }
  _unBindResizeEvent() {
    this.autoFit() && (window.removeEventListener("resize", this._onResize), this._observer && (this._observer.disconnect(), this._observer = null));
  }
  _getContainerSize() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const container2 = null === (_e = null === (_d = null === (_c = null === (_b = null === (_a = this.renderer) || void 0 === _a ? void 0 : _a.stage) || void 0 === _b ? void 0 : _b.call(_a)) || void 0 === _c ? void 0 : _c.window) || void 0 === _d ? void 0 : _d.getContainer) || void 0 === _e ? void 0 : _e.call(_d);
    if (container2) {
      const { width: containerWidth, height: containerHeight } = getContainerSize(container2);
      return {
        width: null !== (_h = null !== (_g = null === (_f = this._spec) || void 0 === _f ? void 0 : _f.width) && void 0 !== _g ? _g : this._options.width) && void 0 !== _h ? _h : containerWidth,
        height: null !== (_l = null !== (_k = null === (_j = this._spec) || void 0 === _j ? void 0 : _j.height) && void 0 !== _k ? _k : this._options.height) && void 0 !== _l ? _l : containerHeight
      };
    }
    return null;
  }
  resize(width, height, render = true) {
    let needDataflow = false;
    return width !== this.width() && (needDataflow = true, this.updateSignal(SIGNAL_WIDTH, width)), height !== this.height() && (needDataflow = true, this.updateSignal(SIGNAL_HEIGHT, height)), needDataflow && (render ? this.evaluate() : this._dataflow.evaluate()), this;
  }
  _resizeRenderer() {
    const width = this.width(), height = this.height();
    return !!this.renderer.shouldResize(width, height) && (this.renderer.resize(width, height), this.emit("resize", {}, {
      width,
      height
    }), true);
  }
  bindEvents(eventSpec) {
    if (this._eventConfig.disable)
      return;
    const { type: evtType, filter: filter2, callback, throttle: throttle2, debounce: debounce2, consume, target, dependency } = eventSpec, eventSelector = parseEventSelector(evtType);
    if (!eventSelector)
      return;
    const { source, type } = eventSelector, markFilter = generateFilterByMark(eventSelector), validateSignals = (Array.isArray(target) && target.length ? target.map((entry) => ({
      signal: this.getSignalById(entry.target),
      callback: entry.callback
    })) : [{
      signal: isString_default(target) ? this.getSignalById(target) : null,
      callback
    }]).filter((entry) => entry.signal || entry.callback), refs = parseReference(dependency, this), send = parseHandler((evt, element) => {
      const needPreventDefault = source === EVENT_SOURCE_VIEW && prevent(this._eventConfig, type) || consume && (void 0 === evt.cancelable || evt.cancelable);
      source === EVENT_SOURCE_WINDOW && (evt = getExtendedEvents(this, evt, element, type, EVENT_SOURCE_WINDOW));
      let hasCommitted = false;
      if ((!filter2 || filter2(evt)) && (!markFilter || markFilter(element)) && validateSignals.length) {
        const params2 = refs.reduce((params3, ref) => (params3[ref.id()] = ref.output(), params3), {});
        validateSignals.forEach((entry) => {
          if (entry.callback && entry.signal) {
            entry.signal.set(entry.callback(evt, params2)) && (this.commit(entry.signal), hasCommitted = true);
          } else
            entry.callback ? entry.callback(evt, params2) : (this.commit(entry.signal), hasCommitted = true);
        });
      }
      needPreventDefault && evt.preventDefault(), consume && evt.stopPropagation(), hasCommitted && this.run();
    }, {
      throttle: throttle2,
      debounce: debounce2
    });
    if (source === EVENT_SOURCE_VIEW) {
      if (permit(this._eventConfig, EVENT_SOURCE_VIEW, type))
        return this.addEventListener(type, send, NO_TRAP), () => {
          this.removeEventListener(type, send);
        };
    } else if (source === EVENT_SOURCE_WINDOW)
      return vglobal.addEventListener(type, send), this._eventListeners.push({
        type,
        source: vglobal,
        handler: send
      }), () => {
        vglobal.removeEventListener(type, send);
        const index = this._eventListeners.findIndex((entry) => entry.type === type && entry.source === vglobal && entry.handler === send);
        index >= 0 && this._eventListeners.splice(index, 1);
      };
  }
  event(eventSpec) {
    if ("between" in eventSpec) {
      const [starEvent, endEvent] = eventSpec.between, id2 = `${starEvent.type}-${eventSpec.type}-${endEvent.type}`;
      let unbindEndEvent;
      this.bindEvents(Object.assign({}, starEvent, {
        callback: () => {
          if (this._eventCache || (this._eventCache = {}), !this._eventCache[id2]) {
            const unbindEvent = this.bindEvents(eventSpec);
            this._eventCache[id2] = unbindEvent;
          }
          unbindEndEvent || (unbindEndEvent = this.bindEvents(Object.assign({}, endEvent, {
            callback: () => {
              this._eventCache[id2] && (this._eventCache[id2](), this._eventCache[id2] = null);
            }
          })));
        }
      }));
    } else
      "merge" in eventSpec ? eventSpec.merge.forEach((entry) => {
        const singleEvent = Object.assign({}, eventSpec);
        isString_default(entry) ? singleEvent.type = entry : isObject_default(entry) && Object.assign(singleEvent, entry), singleEvent.debounce = 50, this.bindEvents(singleEvent);
      }) : this.bindEvents(eventSpec);
  }
  interaction(type, spec) {
    const interaction = Factory.createInteraction(type, this, spec);
    return interaction && (interaction.bind(), this._boundInteractions || (this._boundInteractions = []), this._boundInteractions.push(interaction)), interaction;
  }
  removeInteraction(type, id2) {
    if (this._boundInteractions) {
      const instances = this._boundInteractions.filter((interaction) => {
        var _a;
        return isNil_default(id2) ? isString_default(type) ? interaction.type === type : type ? interaction === type : void 0 : (null === (_a = interaction.options) || void 0 === _a ? void 0 : _a.id) === id2;
      });
      instances.length && instances.forEach((instance) => {
        instance.unbind();
      });
    }
    return this;
  }
  removeAllInteractions() {
    return this._boundInteractions && (this._boundInteractions.forEach((instance) => {
      instance.unbind();
    }), this._boundInteractions = null), this;
  }
  initEvent() {
    const stage = this.renderer.stage();
    stage && stage.on("*", this.delegateEvent);
  }
  releaseStageEvent() {
    const stage = this.renderer.stage();
    stage && stage.off("*", this.delegateEvent);
  }
  addEventListener(type, handler, options) {
    let callback = handler;
    return options && false === options.trap || (callback = handler, callback.raw = handler), options && options.target && (callback.target = options.target), this.on(type, callback), this;
  }
  removeEventListener(type, handler) {
    return handler ? this.off(type, handler) : this.off(type), this;
  }
  initializeRenderer() {
    const width = this._options.width, height = this._options.height;
    this.renderer = new CanvasRenderer(this), this.renderer.initialize(width, height, this._options, this._eventConfig).background(this._background);
  }
  initialize() {
    var _a;
    this.grammars = new RecordedGrammars((grammar) => grammar.id(), (key, grammar) => this.logger.warn(`Grammar id '${key}' has been occupied`, grammar)), this._cachedGrammars = new RecordedTreeGrammars((grammar) => grammar.id()), this._options.logger && Logger.setInstance(this._options.logger), this.logger = Logger.getInstance(null !== (_a = this._options.logLevel) && void 0 !== _a ? _a : 0), this._dataflow = new Dataflow(), this.animate = new ViewAnimate(this), this._morph = new Morph(), this._options.hooks && (Object.keys(this._options.hooks).forEach((key) => {
      this.on(key, this._options.hooks[key]);
    }), this.hooks = this._options.hooks), this.container = null, this.renderer = null, this._eventListeners = [], this._eventConfig = initializeEventConfig(this._options.eventConfig), this._theme = this._options.disableTheme ? null : ThemeManager.getDefaultTheme(), this.parseBuiltIn(), configureEnvironment(this._options), this.initializeRenderer(), this._eventConfig.disable || this.initEvent(), this._bindResizeEvent(), this._needBuildLayoutTree = true, this._layoutState = LayoutState.before, this.theme(this._theme);
  }
  pauseProgressive() {
    return false;
  }
  resumeProgressive() {
    return false;
  }
  restartProgressive() {
    return false;
  }
  findProgressiveMarks() {
    const marks = [];
    return this.traverseMarkTree((mark) => {
      marks.push(mark);
    }, (mark) => mark.markType !== GrammarMarkType.group && mark.isProgressive()), marks.length ? (this._progressiveMarks = marks, this.renderer && this.renderer.combineIncrementalLayers(), marks) : (this._progressiveMarks = null, null);
  }
  doPreProgressive() {
    if (this._progressiveMarks && this._progressiveMarks.some((mark) => mark.isDoingProgressive())) {
      const raf = vglobal.getRequestAnimationFrame();
      this._progressiveRafId = raf(this.handleProgressiveFrame);
    }
  }
  clearProgressive() {
    if (this._progressiveRafId) {
      vglobal.getCancelAnimationFrame()(this._progressiveRafId);
    }
    this._progressiveMarks && this._progressiveMarks.length && (this._progressiveMarks.forEach((entry) => {
      entry.clearProgressive();
    }), this._progressiveMarks = null);
  }
  release() {
    var _a, _b, _c;
    this.removeAllInteractions(), this.releaseStageEvent(), this._unBindResizeEvent(), this.clearProgressive(), Factory.unregisterRuntimeTransforms(), Logger.setInstance(null), this.animate.stop(), this.grammars.release(), this._cachedGrammars.release(), this._dataflow.release(), this._dataflow = null, null === (_b = null === (_a = this.renderer) || void 0 === _a ? void 0 : _a.release) || void 0 === _b || _b.call(_a), this.renderer = null, this._boundInteractions = null, this.removeAllListeners(), null === (_c = this._eventListeners) || void 0 === _c || _c.forEach((listener) => {
      listener.source.removeEventListener(listener.type, listener.handler);
    }), this._eventListeners = null;
  }
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/mark/graphic
var registerArcGraphic2 = () => {
  registerShadowRoot(), registerArc(), Factory.registerGraphic(GrammarMarkType.arc, createArc);
};
var registerGroupGraphic2 = () => {
  registerShadowRoot(), registerGroup(), Factory.registerGraphic(GrammarMarkType.group, createGroup);
};
var registerLineGraphic2 = () => {
  registerShadowRoot(), registerLine(), Factory.registerGraphic(GrammarMarkType.line, createLine);
};
var registerRectGraphic2 = () => {
  registerShadowRoot(), registerRect(), Factory.registerGraphic(GrammarMarkType.rect, createRect);
};
var registerSymbolGraphic2 = () => {
  registerShadowRoot(), registerSymbol(), Factory.registerGraphic(GrammarMarkType.symbol, createSymbol);
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/component/scale
var ScaleComponent = class extends Component {
  parseAddition(spec) {
    return super.parseAddition(spec), this.scale(spec.scale), this;
  }
  scale(scale4) {
    if (this.spec.scale) {
      const lastScaleGrammar = isString_default(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale;
      this.detach(lastScaleGrammar), this.spec.scale = void 0;
    }
    const scaleGrammar = isString_default(scale4) ? this.view.getScaleById(scale4) : scale4;
    return this.spec.scale = scaleGrammar, this.attach(scaleGrammar), this._updateComponentEncoders(), this.commit(), this;
  }
  getScale() {
    return isString_default(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale;
  }
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/component/axis
var generateLineAxisAttributes = (scale4, theme2, addition, tickCount) => {
  var _a, _b, _c, _d;
  const axisTheme = null !== (_b = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.axis) && void 0 !== _b ? _b : {};
  if (!scale4)
    return merge({}, axisTheme, null != addition ? addition : {});
  const items = [(null !== (_d = null === (_c = scale4.tickData) || void 0 === _c ? void 0 : _c.call(scale4, tickCount)) && void 0 !== _d ? _d : []).map((tick) => ({
    id: tick.index,
    label: tick.tick,
    value: tick.value,
    rawValue: tick.tick
  }))];
  return merge({}, axisTheme, {
    items
  }, null != addition ? addition : {});
};
var generateCircleAxisAttributes = (scale4, theme2, addition, tickCount) => {
  var _a, _b, _c, _d;
  const axisTheme = null !== (_b = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.circleAxis) && void 0 !== _b ? _b : {};
  if (!scale4)
    return merge({}, axisTheme, null != addition ? addition : {});
  const items = [(null !== (_d = null === (_c = scale4.tickData) || void 0 === _c ? void 0 : _c.call(scale4, tickCount)) && void 0 !== _d ? _d : []).map((tick) => ({
    id: tick.index,
    label: tick.tick,
    value: tick.value,
    rawValue: tick.tick
  }))];
  return merge({}, axisTheme, {
    items
  }, null != addition ? addition : {});
};
var generateCoordinateAxisAttribute = (scale4, coordinate, inside, baseValue, layout, isGrid) => {
  var _a;
  const axisPosition = scale4.getCoordinateAxisPosition();
  layout && "auto" === layout.position && (layout.position = inside ? "content" : axisPosition);
  const axisPoints = scale4.getCoordinateAxisPoints(baseValue);
  if (axisPoints) {
    const res = {
      start: axisPoints[0],
      end: axisPoints[1],
      verticalFactor: ("top" === axisPosition || "left" === axisPosition ? -1 : 1) * (inside ? -1 : 1) * ((null === (_a = scale4.getSpec().range) || void 0 === _a ? void 0 : _a.reversed) ? -1 : 1)
    };
    if (isGrid && "polar" === coordinate.type) {
      const angle3 = coordinate.angle();
      res.center = coordinate.origin(), res.startAngle = angle3[0], res.endAngle = angle3[1];
    }
    return res;
  }
  const radius = coordinate.radius(), angle2 = coordinate.angle();
  return {
    center: coordinate.origin(),
    radius: radius[1],
    innerRadius: radius[0],
    inside,
    startAngle: angle2[0],
    endAngle: angle2[1]
  };
};
var Axis = class extends ScaleComponent {
  constructor(view, group, mode) {
    super(view, ComponentEnum.axis, group), this.spec.componentType = ComponentEnum.axis, this.mode = mode;
  }
  parseAddition(spec) {
    return super.parseAddition(spec), this.axisType(spec.axisType), this.tickCount(spec.tickCount), this.inside(spec.inside), this.baseValue(spec.baseValue), this;
  }
  scale(scale4) {
    return super.scale(scale4), this._axisComponentType = null, this;
  }
  axisType(axisType) {
    return this.spec.axisType = axisType, this._axisComponentType = null, this._prepareRejoin(), this.commit(), this;
  }
  addGraphicItem(attrs, groupKey) {
    const initialAttributes = merge({
      x: 0,
      y: 0,
      start: {
        x: 0,
        y: 0
      },
      end: {
        x: 0,
        y: 0
      }
    }, attrs), graphicItem = Factory.createGraphicComponent(this._getAxisComponentType(), initialAttributes, {
      mode: this.mode,
      skipDefault: this.spec.skipTheme
    });
    return super.addGraphicItem(initialAttributes, groupKey, graphicItem);
  }
  tickCount(tickCount) {
    const scaleGrammar = isString_default(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale;
    return scaleGrammar && scaleGrammar.tickCount(tickCount), this.setFunctionSpec(tickCount, "tickCount");
  }
  inside(inside) {
    return this.setFunctionSpec(inside, "inside");
  }
  baseValue(baseValue) {
    return this.setFunctionSpec(baseValue, "baseValue");
  }
  getAxisComponentType() {
    return this._axisComponentType;
  }
  _updateComponentEncoders() {
    const scaleGrammar = isString_default(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale, encoders = Object.assign({
      update: {}
    }, this.spec.encode), componentEncoders = Object.keys(encoders).reduce((res, state) => {
      const encoder = encoders[state];
      return encoder && (res[state] = {
        callback: (datum, element, parameters) => {
          var _a, _b;
          const theme2 = this.spec.skipTheme ? null : this.view.getCurrentTheme();
          let addition = invokeEncoder(encoder, datum, element, parameters);
          const inside = invokeFunctionType(this.spec.inside, parameters, datum, element), baseValue = invokeFunctionType(this.spec.baseValue, parameters, datum, element), coordinate = null === (_a = null == scaleGrammar ? void 0 : scaleGrammar.getCoordinate) || void 0 === _a ? void 0 : _a.call(scaleGrammar);
          coordinate && (addition = Object.assign(generateCoordinateAxisAttribute(scaleGrammar, coordinate, inside, baseValue, this.spec.layout), addition));
          const scale4 = null === (_b = null == scaleGrammar ? void 0 : scaleGrammar.getScale) || void 0 === _b ? void 0 : _b.call(scaleGrammar), tickCount = invokeFunctionType(this.spec.tickCount, parameters, datum, element);
          switch (this._getAxisComponentType()) {
            case AxisEnum.lineAxis:
              return generateLineAxisAttributes(scale4, theme2, addition, tickCount);
            case AxisEnum.circleAxis:
              return generateCircleAxisAttributes(scale4, theme2, addition, tickCount);
          }
          return addition;
        }
      }), res;
    }, {});
    this._encoders = componentEncoders;
  }
  _getAxisComponentType() {
    var _a;
    if (this._axisComponentType)
      return this._axisComponentType;
    let type = this.spec.axisType;
    if (isNil_default(type)) {
      const scaleGrammar = isString_default(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale;
      type = (null === (_a = null == scaleGrammar ? void 0 : scaleGrammar.getCoordinate) || void 0 === _a ? void 0 : _a.call(scaleGrammar)) ? scaleGrammar.getCoordinateAxisPoints() ? "line" : "circle" : "line";
    }
    return this._axisComponentType = "circle" === type ? AxisEnum.circleAxis : AxisEnum.lineAxis, this._axisComponentType;
  }
};
Axis.componentType = ComponentEnum.axis;
var registerAxis = () => {
  Factory.registerGraphicComponent(AxisEnum.lineAxis, (attrs, options) => new LineAxis(attrs, options)), Factory.registerGraphicComponent(AxisEnum.circleAxis, (attrs) => new CircleAxis(attrs)), Factory.registerComponent(ComponentEnum.axis, Axis);
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/component/grid
var generateLineAxisGridAttributes = (scale4, theme2, addition, tickCount) => {
  var _a, _b, _c, _d;
  const gridTheme = null !== (_b = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.grid) && void 0 !== _b ? _b : {};
  if (!scale4)
    return merge({}, gridTheme, null != addition ? addition : {});
  const items = (null !== (_d = null === (_c = scale4.tickData) || void 0 === _c ? void 0 : _c.call(scale4, tickCount)) && void 0 !== _d ? _d : []).map((tick) => ({
    id: tick.index,
    label: tick.tick,
    value: tick.value,
    rawValue: tick.tick
  }));
  return merge({}, gridTheme, {
    items
  }, null != addition ? addition : {});
};
var generateCircleAxisGridAttributes = (scale4, theme2, addition, tickCount) => {
  var _a, _b, _c, _d;
  const gridTheme = null !== (_b = null === (_a = null == theme2 ? void 0 : theme2.components) || void 0 === _a ? void 0 : _a.circleGrid) && void 0 !== _b ? _b : {};
  if (!scale4)
    return merge({}, gridTheme, null != addition ? addition : {});
  const items = (null !== (_d = null === (_c = scale4.tickData) || void 0 === _c ? void 0 : _c.call(scale4, tickCount)) && void 0 !== _d ? _d : []).map((tick) => ({
    id: tick.index,
    label: tick.tick,
    value: tick.value,
    rawValue: tick.tick
  }));
  return merge({}, gridTheme, {
    items
  }, null != addition ? addition : {});
};
var Grid = class extends ScaleComponent {
  constructor(view, group, mode) {
    super(view, ComponentEnum.grid, group), this.spec.componentType = ComponentEnum.grid, this.mode = mode;
  }
  parseAddition(spec) {
    return super.parseAddition(spec), this.target(spec.target), this.gridType(spec.gridType), this.gridShape(spec.gridShape), this;
  }
  scale(scale4) {
    return super.scale(scale4), this._gridComponentType = null, this;
  }
  gridType(gridType) {
    return this.spec.gridType = gridType, this._gridComponentType = null, this._prepareRejoin(), this.commit(), this;
  }
  gridShape(gridShape) {
    return this.spec.gridShape = gridShape, this.commit(), this;
  }
  target(axis2) {
    if (this.spec.target) {
      const prevAxis = isString_default(this.spec.target) ? this.view.getMarkById(this.spec.target) : this.spec.target;
      this.detach(prevAxis);
    }
    this.spec.target = axis2;
    const nextAxis = isString_default(axis2) ? this.view.getMarkById(axis2) : axis2;
    return this.attach(nextAxis), this._targetAxis = nextAxis, this._gridComponentType = null, this._updateComponentEncoders(), this.commit(), this;
  }
  tickCount(tickCount) {
    const scaleGrammar = isString_default(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale;
    return scaleGrammar && scaleGrammar.tickCount(tickCount), this.setFunctionSpec(tickCount, "tickCount");
  }
  inside(inside) {
    return this.setFunctionSpec(inside, "inside");
  }
  baseValue(baseValue) {
    return this.setFunctionSpec(baseValue, "baseValue");
  }
  addGraphicItem(attrs, groupKey) {
    const initialAttributes = merge({
      x: 0,
      y: 0,
      start: {
        x: 0,
        y: 0
      },
      end: {
        x: 0,
        y: 0
      }
    }, attrs), graphicItem = Factory.createGraphicComponent(this._getGridComponentType(), initialAttributes, {
      mode: this.mode,
      skipDefault: this.spec.skipTheme
    });
    return super.addGraphicItem(initialAttributes, groupKey, graphicItem);
  }
  _updateComponentEncoders() {
    const encoders = Object.assign({
      update: {}
    }, this.spec.encode), componentEncoders = Object.keys(encoders).reduce((res, state) => {
      const encoder = encoders[state];
      return encoder && (res[state] = {
        callback: (datum, element, parameters) => {
          var _a, _b, _c, _d;
          const theme2 = this.spec.skipTheme ? null : this.view.getCurrentTheme();
          let scaleGrammar, addition = invokeEncoder(encoder, datum, element, parameters);
          const baseValue = invokeFunctionType(this.spec.baseValue, parameters, datum, element);
          if (this._targetAxis) {
            const targetScale = null === (_a = this._targetAxis.getSpec()) || void 0 === _a ? void 0 : _a.scale;
            scaleGrammar = isString_default(targetScale) ? this.view.getScaleById(targetScale) : targetScale;
            const targetElement = this._targetAxis.elements[0];
            if (targetElement)
              switch (this._getGridComponentType()) {
                case GridEnum.lineAxisGrid:
                  addition = Object.assign({
                    x: targetElement.getGraphicAttribute("x"),
                    y: targetElement.getGraphicAttribute("y"),
                    start: targetElement.getGraphicAttribute("start"),
                    end: targetElement.getGraphicAttribute("end"),
                    verticalFactor: null !== (_b = targetElement.getGraphicAttribute("verticalFactor")) && void 0 !== _b ? _b : 1
                  }, addition);
                  break;
                case GridEnum.circleAxisGrid:
                  addition = Object.assign({
                    x: targetElement.getGraphicAttribute("x"),
                    y: targetElement.getGraphicAttribute("y"),
                    center: targetElement.getGraphicAttribute("center"),
                    radius: targetElement.getGraphicAttribute("radius"),
                    innerRadius: targetElement.getGraphicAttribute("innerRadius"),
                    inside: targetElement.getGraphicAttribute("inside"),
                    startAngle: targetElement.getGraphicAttribute("startAngle"),
                    endAngle: targetElement.getGraphicAttribute("endAngle")
                  }, addition);
              }
          } else {
            scaleGrammar = isString_default(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale;
            const inside = invokeFunctionType(this.spec.inside, parameters, datum, element), coordinate = null === (_c = null == scaleGrammar ? void 0 : scaleGrammar.getCoordinate) || void 0 === _c ? void 0 : _c.call(scaleGrammar);
            coordinate && (addition = Object.assign(generateCoordinateAxisAttribute(scaleGrammar, coordinate, inside, baseValue, this.spec.layout, true), addition));
          }
          this._getGridComponentType() === GridEnum.lineAxisGrid && (addition = "line" !== this.spec.gridShape && this.spec.gridShape ? Object.assign({
            center: addition.start,
            closed: true
          }, addition, {
            type: this.spec.gridShape
          }) : Object.assign({}, addition, {
            type: "line"
          }));
          const scale4 = null === (_d = null == scaleGrammar ? void 0 : scaleGrammar.getScale) || void 0 === _d ? void 0 : _d.call(scaleGrammar), tickCount = invokeFunctionType(this.spec.tickCount, parameters, datum, element);
          switch (this._getGridComponentType()) {
            case GridEnum.lineAxisGrid:
              return generateLineAxisGridAttributes(scale4, theme2, addition, tickCount);
            case GridEnum.circleAxisGrid:
              return generateCircleAxisGridAttributes(scale4, theme2, addition, tickCount);
          }
          return addition;
        }
      }), res;
    }, {});
    this._encoders = componentEncoders;
  }
  _getGridComponentType() {
    var _a;
    if (this._gridComponentType)
      return this._gridComponentType;
    if (this.spec.gridType)
      if ("circle" === this.spec.gridType)
        this._gridComponentType = GridEnum.circleAxisGrid;
      else
        this._gridComponentType = GridEnum.lineAxisGrid;
    else if (this._targetAxis) {
      switch (this._targetAxis.getAxisComponentType()) {
        case AxisEnum.circleAxis:
          this._gridComponentType = GridEnum.circleAxisGrid;
          break;
        case AxisEnum.lineAxis:
        default:
          this._gridComponentType = GridEnum.lineAxisGrid;
      }
    } else if (this.spec.scale) {
      const scaleGrammar = isString_default(this.spec.scale) ? this.view.getScaleById(this.spec.scale) : this.spec.scale;
      this._gridComponentType = (null === (_a = null == scaleGrammar ? void 0 : scaleGrammar.getCoordinate) || void 0 === _a ? void 0 : _a.call(scaleGrammar)) ? scaleGrammar.getCoordinateAxisPoints() ? GridEnum.lineAxisGrid : GridEnum.circleAxisGrid : GridEnum.lineAxisGrid;
    } else
      this._gridComponentType = GridEnum.lineAxisGrid;
    return this._gridComponentType;
  }
};
Grid.componentType = ComponentEnum.grid;
var registerGrid = () => {
  Factory.registerGraphicComponent(GridEnum.lineAxisGrid, (attrs, options) => new LineAxisGrid(attrs, options)), Factory.registerGraphicComponent(GridEnum.circleAxisGrid, (attrs, options) => new CircleAxisGrid(attrs, options)), Factory.registerComponent(ComponentEnum.grid, Grid);
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/transforms/data/filter
var transform = (options, data, parameters) => data.filter((entry) => options.callback(entry, parameters));

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/transforms/data/map
var transform2 = (options, upstreamData, params2) => {
  const func = options.callback, as = options.as;
  if (!options.all)
    return upstreamData.forEach((entry) => {
      const data2 = func(entry, params2);
      if (!isNil_default(as)) {
        if (isNil_default(entry))
          return;
        entry[as] = data2;
      }
      return data2;
    }), upstreamData;
  const data = func(upstreamData, params2);
  return isNil_default(as) || isNil_default(upstreamData) ? data : (upstreamData[as] = data, upstreamData);
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/transforms/util/util
function sum3(arr) {
  return arr.reduce((accumulator, currentValue) => accumulator + currentValue, 0);
}
function average2(arr) {
  if (0 === arr.length)
    return 0;
  return sum3(arr) / arr.length;
}

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/transforms/data/sampling
var samplerMap = {
  min: minInArray,
  max: maxInArray,
  average: average2,
  sum: sum3
};
function lttb(size, array3, isGroup, yfield) {
  const frameSize = Math.floor(array3.length / size), newIndices = [], len = array3.length;
  let maxArea, area2, nextIndex, currentIndex = 0, sampledIndex = 0;
  newIndices[sampledIndex++] = currentIndex;
  for (let i = 1; i < len - 1; i += frameSize) {
    const nextFrameStart = Math.min(i + frameSize, len - 1), nextFrameEnd = Math.min(i + 2 * frameSize, len), avgX = (nextFrameEnd + nextFrameStart) / 2;
    let avgY = 0;
    for (let idx = nextFrameStart; idx < nextFrameEnd; idx++) {
      const value = array3[idx][yfield];
      Number.isNaN(value) || (avgY += value);
    }
    avgY /= nextFrameEnd - nextFrameStart;
    const frameStart = i, frameEnd = Math.min(i + frameSize, len), pointAX = i - 1, pointAY = array3[currentIndex][yfield];
    maxArea = -1, nextIndex = frameStart;
    for (let idx = frameStart; idx < frameEnd; idx++) {
      const value = array3[idx][yfield];
      Number.isNaN(yfield) || (area2 = Math.abs((pointAX - avgX) * (value - pointAY) - (pointAX - idx) * (avgY - pointAY)), area2 > maxArea && (maxArea = area2, nextIndex = idx));
    }
    newIndices[sampledIndex++] = nextIndex, currentIndex = nextIndex;
  }
  newIndices[sampledIndex - 1] !== len - 1 && (newIndices[sampledIndex++] = len - 1);
  return newIndices.map((i) => isGroup ? array3[i].i : i);
}
function sample(size, array3, isGroup, mode, yfield) {
  let frameSize = Math.floor(array3.length / size);
  const newIndices = [], len = array3.length;
  let sampledIndex = 0, frameValues = [];
  newIndices.push(sampledIndex), array3[sampledIndex][yfield] = array3[sampledIndex][yfield];
  for (let i = 1; i < len - 1; i += frameSize) {
    frameSize > len - i && (frameSize = len - i, frameValues.length = frameSize), frameValues = [];
    for (let k2 = 0; k2 < frameSize; k2++)
      frameValues.push(array3[i + k2][yfield]);
    const value = samplerMap[mode](frameValues);
    sampledIndex = Math.min(Math.round(i + frameValues.length / 2) || 0, len - 1), array3[sampledIndex][yfield] = value, newIndices.push(sampledIndex);
  }
  return newIndices.map((i) => isGroup ? array3[i].i : i);
}
function sampleMin(size, array3, isGroup, yfield) {
  return sample(size, array3, isGroup, "min", yfield);
}
function sampleMax(size, array3, isGroup, yfield) {
  return sample(size, array3, isGroup, "max", yfield);
}
function sampleAverage(size, array3, isGroup, yfield) {
  return sample(size, array3, isGroup, "average", yfield);
}
function sampleSum(size, array3, isGroup, yfield) {
  return sample(size, array3, isGroup, "sum", yfield);
}
var transform3 = (options, upstreamData) => {
  let size = options.size;
  const factor = options.factor || 1;
  if (Array.isArray(size) && (size = Math.floor(size[1] - size[0])), size *= factor, size <= 0)
    return [];
  if (upstreamData.length <= size)
    return upstreamData;
  if (options.skipfirst)
    return upstreamData.slice(0, 1);
  const { mode, yfield: y, groupBy: groupBy2 } = options, yfield = null != y ? y : "y";
  let sampler = lttb;
  if ("min" === mode ? sampler = sampleMin : "max" === mode ? sampler = sampleMax : "average" === mode ? sampler = sampleAverage : "sum" === mode && (sampler = sampleSum), upstreamData.length) {
    const groups2 = {};
    if (groupBy2) {
      for (let i = 0, n = upstreamData.length; i < n; i++) {
        const datum = upstreamData[i], groupId = datum[groupBy2];
        groups2[groupId] ? groups2[groupId].push({
          [yfield]: datum[yfield],
          i
        }) : (groups2[groupId] = [], groups2[groupId].push({
          [yfield]: datum[yfield],
          i
        }));
      }
      let rawIndice = [];
      return Object.keys(groups2).forEach((groupName) => {
        const group = groups2[groupName];
        if (group.length <= size) {
          const indices = group.map((datum) => datum.i);
          rawIndice = rawIndice.concat(indices);
        } else {
          const indices = sampler(size, group, true, yfield);
          rawIndice = rawIndice.concat(indices), group.forEach((datum) => upstreamData[datum.i][yfield] = datum[yfield]);
        }
      }), rawIndice.sort((a3, b) => a3 - b), rawIndice.map((index) => upstreamData[index]);
    }
    return sampler(size, upstreamData, false, yfield).map((index) => upstreamData[index]);
  }
  return [];
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/transforms/mark/mark-overlap
var HIDE_KEY = "_mo_hide_";
function reset2(elements) {
  return elements.forEach((element) => {
    element.getGraphicAttribute(HIDE_KEY) && (element.setGraphicAttribute("visible", true), element.setGraphicAttribute(HIDE_KEY, false));
  }), elements;
}
function overlapX(elements, delta, deltaMul, useRadius) {
  if (useRadius) {
    let lastX = -1 / 0, lastR = 0;
    const useDeltaMul = isNil_default(delta);
    let itemDelta = delta;
    elements.forEach((element) => {
      if (false === element.getGraphicAttribute("visible"))
        return;
      const r = element.getGraphicAttribute("size") / 2, currentX = element.getGraphicAttribute("x");
      useDeltaMul && (itemDelta = (r + lastR) * deltaMul), Math.abs(currentX - lastX) < itemDelta + lastR + r ? element.getGraphicAttribute("forceShow") || (element.setGraphicAttribute(HIDE_KEY, true), element.setGraphicAttribute("visible", false)) : lastX = currentX, lastR = r;
    });
  }
}
function overlapY(elements, delta, deltaMul, useRadius) {
  if (useRadius) {
    let lastY = -1 / 0, lastR = 0;
    const useDeltaMul = isNil_default(delta);
    let itemDelta = delta;
    elements.forEach((element) => {
      if (false === element.getGraphicAttribute("visible"))
        return;
      const r = element.getGraphicAttribute("size") / 2, currentY = element.getGraphicAttribute("y");
      useDeltaMul && (itemDelta = (r + lastR) * deltaMul), Math.abs(currentY - lastY) < itemDelta + lastR + r ? element.getGraphicAttribute("forceShow") || (element.setGraphicAttribute(HIDE_KEY, true), element.setGraphicAttribute("visible", false)) : lastY = currentY, lastR = r;
    });
  }
}
function overlapXY(elements, delta, deltaMul, useRadius) {
  if (useRadius) {
    const lastX = -1 / 0;
    let lastY = -1 / 0, lastR = 0, dis = 0;
    const useDeltaMul = isNil_default(delta);
    let itemDelta = delta;
    elements.forEach((element) => {
      if (false === element.getGraphicAttribute("visible"))
        return;
      const r = element.getGraphicAttribute("size") / 2, currentX = element.getGraphicAttribute("x"), currentY = element.getGraphicAttribute("y");
      useDeltaMul && (itemDelta = (r + lastR) * deltaMul), dis = (lastX - currentX) ** 2 + (lastY - currentY) ** 2, dis < (itemDelta + lastR + r) ** 2 ? element.getGraphicAttribute("forceShow") || (element.setGraphicAttribute(HIDE_KEY, true), element.setGraphicAttribute("visible", false)) : lastY = currentY, lastR = r;
    });
  }
}
var transform4 = (options, upstreamData) => {
  if (!upstreamData || 0 === upstreamData.length)
    return;
  let { radius } = options;
  isNil_default(radius) && "symbol" === upstreamData[0].mark.markType && (radius = true);
  const { direction: direction2, delta, deltaMul = 1, groupBy: groupBy2 } = options, handleOverlap = (elements) => {
    reset2(elements);
    const sortedElements = options.sort ? elements.slice().sort((a3, b) => a3.getGraphicAttribute("x") - b.getGraphicAttribute("x")) : elements;
    0 === direction2 ? overlapXY(sortedElements, delta, deltaMul, radius) : 1 === direction2 ? overlapX(sortedElements, delta, deltaMul, radius) : overlapY(sortedElements, delta, deltaMul, radius);
  };
  if (groupBy2) {
    const map4 = upstreamData.reduce((res, element) => {
      const groupName = element.getDatum()[groupBy2];
      return res[groupName] ? res[groupName].push(element) : res[groupName] = [element], res;
    }, {});
    Object.keys(map4).forEach((key) => {
      handleOverlap(map4[key]);
    });
  } else
    handleOverlap(upstreamData);
  return upstreamData;
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/transforms
var registerFilterTransform = () => {
  Factory.registerTransform("filter", {
    transform,
    markPhase: "beforeJoin"
  }, true);
};
var registerMapTransform = () => {
  Factory.registerTransform("map", {
    transform: transform2,
    markPhase: "beforeJoin"
  }, true);
};
var registerSampleTransform = () => {
  Factory.registerTransform("sampling", {
    transform: transform3,
    markPhase: "afterEncode"
  }, true);
};
var registerMarkOverlapTransform = () => {
  Factory.registerTransform("markoverlap", {
    transform: transform4,
    markPhase: "afterEncode"
  }, true);
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/animation/animation/clip
var clipIn = (element, options, animationParameters) => {
  var _a;
  const clipDimension = element.getGraphicAttribute("clipRangeByDimension", false), clipRange = null !== (_a = element.getGraphicAttribute("clipRange", false)) && void 0 !== _a ? _a : 1;
  return options && options.clipDimension ? {
    from: {
      clipRange: 0,
      clipRangeByDimension: options.clipDimension
    },
    to: {
      clipRange,
      clipRangeByDimension: clipDimension
    }
  } : {
    from: {
      clipRange: 0
    },
    to: {
      clipRange
    }
  };
};
var clipOut = (element, options, animationParameters) => {
  var _a;
  const clipDimension = element.getGraphicAttribute("clipRangeByDimension", true), clipRange = null !== (_a = element.getGraphicAttribute("clipRange", true)) && void 0 !== _a ? _a : 1;
  return options && options.clipDimension ? {
    from: {
      clipRange,
      clipRangeByDimension: options.clipDimension
    },
    to: {
      clipRange: 0,
      clipRangeByDimension: clipDimension
    }
  } : {
    from: {
      clipRange
    },
    to: {
      clipRange: 0
    }
  };
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/animation/animation/fade
var fadeIn = (element, options, animationParameters) => {
  var _a, _b, _c;
  const finalAttrs = element.getFinalGraphicAttributes();
  return {
    from: {
      opacity: 0,
      fillOpacity: 0,
      strokeOpacity: 0
    },
    to: {
      opacity: null !== (_a = finalAttrs.opacity) && void 0 !== _a ? _a : 1,
      fillOpacity: null !== (_b = finalAttrs.fillOpacity) && void 0 !== _b ? _b : 1,
      strokeOpacity: null !== (_c = finalAttrs.strokeOpacity) && void 0 !== _c ? _c : 1
    }
  };
};
var fadeOut = (element, options, animationParameters) => {
  var _a, _b, _c;
  return {
    from: {
      opacity: null !== (_a = element.getGraphicAttribute("opacity", true)) && void 0 !== _a ? _a : 1,
      fillOpacity: null !== (_b = element.getGraphicAttribute("fillOpacity", true)) && void 0 !== _b ? _b : 1,
      strokeOpacity: null !== (_c = element.getGraphicAttribute("strokeOpacity", true)) && void 0 !== _c ? _c : 1
    },
    to: {
      opacity: 0,
      fillOpacity: 0,
      strokeOpacity: 0
    }
  };
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/animation/animation/grow-cartesian
var growCenterIn = (element, options, animationParameters) => {
  switch (null == options ? void 0 : options.direction) {
    case "x": {
      const x = element.getGraphicAttribute("x", false), x14 = element.getGraphicAttribute("x1", false), width = element.getGraphicAttribute("width", false);
      return {
        from: isValid_default(width) ? {
          x: x + width / 2,
          x1: void 0,
          width: 0
        } : {
          x: (x + x14) / 2,
          x1: (x + x14) / 2,
          width: void 0
        },
        to: {
          x,
          x1: x14,
          width
        }
      };
    }
    case "y": {
      const y = element.getGraphicAttribute("y", false), y14 = element.getGraphicAttribute("y1", false), height = element.getGraphicAttribute("height", false);
      return {
        from: isValid_default(height) ? {
          y: y + height / 2,
          y1: void 0,
          height: 0
        } : {
          y: (y + y14) / 2,
          y1: (y + y14) / 2,
          height: void 0
        },
        to: {
          y,
          y1: y14,
          height
        }
      };
    }
    default: {
      const x = element.getGraphicAttribute("x", false), x14 = element.getGraphicAttribute("x1", false), width = element.getGraphicAttribute("width", false), y = element.getGraphicAttribute("y", false), y14 = element.getGraphicAttribute("y1", false), height = element.getGraphicAttribute("height", false), from = {};
      return isValid_default(width) ? (from.x = x + width / 2, from.width = 0, from.x1 = void 0) : (from.x = (x + x14) / 2, from.x1 = (x + x14) / 2, from.width = void 0), isValid_default(height) ? (from.y = y + height / 2, from.height = 0, from.y1 = void 0) : (from.y = (y + y14) / 2, from.y1 = (y + y14) / 2, from.height = void 0), {
        from,
        to: {
          x,
          y,
          x1: x14,
          y1: y14,
          width,
          height
        }
      };
    }
  }
};
var growCenterOut = (element, options, animationParameters) => {
  switch (null == options ? void 0 : options.direction) {
    case "x": {
      const x = element.getGraphicAttribute("x", false), x14 = element.getGraphicAttribute("x1", false), width = element.getGraphicAttribute("width", false);
      return {
        to: isValid_default(width) ? {
          x: x + width / 2,
          x1: void 0,
          width: 0
        } : {
          x: (x + x14) / 2,
          x1: (x + x14) / 2,
          width: void 0
        }
      };
    }
    case "y": {
      const y = element.getGraphicAttribute("y", false), y14 = element.getGraphicAttribute("y1", false), height = element.getGraphicAttribute("height", false);
      return {
        to: isValid_default(height) ? {
          y: y + height / 2,
          y1: void 0,
          height: 0
        } : {
          y: (y + y14) / 2,
          y1: (y + y14) / 2,
          height: void 0
        }
      };
    }
    default: {
      const x = element.getGraphicAttribute("x", false), y = element.getGraphicAttribute("y", false), x14 = element.getGraphicAttribute("x1", false), y14 = element.getGraphicAttribute("y1", false), width = element.getGraphicAttribute("width", false), height = element.getGraphicAttribute("height", false), to = {};
      return isValid_default(width) ? (to.x = x + width / 2, to.width = 0, to.x1 = void 0) : (to.x = (x + x14) / 2, to.x1 = (x + x14) / 2, to.width = void 0), isValid_default(height) ? (to.y = y + height / 2, to.height = 0, to.y1 = void 0) : (to.y = (y + y14) / 2, to.y1 = (y + y14) / 2, to.height = void 0), {
        to
      };
    }
  }
};
function growWidthInIndividual(element, options, animationParameters) {
  const x = element.getGraphicAttribute("x", false), x14 = element.getGraphicAttribute("x1", false), width = element.getGraphicAttribute("width", false);
  if (options && "negative" === options.orient) {
    const computedX1 = isValid_default(width) ? Math.max(x, x + width) : Math.max(x, x14);
    return {
      from: {
        x: computedX1,
        x1: isNil_default(x14) ? void 0 : computedX1,
        width: isNil_default(width) ? void 0 : 0
      },
      to: {
        x,
        x1: x14,
        width
      }
    };
  }
  const computedX = isValid_default(width) ? Math.min(x, x + width) : Math.min(x, x14);
  return {
    from: {
      x: computedX,
      x1: isNil_default(x14) ? void 0 : computedX,
      width: isNil_default(width) ? void 0 : 0
    },
    to: {
      x,
      x1: x14,
      width
    }
  };
}
function growWidthInOverall(element, options, animationParameters) {
  var _a;
  const x = element.getGraphicAttribute("x", false), x14 = element.getGraphicAttribute("x1", false), width = element.getGraphicAttribute("width", false);
  let overallValue;
  return options && "negative" === options.orient ? isNumber_default(options.overall) ? overallValue = options.overall : animationParameters.group ? (overallValue = null !== (_a = animationParameters.groupWidth) && void 0 !== _a ? _a : animationParameters.group.getBounds().width(), animationParameters.groupWidth = overallValue) : overallValue = animationParameters.width : overallValue = isNumber_default(null == options ? void 0 : options.overall) ? null == options ? void 0 : options.overall : 0, {
    from: {
      x: overallValue,
      x1: isNil_default(x14) ? void 0 : overallValue,
      width: isNil_default(width) ? void 0 : 0
    },
    to: {
      x,
      x1: x14,
      width
    }
  };
}
var growWidthIn = (element, options, animationParameters) => {
  var _a;
  return false !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growWidthInOverall(element, options, animationParameters) : growWidthInIndividual(element, options, animationParameters);
};
function growWidthOutIndividual(element, options, animationParameters) {
  const x = element.getGraphicAttribute("x", false), x14 = element.getGraphicAttribute("x1", false), width = element.getGraphicAttribute("width", false);
  if (options && "negative" === options.orient) {
    const computedX1 = isValid_default(width) ? Math.max(x, x + width) : Math.max(x, x14);
    return {
      to: {
        x: computedX1,
        x1: isNil_default(x14) ? void 0 : computedX1,
        width: isNil_default(width) ? void 0 : 0
      }
    };
  }
  const computedX = isValid_default(width) ? Math.min(x, x + width) : Math.min(x, x14);
  return {
    to: {
      x: computedX,
      x1: isNil_default(x14) ? void 0 : computedX,
      width: isNil_default(width) ? void 0 : 0
    }
  };
}
function growWidthOutOverall(element, options, animationParameters) {
  var _a;
  const x14 = element.getGraphicAttribute("x1", false), width = element.getGraphicAttribute("width", false);
  let overallValue;
  return options && "negative" === options.orient ? isNumber_default(options.overall) ? overallValue = options.overall : animationParameters.group ? (overallValue = null !== (_a = animationParameters.groupWidth) && void 0 !== _a ? _a : animationParameters.group.getBounds().width(), animationParameters.groupWidth = overallValue) : overallValue = animationParameters.width : overallValue = isNumber_default(null == options ? void 0 : options.overall) ? options.overall : 0, {
    to: {
      x: overallValue,
      x1: isNil_default(x14) ? void 0 : overallValue,
      width: isNil_default(width) ? void 0 : 0
    }
  };
}
var growWidthOut = (element, options, animationParameters) => {
  var _a;
  return false !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growWidthOutOverall(element, options, animationParameters) : growWidthOutIndividual(element, options, animationParameters);
};
function growHeightInIndividual(element, options, animationParameters) {
  const y = element.getGraphicAttribute("y", false), y14 = element.getGraphicAttribute("y1", false), height = element.getGraphicAttribute("height", false);
  if (options && "negative" === options.orient) {
    const computedY1 = isValid_default(height) ? Math.max(y, y + height) : Math.max(y, y14);
    return {
      from: {
        y: computedY1,
        y1: isNil_default(y14) ? void 0 : computedY1,
        height: isNil_default(height) ? void 0 : 0
      },
      to: {
        y,
        y1: y14,
        height
      }
    };
  }
  const computedY = isValid_default(height) ? Math.min(y, y + height) : Math.min(y, y14);
  return {
    from: {
      y: computedY,
      y1: isNil_default(y14) ? void 0 : computedY,
      height: isNil_default(height) ? void 0 : 0
    },
    to: {
      y,
      y1: y14,
      height
    }
  };
}
function growHeightInOverall(element, options, animationParameters) {
  var _a;
  const y = element.getGraphicAttribute("y", false), y14 = element.getGraphicAttribute("y1", false), height = element.getGraphicAttribute("height", false);
  let overallValue;
  return options && "negative" === options.orient ? isNumber_default(options.overall) ? overallValue = options.overall : animationParameters.group ? (overallValue = null !== (_a = animationParameters.groupHeight) && void 0 !== _a ? _a : animationParameters.group.getBounds().height(), animationParameters.groupHeight = overallValue) : overallValue = animationParameters.height : overallValue = isNumber_default(null == options ? void 0 : options.overall) ? options.overall : 0, {
    from: {
      y: overallValue,
      y1: isNil_default(y14) ? void 0 : overallValue,
      height: isNil_default(height) ? void 0 : 0
    },
    to: {
      y,
      y1: y14,
      height
    }
  };
}
var growHeightIn = (element, options, animationParameters) => {
  var _a;
  return false !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growHeightInOverall(element, options, animationParameters) : growHeightInIndividual(element, options, animationParameters);
};
function growHeightOutIndividual(element, options, animationParameters) {
  const y = element.getGraphicAttribute("y", false), y14 = element.getGraphicAttribute("y1", false), height = element.getGraphicAttribute("height", false);
  if (options && "negative" === options.orient) {
    const computedY1 = isValid_default(height) ? Math.max(y, y + height) : Math.max(y, y14);
    return {
      to: {
        y: computedY1,
        y1: isNil_default(y14) ? void 0 : computedY1,
        height: isNil_default(height) ? void 0 : 0
      }
    };
  }
  const computedY = isValid_default(height) ? Math.min(y, y + height) : Math.min(y, y14);
  return {
    to: {
      y: computedY,
      y1: isNil_default(y14) ? void 0 : computedY,
      height: isNil_default(height) ? void 0 : 0
    }
  };
}
function growHeightOutOverall(element, options, animationParameters) {
  var _a;
  const y14 = element.getGraphicAttribute("y1", false), height = element.getGraphicAttribute("height", false);
  let overallValue;
  return options && "negative" === options.orient ? isNumber_default(options.overall) ? overallValue = options.overall : animationParameters.group ? (overallValue = null !== (_a = animationParameters.groupHeight) && void 0 !== _a ? _a : animationParameters.group.getBounds().height(), animationParameters.groupHeight = overallValue) : overallValue = animationParameters.height : overallValue = isNumber_default(null == options ? void 0 : options.overall) ? options.overall : 0, {
    to: {
      y: overallValue,
      y1: isNil_default(y14) ? void 0 : overallValue,
      height: isNil_default(height) ? void 0 : 0
    }
  };
}
var growHeightOut = (element, options, animationParameters) => {
  var _a;
  return false !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growHeightOutOverall(element, options, animationParameters) : growHeightOutIndividual(element, options, animationParameters);
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/animation/animation/grow-polar
var growAngleInIndividual = (element, options, animationParameters) => {
  const finalAttrs = element.getFinalGraphicAttributes();
  return options && "anticlockwise" === options.orient ? {
    from: {
      startAngle: null == finalAttrs ? void 0 : finalAttrs.endAngle
    },
    to: {
      startAngle: null == finalAttrs ? void 0 : finalAttrs.startAngle
    }
  } : {
    from: {
      endAngle: null == finalAttrs ? void 0 : finalAttrs.startAngle
    },
    to: {
      endAngle: null == finalAttrs ? void 0 : finalAttrs.endAngle
    }
  };
};
var growAngleInOverall = (element, options, animationParameters) => {
  const finalAttrs = element.getFinalGraphicAttributes();
  if (options && "anticlockwise" === options.orient) {
    const overallValue2 = isNumber_default(options.overall) ? options.overall : 2 * Math.PI;
    return {
      from: {
        startAngle: overallValue2,
        endAngle: overallValue2
      },
      to: {
        startAngle: null == finalAttrs ? void 0 : finalAttrs.startAngle,
        endAngle: null == finalAttrs ? void 0 : finalAttrs.endAngle
      }
    };
  }
  const overallValue = isNumber_default(null == options ? void 0 : options.overall) ? options.overall : 0;
  return {
    from: {
      startAngle: overallValue,
      endAngle: overallValue
    },
    to: {
      startAngle: null == finalAttrs ? void 0 : finalAttrs.startAngle,
      endAngle: null == finalAttrs ? void 0 : finalAttrs.endAngle
    }
  };
};
var growAngleIn = (element, options, animationParameters) => {
  var _a;
  return false !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growAngleInOverall(element, options) : growAngleInIndividual(element, options);
};
var growAngleOutIndividual = (element, options, animationParameters) => {
  const finalAttrs = element.getFinalGraphicAttributes();
  return options && "anticlockwise" === options.orient ? {
    from: {
      startAngle: element.getGraphicAttribute("startAngle", true)
    },
    to: {
      startAngle: null == finalAttrs ? void 0 : finalAttrs.endAngle
    }
  } : {
    from: {
      endAngle: element.getGraphicAttribute("endAngle", true)
    },
    to: {
      endAngle: null == finalAttrs ? void 0 : finalAttrs.startAngle
    }
  };
};
var growAngleOutOverall = (element, options, animationParameters) => {
  if (options && "anticlockwise" === options.orient) {
    const overallValue2 = isNumber_default(options.overall) ? options.overall : 2 * Math.PI;
    return {
      from: {
        startAngle: element.getGraphicAttribute("startAngle", true),
        endAngle: element.getGraphicAttribute("endAngle", true)
      },
      to: {
        startAngle: overallValue2,
        endAngle: overallValue2
      }
    };
  }
  const overallValue = isNumber_default(null == options ? void 0 : options.overall) ? options.overall : 0;
  return {
    from: {
      startAngle: element.getGraphicAttribute("startAngle", true),
      endAngle: element.getGraphicAttribute("endAngle", true)
    },
    to: {
      startAngle: overallValue,
      endAngle: overallValue
    }
  };
};
var growAngleOut = (element, options, animationParameters) => {
  var _a;
  return false !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growAngleOutOverall(element, options) : growAngleOutIndividual(element, options);
};
var growRadiusInIndividual = (element, options, animationParameters) => {
  const finalAttrs = element.getFinalGraphicAttributes();
  return options && "inside" === options.orient ? {
    from: {
      innerRadius: null == finalAttrs ? void 0 : finalAttrs.outerRadius
    },
    to: {
      innerRadius: null == finalAttrs ? void 0 : finalAttrs.innerRadius
    }
  } : {
    from: {
      outerRadius: null == finalAttrs ? void 0 : finalAttrs.innerRadius
    },
    to: {
      outerRadius: null == finalAttrs ? void 0 : finalAttrs.outerRadius
    }
  };
};
var growRadiusInOverall = (element, options, animationParameters) => {
  const finalAttrs = element.getFinalGraphicAttributes(), overallValue = isNumber_default(null == options ? void 0 : options.overall) ? options.overall : 0;
  return {
    from: {
      innerRadius: overallValue,
      outerRadius: overallValue
    },
    to: {
      innerRadius: null == finalAttrs ? void 0 : finalAttrs.innerRadius,
      outerRadius: null == finalAttrs ? void 0 : finalAttrs.outerRadius
    }
  };
};
var growRadiusIn = (element, options, animationParameters) => {
  var _a;
  return false !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growRadiusInOverall(element, options) : growRadiusInIndividual(element, options);
};
var growRadiusOutIndividual = (element, options, animationParameters) => {
  const finalAttrs = element.getFinalGraphicAttributes();
  return options && "inside" === options.orient ? {
    from: {
      innerRadius: element.getGraphicAttribute("innerRadius", true)
    },
    to: {
      innerRadius: null == finalAttrs ? void 0 : finalAttrs.outerRadius
    }
  } : {
    from: {
      outerRadius: element.getGraphicAttribute("outerRadius", true)
    },
    to: {
      outerRadius: null == finalAttrs ? void 0 : finalAttrs.innerRadius
    }
  };
};
var growRadiusOutOverall = (element, options, animationParameters) => {
  const overallValue = isNumber_default(null == options ? void 0 : options.overall) ? options.overall : 0;
  return {
    from: {
      innerRadius: element.getGraphicAttribute("innerRadius", true),
      outerRadius: element.getGraphicAttribute("outerRadius", true)
    },
    to: {
      innerRadius: overallValue,
      outerRadius: overallValue
    }
  };
};
var growRadiusOut = (element, options, animationParameters) => {
  var _a;
  return false !== (null !== (_a = null == options ? void 0 : options.overall) && void 0 !== _a && _a) ? growRadiusOutOverall(element, options) : growRadiusOutIndividual(element, options);
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/animation/animation/grow-points
var getCenterPoints = (element, options, animationParameters) => {
  const points = element.getGraphicAttribute("points", false), center2 = {
    x: 0,
    y: 0
  };
  return points.forEach((point5) => {
    center2.x += point5.x, center2.y += point5.y;
  }), center2.x /= points.length, center2.y /= points.length, options && options.center && (isValidNumber_default(options.center.x) && (center2.x = options.center.x), isValidNumber_default(options.center.y) && (center2.y = options.center.y)), "area" === element.mark.markType && (center2.x1 = center2.x, center2.y1 = center2.y), points.map(() => Object.assign(center2));
};
var growPointsIn = (element, options, animationParameters) => ({
  from: {
    points: getCenterPoints(element, options)
  },
  to: {
    points: element.getGraphicAttribute("points", false)
  }
});
var growPointsOut = (element, options, animationParameters) => ({
  from: {
    points: element.getGraphicAttribute("points", true)
  },
  to: {
    points: getCenterPoints(element, options)
  }
});
var changePointsX = (element, options, animationParameters) => element.getGraphicAttribute("points", false).map((point5) => {
  var _a;
  if (options && "negative" === options.orient) {
    let groupRight = animationParameters.width;
    return animationParameters.group && (groupRight = null !== (_a = animationParameters.groupWidth) && void 0 !== _a ? _a : animationParameters.group.getBounds().width(), animationParameters.groupWidth = groupRight), {
      x: groupRight,
      y: point5.y,
      x1: groupRight,
      y1: point5.y1,
      defined: false !== point5.defined
    };
  }
  return {
    x: 0,
    y: point5.y,
    x1: 0,
    y1: point5.y1,
    defined: false !== point5.defined
  };
});
var growPointsXIn = (element, options, animationParameters) => ({
  from: {
    points: changePointsX(element, options, animationParameters)
  },
  to: {
    points: element.getGraphicAttribute("points", false)
  }
});
var growPointsXOut = (element, options, animationParameters) => ({
  from: {
    points: element.getGraphicAttribute("points", true)
  },
  to: {
    points: changePointsX(element, options, animationParameters)
  }
});
var changePointsY = (element, options, animationParameters) => element.getGraphicAttribute("points", false).map((point5) => {
  var _a;
  if (options && "negative" === options.orient) {
    let groupBottom = animationParameters.height;
    return animationParameters.group && (groupBottom = null !== (_a = animationParameters.groupHeight) && void 0 !== _a ? _a : animationParameters.group.getBounds().height(), animationParameters.groupHeight = groupBottom), {
      x: point5.x,
      y: groupBottom,
      x1: point5.x1,
      y1: groupBottom,
      defined: false !== point5.defined
    };
  }
  return {
    x: point5.x,
    y: 0,
    x1: point5.x1,
    y1: 0,
    defined: false !== point5.defined
  };
});
var growPointsYIn = (element, options, animationParameters) => ({
  from: {
    points: changePointsY(element, options, animationParameters)
  },
  to: {
    points: element.getGraphicAttribute("points", false)
  }
});
var growPointsYOut = (element, options, animationParameters) => ({
  from: {
    points: element.getGraphicAttribute("points", true)
  },
  to: {
    points: changePointsY(element, options, animationParameters)
  }
});

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/animation/animation/move
var moveIn = (element, options, animationParameters) => {
  var _a, _b;
  const { offset = 0, orient, direction: direction2, point: pointOpt } = null != options ? options : {};
  let changedX = 0, changedY = 0;
  "negative" === orient && (animationParameters.group ? (changedX = null !== (_a = animationParameters.groupWidth) && void 0 !== _a ? _a : animationParameters.group.getBounds().width(), changedY = null !== (_b = animationParameters.groupHeight) && void 0 !== _b ? _b : animationParameters.group.getBounds().height(), animationParameters.groupWidth = changedX, animationParameters.groupHeight = changedY) : (changedX = animationParameters.width, changedY = animationParameters.height)), changedX += offset, changedY += offset;
  const point5 = isFunction_default(pointOpt) ? pointOpt.call(null, element.getDatum(), element, animationParameters) : pointOpt, fromX = point5 && isValidNumber_default(point5.x) ? point5.x : changedX, fromY = point5 && isValidNumber_default(point5.y) ? point5.y : changedY, finalAttrs = element.getFinalGraphicAttributes();
  switch (direction2) {
    case "x":
      return {
        from: {
          x: fromX
        },
        to: {
          x: null == finalAttrs ? void 0 : finalAttrs.x
        }
      };
    case "y":
      return {
        from: {
          y: fromY
        },
        to: {
          y: null == finalAttrs ? void 0 : finalAttrs.y
        }
      };
    default:
      return {
        from: {
          x: fromX,
          y: fromY
        },
        to: {
          x: null == finalAttrs ? void 0 : finalAttrs.x,
          y: null == finalAttrs ? void 0 : finalAttrs.y
        }
      };
  }
};
var moveOut = (element, options, animationParameters) => {
  var _a, _b;
  const { offset = 0, orient, direction: direction2, point: pointOpt } = null != options ? options : {}, groupBounds = animationParameters.group ? animationParameters.group.getBounds() : null, groupWidth = null !== (_a = null == groupBounds ? void 0 : groupBounds.width()) && void 0 !== _a ? _a : animationParameters.width, groupHeight = null !== (_b = null == groupBounds ? void 0 : groupBounds.height()) && void 0 !== _b ? _b : animationParameters.height, changedX = ("negative" === orient ? groupWidth : 0) + offset, changedY = ("negative" === orient ? groupHeight : 0) + offset, point5 = isFunction_default(pointOpt) ? pointOpt.call(null, element.getDatum(), element, animationParameters) : pointOpt, fromX = point5 && isValidNumber_default(point5.x) ? point5.x : changedX, fromY = point5 && isValidNumber_default(point5.y) ? point5.y : changedY;
  switch (direction2) {
    case "x":
      return {
        from: {
          x: element.getGraphicAttribute("x", true)
        },
        to: {
          x: fromX
        }
      };
    case "y":
      return {
        from: {
          y: element.getGraphicAttribute("y", true)
        },
        to: {
          y: fromY
        }
      };
    default:
      return {
        from: {
          x: element.getGraphicAttribute("x", true),
          y: element.getGraphicAttribute("y", true)
        },
        to: {
          x: fromX,
          y: fromY
        }
      };
  }
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/animation/animation/scale
var scaleIn = (element, options, animationParameters) => {
  var _a, _b, _c, _d;
  const finalAttrs = element.getFinalGraphicAttributes();
  switch (null == options ? void 0 : options.direction) {
    case "x":
      return {
        from: {
          scaleX: 0
        },
        to: {
          scaleX: null !== (_a = null == finalAttrs ? void 0 : finalAttrs.scaleX) && void 0 !== _a ? _a : 1
        }
      };
    case "y":
      return {
        from: {
          scaleY: 0
        },
        to: {
          scaleY: null !== (_b = null == finalAttrs ? void 0 : finalAttrs.scaleY) && void 0 !== _b ? _b : 1
        }
      };
    default:
      return {
        from: {
          scaleX: 0,
          scaleY: 0
        },
        to: {
          scaleX: null !== (_c = null == finalAttrs ? void 0 : finalAttrs.scaleX) && void 0 !== _c ? _c : 1,
          scaleY: null !== (_d = null == finalAttrs ? void 0 : finalAttrs.scaleY) && void 0 !== _d ? _d : 1
        }
      };
  }
};
var scaleOut = (element, options, animationParameters) => {
  var _a, _b, _c, _d;
  switch (null == options ? void 0 : options.direction) {
    case "x":
      return {
        from: {
          scaleX: null !== (_a = element.getGraphicAttribute("scaleX", true)) && void 0 !== _a ? _a : 1
        },
        to: {
          scaleX: 0
        }
      };
    case "y":
      return {
        from: {
          scaleY: null !== (_b = element.getGraphicAttribute("scaleY", true)) && void 0 !== _b ? _b : 1
        },
        to: {
          scaleY: 0
        }
      };
    default:
      return {
        from: {
          scaleX: null !== (_c = element.getGraphicAttribute("scaleX", true)) && void 0 !== _c ? _c : 1,
          scaleY: null !== (_d = element.getGraphicAttribute("scaleY", true)) && void 0 !== _d ? _d : 1
        },
        to: {
          scaleX: 0,
          scaleY: 0
        }
      };
  }
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/animation/animation/update
var BUILT_IN_EXCLUDE_CHANNELS = {
  symbol: ["_mo_hide_", "visible"]
};
var update = (element, options, animationParameters) => {
  const from = Object.assign({}, element.getPrevGraphicAttributes()), to = Object.assign({}, element.getNextGraphicAttributes());
  let excludeChannels;
  options && array(options.excludeChannels).forEach((key) => {
    delete from[key], delete to[key];
  }), element.mark && element.mark.markType && (excludeChannels = BUILT_IN_EXCLUDE_CHANNELS[element.mark.markType]) && excludeChannels.forEach((key) => {
    delete from[key], delete to[key];
  }), Object.keys(to).forEach((key) => {
    isEqual2(key, from, to) && (delete from[key], delete to[key]);
  });
  const final = element.getFinalGraphicAttributes();
  return Object.keys(from).forEach((key) => {
    isNil_default(to[key]) && (isNil_default(final[key]) || isEqual(from[key], final[key]) ? delete from[key] : to[key] = final[key]);
  }), {
    from,
    to
  };
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/animation/animation/rotate
var rotateIn = (element, options, animationParameters) => {
  var _a, _b;
  const finalAngle = null !== (_b = null === (_a = element.getFinalGraphicAttributes()) || void 0 === _a ? void 0 : _a.angle) && void 0 !== _b ? _b : 0;
  let angle2 = 0;
  return angle2 = isNumberClose(finalAngle / (2 * Math.PI), 0) ? Math.round(finalAngle / (2 * Math.PI)) * Math.PI * 2 : isValidNumber_default(null == options ? void 0 : options.angle) ? options.angle : "anticlockwise" === (null == options ? void 0 : options.orient) ? Math.ceil(finalAngle / (2 * Math.PI)) * Math.PI * 2 : Math.floor(finalAngle / (2 * Math.PI)) * Math.PI * 2, {
    from: {
      angle: angle2
    },
    to: {
      angle: finalAngle
    }
  };
};
var rotateOut = (element, options, animationParameters) => {
  var _a;
  const finalAngle = null !== (_a = element.getGraphicAttribute("angle", true)) && void 0 !== _a ? _a : 0;
  let angle2 = 0;
  return angle2 = isNumberClose(finalAngle / (2 * Math.PI), 0) ? Math.round(finalAngle / (2 * Math.PI)) * Math.PI * 2 : isValidNumber_default(null == options ? void 0 : options.angle) ? options.angle : "anticlockwise" === (null == options ? void 0 : options.orient) ? Math.ceil(finalAngle / (2 * Math.PI)) * Math.PI * 2 : Math.floor(finalAngle / (2 * Math.PI)) * Math.PI * 2, {
    from: {
      angle: finalAngle
    },
    to: {
      angle: angle2
    }
  };
};

// http-url:https://unpkg.com/@visactor/vgrammar-core@0.13.8/es/graph/animation/animation
var registerClipInAnimation = () => {
  Factory.registerAnimationType("clipIn", clipIn);
};
var registerClipOutAnimation = () => {
  Factory.registerAnimationType("clipOut", clipOut);
};
var registerFadeInAnimation = () => {
  Factory.registerAnimationType("fadeIn", fadeIn);
};
var registerFadeOutAnimation = () => {
  Factory.registerAnimationType("fadeOut", fadeOut);
};
var registerGrowCenterInAnimation = () => {
  Factory.registerAnimationType("growCenterIn", growCenterIn);
};
var registerGrowCenterOutAnimation = () => {
  Factory.registerAnimationType("growCenterOut", growCenterOut);
};
var registerGrowHeightInAnimation = () => {
  Factory.registerAnimationType("growHeightIn", growHeightIn);
};
var registerGrowHeightOutAnimation = () => {
  Factory.registerAnimationType("growHeightOut", growHeightOut);
};
var registerGrowWidthInAnimation = () => {
  Factory.registerAnimationType("growWidthIn", growWidthIn);
};
var registerGrowWidthOutAnimation = () => {
  Factory.registerAnimationType("growWidthOut", growWidthOut);
};
var registerGrowPointsInAnimation = () => {
  Factory.registerAnimationType("growPointsIn", growPointsIn);
};
var registerGrowPointsOutAnimation = () => {
  Factory.registerAnimationType("growPointsOut", growPointsOut);
};
var registerGrowPointsXInAnimation = () => {
  Factory.registerAnimationType("growPointsXIn", growPointsXIn);
};
var registerGrowPointsXOutAnimation = () => {
  Factory.registerAnimationType("growPointsXOut", growPointsXOut);
};
var registerGrowPointsYInAnimation = () => {
  Factory.registerAnimationType("growPointsYIn", growPointsYIn);
};
var registerGrowPointsYOutAnimation = () => {
  Factory.registerAnimationType("growPointsYOut", growPointsYOut);
};
var registerGrowAngleInAnimation = () => {
  Factory.registerAnimationType("growAngleIn", growAngleIn);
};
var registerGrowAngleOutAnimation = () => {
  Factory.registerAnimationType("growAngleOut", growAngleOut);
};
var registerGrowRadiusInAnimation = () => {
  Factory.registerAnimationType("growRadiusIn", growRadiusIn);
};
var registerGrowRadiusOutAnimation = () => {
  Factory.registerAnimationType("growRadiusOut", growRadiusOut);
};
var registerMoveInAnimation = () => {
  Factory.registerAnimationType("moveIn", moveIn);
};
var registerMoveOutAnimation = () => {
  Factory.registerAnimationType("moveOut", moveOut);
};
var registerScaleInAnimation = () => {
  Factory.registerAnimationType("scaleIn", scaleIn);
};
var registerScaleOutAnimation = () => {
  Factory.registerAnimationType("scaleOut", scaleOut);
};
var registerRotateInAnimation = () => {
  Factory.registerAnimationType("rotateIn", rotateIn);
};
var registerRotateOutAnimation = () => {
  Factory.registerAnimationType("rotateOut", rotateOut);
};
var registerUpdateAnimation = () => {
  Factory.registerAnimationType("update", update);
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/constant/event
var BASE_EVENTS = ["pointerdown", "pointerup", "pointerupoutside", "pointertap", "pointerover", "pointermove", "pointerenter", "pointerleave", "pointerout", "mousedown", "mouseup", "mouseupoutside", "rightdown", "rightup", "rightupoutside", "click", "dblclick", "mousemove", "mouseover", "mouseout", "mouseenter", "mouseleave", "wheel", "touchstart", "touchend", "touchendoutside", "touchmove", "touchcancel", "tap", "dragstart", "drag", "dragenter", "dragleave", "dragover", "dragend", "drop", "pan", "panstart", "panend", "press", "pressup", "pressend", "pinch", "pinchstart", "pinchend", "swipe"];
var ChartEvent;
!function(ChartEvent2) {
  ChartEvent2.initialized = "initialized", ChartEvent2.rendered = "rendered", ChartEvent2.renderFinished = "renderFinished", ChartEvent2.animationFinished = "animationFinished", ChartEvent2.regionSeriesDataFilterOver = "regionSeriesDataFilterOver", ChartEvent2.afterInitData = "afterInitData", ChartEvent2.afterInitEvent = "afterInitEvent", ChartEvent2.afterInitMark = "afterInitMark", ChartEvent2.rawDataUpdate = "rawDataUpdate", ChartEvent2.viewDataFilterOver = "viewDataFilterOver", ChartEvent2.viewDataUpdate = "viewDataUpdate", ChartEvent2.viewDataStatisticsUpdate = "viewDataStatisticsUpdate", ChartEvent2.markDeltaYUpdate = "markDeltaYUpdate", ChartEvent2.viewDataLabelUpdate = "viewDataLabelUpdate", ChartEvent2.scaleDomainUpdate = "scaleDomainUpdate", ChartEvent2.scaleUpdate = "scaleUpdate", ChartEvent2.dataZoomChange = "dataZoomChange", ChartEvent2.drill = "drill", ChartEvent2.layoutStart = "layoutStart", ChartEvent2.layoutEnd = "layoutEnd", ChartEvent2.layoutRectUpdate = "layoutRectUpdate", ChartEvent2.playerPlay = "playerPlay", ChartEvent2.playerPause = "playerPause", ChartEvent2.playerEnd = "playerEnd", ChartEvent2.playerChange = "playerChange", ChartEvent2.playerForward = "playerForward", ChartEvent2.playerBackward = "playerBackward", ChartEvent2.scrollBarChange = "scrollBarChange", ChartEvent2.brushStart = "brushStart", ChartEvent2.brushChange = "brushChange", ChartEvent2.brushEnd = "brushEnd", ChartEvent2.brushClear = "brushClear", ChartEvent2.legendSelectedDataChange = "legendSelectedDataChange", ChartEvent2.legendFilter = "legendFilter", ChartEvent2.legendItemClick = "legendItemClick", ChartEvent2.legendItemHover = "legendItemHover", ChartEvent2.legendItemUnHover = "legendItemUnHover", ChartEvent2.tooltipShow = "tooltipShow", ChartEvent2.tooltipHide = "tooltipHide", ChartEvent2.tooltipRelease = "tooltipRelease", ChartEvent2.afterResize = "afterResize", ChartEvent2.afterRender = "afterRender", ChartEvent2.afterLayout = "afterLayout";
}(ChartEvent || (ChartEvent = {}));
var Event_Source_Type;
!function(Event_Source_Type2) {
  Event_Source_Type2.chart = "chart", Event_Source_Type2.window = "window", Event_Source_Type2.canvas = "canvas";
}(Event_Source_Type || (Event_Source_Type = {}));
var Event_Bubble_Level;
!function(Event_Bubble_Level2) {
  Event_Bubble_Level2.vchart = "vchart", Event_Bubble_Level2.chart = "chart", Event_Bubble_Level2.model = "model", Event_Bubble_Level2.mark = "mark";
}(Event_Bubble_Level || (Event_Bubble_Level = {}));

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/constant/waterfall
var WaterfallDefaultSeriesField = `${PREFIX}_waterfall_default_seriesField`;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/constant/correlation
var CORRELATION_X = `${PREFIX}_CORRELATION_X`;
var CORRELATION_Y = `${PREFIX}_CORRELATION_Y`;
var CORRELATION_SIZE = `${PREFIX}_CORRELATION_SIZE`;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/constant
var DEFAULT_MEASURE_CANVAS_ID = `${PREFIX}_MEASURE_CANVAS_ID`;
var DEFAULT_DATA_INDEX = `${PREFIX}_DEFAULT_DATA_INDEX`;
var DEFAULT_DATA_KEY = `${PREFIX}_DEFAULT_DATA_KEY`;
var DEFAULT_DATA_SERIES_FIELD = `${PREFIX}_DEFAULT_DATA_SERIES_FIELD`;
var DEFAULT_SERIES_STYLE_NAME = `${PREFIX}_DEFAULT_SERIES_STYLE_NAME`;
var AttributeLevel;
!function(AttributeLevel3) {
  AttributeLevel3[AttributeLevel3.Default = 0] = "Default", AttributeLevel3[AttributeLevel3.Theme = 1] = "Theme", AttributeLevel3[AttributeLevel3.Chart = 2] = "Chart", AttributeLevel3[AttributeLevel3.Base_Series = 3] = "Base_Series", AttributeLevel3[AttributeLevel3.Series = 4] = "Series", AttributeLevel3[AttributeLevel3.Mark = 5] = "Mark", AttributeLevel3[AttributeLevel3.User_Chart = 6] = "User_Chart", AttributeLevel3[AttributeLevel3.User_Series = 7] = "User_Series", AttributeLevel3[AttributeLevel3.User_Mark = 8] = "User_Mark", AttributeLevel3[AttributeLevel3.Built_In = 99] = "Built_In";
}(AttributeLevel || (AttributeLevel = {}));
var STACK_FIELD_KEY = `${PREFIX}_STACK_KEY`;
var STACK_FIELD_START = `${PREFIX}_STACK_START`;
var STACK_FIELD_END = `${PREFIX}_STACK_END`;
var STACK_FIELD_START_PERCENT = `${PREFIX}_STACK_START_PERCENT`;
var STACK_FIELD_END_PERCENT = `${PREFIX}_STACK_END_PERCENT`;
var STACK_FIELD_START_OffsetSilhouette = `${PREFIX}_STACK_START_OffsetSilhouette`;
var STACK_FIELD_END_OffsetSilhouette = `${PREFIX}_STACK_END_OffsetSilhouette`;
var STACK_FIELD_TOTAL = `${PREFIX}_STACK_TOTAL`;
var STACK_FIELD_TOTAL_PERCENT = `${PREFIX}_STACK_TOTAL_PERCENT`;
var STACK_FIELD_TOTAL_TOP = `${PREFIX}_STACK_TOTAL_TOP`;
var SEGMENT_FIELD_START = `${PREFIX}_SEGMENT_START`;
var SEGMENT_FIELD_END = `${PREFIX}_SEGMENT_END`;
var LayoutZIndex;
!function(LayoutZIndex3) {
  LayoutZIndex3[LayoutZIndex3.Axis_Grid = 50] = "Axis_Grid", LayoutZIndex3[LayoutZIndex3.CrossHair_Grid = 100] = "CrossHair_Grid", LayoutZIndex3[LayoutZIndex3.Region = 450] = "Region", LayoutZIndex3[LayoutZIndex3.Mark = 300] = "Mark", LayoutZIndex3[LayoutZIndex3.Node = 400] = "Node", LayoutZIndex3[LayoutZIndex3.Axis = 100] = "Axis", LayoutZIndex3[LayoutZIndex3.MarkLine = 500] = "MarkLine", LayoutZIndex3[LayoutZIndex3.MarkArea = 100] = "MarkArea", LayoutZIndex3[LayoutZIndex3.MarkPoint = 500] = "MarkPoint", LayoutZIndex3[LayoutZIndex3.DataZoom = 500] = "DataZoom", LayoutZIndex3[LayoutZIndex3.ScrollBar = 500] = "ScrollBar", LayoutZIndex3[LayoutZIndex3.Player = 500] = "Player", LayoutZIndex3[LayoutZIndex3.Legend = 500] = "Legend", LayoutZIndex3[LayoutZIndex3.CrossHair = 500] = "CrossHair", LayoutZIndex3[LayoutZIndex3.Indicator = 500] = "Indicator", LayoutZIndex3[LayoutZIndex3.Title = 500] = "Title", LayoutZIndex3[LayoutZIndex3.Label = 500] = "Label", LayoutZIndex3[LayoutZIndex3.Brush = 500] = "Brush", LayoutZIndex3[LayoutZIndex3.CustomMark = 500] = "CustomMark", LayoutZIndex3[LayoutZIndex3.Interaction = 700] = "Interaction";
}(LayoutZIndex || (LayoutZIndex = {}));
var LayoutLevel;
!function(LayoutLevel3) {
  LayoutLevel3[LayoutLevel3.Indicator = 10] = "Indicator", LayoutLevel3[LayoutLevel3.Region = 20] = "Region", LayoutLevel3[LayoutLevel3.Axis = 30] = "Axis", LayoutLevel3[LayoutLevel3.DataZoom = 40] = "DataZoom", LayoutLevel3[LayoutLevel3.Player = 40] = "Player", LayoutLevel3[LayoutLevel3.ScrollBar = 40] = "ScrollBar", LayoutLevel3[LayoutLevel3.Legend = 50] = "Legend", LayoutLevel3[LayoutLevel3.Title = 70] = "Title", LayoutLevel3[LayoutLevel3.CustomMark = 70] = "CustomMark";
}(LayoutLevel || (LayoutLevel = {}));
var GradientType = ["linear", "radial", "conical"];
var DEFAULT_LINEAR_GRADIENT_CONFIG = {
  x0: 0,
  y0: 0,
  x1: 1,
  y1: 1
};
var DEFAULT_RADIAL_GRADIENT_CONFIG = {
  x0: 0,
  y0: 0,
  x1: 1,
  y1: 1,
  r0: 0,
  r1: 1
};
var DEFAULT_CONICAL_GRADIENT_CONFIG = {
  x: 0.5,
  y: 0.5,
  startAngle: 0,
  endAngle: 2 * Math.PI
};
var DEFAULT_GRADIENT_CONFIG = {
  linear: DEFAULT_LINEAR_GRADIENT_CONFIG,
  radial: DEFAULT_RADIAL_GRADIENT_CONFIG,
  conical: DEFAULT_CONICAL_GRADIENT_CONFIG
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/base/constant
var baseSeriesMark = {
  label: {
    name: "label",
    type: "text"
  }
};
var RECT_X = `${PREFIX}_rect_x`;
var RECT_X1 = `${PREFIX}_rect_x1`;
var RECT_Y = `${PREFIX}_rect_y`;
var RECT_Y1 = `${PREFIX}_rect_y1`;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/bar/constant
var barSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  bar: {
    name: "bar",
    type: "rect"
  },
  barBackground: {
    name: "barBackground",
    type: "rect"
  }
});
var bar3dSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  bar3d: {
    name: "bar3d",
    type: "rect3d"
  }
});

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/mixin/constant
var lineLikeSeriesMark = {
  point: {
    name: "point",
    type: "symbol"
  },
  line: {
    name: "line",
    type: "line"
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/line/constant
var lineSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), lineLikeSeriesMark);

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/scatter/constant
var scatterSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  point: {
    name: "point",
    type: "symbol"
  }
});

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/area/constant
var areaSeriesMark = Object.assign(Object.assign(Object.assign({}, baseSeriesMark), lineLikeSeriesMark), {
  area: {
    name: "area",
    type: "area"
  }
});

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/radar/constant
var radarSeriesMark = Object.assign(Object.assign(Object.assign({}, baseSeriesMark), lineLikeSeriesMark), {
  area: {
    name: "area",
    type: "area"
  }
});

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/pie/constant
var pieSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  pie: {
    name: "pie",
    type: "arc"
  },
  labelLine: {
    name: "labelLine",
    type: "path"
  }
});
var pie3dSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  pie3d: {
    name: "pie3d",
    type: "arc3d"
  },
  labelLine: {
    name: "labelLine",
    type: "path"
  }
});

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/rose/constant
var roseSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  rose: {
    name: "rose",
    type: "arc"
  }
});

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/map/constant
var mapSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  area: {
    name: "area",
    type: "path"
  }
});

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/polar/progress-like/constant
var progressLikeSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  group: {
    name: "group",
    type: "group"
  }
});

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/progress/circular/constant
var circularProgressSeriesMark = Object.assign(Object.assign({}, progressLikeSeriesMark), {
  track: {
    name: "track",
    type: "arc"
  },
  progress: {
    name: "progress",
    type: "arc"
  }
});

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/link/constant
var linkSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  group: {
    name: "group",
    type: "group"
  },
  link: {
    name: "link",
    type: "rule"
  },
  arrow: {
    name: "arrow",
    type: "symbol"
  }
});

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/dot/constant
var dotSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  group: {
    name: "group",
    type: "group"
  },
  grid: {
    name: "grid",
    type: "rule"
  },
  gridBackground: {
    name: "gridBackground",
    type: "rect"
  },
  dot: {
    name: "dot",
    type: "symbol"
  },
  title: {
    name: "title",
    type: "text"
  },
  subTitle: {
    name: "subTitle",
    type: "text"
  },
  symbol: {
    name: "symbol",
    type: "symbol"
  }
});

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/word-cloud/constant
var wordCloudSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  word: {
    name: "word",
    type: "text"
  },
  fillingWord: {
    name: "fillingWord",
    type: "text"
  }
});

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/funnel/constant
var funnelSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  funnel: {
    name: "funnel",
    type: "polygon"
  },
  transform: {
    name: "transform",
    type: "polygon"
  },
  transformLabel: {
    name: "transformLabel",
    type: "text"
  },
  outerLabel: {
    name: "outerLabel",
    type: "text"
  },
  outerLabelLine: {
    name: "outerLabelLine",
    type: "rule"
  }
});
var funnel3dSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  funnel3d: {
    name: "funnel3d",
    type: "pyramid3d"
  },
  transform3d: {
    name: "transform3d",
    type: "pyramid3d"
  },
  transformLabel: {
    name: "transformLabel",
    type: "text"
  },
  outerLabel: {
    name: "outerLabel",
    type: "text"
  },
  outerLabelLine: {
    name: "outerLabelLine",
    type: "rule"
  }
});

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/progress/linear/constant
var linearProgressSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  track: {
    name: "track",
    type: "rect"
  },
  progress: {
    name: "progress",
    type: "rect"
  },
  group: {
    name: "group",
    type: "group"
  }
});

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/waterfall/constant
var waterfallSeriesMark = Object.assign(Object.assign({}, barSeriesMark), {
  leaderLine: {
    name: "leaderLine",
    type: "rule"
  },
  stackLabel: {
    name: "stackLabel",
    type: "text"
  }
});

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/box-plot/constant
var boxPlotSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  boxPlot: {
    name: "boxPlot",
    type: "boxPlot"
  },
  outlier: {
    name: "outlier",
    type: "symbol"
  }
});

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/treemap/constant
var treemapSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  nonLeaf: {
    name: "nonLeaf",
    type: "rect"
  },
  leaf: {
    name: "leaf",
    type: "rect"
  },
  nonLeafLabel: {
    name: "nonLeafLabel",
    type: "text"
  }
});

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/sankey/constant
var sankeySeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  node: {
    name: "node",
    type: "rect"
  },
  link: {
    name: "link",
    type: "linkPath"
  }
});

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/gauge/constant
var gaugeSeriesMark = Object.assign(Object.assign({}, progressLikeSeriesMark), {
  segment: {
    name: "segment",
    type: "arc"
  },
  track: {
    name: "track",
    type: "arc"
  }
});
var gaugePointerSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  pin: {
    name: "pin",
    type: "path"
  },
  pinBackground: {
    name: "pinBackground",
    type: "path"
  },
  pointer: {
    name: "pointer",
    type: ["path", "rect"]
  }
});

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/sunburst/constant
var sunburstSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  sunburst: {
    name: "sunburst",
    type: "arc"
  }
});

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/range-column/constant
var rangeColumnSeriesMark = Object.assign(Object.assign({}, barSeriesMark), {
  minLabel: {
    name: "minLabel",
    type: "text"
  },
  maxLabel: {
    name: "maxLabel",
    type: "text"
  }
});
var rangeColumn3dSeriesMark = Object.assign(Object.assign({}, bar3dSeriesMark), {
  minLabel: {
    name: "minLabel",
    type: "text"
  },
  maxLabel: {
    name: "maxLabel",
    type: "text"
  }
});

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/circle-packing/constant
var circlePackingSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  circlePacking: {
    name: "circlePacking",
    type: "arc"
  }
});

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/heatmap/constant
var heatmapSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  cell: {
    name: "cell",
    type: "cell"
  },
  cellBackground: {
    name: "cellBackground",
    type: "cell"
  }
});

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/correlation/constant
var correlationSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  nodePoint: {
    name: "nodePoint",
    type: "symbol"
  },
  ripplePoint: {
    name: "ripplePoint",
    type: "ripple"
  },
  centerPoint: {
    name: "centerPoint",
    type: "symbol"
  },
  centerLabel: {
    name: "centerLabel",
    type: "text"
  }
});

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/range-area/constant
var rangeAreaSeriesMark = Object.assign({}, areaSeriesMark);

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/liquid/constant
var LiquidSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  liquid: {
    name: "liquid",
    type: "liquid"
  },
  liquidBackground: {
    name: "liquidBackground",
    type: "group"
  },
  liquidOutline: {
    name: "liquidOutline",
    type: "symbol"
  }
});

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/venn/constant
var vennSeriesMark = Object.assign(Object.assign({}, baseSeriesMark), {
  circle: {
    name: "circle",
    type: "arc"
  },
  overlap: {
    name: "overlap",
    type: "path"
  },
  overlapLabel: {
    name: "overlapLabel",
    type: "text"
  }
});

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/interface/theme
var SeriesTypeForThemeEnum;
!function(SeriesTypeForThemeEnum2) {
  SeriesTypeForThemeEnum2.area_horizontal = "area_horizontal", SeriesTypeForThemeEnum2.area_vertical = "area_vertical", SeriesTypeForThemeEnum2.area_stack = "area_stack", SeriesTypeForThemeEnum2.line_horizontal = "line_horizontal", SeriesTypeForThemeEnum2.line_vertical = "line_vertical", SeriesTypeForThemeEnum2.line_stack = "line_stack", SeriesTypeForThemeEnum2.bar_horizontal = "bar_horizontal", SeriesTypeForThemeEnum2.bar_vertical = "bar_vertical", SeriesTypeForThemeEnum2.bar_stack = "bar_stack", SeriesTypeForThemeEnum2.bar3d_horizontal = "bar3d_horizontal", SeriesTypeForThemeEnum2.bar3d_vertical = "bar3d_vertical", SeriesTypeForThemeEnum2.bar3d_stack = "bar3d_stack", SeriesTypeForThemeEnum2.rangeColumn_horizontal = "rangeColumn_horizontal", SeriesTypeForThemeEnum2.rangeColumn_vertical = "rangeColumn_vertical", SeriesTypeForThemeEnum2.rangeColumn3d_horizontal = "rangeColumn3d_horizontal", SeriesTypeForThemeEnum2.rangeColumn3d_vertical = "rangeColumn3d_vertical", SeriesTypeForThemeEnum2.rangeArea_horizontal = "rangeArea_horizontal", SeriesTypeForThemeEnum2.rangeArea_vertical = "rangeArea_vertical", SeriesTypeForThemeEnum2.linearProgress_horizontal = "linearProgress_horizontal", SeriesTypeForThemeEnum2.linearProgress_vertical = "linearProgress_vertical", SeriesTypeForThemeEnum2.linearProgress_stack = "linearProgress_stack", SeriesTypeForThemeEnum2.boxPlot_horizontal = "boxPlot_horizontal", SeriesTypeForThemeEnum2.boxPlot_vertical = "boxPlot_vertical", SeriesTypeForThemeEnum2.sankey_horizontal = "sankey_horizontal", SeriesTypeForThemeEnum2.sankey_vertical = "sankey_vertical", SeriesTypeForThemeEnum2.waterfall_horizontal = "waterfall_horizontal", SeriesTypeForThemeEnum2.waterfall_vertical = "waterfall_vertical", SeriesTypeForThemeEnum2.circularProgress_stack = "circularProgress_stack", SeriesTypeForThemeEnum2.radar_stack = "radar_stack", SeriesTypeForThemeEnum2.rose_stack = "rose_stack";
}(SeriesTypeForThemeEnum || (SeriesTypeForThemeEnum = {}));
var seriesMarkInfoMap = {
  [SeriesTypeEnum.bar]: barSeriesMark,
  [SeriesTypeEnum.bar3d]: bar3dSeriesMark,
  [SeriesTypeEnum.line]: lineSeriesMark,
  [SeriesTypeEnum.scatter]: scatterSeriesMark,
  [SeriesTypeEnum.area]: areaSeriesMark,
  [SeriesTypeEnum.radar]: radarSeriesMark,
  [SeriesTypeEnum.pie]: pieSeriesMark,
  [SeriesTypeEnum.pie3d]: pie3dSeriesMark,
  [SeriesTypeEnum.rose]: roseSeriesMark,
  [SeriesTypeEnum.geo]: baseSeriesMark,
  [SeriesTypeEnum.map]: mapSeriesMark,
  [SeriesTypeEnum.circularProgress]: circularProgressSeriesMark,
  [SeriesTypeEnum.link]: linkSeriesMark,
  [SeriesTypeEnum.dot]: dotSeriesMark,
  [SeriesTypeEnum.wordCloud]: wordCloudSeriesMark,
  [SeriesTypeEnum.wordCloud3d]: wordCloudSeriesMark,
  [SeriesTypeEnum.funnel]: funnelSeriesMark,
  [SeriesTypeEnum.funnel3d]: funnel3dSeriesMark,
  [SeriesTypeEnum.linearProgress]: linearProgressSeriesMark,
  [SeriesTypeEnum.waterfall]: waterfallSeriesMark,
  [SeriesTypeEnum.boxPlot]: boxPlotSeriesMark,
  [SeriesTypeEnum.treemap]: treemapSeriesMark,
  [SeriesTypeEnum.sankey]: sankeySeriesMark,
  [SeriesTypeEnum.gauge]: gaugeSeriesMark,
  [SeriesTypeEnum.gaugePointer]: gaugePointerSeriesMark,
  [SeriesTypeEnum.sunburst]: sunburstSeriesMark,
  [SeriesTypeEnum.rangeColumn]: rangeColumnSeriesMark,
  [SeriesTypeEnum.rangeColumn3d]: rangeColumn3dSeriesMark,
  [SeriesTypeEnum.circlePacking]: circlePackingSeriesMark,
  [SeriesTypeEnum.heatmap]: heatmapSeriesMark,
  [SeriesTypeEnum.correlation]: correlationSeriesMark,
  [SeriesTypeEnum.rangeArea]: rangeAreaSeriesMark,
  [SeriesTypeEnum.liquid]: LiquidSeriesMark,
  [SeriesTypeEnum.venn]: vennSeriesMark
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/util/spec
function getDirectionFromSeriesSpec(spec) {
  var _a, _b;
  const { type } = spec;
  return type === SeriesTypeEnum.sankey ? null !== (_a = spec.direction) && void 0 !== _a ? _a : "horizontal" : null !== (_b = spec.direction) && void 0 !== _b ? _b : "vertical";
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/color-scheme/legacy
var newTokenToLegacyToken = {
  primaryFontColor: "titleFontColor",
  tertiaryFontColor: "labelFontColor",
  axisLabelFontColor: "axisFontColor",
  axisMarkerFontColor: "labelReverseFontColor",
  dataZoomHandleStrokeColor: "dataZoomHandlerStrokeColor",
  sliderHandleColor: "dataZoomHandlerFillColor",
  sliderRailColor: "dataZoomBackgroundColor",
  sliderTrackColor: "dataZoomSelectedColor",
  playerControllerColor: "dataZoomSelectedColor",
  popupBackgroundColor: "tooltipBackgroundColor",
  hoverBackgroundColor: "axisGridColor"
};
var legacyTokenToNewToken = {
  titleFontColor: "primaryFontColor",
  labelFontColor: "tertiaryFontColor",
  axisFontColor: "axisLabelFontColor",
  labelReverseFontColor: "axisMarkerFontColor",
  dataZoomHandlerStrokeColor: "dataZoomHandleStrokeColor",
  dataZoomHandlerFillColor: "sliderHandleColor",
  dataZoomBackgroundColor: "sliderRailColor",
  dataZoomSelectedColor: "sliderTrackColor",
  tooltipBackgroundColor: "popupBackgroundColor"
};
function getUpgradedTokenValue(palette, key) {
  const legacyKey = newTokenToLegacyToken[key];
  if (legacyKey && palette[legacyKey])
    return palette[legacyKey];
  if (palette[key])
    return palette[key];
  const newKey = legacyTokenToNewToken[key];
  return newKey ? palette[newKey] : void 0;
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/color-scheme/util
function getDataScheme(colorScheme3, seriesSpec) {
  var _a;
  if (!colorScheme3)
    return [];
  const scheme = getColorSchemeBySeries(colorScheme3, seriesSpec);
  if (!scheme || isArray_default(scheme))
    return null !== (_a = scheme) && void 0 !== _a ? _a : [];
  if (isObject_default(scheme)) {
    const { dataScheme: dataScheme2 } = scheme;
    return dataScheme2 ? isProgressiveDataColorScheme(dataScheme2) ? dataScheme2.map((item) => Object.assign(Object.assign({}, item), {
      scheme: item.scheme.map((color) => isColorKey(color) ? queryColorFromColorScheme(colorScheme3, color, seriesSpec) : color).filter(isValid_default)
    })) : dataScheme2.map((color) => isColorKey(color) ? queryColorFromColorScheme(colorScheme3, color, seriesSpec) : color).filter(isValid_default) : [];
  }
  return [];
}
function computeActualDataScheme(dataScheme2, colorDomain) {
  var _a, _b;
  return isProgressiveDataColorScheme(dataScheme2) ? null !== (_b = null === (_a = dataScheme2.find((item) => isValid_default(item.isAvailable) ? isFunction_default(item.isAvailable) ? item.isAvailable(colorDomain) : !!item.isAvailable : !isValid_default(item.maxDomainLength) || (null == colorDomain ? void 0 : colorDomain.length) <= item.maxDomainLength)) || void 0 === _a ? void 0 : _a.scheme) && void 0 !== _b ? _b : dataScheme2[dataScheme2.length - 1].scheme : dataScheme2;
}
function queryColorFromColorScheme(colorScheme3, colorKey, seriesSpec) {
  var _a;
  const scheme = getColorSchemeBySeries(colorScheme3, seriesSpec);
  if (!scheme)
    return;
  let color;
  const { palette } = scheme;
  if (isObject_default(palette) && (color = null !== (_a = getUpgradedTokenValue(palette, colorKey.key)) && void 0 !== _a ? _a : colorKey.default), !color)
    return;
  if (isNil_default(colorKey.a) && isNil_default(colorKey.l) || !isString_default(color))
    return color;
  let c3 = new Color(color);
  if (isValid_default(colorKey.l)) {
    const { r, g, b } = c3.color, { h, s: s2 } = rgbToHsl(r, g, b), rgb2 = hslToRgb(h, s2, colorKey.l), newColor = new Color(`rgb(${rgb2.r}, ${rgb2.g}, ${rgb2.b})`);
    newColor.setOpacity(c3.color.opacity), c3 = newColor;
  }
  return isValid_default(colorKey.a) && c3.setOpacity(colorKey.a), c3.toRGBA();
}
var getActualColor = (value, colorScheme3, seriesSpec) => {
  if (colorScheme3 && isColorKey(value)) {
    const color = queryColorFromColorScheme(colorScheme3, value, seriesSpec);
    if (color)
      return color;
  }
  return value;
};
function isColorKey(obj) {
  return obj && "palette" === obj.type && !!obj.key;
}
function isProgressiveDataColorScheme(obj) {
  return !(!isArray_default(obj) || 0 === obj.length) && obj.every((item) => isValid_default(item.scheme));
}
function transformColorSchemeToStandardStruct(colorScheme3) {
  return isArray_default(colorScheme3) ? {
    dataScheme: colorScheme3
  } : colorScheme3;
}
function getColorSchemeBySeries(colorScheme3, seriesSpec) {
  var _a, _b;
  const { type: seriesType } = null != seriesSpec ? seriesSpec : {};
  let scheme;
  if (!seriesSpec || isNil_default(seriesType))
    scheme = null == colorScheme3 ? void 0 : colorScheme3.default;
  else {
    const direction2 = getDirectionFromSeriesSpec(seriesSpec);
    scheme = null !== (_b = null !== (_a = null == colorScheme3 ? void 0 : colorScheme3[`${seriesType}_${direction2}`]) && void 0 !== _a ? _a : null == colorScheme3 ? void 0 : colorScheme3[seriesType]) && void 0 !== _b ? _b : null == colorScheme3 ? void 0 : colorScheme3.default;
  }
  return scheme;
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/scale/color-ordinal-scale
var ColorOrdinalScale = class extends OrdinalScale {
  range(value) {
    return value ? (this._range = value, this._resetRange(), this) : super.range();
  }
  domain(value) {
    return value ? (super.domain(value), this._resetRange(), this) : super.domain();
  }
  _resetRange() {
    if (!isProgressiveDataColorScheme(this._range))
      return void super.range(this._range);
    const range2 = computeActualDataScheme(this._range, this._domain);
    super.range(range2);
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/util/scale
var defaultScaleMap = {
  linear: LinearScale,
  band: BandScale,
  point: PointScale,
  ordinal: OrdinalScale,
  threshold: ThresholdScale,
  colorOrdinal: ColorOrdinalScale
};
function createScale(type) {
  const scaleConstructor = defaultScaleMap[type];
  return scaleConstructor ? new scaleConstructor() : null;
}
function createScaleWithSpec(spec, context) {
  if ("scale" in spec && spec.scale)
    return isString_default(spec.scale) && (null == context ? void 0 : context.globalScale) ? context.globalScale.registerMarkAttributeScale(spec, context.seriesId) : spec.scale;
  const scale4 = createScale(spec.type);
  return scale4 && initScaleWithSpec(scale4, spec), scale4;
}
function initScaleWithSpec(scale4, spec) {
  scale4 && spec && (spec.domain && scale4.domain(spec.domain), spec.range && scale4.range(spec.range), spec.specified && scale4.specified && scale4.specified(spec.specified));
}
function valueInScaleRange(v, s2) {
  if (!s2)
    return v;
  const range2 = s2.range(), min3 = Math.min(range2[0], range2[range2.length - 1]), max3 = Math.max(range2[0], range2[range2.length - 1]);
  return Math.min(Math.max(min3, v), max3);
}
function isSpecValueWithScale(specValue) {
  return isValid_default(null == specValue ? void 0 : specValue.field) && isValid_default(null == specValue ? void 0 : specValue.scale);
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/util/space
function isValidOrient(orient) {
  switch (orient) {
    case "left":
    case "right":
    case "top":
    case "bottom":
      return true;
    default:
      return false;
  }
}
function isPercent(v) {
  return !!isString_default(v) && (!!v.endsWith("%") && couldBeValidNumber(v.substring(0, v.length - 1)));
}
function isPercentOffset(v) {
  return !!isObject_default(v) && ("percent" in v || "offset" in v);
}
function calcLayoutNumber(v, size, callOp, defaultValue = 0) {
  var _a, _b;
  return isNumber_default(v) ? v : isPercent(v) ? Number(v.substring(0, v.length - 1)) * size / 100 : isFunction_default(v) ? v(callOp) : isObject_default(v) ? size * (null !== (_a = v.percent) && void 0 !== _a ? _a : 0) + (null !== (_b = v.offset) && void 0 !== _b ? _b : 0) : defaultValue;
}
function calcPadding(paddingSpec, rect, callOp) {
  var _a, _b, _c, _d;
  const result2 = {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0
  };
  if (Object.values(paddingSpec).every((value) => isNumber_default(value)))
    return result2.top = null !== (_a = paddingSpec.top) && void 0 !== _a ? _a : 0, result2.right = null !== (_b = paddingSpec.right) && void 0 !== _b ? _b : 0, result2.bottom = null !== (_c = paddingSpec.bottom) && void 0 !== _c ? _c : 0, result2.left = null !== (_d = paddingSpec.left) && void 0 !== _d ? _d : 0, result2;
  return [{
    orients: ["left", "right"],
    size: rect.width
  }, {
    orients: ["top", "bottom"],
    size: rect.height
  }].forEach((p) => {
    p.orients.forEach((o) => {
      result2[o] = calcLayoutNumber(paddingSpec[o], p.size, callOp);
    });
  }), result2;
}
function boundsInRect(bounds, rect) {
  return bounds ? {
    width: Math.ceil(Math.min(bounds.x2 - bounds.x1, rect.width)),
    height: Math.ceil(Math.min(bounds.y2 - bounds.y1, rect.height))
  } : {
    width: 0,
    height: 0
  };
}
function normalizeLayoutPaddingSpec(spec) {
  let result2 = {};
  return isArray_default(spec) ? (isNil_default(spec[0]) || (result2.top = result2.left = result2.bottom = result2.right = spec[0]), isNil_default(spec[1]) || (result2.left = result2.right = spec[1]), isNil_default(spec[2]) || (result2.bottom = spec[2]), isNil_default(spec[3]) || (result2.left = spec[3]), result2) : isNumber_default(spec) || isPercent(spec) || isFunction_default(spec) || isPercentOffset(spec) ? (result2.top = result2.left = result2.bottom = result2.right = spec, result2) : isObject_default(spec) ? (result2 = Object.assign({}, spec), result2) : result2;
}
function convertPoint(point5, relativePoint, convert) {
  return convert ? {
    x: point5.x + relativePoint.x,
    y: point5.y + relativePoint.y
  } : point5;
}
var getActualNumValue = (originValue, total) => {
  const originNumValue = Number(originValue), originStrValue = originValue.toString();
  return isNaN(originNumValue) && "%" === originStrValue[originStrValue.length - 1] ? total * (Number(originStrValue.slice(0, originStrValue.length - 1)) / 100) : originNumValue;
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/color-scheme/builtin/default
var dataScheme = [{
  maxDomainLength: 10,
  scheme: ["#1664FF", "#1AC6FF", "#FF8A00", "#3CC780", "#7442D4", "#FFC400", "#304D77", "#B48DEB", "#009488", "#FF7DDA"]
}, {
  scheme: ["#1664FF", "#B2CFFF", "#1AC6FF", "#94EFFF", "#FF8A00", "#FFCE7A", "#3CC780", "#B9EDCD", "#7442D4", "#DDC5FA", "#FFC400", "#FAE878", "#304D77", "#8B959E", "#B48DEB", "#EFE3FF", "#009488", "#59BAA8", "#FF7DDA", "#FFCFEE"]
}];

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/light/color-scheme
var colorScheme = {
  default: {
    dataScheme,
    palette: {
      backgroundColor: "#ffffff",
      borderColor: "#e3e5e8",
      shadowColor: "rgba(33,37,44,0.1)",
      hoverBackgroundColor: "#f1f2f5",
      sliderRailColor: "#f1f3f4",
      sliderHandleColor: "#ffffff",
      sliderTrackColor: "#0040ff",
      popupBackgroundColor: "#ffffff",
      primaryFontColor: "#21252c",
      secondaryFontColor: "#606773",
      tertiaryFontColor: "#89909d",
      axisLabelFontColor: "#89909d",
      disableFontColor: "#bcc1cb",
      axisMarkerFontColor: "#ffffff",
      axisGridColor: "#f1f2f5",
      axisDomainColor: "#d9dde4",
      dataZoomHandleStrokeColor: "#aeb5be",
      dataZoomChartColor: "#c9ced8",
      playerControllerColor: "#0040ff",
      scrollBarSliderColor: "rgba(0,0,0,0.3)",
      axisMarkerBackgroundColor: "#21252c",
      markLabelBackgroundColor: "#f1f2f5",
      markLineStrokeColor: "#606773",
      dangerColor: "#e33232",
      warningColor: "#ffc528",
      successColor: "#07a35a",
      infoColor: "#3073f2"
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/series/area
var area = {
  label: {
    visible: false,
    offset: 5,
    position: "top",
    style: {
      stroke: {
        type: "palette",
        key: "backgroundColor"
      },
      lineWidth: 2
    }
  },
  point: {
    style: {
      symbolType: "circle"
    }
  },
  seriesMark: "area"
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/series/bar
var bar = {
  label: {
    visible: false,
    position: "outside",
    offset: 5,
    style: {
      lineWidth: 2,
      stroke: {
        type: "palette",
        key: "backgroundColor"
      }
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/series/bar3d
var bar3d = {
  bar3d: {
    style: {
      length: 3
    }
  },
  label: {
    visible: false,
    style: {
      offset: 12,
      position: "outside"
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/series/circular-progress
var circularProgress = {
  outerRadius: 0.8,
  innerRadius: 0.6,
  progress: {
    style: {
      fillOpacity: 1
    }
  },
  track: {
    style: {
      fillOpacity: 0.2
    }
  },
  tickMask: {
    visible: false,
    angle: 3,
    offsetAngle: 0,
    forceAlign: true
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/series/dot
var dot = {
  dot: {
    style: {
      size: 10,
      fillOpacity: 1
    }
  },
  symbol: {
    style: {
      size: 10
    }
  },
  title: {
    style: {
      textAlign: "left",
      textBaseline: "middle",
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      lineHeight: {
        type: "token",
        key: "l5LineHeight"
      }
    }
  },
  subTitle: {
    style: {
      textAlign: "left",
      textBaseline: "top",
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      lineHeight: {
        type: "token",
        key: "l5LineHeight"
      }
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/series/funnel
var funnel = {
  transform: {
    style: {
      fill: {
        type: "palette",
        key: "axisGridColor"
      }
    }
  },
  label: {
    style: {
      fill: "white",
      textBaseline: "middle",
      lineWidth: 2
    }
  },
  outerLabel: {
    style: {
      fontSize: {
        type: "token",
        key: "l4FontSize"
      },
      fill: {
        type: "palette",
        key: "secondaryFontColor"
      }
    },
    line: {
      style: {
        stroke: {
          type: "palette",
          key: "axisDomainColor"
        }
      }
    }
  },
  transformLabel: {
    style: {
      fontSize: {
        type: "token",
        key: "l4FontSize"
      },
      fill: {
        type: "palette",
        key: "secondaryFontColor"
      },
      textBaseline: "middle"
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/series/funnel3d
var funnel3d = {
  transform3d: {
    style: {
      fill: "#f5f5f5"
    }
  },
  label: {
    style: {
      fill: "white",
      textBaseline: "middle",
      lineWidth: 2
    }
  },
  outerLabel: {
    style: {
      fontSize: {
        type: "token",
        key: "l4FontSize"
      },
      fill: "#707070"
    },
    line: {
      style: {
        stroke: {
          type: "palette",
          key: "axisDomainColor"
        }
      }
    }
  },
  transformLabel: {
    style: {
      fontSize: {
        type: "token",
        key: "l4FontSize"
      },
      fill: "#707070",
      textBaseline: "middle"
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/series/gauge
var gauge = {
  outerRadius: 0.8,
  innerRadius: 0.6,
  padAngle: 1.146,
  segment: {
    style: {
      fillOpacity: 1
    }
  },
  tickMask: {
    visible: false,
    angle: 3,
    offsetAngle: 0,
    forceAlign: true
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/series/gauge-pointer
var pointerPath = "M-0.020059 -0.978425 C-0.018029 -0.9888053 -0.013378 -1 0 -1 C0.01342 -1 0.01812 -0.989146 0.0201 -0.978425 C0.02161 -0.9702819 0.0692 -0.459505 0.09486 -0.184807 C0.10298 -0.097849 0.1089 -0.034548 0.11047 -0.018339 C0.11698 0.04908 0.07373 0.11111 0.00002 0.11111 C-0.07369 0.11111 -0.117184 0.04991 -0.110423 -0.018339 C-0.103662 -0.086591 -0.022089 -0.9680447 -0.020059 -0.978425Z";
var circlePath = "M1 0 C1 0.55228 0.55228 1 0 1 C-0.552285 1 -1 0.55228 -1 0 C-1 -0.552285 -0.552285 -1 0 -1 C0.55228 -1 1 -0.552285 1 0Z";
var gaugePointer = {
  pointer: {
    type: "path",
    width: 0.4,
    height: 0.4,
    style: {
      path: pointerPath
    }
  },
  pin: {
    width: 0.025,
    height: 0.025,
    style: {
      path: circlePath,
      fill: "#888"
    }
  },
  pinBackground: {
    width: 0.06,
    height: 0.06,
    style: {
      path: circlePath,
      fill: "#ddd"
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/series/line
var line = {
  label: {
    visible: false,
    position: "top",
    offset: 5,
    style: {
      lineWidth: 2,
      stroke: {
        type: "palette",
        key: "backgroundColor"
      }
    }
  },
  point: {
    style: {
      symbolType: "circle"
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/series/linear-progress
var linearProgress = {
  bandWidth: 30,
  progress: {
    style: {
      fillOpacity: 1
    }
  },
  track: {
    style: {
      fill: "#E7EBED",
      fillOpacity: 1
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/series/link
var link2 = {
  arrow: {
    style: {
      size: 10
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/series/map
var map2 = {
  defaultFillColor: "#f3f3f3",
  area: {
    style: {
      lineWidth: 0.5,
      strokeOpacity: 1,
      stroke: "black",
      fillOpacity: 1
    }
  },
  label: {
    interactive: false,
    style: {
      fontSize: {
        type: "token",
        key: "l6FontSize"
      },
      lineHeight: {
        type: "token",
        key: "l6LineHeight"
      },
      textBaseline: "middle",
      fill: {
        type: "palette",
        key: "secondaryFontColor",
        default: "#89909d"
      },
      stroke: {
        type: "palette",
        key: "backgroundColor"
      }
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/series/pie
var pie = {
  outerRadius: 0.6,
  pie: {
    style: {
      fillOpacity: 1
    }
  },
  label: {
    visible: false,
    position: "outside",
    style: {
      fontWeight: "normal",
      stroke: {
        type: "palette",
        key: "backgroundColor"
      },
      fillOpacity: 1
    }
  },
  innerLabel: {
    style: {
      lineWidth: 2
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/series/pie3d
var pie3d = {
  outerRadius: 0.6,
  pie3d: {
    style: {
      height: 10,
      fillOpacity: 1
    }
  },
  label: {
    visible: false,
    position: "outside"
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/series/radar
var radar = {
  label: {
    visible: false,
    offset: 5,
    style: {
      lineWidth: 2,
      stroke: {
        type: "palette",
        key: "backgroundColor"
      }
    }
  },
  point: {
    style: {
      symbolType: "circle"
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/series/scatter
var scatter = {
  point: {
    style: {
      size: 8,
      symbolType: "circle",
      lineWidth: 0,
      fillOpacity: 0.8
    }
  },
  label: {
    visible: false,
    offset: 5,
    position: "top",
    style: {
      lineWidth: 2,
      stroke: {
        type: "palette",
        key: "backgroundColor"
      }
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/series/waterfall
var waterfall = {
  seriesFieldName: {
    total: "total",
    increase: "increase",
    decrease: "decrease"
  },
  leaderLine: {
    style: {
      stroke: "black",
      lineWidth: 1,
      lineDash: [4, 4]
    }
  },
  stackLabel: {
    visible: true,
    offset: 12,
    position: "withChange",
    style: {
      fill: "black",
      fontSize: {
        type: "token",
        key: "l4FontSize"
      }
    }
  },
  label: {
    visible: false,
    offset: 12,
    position: "inside",
    style: {
      lineWidth: 2
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/series/word-cloud
var wordCloud = {
  word: {
    padding: 1,
    style: {
      textAlign: "center",
      textBaseline: "alphabetic"
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/series/word-cloud3d
var wordCloud3d = {
  word: {
    padding: 1,
    style: {
      textAlign: "center",
      textBaseline: "alphabetic"
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/series/treemap
var treemap = {
  gapWidth: 1,
  nodePadding: [5],
  nonLeaf: {
    visible: false,
    style: {
      fillOpacity: 0.5
    }
  },
  label: {
    style: {
      fill: "white",
      textBaseline: "middle",
      textAlign: "center",
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      lineHeight: {
        type: "token",
        key: "l5LineHeight"
      }
    }
  },
  nonLeafLabel: {
    padding: 24,
    style: {
      fill: "black",
      stroke: {
        type: "palette",
        key: "backgroundColor"
      },
      lineWidth: 2,
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      lineHeight: {
        type: "token",
        key: "l5LineHeight"
      },
      textBaseline: "middle",
      textAlign: "center"
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/series/sunburst
var sunburst = {
  innerRadius: 0,
  outerRadius: 1,
  startAngle: POLAR_START_ANGLE2,
  endAngle: POLAR_END_ANGLE2,
  gap: 0,
  labelLayout: {
    align: "center",
    offset: 0,
    rotate: "radial"
  },
  sunburst: {
    style: {
      stroke: {
        type: "palette",
        key: "backgroundColor"
      },
      fillOpacity: 1,
      cursor: "pointer"
    }
  },
  label: {
    visible: true,
    style: {
      cursor: "pointer",
      fill: {
        type: "palette",
        key: "primaryFontColor"
      },
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      lineHeight: {
        type: "token",
        key: "l5LineHeight"
      }
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/series/rangeColumn
var rangeColumn = {
  label: {
    visible: false,
    offset: 5,
    position: "inside",
    style: {
      lineWidth: 2,
      fill: {
        type: "palette",
        key: "axisMarkerFontColor"
      }
    },
    minLabel: {
      position: "end"
    },
    maxLabel: {
      position: "start"
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/series/circle-packing
var circlePacking = {
  layoutPadding: 5,
  circlePacking: {
    visible: true,
    style: {
      cursor: "pointer",
      stroke: {
        type: "palette",
        key: "backgroundColor"
      }
    }
  },
  label: {
    visible: true,
    style: {
      cursor: "pointer",
      fill: "black",
      stroke: {
        type: "palette",
        key: "backgroundColor"
      },
      lineWidth: 2,
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      lineHeight: {
        type: "token",
        key: "l5LineHeight"
      }
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/series/heatmap
var heatmap = {
  cell: {
    style: {
      shape: "square",
      fillOpacity: 1
    }
  },
  cellBackground: {
    visible: false
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/series/sankey
var sankey = {
  link: {
    style: {
      fillOpacity: 0.15,
      round: true
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/series/rose
var rose = {
  rose: {
    style: {
      fillOpacity: 1
    }
  },
  label: {
    style: {
      lineWidth: 2,
      stroke: {
        type: "palette",
        key: "backgroundColor"
      },
      textAlign: "center",
      textBaseline: "middle"
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/series/box-plot
var boxPlot = {
  boxPlot: {
    style: {
      lineWidth: 1
    }
  },
  label: {
    style: {
      lineWidth: 2
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/series/correlation
var correlation = {
  centerLabel: {
    visible: true,
    position: "center",
    style: {
      fill: "#fff",
      text: ""
    }
  },
  label: {
    visible: true,
    position: "bottom",
    style: {
      fill: "#000"
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/series/liquid
var liquid = {
  outlinePadding: 10,
  liquidBackground: {
    style: {
      lineWidth: 0,
      fillOpacity: 0.2
    }
  },
  liquidOutline: {
    style: {
      lineWidth: 2
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/series/venn
var venn = {
  circle: {
    style: {
      opacity: 0.8
    },
    state: {
      hover: {
        opacity: 1
      }
    }
  },
  overlap: {
    style: {
      opacity: 0.8
    },
    state: {
      hover: {
        opacity: 1,
        stroke: "white",
        lineWidth: 2
      }
    }
  },
  label: {
    visible: true,
    style: {
      fill: "white",
      textBaseline: "middle",
      textAlign: "center",
      fontSize: {
        type: "token",
        key: "l4FontSize"
      },
      lineHeight: {
        type: "token",
        key: "l4LineHeight"
      }
    }
  },
  overlapLabel: {
    visible: true,
    style: {
      textBaseline: "middle",
      textAlign: "center",
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      lineHeight: {
        type: "token",
        key: "l5LineHeight"
      }
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/series
var series = {
  scatter,
  line,
  area,
  bar,
  bar3d,
  pie,
  pie3d,
  map: map2,
  radar,
  dot,
  link: link2,
  wordCloud,
  wordCloud3d,
  funnel,
  funnel3d,
  linearProgress,
  circularProgress,
  waterfall,
  gauge,
  gaugePointer,
  treemap,
  sunburst,
  rangeColumn,
  circlePacking,
  heatmap,
  sankey,
  rose,
  boxPlot,
  correlation,
  liquid,
  venn
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/mark
var markByType = {
  text: {
    style: {
      fontSize: {
        type: "token",
        key: "l4FontSize"
      },
      fontWeight: "normal",
      fillOpacity: 1
    }
  }
};
var markByName = {
  label: {
    style: {
      fontSize: {
        type: "token",
        key: "l4FontSize"
      },
      fontWeight: "normal",
      fillOpacity: 1,
      lineJoin: "bevel"
    }
  },
  area: {
    style: {
      fillOpacity: 0.2
    }
  },
  line: {
    style: {
      lineWidth: 2,
      lineCap: "round",
      lineJoin: "round"
    }
  },
  point: {
    style: {
      size: 8,
      stroke: {
        type: "palette",
        key: "backgroundColor"
      },
      lineWidth: 1,
      fillOpacity: 1
    }
  },
  word: {
    style: {
      fontSize: null
    }
  },
  fillingWord: {
    style: {
      fontSize: null
    }
  },
  sunburst: {
    style: {
      lineWidth: 1,
      stroke: {
        type: "palette",
        key: "backgroundColor"
      }
    }
  },
  circlePacking: {
    style: {
      lineWidth: 1,
      stroke: {
        type: "palette",
        key: "backgroundColor"
      }
    }
  },
  funnel3d: {
    style: {
      stroke: false
    }
  },
  barBackground: {
    visible: false,
    style: {
      fill: {
        type: "palette",
        key: "primaryFontColor",
        a: 0.06
      },
      stroke: "transparent"
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/component/axis/band-axis
var axisBand = {
  domainLine: {
    visible: true
  },
  grid: {
    visible: false
  },
  subGrid: {
    visible: false
  },
  tick: {
    visible: true
  },
  subTick: {
    visible: false
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/component/axis/cartesian-axis
var axisX = {
  label: {
    space: 8
  },
  title: {
    space: 8
  },
  maxHeight: "30%",
  unit: {
    visible: false,
    style: {
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      fill: {
        type: "palette",
        key: "axisLabelFontColor"
      },
      fontWeight: "normal",
      fillOpacity: 1
    }
  }
};
var axisY = {
  label: {
    space: 12,
    autoLimit: true
  },
  title: {
    space: 12,
    autoRotate: true
  },
  maxWidth: "30%",
  unit: {
    visible: false,
    style: {
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      fill: {
        type: "palette",
        key: "axisLabelFontColor"
      },
      fontWeight: "normal",
      fillOpacity: 1
    }
  }
};
var axisZ = Object.assign(Object.assign({}, axisX), {
  label: {
    space: 0
  }
});

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/component/axis/common-axis
var commonAxis = {
  domainLine: {
    visible: true,
    style: {
      lineWidth: 1,
      stroke: {
        type: "palette",
        key: "axisDomainColor"
      },
      strokeOpacity: 1
    }
  },
  grid: {
    visible: true,
    style: {
      lineWidth: 1,
      stroke: {
        type: "palette",
        key: "axisGridColor"
      },
      strokeOpacity: 1,
      lineDash: []
    }
  },
  subGrid: {
    visible: false,
    style: {
      lineWidth: 1,
      stroke: {
        type: "palette",
        key: "axisGridColor"
      },
      strokeOpacity: 1,
      lineDash: [4, 4]
    }
  },
  tick: {
    visible: true,
    inside: false,
    tickSize: 4,
    alignWithLabel: true,
    style: {
      lineWidth: 1,
      stroke: {
        type: "palette",
        key: "axisDomainColor"
      },
      strokeOpacity: 1
    }
  },
  subTick: {
    visible: false,
    tickSize: 2,
    style: {
      lineWidth: 1,
      stroke: {
        type: "palette",
        key: "axisDomainColor"
      },
      strokeOpacity: 1
    }
  },
  label: {
    visible: true,
    inside: false,
    space: 10,
    style: {
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      fill: {
        type: "palette",
        key: "axisLabelFontColor"
      },
      fontWeight: "normal",
      fillOpacity: 1
    }
  },
  title: {
    space: 10,
    padding: 0,
    style: {
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      lineHeight: {
        type: "token",
        key: "l5LineHeight"
      },
      fill: {
        type: "palette",
        key: "secondaryFontColor"
      },
      fontWeight: "normal",
      fillOpacity: 1
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/component/axis/linear-axis
var axisLinear = {
  domainLine: {
    visible: false
  },
  grid: {
    visible: true
  },
  subGrid: {
    visible: false
  },
  tick: {
    visible: false
  },
  subTick: {
    visible: false
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/component/axis/polar-axis
var axisRadius = {
  grid: {
    smooth: true,
    visible: true
  },
  subGrid: {
    smooth: true,
    visible: false
  }
};
var axisAngle = {
  grid: {
    visible: true,
    style: {
      lineDash: [6, 6]
    }
  },
  label: {
    space: 5
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/component/brush
var brush = {
  style: {
    fill: "#B0C8F9",
    fillOpacity: 0.2,
    stroke: "#B0C8F9",
    lineWidth: 2
  },
  brushMode: "single",
  brushType: "rect",
  brushMoved: true,
  removeOnClick: true,
  delayType: "throttle",
  delayTime: 0
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/component/crosshair
var crosshair = {
  trigger: "hover",
  bandField: {
    visible: false,
    line: {
      type: "rect",
      visible: true,
      style: {
        fill: {
          type: "palette",
          key: "axisGridColor"
        },
        opacity: 0.7,
        lineWidth: 0,
        stroke: {
          type: "palette",
          key: "markLineStrokeColor"
        },
        lineDash: [2, 3]
      }
    },
    label: {
      visible: false,
      style: {
        fontWeight: "normal",
        fill: {
          type: "palette",
          key: "axisMarkerFontColor"
        },
        fontSize: {
          type: "token",
          key: "l5FontSize"
        }
      },
      labelBackground: {
        padding: {
          bottom: 0,
          top: 0,
          left: 2,
          right: 2
        },
        style: {
          fill: {
            type: "palette",
            key: "axisMarkerBackgroundColor"
          },
          cornerRadius: 1
        }
      }
    }
  },
  linearField: {
    visible: false,
    line: {
      type: "line",
      visible: true,
      style: {
        stroke: {
          type: "palette",
          key: "markLineStrokeColor"
        },
        fill: "transparent",
        opacity: 0.7,
        lineDash: [2, 3]
      }
    },
    label: {
      visible: false,
      style: {
        fontWeight: "normal",
        fill: {
          type: "palette",
          key: "axisMarkerFontColor"
        },
        fontSize: {
          type: "token",
          key: "l5FontSize"
        }
      },
      labelBackground: {
        padding: {
          bottom: 0,
          top: 0,
          left: 2,
          right: 2
        },
        style: {
          fill: {
            type: "palette",
            key: "axisMarkerBackgroundColor"
          },
          cornerRadius: 1
        }
      }
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/component/data-zoom
var DataZoomHandlerSymbolType = "M-0.5-2.4h0.9c0.4,0,0.7,0.3,0.7,0.7v3.3c0,0.4-0.3,0.7-0.7,0.7h-0.9c-0.4,0-0.7-0.3-0.7-0.7v-3.3\nC-1.2-2-0.9-2.4-0.5-2.4z M-0.4-1.4L-0.4-1.4c0,0,0,0.1,0,0.1v2.6c0,0.1,0,0.1,0,0.1l0,0c0,0,0-0.1,0-0.1v-2.6\nC-0.4-1.4-0.4-1.4-0.4-1.4z M0.3-1.4L0.3-1.4c0,0,0,0.1,0,0.1v2.6c0,0.1,0,0.1,0,0.1l0,0c0,0,0-0.1,0-0.1v-2.6\nC0.3-1.4,0.3-1.4,0.3-1.4z;";
var dataZoom = {
  padding: [12, 0],
  showDetail: "auto",
  brushSelect: false,
  middleHandler: {
    visible: false,
    background: {
      size: 6,
      style: {
        stroke: {
          type: "palette",
          key: "dataZoomHandleStrokeColor"
        },
        cornerRadius: 2
      }
    },
    icon: {
      style: {
        size: 4,
        fill: {
          type: "palette",
          key: "sliderHandleColor"
        },
        stroke: {
          type: "palette",
          key: "dataZoomHandleStrokeColor"
        },
        symbolType: "M 0.3 -0.5 C 0.41 -0.5 0.5 -0.41 0.5 -0.3 C 0.5 -0.3 0.5 0.3 0.5 0.3 C 0.5 0.41 0.41 0.5 0.3 0.5 C 0.3 0.5 -0.3 0.5 -0.3 0.5 C -0.41 0.5 -0.5 0.41 -0.5 0.3 C -0.5 0.3 -0.5 -0.3 -0.5 -0.3 C -0.5 -0.41 -0.41 -0.5 -0.3 -0.5 C -0.3 -0.5 0.3 -0.5 0.3 -0.5 Z",
        lineWidth: 0.5
      }
    }
  },
  background: {
    size: 20,
    style: {
      fill: {
        type: "palette",
        key: "sliderRailColor"
      },
      lineWidth: 0
    }
  },
  selectedBackground: {
    style: {
      fill: {
        type: "palette",
        key: "sliderTrackColor"
      },
      fillOpacity: 0.1,
      outerBorder: {
        stroke: {
          type: "palette",
          key: "sliderTrackColor"
        },
        strokeOpacity: 0.2,
        distance: -0.5,
        lineWidth: 1
      }
    }
  },
  selectedBackgroundChart: {
    area: {
      style: {
        visible: false,
        stroke: false,
        fill: {
          type: "palette",
          key: "dataZoomChartColor"
        }
      }
    },
    line: {
      style: {
        visible: false,
        stroke: {
          type: "palette",
          key: "dataZoomChartColor"
        },
        lineWidth: 1
      }
    }
  },
  startHandler: {
    style: {
      symbolType: DataZoomHandlerSymbolType,
      fill: {
        type: "palette",
        key: "sliderHandleColor"
      },
      scaleX: 1.2,
      scaleY: 1.2,
      stroke: {
        type: "palette",
        key: "dataZoomHandleStrokeColor"
      },
      lineWidth: 1
    }
  },
  endHandler: {
    style: {
      symbolType: DataZoomHandlerSymbolType,
      fill: {
        type: "palette",
        key: "sliderHandleColor"
      },
      scaleX: 1.2,
      scaleY: 1.2,
      stroke: {
        type: "palette",
        key: "dataZoomHandleStrokeColor"
      },
      lineWidth: 1
    }
  },
  startText: {
    padding: 8,
    style: {
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      lineHeight: {
        type: "token",
        key: "l5LineHeight"
      },
      fill: {
        type: "palette",
        key: "secondaryFontColor",
        default: "#89909d"
      }
    }
  },
  endText: {
    padding: 8,
    style: {
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      lineHeight: {
        type: "token",
        key: "l5LineHeight"
      },
      fill: {
        type: "palette",
        key: "secondaryFontColor",
        default: "#89909d"
      }
    }
  },
  backgroundChart: {
    area: {
      style: {
        stroke: false,
        fill: {
          type: "palette",
          key: "dataZoomChartColor"
        }
      }
    },
    line: {
      style: {
        stroke: {
          type: "palette",
          key: "dataZoomChartColor"
        },
        lineWidth: 1
      }
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/component/indicator
var indicator = {
  title: {
    visible: true,
    autoLimit: false,
    autoFit: false,
    style: {
      fontSize: {
        type: "token",
        key: "l1FontSize"
      },
      fill: {
        type: "palette",
        key: "primaryFontColor"
      },
      fontWeight: "normal",
      fillOpacity: 1,
      textBaseline: "top",
      textAlign: "center"
    }
  },
  content: {
    visible: true,
    style: {
      fontSize: {
        type: "token",
        key: "l2FontSize"
      },
      fill: {
        type: "palette",
        key: "tertiaryFontColor"
      },
      fontWeight: "normal",
      fillOpacity: 1,
      textBaseline: "top",
      textAlign: "center"
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/component/legend/continuous
var DEFAULT_CONTINUOUS_LEGEND_THEME = {
  orient: "right",
  position: "middle",
  padding: [16, 24],
  title: {
    visible: false,
    padding: 0,
    textStyle: {
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      lineHeight: {
        type: "token",
        key: "l5LineHeight"
      },
      fontWeight: "normal",
      fill: {
        type: "palette",
        key: "primaryFontColor"
      }
    },
    space: 12
  },
  handler: {
    visible: true
  },
  startText: {
    style: {
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      lineHeight: {
        type: "token",
        key: "l5LineHeight"
      },
      fontWeight: "normal",
      fill: {
        type: "palette",
        key: "secondaryFontColor",
        default: "#89909d"
      }
    },
    space: 6
  },
  endText: {
    style: {
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      lineHeight: {
        type: "token",
        key: "l5LineHeight"
      },
      fontWeight: "normal",
      fill: {
        type: "palette",
        key: "secondaryFontColor",
        default: "#89909d"
      }
    },
    space: 6
  },
  handlerText: {
    style: {
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      lineHeight: {
        type: "token",
        key: "l5LineHeight"
      },
      fontWeight: "normal",
      fill: {
        type: "palette",
        key: "secondaryFontColor",
        default: "#89909d"
      }
    },
    space: 6
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/component/legend/color-legend
var handlerTheme = {
  style: {
    symbolType: "circle",
    lineWidth: 0,
    outerBorder: {
      lineWidth: 2,
      distance: 0.8,
      stroke: "#ffffff"
    },
    shadowBlur: 12,
    shadowOffsetX: 0,
    shadowOffsetY: 4,
    shadowColor: {
      type: "palette",
      key: "shadowColor"
    }
  }
};
var colorLegend2 = {
  horizontal: Object.assign(Object.assign({}, DEFAULT_CONTINUOUS_LEGEND_THEME), {
    rail: {
      width: 200,
      height: 8,
      style: {
        fill: {
          type: "palette",
          key: "sliderRailColor"
        }
      }
    },
    handler: handlerTheme
  }),
  vertical: Object.assign(Object.assign({}, DEFAULT_CONTINUOUS_LEGEND_THEME), {
    rail: {
      width: 8,
      height: 200,
      style: {
        fill: {
          type: "palette",
          key: "sliderRailColor"
        }
      }
    },
    handler: handlerTheme
  })
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/component/legend/discrete-legend
var discreteLegend2 = {
  orient: "bottom",
  position: "middle",
  padding: [16, 24],
  title: {
    visible: false,
    padding: 0,
    textStyle: {
      fontSize: {
        type: "token",
        key: "l5FontSize"
      },
      lineHeight: {
        type: "token",
        key: "l5LineHeight"
      },
      fill: {
        type: "palette",
        key: "primaryFontColor"
      },
      fontWeight: "normal"
    },
    space: 12
  },
  item: {
    visible: true,
    spaceCol: 10,
    spaceRow: 6,
    padding: 2,
    background: {
      state: {
        selectedHover: {
          fill: {
            type: "palette",
            key: "hoverBackgroundColor"
          }
        },
        unSelectedHover: {
          fill: {
            type: "palette",
            key: "hoverBackgroundColor"
          }
        }
      }
    },
    shape: {
      space: 6,
      style: {
        lineWidth: 0,
        fillOpacity: 1,
        opacity: 1
      },
      state: {
        unSelected: {
          fillOpacity: 0.2,
          opacity: 1
        }
      }
    },
    label: {
      space: 6,
      style: {
        fill: {
          type: "palette",
          key: "secondaryFontColor",
          default: "#89909d"
        },
        fontSize: {
          type: "token",
          key: "l5FontSize"
        },
        lineHeight: {
          type: "token",
          key: "l5LineHeight"
        },
        opacity: 1
      },
      state: {
        unSelected: {
          fill: {
            type: "palette",
            key: "disableFontColor"
          },
          opacity: 1
        }
      }
    }
  },
  allowAllCanceled: false
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/component/legend/size-legend
var handlerTheme2 = {
  style: {
    symbolType: "circle",
    lineWidth: 0,
    outerBorder: {
      lineWidth: 2,
      distance: 0.8,
      stroke: {
        type: "palette",
        key: "sliderTrackColor"
      }
    },
    fill: {
      type: "palette",
      key: "sliderHandleColor"
    }
  }
};
var sizeLegend2 = {
  horizontal: Object.assign(Object.assign({}, DEFAULT_CONTINUOUS_LEGEND_THEME), {
    sizeBackground: {
      fill: {
        type: "palette",
        key: "dataZoomChartColor"
      }
    },
    track: {
      style: {
        fill: {
          type: "palette",
          key: "sliderTrackColor",
          a: 0.8
        }
      }
    },
    rail: {
      width: 200,
      height: 4,
      style: {
        fill: {
          type: "palette",
          key: "sliderRailColor"
        }
      }
    },
    handler: handlerTheme2
  }),
  vertical: Object.assign(Object.assign({}, DEFAULT_CONTINUOUS_LEGEND_THEME), {
    sizeBackground: {
      fill: {
        type: "palette",
        key: "dataZoomChartColor"
      }
    },
    track: {
      style: {
        fill: {
          type: "palette",
          key: "sliderTrackColor",
          a: 0.8
        }
      }
    },
    rail: {
      width: 4,
      height: 200,
      style: {
        fill: {
          type: "palette",
          key: "sliderRailColor"
        }
      }
    },
    handler: handlerTheme2
  })
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/component/map-label
var mapLabel = {
  visible: true,
  offset: 12,
  position: "top",
  space: 10,
  nameLabel: {
    visible: true,
    style: {
      textBaseline: "middle",
      textAlign: "left",
      fill: "black",
      fontSize: {
        type: "token",
        key: "l6FontSize"
      }
    }
  },
  valueLabel: {
    visible: true,
    style: {
      textBaseline: "middle",
      textAlign: "left",
      fill: "black",
      fontSize: {
        type: "token",
        key: "l6FontSize"
      }
    }
  },
  background: {
    visible: true,
    padding: {
      top: 4,
      bottom: 4,
      left: 6,
      right: 6
    },
    style: {
      cornerRadius: 2,
      lineWidth: 1,
      fill: "white",
      stroke: "grey"
    }
  },
  leader: {
    visible: false,
    style: {
      lineWidth: 1,
      stroke: "red"
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/component/mark-area
var markArea = {
  area: {
    style: {
      fill: {
        type: "palette",
        key: "axisDomainColor",
        a: 0.25
      }
    }
  },
  label: {
    style: {
      fontSize: {
        type: "token",
        key: "l4FontSize"
      },
      fontWeight: "normal",
      fontStyle: "normal",
      fill: {
        type: "palette",
        key: "primaryFontColor"
      }
    },
    labelBackground: {
      padding: {
        top: 2,
        bottom: 2,
        right: 4,
        left: 4
      },
      style: {
        cornerRadius: 3,
        fill: {
          type: "palette",
          key: "markLabelBackgroundColor"
        }
      }
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/component/mark-line
var markLine = {
  line: {
    style: {
      lineDash: [3, 3],
      stroke: {
        type: "palette",
        key: "markLineStrokeColor"
      }
    }
  },
  startSymbol: {
    visible: false,
    symbolType: "triangle",
    size: 10,
    style: {
      fill: {
        type: "palette",
        key: "markLineStrokeColor"
      },
      stroke: null,
      lineWidth: 0
    }
  },
  endSymbol: {
    visible: true,
    symbolType: "triangle",
    size: 10,
    style: {
      fill: {
        type: "palette",
        key: "markLineStrokeColor"
      },
      stroke: null,
      lineWidth: 0
    }
  },
  label: {
    refY: 5,
    style: {
      fontSize: {
        type: "token",
        key: "l4FontSize"
      },
      fontWeight: "normal",
      fontStyle: "normal",
      fill: {
        type: "palette",
        key: "primaryFontColor"
      }
    },
    labelBackground: {
      padding: {
        top: 2,
        bottom: 2,
        right: 4,
        left: 4
      },
      style: {
        cornerRadius: 3,
        fill: {
          type: "palette",
          key: "markLabelBackgroundColor"
        }
      }
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/component/mark-point
var markPoint = {
  itemLine: {
    decorativeLine: {
      visible: false
    },
    startSymbol: {
      size: 5,
      visible: true,
      style: {
        fill: {
          type: "palette",
          key: "markLineStrokeColor"
        },
        stroke: null,
        lineWidth: 0
      }
    },
    endSymbol: {
      style: {
        fill: {
          type: "palette",
          key: "markLineStrokeColor"
        },
        stroke: null,
        lineWidth: 0
      }
    },
    line: {
      style: {
        stroke: {
          type: "palette",
          key: "markLineStrokeColor"
        }
      }
    }
  },
  itemContent: {
    offsetY: -50
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/component/player
var player = {
  visible: true,
  position: "start",
  padding: {
    top: 20,
    bottom: 20
  },
  slider: {
    space: 10,
    trackStyle: {
      fill: {
        type: "palette",
        key: "sliderTrackColor"
      },
      fillOpacity: 0.8
    },
    railStyle: {
      fill: {
        type: "palette",
        key: "sliderRailColor"
      }
    },
    handlerStyle: {
      size: 15,
      stroke: {
        type: "palette",
        key: "backgroundColor"
      },
      lineWidth: 2,
      fill: {
        type: "palette",
        key: "playerControllerColor"
      }
    }
  },
  controller: {
    start: {
      order: 0,
      space: 0,
      style: {
        size: 25,
        fill: {
          type: "palette",
          key: "playerControllerColor"
        },
        fillOpacity: 0.8
      }
    },
    pause: {
      order: 0,
      space: 0,
      style: {
        size: 25,
        fill: {
          type: "palette",
          key: "playerControllerColor"
        },
        fillOpacity: 0.8
      }
    },
    backward: {
      order: 0,
      space: 10,
      position: "start",
      style: {
        size: 12,
        fill: {
          type: "palette",
          key: "playerControllerColor"
        },
        fillOpacity: 0.8
      }
    },
    forward: {
      order: 0,
      space: 10,
      position: "end",
      style: {
        size: 12,
        fill: {
          type: "palette",
          key: "playerControllerColor"
        },
        fillOpacity: 0.8
      }
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/component/title
var title2 = {
  padding: {
    top: 4,
    bottom: 20
  },
  textStyle: {
    fontSize: {
      type: "token",
      key: "l3FontSize"
    },
    lineHeight: {
      type: "token",
      key: "l3LineHeight"
    },
    fill: {
      type: "palette",
      key: "primaryFontColor"
    }
  },
  subtextStyle: {
    fontSize: {
      type: "token",
      key: "l4FontSize"
    },
    lineHeight: {
      type: "token",
      key: "l4LineHeight"
    },
    fill: {
      type: "palette",
      key: "tertiaryFontColor"
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/component/tooltip
var tooltip2 = {
  offset: {
    x: 10,
    y: 10
  },
  panel: {
    padding: {
      top: 10,
      left: 10,
      right: 10,
      bottom: 10
    },
    backgroundColor: {
      type: "palette",
      key: "popupBackgroundColor"
    },
    border: {
      color: {
        type: "palette",
        key: "popupBackgroundColor"
      },
      width: 0,
      radius: 3
    },
    shadow: {
      x: 0,
      y: 4,
      blur: 12,
      spread: 0,
      color: {
        type: "palette",
        key: "shadowColor"
      }
    }
  },
  spaceRow: 6,
  titleLabel: {
    fontSize: {
      type: "token",
      key: "l4FontSize"
    },
    lineHeight: {
      type: "token",
      key: "l4LineHeight"
    },
    fontColor: {
      type: "palette",
      key: "primaryFontColor"
    },
    fontWeight: "bold",
    textAlign: "left",
    textBaseline: "middle",
    spacing: 0
  },
  shape: {
    size: 8,
    spacing: 6
  },
  keyLabel: {
    fontSize: {
      type: "token",
      key: "l4FontSize"
    },
    lineHeight: {
      type: "token",
      key: "l4LineHeight"
    },
    fontColor: {
      type: "palette",
      key: "secondaryFontColor"
    },
    textAlign: "left",
    textBaseline: "middle",
    spacing: 26
  },
  valueLabel: {
    fontSize: {
      type: "token",
      key: "l4FontSize"
    },
    lineHeight: {
      type: "token",
      key: "l4LineHeight"
    },
    fontColor: {
      type: "palette",
      key: "primaryFontColor"
    },
    fontWeight: "bold",
    textBaseline: "middle",
    spacing: 0
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/component/poptip
var poptip = {
  visible: true,
  position: "auto",
  padding: 8,
  titleStyle: {
    fontSize: {
      type: "token",
      key: "l5FontSize"
    },
    fontWeight: "bold",
    fill: {
      type: "palette",
      key: "primaryFontColor"
    }
  },
  contentStyle: {
    fontSize: {
      type: "token",
      key: "l5FontSize"
    },
    fill: {
      type: "palette",
      key: "primaryFontColor"
    }
  },
  panel: {
    visible: true,
    fill: {
      type: "palette",
      key: "popupBackgroundColor"
    },
    cornerRadius: 3,
    lineWidth: 0,
    shadowBlur: 12,
    shadowOffsetX: 0,
    shadowOffsetY: 4,
    shadowColor: {
      type: "palette",
      key: "shadowColor"
    },
    size: 0,
    space: 12
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/component/total-label
var totalLabel = {
  visible: false,
  offset: 5,
  overlap: {
    clampForce: true,
    strategy: []
  },
  smartInvert: false,
  animation: false,
  style: {
    fontSize: {
      type: "token",
      key: "l4FontSize"
    },
    fill: {
      type: "palette",
      key: "primaryFontColor"
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/component/scroll-bar
var scrollBar = {
  horizontal: {
    height: 10,
    slider: {
      style: {
        fill: {
          type: "palette",
          key: "scrollBarSliderColor"
        }
      }
    }
  },
  vertical: {
    width: 10,
    slider: {
      style: {
        fill: {
          type: "palette",
          key: "scrollBarSliderColor"
        }
      }
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/common/component
var component = {
  discreteLegend: discreteLegend2,
  colorLegend: colorLegend2,
  sizeLegend: sizeLegend2,
  axis: commonAxis,
  axisBand,
  axisLinear,
  axisX,
  axisY,
  axisZ,
  axisAngle,
  axisRadius,
  markLine,
  markArea,
  markPoint,
  polarMarkLine: markLine,
  polarMarkArea: markArea,
  polarMarkPoint: markPoint,
  geoMarkPoint: markPoint,
  tooltip: tooltip2,
  dataZoom,
  crosshair,
  player,
  brush,
  indicator,
  title: title2,
  mapLabel,
  poptip,
  totalLabel,
  scrollBar
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/token/util
function queryToken(tokenMap, tokenKey) {
  return tokenMap && tokenKey.key in tokenMap ? tokenMap[tokenKey.key] : tokenKey.default;
}
function isTokenKey(obj) {
  return obj && "token" === obj.type && !!obj.key;
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/token/builtin/default
var token = {
  fontFamily: "PingFang SC,Helvetica Neue,Microsoft Yahei,system-ui,-apple-system,segoe ui,Roboto,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol",
  fontSize: 14,
  l1FontSize: 32,
  l1LineHeight: "150%",
  l2FontSize: 20,
  l2LineHeight: "140%",
  l3FontSize: 16,
  l3LineHeight: "150%",
  l4FontSize: 14,
  l4LineHeight: "150%",
  l5FontSize: 12,
  l5LineHeight: "130%",
  l6FontSize: 10,
  l6LineHeight: "120%"
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/light
var lightTheme = {
  name: "light",
  background: {
    type: "palette",
    key: "backgroundColor"
  },
  padding: 20,
  fontFamily: {
    type: "token",
    key: "fontFamily"
  },
  colorScheme,
  token,
  mark: markByType,
  markByName,
  series,
  component,
  animationThreshold: 2e3
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/dark/color-scheme
var colorScheme2 = {
  default: {
    dataScheme,
    palette: {
      backgroundColor: "#202226",
      borderColor: "#404349",
      shadowColor: "rgba(0,0,0,0.1)",
      hoverBackgroundColor: "#404349",
      sliderRailColor: "#404349",
      sliderHandleColor: "#202226",
      sliderTrackColor: "#4284FF",
      popupBackgroundColor: "#404349",
      primaryFontColor: "#fdfdfd",
      secondaryFontColor: "#bbbdc3",
      tertiaryFontColor: "#888c93",
      axisLabelFontColor: "#888c93",
      disableFontColor: "#55595f",
      axisMarkerFontColor: "#202226",
      axisGridColor: "#404349",
      axisDomainColor: "#4b4f54",
      dataZoomHandleStrokeColor: "#bbbdc3",
      dataZoomChartColor: "#55595F",
      playerControllerColor: "#4284FF",
      scrollBarSliderColor: "rgba(255,255,255,0.3)",
      axisMarkerBackgroundColor: "#fdfdfd",
      markLabelBackgroundColor: "#404349",
      markLineStrokeColor: "#bbbdc3",
      dangerColor: "#eb4b4b",
      warningColor: "#f0bd30",
      successColor: "#14b267",
      infoColor: "#4284ff"
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin/dark
var darkTheme2 = {
  name: "dark",
  colorScheme: colorScheme2,
  component: {
    dataZoom: {
      selectedBackground: {
        style: {
          fillOpacity: 0.4,
          outerBorder: {
            strokeOpacity: 0.4
          }
        }
      }
    }
  }
};

// http-url:https://unpkg.com/@visactor/vutils-extension@1.11.3/es/utils/object
var includeSpec = (spec, searchSpec) => spec === searchSpec || !isFunction_default(spec) && !isFunction_default(searchSpec) && (isArray_default(spec) && isArray_default(searchSpec) ? searchSpec.every((searchItem) => spec.some((item) => includeSpec(item, searchItem))) : !(!isObject_default(spec) || !isObject_default(searchSpec)) && Object.keys(searchSpec).every((key) => includeSpec(spec[key], searchSpec[key])));
var setProperty = (target, path, value) => {
  if (isNil_default(path))
    return target;
  const key = path[0];
  return isNil_default(key) ? target : 1 === path.length ? (target[key] = value, target) : (isNil_default(target[key]) && ("number" == typeof path[1] ? target[key] = [] : target[key] = {}), setProperty(target[key], path.slice(1), value));
};
var getProperty = (target, path, defaultValue) => {
  if (!isNil_default(path))
    return get_default(target, path, defaultValue);
};

// http-url:https://unpkg.com/@visactor/vutils-extension@1.11.3/es/spec/clone-deep
function cloneDeepSpec(spec, excludeKeys = ["data"]) {
  const value = spec;
  let result2;
  if (!isValid_default(value) || "object" != typeof value)
    return value;
  if (isDataView(value) || isHTMLElement(value))
    return value;
  const isArr = isArray_default(value), length2 = value.length;
  result2 = isArr ? new Array(length2) : "object" == typeof value ? {} : isBoolean_default(value) || isNumber_default(value) || isString_default(value) ? value : isDate_default(value) ? /* @__PURE__ */ new Date(+value) : void 0;
  const props = isArr ? void 0 : Object.keys(Object(value));
  let index = -1;
  if (result2)
    for (; ++index < (props || value).length; ) {
      const key = props ? props[index] : index, subValue = value[key];
      (null == excludeKeys ? void 0 : excludeKeys.includes(key.toString())) ? result2[key] = subValue : result2[key] = cloneDeepSpec(subValue, excludeKeys);
    }
  return result2;
}

// http-url:https://unpkg.com/@visactor/vutils-extension@1.11.3/es/spec/merge-spec
function baseMerge2(target, source, shallowArray = false) {
  if (source) {
    if (target === source)
      return;
    if (isValid_default(source) && "object" == typeof source) {
      const iterable = Object(source), props = [];
      for (const key in iterable)
        props.push(key);
      let { length: length2 } = props, propIndex = -1;
      for (; length2--; ) {
        const key = props[++propIndex];
        isValid_default(iterable[key]) && "object" == typeof iterable[key] && !isArray_default(target[key]) ? baseMergeDeep2(target, source, key, shallowArray) : assignMergeValue2(target, key, iterable[key]);
      }
    }
  }
}
function baseMergeDeep2(target, source, key, shallowArray = false) {
  const objValue = target[key], srcValue = source[key];
  let newValue = source[key], isCommon = true;
  if (isArray_default(srcValue)) {
    if (shallowArray)
      newValue = [];
    else if (isArray_default(objValue))
      newValue = objValue;
    else if (isArrayLike_default(objValue)) {
      newValue = new Array(objValue.length);
      let index = -1;
      const length2 = objValue.length;
      for (; ++index < length2; )
        newValue[index] = objValue[index];
    }
  } else
    isPlainObject_default(srcValue) ? (newValue = null != objValue ? objValue : {}, "function" != typeof objValue && "object" == typeof objValue || (newValue = {})) : isCommon = false;
  isCommon && baseMerge2(newValue, srcValue, shallowArray), assignMergeValue2(target, key, newValue);
}
function assignMergeValue2(target, key, value) {
  (void 0 !== value && !eq2(target[key], value) || void 0 === value && !(key in target)) && (target[key] = value);
}
function eq2(value, other) {
  return value === other || Number.isNaN(value) && Number.isNaN(other);
}
function mergeSpec(target, ...sources) {
  let sourceIndex = -1;
  const length2 = sources.length;
  for (; ++sourceIndex < length2; ) {
    baseMerge2(target, sources[sourceIndex], true);
  }
  return target;
}
function mergeSpecWithFilter(target, filter2, spec, forceMerge) {
  Object.keys(target).forEach((k2) => {
    if (isObject_default(filter2))
      filter2.type === k2 && (isArray_default(target[k2]) ? target[k2].length >= filter2.index && (target[k2][filter2.index] = forceMerge ? mergeSpec({}, target[k2][filter2.index], spec) : spec) : target[k2] = forceMerge ? mergeSpec({}, target[k2], spec) : spec);
    else if (isArray_default(target[k2])) {
      const index = target[k2].findIndex((_s) => _s.id === filter2);
      index >= 0 && (target[k2][index] = forceMerge ? mergeSpec({}, target[k2][index], spec) : spec);
    } else
      target.id === filter2 && (target[k2] = forceMerge ? mergeSpec({}, target[k2], spec) : spec);
  });
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/util/theme/merge-theme
function mergeTheme(target, ...sources) {
  return mergeSpec(transformThemeToMerge(target), ...sources.map(transformThemeToMerge));
}
function transformThemeToMerge(theme2) {
  var _a;
  if (!theme2)
    return theme2;
  const colorScheme3 = transformColorSchemeToMerge(theme2.colorScheme), { series: series2 } = theme2, { mark: markByType2, markByName: markByName2 } = theme2;
  let newSeriesTheme;
  return (markByType2 || markByName2) && (newSeriesTheme = Object.keys(seriesMarkInfoMap).reduce((newSeriesTheme2, key) => {
    var _a2;
    const value = null !== (_a2 = null == series2 ? void 0 : series2[key]) && void 0 !== _a2 ? _a2 : {};
    return newSeriesTheme2[key] = transformSeriesThemeToMerge(value, key, markByType2, markByName2), newSeriesTheme2;
  }, {})), Object.assign({}, theme2, {
    colorScheme: colorScheme3,
    token: null !== (_a = theme2.token) && void 0 !== _a ? _a : {},
    series: Object.assign({}, theme2.series, newSeriesTheme)
  });
}
function transformColorSchemeToMerge(colorScheme3) {
  return colorScheme3 && (colorScheme3 = Object.keys(colorScheme3).reduce((scheme, key) => {
    const value = colorScheme3[key];
    return scheme[key] = transformColorSchemeToStandardStruct(value), scheme;
  }, {})), colorScheme3;
}
function transformSeriesThemeToMerge(seriesTheme, seriesType, markByType2, markByName2) {
  if (!seriesMarkInfoMap[seriesType])
    return seriesTheme;
  const newTheme = {};
  return Object.values(seriesMarkInfoMap[seriesType]).forEach(({ type, name }) => {
    newTheme[name] = mergeSpec({}, null == markByType2 ? void 0 : markByType2[array(type)[0]], null == markByName2 ? void 0 : markByName2[name], null == seriesTheme ? void 0 : seriesTheme[name]);
  }), Object.assign(Object.assign({}, seriesTheme), newTheme);
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/util/theme/preprocess
var IGNORE_KEYS = ["animationThreshold", "colorScheme", "name", "padding"];
function preprocessTheme(obj, colorScheme3, tokenMap, seriesSpec) {
  if (!obj)
    return obj;
  colorScheme3 || (colorScheme3 = obj.colorScheme), tokenMap || (tokenMap = obj.token);
  const newObj = {};
  return Object.keys(obj).forEach((key) => {
    const value = obj[key];
    IGNORE_KEYS.includes(key) ? newObj[key] = value : isPlainObject_default(value) ? isColorKey(value) ? newObj[key] = getActualColor(value, colorScheme3, seriesSpec) : isTokenKey(value) ? newObj[key] = queryToken(tokenMap, value) : newObj[key] = preprocessTheme(value, colorScheme3, tokenMap, seriesSpec) : newObj[key] = value;
  }), newObj;
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/builtin
var builtinThemes = {
  [lightTheme.name]: lightTheme
};
var defaultThemeName = lightTheme.name;
var themes = new Map(Object.keys(builtinThemes).map((key) => [key, builtinThemes[key]]));
var transformedThemes = new Map(Object.keys(builtinThemes).map((key) => [key, preprocessTheme(builtinThemes[key])]));
var hasThemeMerged = new Map(Object.keys(builtinThemes).map((key) => [key, key === defaultThemeName]));
var registerTheme = (name, theme2) => {
  if (!name)
    return;
  const mergedTheme = getMergedTheme(theme2);
  themes.set(name, mergedTheme), transformedThemes.set(name, preprocessTheme(mergedTheme)), hasThemeMerged.set(name, true);
};
var getTheme2 = (name = defaultThemeName, transformed = false) => (hasThemeMerged.has(name) && !hasThemeMerged.get(name) && registerTheme(name, themes.get(name)), transformed ? transformedThemes.get(name) : themes.get(name));
var removeTheme = (name) => themes.delete(name) && transformedThemes.delete(name) && hasThemeMerged.delete(name);
var themeExist = (name) => !!isString_default(name) && themes.has(name);
var getMergedTheme = (theme2) => {
  var _a;
  const baseThemeName = null !== (_a = theme2.type) && void 0 !== _a ? _a : defaultThemeName, baseTheme = getTheme2(baseThemeName);
  return mergeTheme({}, baseTheme, theme2);
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/core/instance-manager
var InstanceManager = class _InstanceManager {
  static registerInstance(instance) {
    _InstanceManager.instances.set(instance.id, instance);
  }
  static unregisterInstance(instance) {
    _InstanceManager.instances.delete(instance.id);
  }
  static getInstance(id2) {
    return _InstanceManager.instances.get(id2);
  }
  static instanceExist(id2) {
    return _InstanceManager.instances.has(id2);
  }
  static forEach(callbackfn, excludeId = [], thisArg) {
    const excludeIdList = array(excludeId);
    return _InstanceManager.instances.forEach((instance, id2, map4) => {
      excludeIdList.includes(id2) || callbackfn(instance, id2, map4);
    }, thisArg);
  }
};
InstanceManager.instances = /* @__PURE__ */ new Map();

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/theme/theme-manager
var ThemeManager2 = class _ThemeManager {
  static registerTheme(name, theme2) {
    registerTheme(name, theme2);
  }
  static getTheme(name, transformed = false) {
    return getTheme2(name, transformed);
  }
  static removeTheme(name) {
    return removeTheme(name);
  }
  static themeExist(name) {
    return themeExist(name);
  }
  static getDefaultTheme() {
    return _ThemeManager.themes.get(defaultThemeName);
  }
  static setCurrentTheme(name) {
    _ThemeManager.themeExist(name) && (_ThemeManager._currentThemeName = name, InstanceManager.forEach((instance) => null == instance ? void 0 : instance.setCurrentTheme(name)));
  }
  static getCurrentTheme(transformed = false) {
    return _ThemeManager.getTheme(_ThemeManager._currentThemeName, transformed);
  }
  static getCurrentThemeName() {
    return _ThemeManager._currentThemeName;
  }
};
ThemeManager2.themes = themes, ThemeManager2._currentThemeName = defaultThemeName;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/util/theme/common
function getThemeObject(theme2, transformed) {
  return isString_default(theme2) ? ThemeManager2.themeExist(theme2) ? ThemeManager2.getTheme(theme2, transformed) : {} : isObject_default(theme2) ? theme2 : {};
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/util/spec/background
function convertBackgroundSpec(bg) {
  if (!bg)
    return null;
  if ("string" == typeof bg)
    return {
      fill: bg,
      fillOpacity: 1
    };
  if ("object" != typeof bg)
    return null;
  const result2 = pickWithout(bg, ["x", "y", "width", "height", "x1", "y1", "image"]);
  return result2.background = bg.image, result2;
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/util/spec/transform
function specTransform(spec, special = {
  data: (v) => v
}) {
  if (!spec)
    return spec;
  if (spec.constructor === Object) {
    const result2 = {};
    for (const key in spec)
      if (Object.prototype.hasOwnProperty.call(spec, key)) {
        if (special[key]) {
          result2[key] = special[key](spec[key]);
          continue;
        }
        result2[key] = specTransform(spec[key], special);
      }
    return result2;
  }
  return isArray_default(spec) ? spec.map((s2) => specTransform(s2, special)) : spec;
}
function functionTransform(spec, VChart2) {
  if (!spec)
    return spec;
  if (isPlainObject_default(spec)) {
    const result2 = {};
    for (const key in spec)
      if (Object.prototype.hasOwnProperty.call(spec, key)) {
        if (isString_default(spec[key]) && VChart2.getFunction(spec[key])) {
          result2[key] = VChart2.getFunction(spec[key]);
          continue;
        }
        result2[key] = functionTransform(spec[key], VChart2);
      }
    return result2;
  }
  return isArray_default(spec) ? spec.map((s2) => functionTransform(s2, VChart2)) : spec;
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/util/text
var initTextMeasure2 = (textSpec, option, useNaiveCanvas) => initTextMeasure(textSpec, option, useNaiveCanvas, {
  fontFamily: token.fontFamily,
  fontSize: token.fontSize
});
var measureText = (text2, textSpec, option, useNaiveCanvas) => initTextMeasure2(textSpec, option, useNaiveCanvas).measure(text2);

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/util/data
function mergeFields(targetFields, mergeFields2) {
  for (let i = 0; i < mergeFields2.length; i++) {
    const element = mergeFields2[i], _target = findFields(targetFields, element.key);
    _target ? _target.operations = [...new Set(_target.operations.concat(element.operations))] : targetFields.push(element);
  }
  return targetFields;
}
function findFields(list, fieldKey) {
  return list.find((i) => i.key === fieldKey);
}
function getFieldAlias(dataView, field3) {
  var _a;
  if (!dataView)
    return null != field3 ? field3 : null;
  const fields2 = dataView.getFields();
  return fields2 && fields2[field3] ? null !== (_a = fields2[field3].alias) && void 0 !== _a ? _a : field3 : null != field3 ? field3 : null;
}
function getRegionStackGroup(region, setInitialValue, filter2) {
  const stackSort = region.getStackSort(), stackValueGroup = {};
  let stackSortCache = null;
  return stackSort && (stackSortCache = {}, region.getSeries().forEach((s2) => {
    const seriesField = s2.getSeriesField();
    if (seriesField) {
      const fieldInfo = s2.getRawDataStatisticsByField(seriesField);
      fieldInfo.values && (stackSortCache[seriesField] || (stackSortCache[seriesField] = {
        lastIndex: 0,
        sort: {}
      }), fieldInfo.values.forEach((v, i) => {
        v in stackSortCache[seriesField].sort || (stackSortCache[seriesField].sort[v] = stackSortCache[seriesField].lastIndex, stackSortCache[seriesField].lastIndex++);
      }));
    }
  })), region.getSeries().forEach((s2) => {
    var _a;
    const stackData = s2.getStackData(), stackValue = s2.getStackValue(), stackValueField = s2.getStackValueField(), filterEnable = !filter2 || filter2(s2);
    stackData && stackValueField && filterEnable && (stackValueGroup[stackValue] = null !== (_a = stackValueGroup[stackValue]) && void 0 !== _a ? _a : {
      nodes: {}
    }, stackGroup(s2, stackData, stackValueGroup[stackValue], stackValueField, setInitialValue, stackSortCache));
  }), stackSort ? sortStackValueGroup(stackValueGroup, stackSortCache) : stackValueGroup;
}
function sortStackValueGroup(stackValueGroup, stackSortCache) {
  var _a;
  for (const key in stackValueGroup)
    (null === (_a = stackValueGroup[key].sortDatums) || void 0 === _a ? void 0 : _a.length) ? (stackValueGroup[key].sortDatums.sort((a3, b) => a3.index - b.index), stackValueGroup[key].values = stackValueGroup[key].sortDatums.map((sd) => sd.datum)) : sortStackValueGroup(stackValueGroup[key].nodes, stackSortCache);
  return stackValueGroup;
}
function stackTotal(stackData, valueField) {
  if ("values" in stackData && stackData.values.length) {
    const total = sum2(stackData.values, valueField), percent = max2(stackData.values, STACK_FIELD_END_PERCENT);
    stackData.values.forEach((v) => {
      v[STACK_FIELD_TOTAL] = total, v[STACK_FIELD_TOTAL_PERCENT] = percent, delete v[STACK_FIELD_TOTAL_TOP];
    });
    const maxNode = stackData.values.reduce((max3, current) => current[STACK_FIELD_END] > max3[STACK_FIELD_END] ? current : max3);
    maxNode[STACK_FIELD_TOTAL_TOP] = true;
  } else
    for (const key in stackData.nodes)
      stackTotal(stackData.nodes[key], valueField);
}
function stackOffsetSilhouette(stackCache) {
  if (!stackCache.values.length)
    return;
  const centerValue = stackCache.values[stackCache.values.length - 1][STACK_FIELD_END] / 2;
  for (let j = 0; j < stackCache.values.length; j++)
    stackCache.values[j][STACK_FIELD_START_OffsetSilhouette] = stackCache.values[j][STACK_FIELD_START] - centerValue, stackCache.values[j][STACK_FIELD_END_OffsetSilhouette] = stackCache.values[j][STACK_FIELD_END] - centerValue;
}
function stack(stackCache, stackInverse, hasPercent) {
  if (stackCache.values.length > 0) {
    let positiveStart = 0, negativeStart = 0, sign3 = 1, value = 0;
    const maxLength = stackCache.values.length;
    for (let index = 0; index < maxLength; index++) {
      const v = stackCache.values[stackInverse ? maxLength - 1 - index : index];
      value = v[STACK_FIELD_END], value >= 0 ? (v[STACK_FIELD_START] = positiveStart, positiveStart += v[STACK_FIELD_END], v[STACK_FIELD_END] = positiveStart) : (v[STACK_FIELD_START] = negativeStart, negativeStart += v[STACK_FIELD_END], v[STACK_FIELD_END] = negativeStart), v[STACK_FIELD_KEY] = stackCache.key;
    }
    if (hasPercent)
      for (let index = 0; index < maxLength; index++) {
        const v = stackCache.values[stackInverse ? maxLength - 1 - index : index];
        value = v[STACK_FIELD_END];
        const denominator = value >= 0 ? positiveStart : negativeStart;
        sign3 = value >= 0 ? 1 : -1, v[STACK_FIELD_START_PERCENT] = 0 === denominator ? 0 : Math.min(1, v[STACK_FIELD_START] / denominator) * sign3, v[STACK_FIELD_END_PERCENT] = 0 === denominator ? 0 : Math.min(1, v[STACK_FIELD_END] / denominator) * sign3;
      }
  }
  for (const key in stackCache.nodes)
    stack(stackCache.nodes[key], stackInverse, hasPercent);
}
function stackGroup(s2, stackData, stackCache, valueField, setInitialValue, stackSortCache, stackKey) {
  if ("values" in stackData)
    if (setInitialValue && stackData.values.forEach((v) => v[STACK_FIELD_END] = toValidNumber2(v[valueField])), stackCache.series.push({
      s: s2,
      values: stackData.values
    }), stackSortCache) {
      const seriesField = s2.getSeriesField();
      stackData.values.forEach((d) => {
        stackCache.sortDatums.push({
          series: s2,
          datum: d,
          index: seriesField ? stackSortCache[seriesField].sort[d[seriesField]] : 0
        });
      });
    } else
      stackCache.values.push(...stackData.values);
  else
    for (const key in stackData.nodes) {
      const newStackKey = stackKey ? `${stackKey}_${key}` : key;
      !stackCache.nodes[key] && (stackCache.nodes[key] = {
        values: [],
        series: [],
        nodes: {},
        sortDatums: [],
        key: newStackKey
      }), stackGroup(s2, stackData.nodes[key], stackCache.nodes[key], valueField, setInitialValue, stackSortCache, newStackKey);
    }
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/util/hierarchy
var findHierarchyNode = (hierarchyData, key, keyField = "key", childrenField = "children") => {
  for (let i = 0; i < hierarchyData.length; i++) {
    const node = hierarchyData[i];
    if (node[keyField] === key)
      return node;
    if (node[childrenField]) {
      const result2 = findHierarchyNode(node[childrenField], key, keyField, childrenField);
      if (result2)
        return result2;
    }
  }
  return null;
};
var findHierarchyNodeParent = (hierarchyData, key, keyField = "key", childrenField = "children") => {
  for (let i = 0; i < hierarchyData.length; i++) {
    const node = hierarchyData[i];
    if (node[childrenField])
      for (let j = 0; j < node[childrenField].length; j++) {
        const childNode = node[childrenField][j];
        if (childNode[keyField] === key)
          return node;
        const result2 = findHierarchyNodeParent([childNode], key, keyField, childrenField);
        if (result2)
          return result2;
      }
  }
  return null;
};
var findHierarchyPath = (hierarchyData, key, keyField = "key", childrenField = "children") => {
  const result2 = [], dfs = (data, path) => {
    for (const item of data) {
      if (item[keyField] === key)
        return result2.push(...path, item[keyField].toString()), true;
      if (item[childrenField]) {
        const res = dfs(item[childrenField], [...path, item[keyField]]);
        if (true === res)
          return res;
      }
    }
    return false;
  };
  return dfs(hierarchyData, []), result2;
};
function isHierarchyItem(item, valueField = "value", childrenField = "children") {
  return !!isObject_default(item) && (!!item.hasOwnProperty(childrenField) && Array.isArray(item[childrenField]));
}
function filterHierarchyDataByRange(data, minValue, maxValue, valueField = "value", childrenField = "children") {
  return Array.isArray(data) ? data.map((item) => {
    const newItem = Object.assign({}, item);
    return Array.isArray(newItem[childrenField]) && (newItem[childrenField] = filterHierarchyDataByRange(newItem[childrenField], minValue, maxValue, valueField, childrenField)), newItem;
  }).filter((item) => +item[valueField] >= minValue && +item[valueField] <= maxValue || item[childrenField] && item[childrenField].length > 0) : data;
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/util/style
function transformComponentStyle(cfg = {}) {
  const newConfig = Object.assign({}, cfg);
  if (isFunction_default(cfg.style) ? newConfig.style = (item, isSelected, index, allItems) => transformToGraphic(cfg.style(item, isSelected, index, allItems)) : isEmpty_default(cfg.style) || (newConfig.style = transformToGraphic(cfg.style)), !isEmpty_default(cfg.state)) {
    const newStateStyle = {};
    Object.keys(cfg.state).forEach((key) => {
      isFunction_default(cfg.state[key]) ? newStateStyle[key] = (item, isSelected, index, allItems) => transformToGraphic(cfg.state[key](item, isSelected, index, allItems)) : isEmpty_default(cfg.state[key]) || (newStateStyle[key] = transformToGraphic(cfg.state[key]));
    }), newConfig.state = newStateStyle;
  }
  return newConfig;
}
function transformStateStyle(stateStyle) {
  if (isEmpty_default(stateStyle))
    return null;
  const newStateStyle = {};
  return Object.keys(stateStyle).forEach((key) => {
    isFunction_default(stateStyle[key]) ? newStateStyle[key] = (value, index, datum, data) => transformToGraphic(stateStyle[key](value, index, datum, data)) : isEmpty_default(stateStyle[key]) || (newStateStyle[key] = transformToGraphic(stateStyle[key]));
  }), newStateStyle;
}
function transformAxisLabelStateStyle(stateStyle) {
  if (isEmpty_default(stateStyle))
    return null;
  const newStateStyle = {};
  return Object.keys(stateStyle).forEach((key) => {
    isFunction_default(stateStyle[key]) ? newStateStyle[key] = (datum, index, data, layer) => transformToGraphic(stateStyle[key](datum.rawValue, index, datum, data, layer)) : isEmpty_default(stateStyle[key]) || (newStateStyle[key] = transformToGraphic(stateStyle[key]));
  }), newStateStyle;
}
function transformToGraphic(style) {
  return (null == style ? void 0 : style.angle) && (style.angle = degreeToRadian(style.angle)), style;
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/core/factory
var Factory2 = class _Factory {
  static registerChart(key, chart) {
    _Factory._charts[key] = chart;
  }
  static registerSeries(key, series2) {
    _Factory._series[key] = series2;
  }
  static registerComponent(key, cmp, alwaysCheck) {
    _Factory._components[key] = {
      cmp,
      alwaysCheck
    };
  }
  static registerMark(key, mark) {
    _Factory._marks[key] = mark;
  }
  static registerRegion(key, region) {
    _Factory._regions[key] = region;
  }
  static registerTransform(key, transform5) {
    _Factory.transforms[key] = transform5;
  }
  static registerLayout(key, layout) {
    _Factory._layout[key] = layout;
  }
  static registerAnimation(key, animation) {
    _Factory._animations[key] = animation;
  }
  static registerImplement(key, implement) {
    _Factory._implements[key] = implement;
  }
  static registerChartPlugin(key, plugin) {
    _Factory._chartPlugin[key] = plugin;
  }
  static registerComponentPlugin(key, plugin) {
    _Factory._componentPlugin[key] = plugin;
  }
  static createChart(chartType, spec, options) {
    if (!_Factory._charts[chartType])
      return null;
    return new (0, _Factory._charts[chartType])(spec, options);
  }
  static createChartSpecTransformer(chartType, option) {
    if (!_Factory._charts[chartType])
      return null;
    const ChartConstructor = _Factory._charts[chartType];
    return new (0, ChartConstructor.transformerConstructor)(Object.assign({
      seriesType: ChartConstructor.seriesType
    }, option));
  }
  static createRegion(regionType, spec, options) {
    if (!_Factory._regions[regionType])
      return null;
    return new (0, _Factory._regions[regionType])(spec, options);
  }
  static createRegionSpecTransformer(regionType, options) {
    if (!_Factory._regions[regionType])
      return null;
    return new (0, _Factory._regions[regionType].transformerConstructor)(options);
  }
  static createSeries(seriesType, spec, options) {
    if (!_Factory._series[seriesType])
      return null;
    return new (0, _Factory._series[seriesType])(spec, options);
  }
  static createSeriesSpecTransformer(seriesType, options) {
    if (!_Factory._series[seriesType])
      return null;
    return new (0, _Factory._series[seriesType].transformerConstructor)(options);
  }
  static createMark(markType, name, options) {
    if (!_Factory._marks[markType])
      return null;
    const markInstance = new (0, _Factory._marks[markType])(name, options);
    return "group" === markInstance.type && markInstance.setInteractive(false), markInstance;
  }
  static getComponents() {
    return Object.values(_Factory._components);
  }
  static getComponentInKey(name) {
    return _Factory._components[name].cmp;
  }
  static getLayout() {
    return Object.values(_Factory._layout);
  }
  static getLayoutInKey(name) {
    return _Factory._layout[name];
  }
  static getSeries() {
    return Object.values(_Factory._series);
  }
  static getSeriesInType(type) {
    return _Factory._series[type];
  }
  static getRegionInType(type) {
    return _Factory._regions[type];
  }
  static getAnimationInKey(key) {
    return _Factory._animations[key];
  }
  static getImplementInKey(key) {
    return _Factory._implements[key];
  }
  static getSeriesMarkMap(seriesType) {
    return _Factory._series[seriesType] ? _Factory._series[seriesType].mark : {};
  }
  static getChartPlugins() {
    return Object.values(_Factory._chartPlugin);
  }
  static getComponentPlugins() {
    return Object.values(_Factory._componentPlugin);
  }
  static getComponentPluginInType(type) {
    return _Factory._componentPlugin[type];
  }
  static registerFormatter(func) {
    this._formatter = func;
  }
  static getFormatter() {
    return this._formatter;
  }
};
Factory2._charts = {}, Factory2._series = {}, Factory2._components = {}, Factory2._marks = {}, Factory2._regions = {}, Factory2._animations = {}, Factory2._implements = {}, Factory2._chartPlugin = {}, Factory2._componentPlugin = {}, Factory2.transforms = {
  fields,
  filter,
  fold
}, Factory2.dataParser = {
  csv: csvParser,
  dsv: dsvParser,
  tsv: tsvParser
}, Factory2._layout = {};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/event/events/dimension/util/common
var isInBound = (pos, min3, max3) => pos.x >= min3.x && pos.x <= max3.x && pos.y >= min3.y && pos.y <= max3.y;
var isInRegionBound = (chart, axis2, pos) => {
  const regionList = chart.getRegionsInIds(array(axis2.layout.layoutBindRegionID));
  return null == regionList ? void 0 : regionList.some((region) => {
    const rect = region.getLayoutRect(), startPoint = region.getLayoutStartPoint();
    return isInBound(pos, {
      x: startPoint.x,
      y: startPoint.y
    }, {
      x: rect.width + startPoint.x,
      y: rect.height + startPoint.y
    });
  });
};
var isSameDimensionInfo = (a3, b) => {
  var _a, _b;
  return a3 === b || !isNil_default(a3) && !isNil_default(b) && (a3.value === b.value && (null === (_a = a3.axis) || void 0 === _a ? void 0 : _a.id) === (null === (_b = b.axis) || void 0 === _b ? void 0 : _b.id));
};
var getDimensionData = (value, axis2, coordinate, getDimensionField) => {
  var _a;
  const scale4 = axis2.getScale(), isDiscreteAxis2 = isDiscrete(scale4.type), data = [], seriesList = axis2.getOption().getChart().getSeriesInIndex(axis2.getSpecInfo().seriesIndexes);
  for (const series2 of seriesList)
    if (series2.coordinate === coordinate) {
      const dimensionField = array(getDimensionField(series2)), viewData = null === (_a = series2.getViewData()) || void 0 === _a ? void 0 : _a.latestData;
      if (dimensionField && viewData)
        if (isDiscreteAxis2) {
          const datums = [], datumIdList = [];
          viewData.forEach((datum, i) => {
            var _a2;
            (null === (_a2 = datum[dimensionField[0]]) || void 0 === _a2 ? void 0 : _a2.toString()) === (null == value ? void 0 : value.toString()) && (datums.push(datum), datumIdList.push(i));
          }), data.push({
            series: series2,
            datum: datums,
            key: getDimensionDataKey(series2, datumIdList)
          });
        } else if (isValid_default(dimensionField[1])) {
          const datums = [], datumIdList = [];
          viewData.forEach((datum, i) => {
            var _a2;
            ((null === (_a2 = datum[dimensionField[0]]) || void 0 === _a2 ? void 0 : _a2.toString()) === (null == value ? void 0 : value.toString()) || isValid_default(datum[dimensionField[0]]) && isValid_default(datum[dimensionField[1]]) && value >= datum[dimensionField[0]] && value < datum[dimensionField[1]]) && (datums.push(datum), datumIdList.push(i));
          }), data.push({
            series: series2,
            datum: datums,
            key: getDimensionDataKey(series2, datumIdList)
          });
        } else {
          const range2 = axis2.getSpec().tooltipFilterRange, rangeArr = isValidNumber_default(range2) ? [-range2, range2] : range2;
          let datums = [], datumIdList = [];
          if (rangeArr)
            viewData.forEach((datum, i) => {
              if (isValid_default(datum[dimensionField[0]])) {
                const delta = datum[dimensionField[0]] - value;
                delta >= rangeArr[0] && delta <= rangeArr[1] && (datums.push(datum), datumIdList.push(i));
              }
            });
          else {
            let minDelta = 1 / 0, deltaSign = 0;
            viewData.forEach((datum, i) => {
              if (isValid_default(datum[dimensionField[0]])) {
                const delta = Math.abs(datum[dimensionField[0]] - value), sign3 = Math.sign(datum[dimensionField[0]] - value);
                delta < minDelta ? (minDelta = delta, datums = [datum], datumIdList = [i], deltaSign = sign3) : delta === minDelta && sign3 === deltaSign && (datums.push(datum), datumIdList.push(i));
              }
            });
          }
          data.push({
            series: series2,
            datum: datums,
            key: getDimensionDataKey(series2, datumIdList)
          });
        }
    }
  return data;
};
var getDimensionDataKey = (series2, datumIdList) => `${series2.id}_${datumIdList.join("_")}`;
var getAxis = (chart, filter2, pos) => {
  const axesComponents = chart.getAllComponents().filter((c3) => "axes" === c3.specKey && filter2(c3) && isInRegionBound(chart, c3, pos));
  return axesComponents.length ? axesComponents : null;
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/event/events/dimension/util/polar
var angleStandardize = (angle2, range2) => {
  const unit = 2 * Math.PI, min3 = minInArray(range2), max3 = maxInArray(range2);
  return angle2 < min3 ? angle2 += Math.ceil((min3 - angle2) / unit) * unit : angle2 > max3 && (angle2 -= Math.ceil((angle2 - max3) / unit) * unit), angle2;
};
var getPolarDimensionInfo = (chart, pos) => {
  if (!chart)
    return null;
  if (!getFirstSeries(chart.getRegionsInIndex(), "polar"))
    return null;
  const { x, y } = pos, angleAxisList = getAxis(chart, (cmp) => "angle" === cmp.getOrient(), pos), radiusAxisList = getAxis(chart, (cmp) => "radius" === cmp.getOrient(), pos), targetAxisInfo = [], getDimensionField = (series2) => series2.getDimensionField()[0];
  return angleAxisList && angleAxisList.forEach((axis2) => {
    var _a;
    const angleScale = axis2.getScale();
    if (angleScale && isDiscrete(angleScale.type)) {
      const angleDomain = angleScale.domain(), angleRange = angleScale.range(), center2 = axis2.getCenter(), vector = {
        x: x - axis2.getLayoutStartPoint().x - center2.x,
        y: y - axis2.getLayoutStartPoint().y - center2.y
      };
      let angle2 = vectorAngle({
        x: 1,
        y: 0
      }, vector);
      angle2 = angleStandardize(angle2, angleRange);
      const radius = distance(vector), radiusScale = null === (_a = radiusAxisList[0]) || void 0 === _a ? void 0 : _a.getScale(), radiusRange = null == radiusScale ? void 0 : radiusScale.range();
      if ((angle2 - (null == angleRange ? void 0 : angleRange[0])) * (angle2 - (null == angleRange ? void 0 : angleRange[1])) > 0 || (radius - (null == radiusRange ? void 0 : radiusRange[0])) * (radius - (null == radiusRange ? void 0 : radiusRange[1])) > 0)
        return;
      const value = axis2.invert(angle2);
      if (isNil_default(value))
        return;
      let index = angleDomain.findIndex((v) => (null == v ? void 0 : v.toString()) === value.toString());
      index < 0 && (index = void 0);
      const data = getDimensionData(value, axis2, "polar", getDimensionField);
      targetAxisInfo.push({
        index,
        value,
        position: angleScale.scale(value),
        axis: axis2,
        data
      });
    }
  }), radiusAxisList && radiusAxisList.forEach((axis2) => {
    var _a;
    const radiusScale = axis2.getScale(), radiusRange = null == radiusScale ? void 0 : radiusScale.range();
    if (radiusScale && isDiscrete(radiusScale.type)) {
      const center2 = axis2.getCenter(), vector = {
        x: x - axis2.getLayoutStartPoint().x - center2.x,
        y: y - axis2.getLayoutStartPoint().y - center2.y
      };
      let angle2 = vectorAngle({
        x: 1,
        y: 0
      }, vector);
      angle2 < -Math.PI / 2 && (angle2 = 2 * Math.PI + angle2);
      const radius = distance(vector), angleScale = null === (_a = angleAxisList[0]) || void 0 === _a ? void 0 : _a.getScale(), angleRange = null == angleScale ? void 0 : angleScale.range();
      if ((angle2 - (null == angleRange ? void 0 : angleRange[0])) * (angle2 - (null == angleRange ? void 0 : angleRange[1])) > 0 || (radius - (null == radiusRange ? void 0 : radiusRange[0])) * (radius - (null == radiusRange ? void 0 : radiusRange[1])) > 0)
        return;
      const value = radiusScale.invert(radius);
      if (isNil_default(value))
        return;
      let index = radiusScale.domain().findIndex((v) => (null == v ? void 0 : v.toString()) === value.toString());
      index < 0 && (index = void 0);
      const data = getDimensionData(value, axis2, "polar", getDimensionField);
      targetAxisInfo.push({
        index,
        value,
        position: radiusScale.scale(value),
        axis: axis2,
        data
      });
    }
  }), targetAxisInfo.length ? targetAxisInfo : null;
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/axis/cartesian/util/common
function isXAxis(orient) {
  return "bottom" === orient || "top" === orient;
}
function isYAxis(orient) {
  return "left" === orient || "right" === orient;
}
function isZAxis(orient) {
  return "z" === orient;
}
function autoAxisType(orient, isHorizontal3) {
  return isHorizontal3 ? isXAxis(orient) ? "linear" : "band" : isXAxis(orient) ? "band" : "linear";
}
function getOrient(spec, whiteList) {
  return isValidOrient(spec.orient) || whiteList && whiteList.includes(spec.orient) ? spec.orient : "left";
}
function getDirectionByOrient(orient) {
  return "top" === orient || "bottom" === orient ? "horizontal" : "vertical";
}
function transformInverse(spec, isHorizontal3) {
  let inverse = spec.inverse;
  return isHorizontal3 && !isXAxis(spec.orient) && (inverse = !isValid_default(spec.inverse) || !spec.inverse), inverse;
}
function getCartesianAxisInfo(spec, isHorizontal3) {
  var _a;
  const axisType = null !== (_a = spec.type) && void 0 !== _a ? _a : autoAxisType(spec.orient, isHorizontal3);
  return {
    axisType,
    componentName: `${ComponentTypeEnum.cartesianAxis}-${axisType}`
  };
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/event/events/dimension/util/cartesian
var discreteXAxisGetDimensionField = (series2) => series2.fieldX[0];
var discreteYAxisGetDimensionField = (series2) => series2.fieldY[0];
var continuousXAxisGetDimensionField = (series2) => {
  var _a;
  return [series2.fieldX[0], null !== (_a = series2.fieldX2) && void 0 !== _a ? _a : series2.fieldX[1]];
};
var continuousYAxisGetDimensionField = (series2) => {
  var _a;
  return [series2.fieldY[0], null !== (_a = series2.fieldY2) && void 0 !== _a ? _a : series2.fieldY[1]];
};
var getDimensionFieldFunc = (isXAxis2, isDiscreteAxis2) => isXAxis2 ? isDiscreteAxis2 ? discreteXAxisGetDimensionField : continuousXAxisGetDimensionField : isDiscreteAxis2 ? discreteYAxisGetDimensionField : continuousYAxisGetDimensionField;
var getCartesianDimensionInfo = (chart, pos, isTooltip) => {
  var _a, _b;
  if (!chart)
    return null;
  if (!getFirstSeries(chart.getRegionsInIndex(), "cartesian"))
    return null;
  const { x, y } = pos, xAxisList = null !== (_a = getAxis(chart, (cmp) => isXAxis(cmp.getOrient()), pos)) && void 0 !== _a ? _a : [], yAxisList = null !== (_b = getAxis(chart, (cmp) => isYAxis(cmp.getOrient()), pos)) && void 0 !== _b ? _b : [], bandAxisSet = /* @__PURE__ */ new Set(), linearAxisSet = /* @__PURE__ */ new Set(), forceAxisSet = /* @__PURE__ */ new Set();
  [xAxisList, yAxisList].forEach((axisList) => axisList.forEach((axis2) => {
    isDiscrete(axis2.getScale().type) ? bandAxisSet.add(axis2) : linearAxisSet.add(axis2), isTooltip && axis2.getSpec().hasDimensionTooltip && forceAxisSet.add(axis2);
  }));
  const targetAxisInfo = [], addAxisDimensionInfo = (orient) => {
    const isXAxis2 = "x" === orient, posValue = isXAxis2 ? x : y;
    (isXAxis2 ? xAxisList : yAxisList).forEach((axis2) => {
      if (forceAxisSet.size > 0) {
        if (forceAxisSet.has(axis2)) {
          const info = getDimensionInfoByPosition(axis2, posValue, orient, getDimensionFieldFunc(isXAxis2, isDiscrete(axis2.getScale().type)));
          info && targetAxisInfo.push(info);
        }
      } else {
        const hasDiscreteAxis = bandAxisSet.size > 0;
        if ((hasDiscreteAxis ? bandAxisSet : linearAxisSet).has(axis2)) {
          const info = getDimensionInfoByPosition(axis2, posValue, orient, getDimensionFieldFunc(isXAxis2, hasDiscreteAxis));
          info && targetAxisInfo.push(info);
        }
      }
    });
  };
  return "horizontal" === chart.getSpec().direction ? (addAxisDimensionInfo("y"), 0 === targetAxisInfo.length && addAxisDimensionInfo("x")) : (addAxisDimensionInfo("x"), 0 === targetAxisInfo.length && addAxisDimensionInfo("y")), targetAxisInfo.length ? targetAxisInfo : null;
};
var getDimensionInfoByPosition = (axis2, posValue, posKey, getDimensionField) => {
  const scale4 = axis2.getScale(), scalePos = posValue - axis2.getLayoutStartPoint()[posKey];
  if ((scalePos - scale4.range()[0]) * (scalePos - scale4.range()[1]) > 0)
    return null;
  const value = scale4.invert(scalePos);
  return getDimensionInfoByValue(axis2, value, getDimensionField);
};
var getDimensionInfoByValue = (axis2, value, getDimensionField) => {
  const scale4 = axis2.getScale();
  if (isNil_default(value))
    return null;
  let index = scale4.domain().findIndex((v) => (null == v ? void 0 : v.toString()) === value.toString());
  index < 0 && (index = void 0);
  const data = getDimensionData(value, axis2, "cartesian", null != getDimensionField ? getDimensionField : isXAxis(axis2.getOrient()) ? discreteXAxisGetDimensionField : discreteYAxisGetDimensionField);
  return {
    index,
    value,
    position: scale4.scale(value),
    axis: axis2,
    data
  };
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/event/events/dimension/base
var DimensionEvent = class {
  constructor(eventDispatcher, mode) {
    this._eventDispatcher = eventDispatcher, this._mode = mode;
  }
  get chart() {
    var _a, _b;
    return this._chart || (this._chart = null === (_b = (_a = this._eventDispatcher.globalInstance).getChart) || void 0 === _b ? void 0 : _b.call(_a)), this._chart;
  }
  register(eType, handler) {
    var _a, _b;
    (null !== (_b = null === (_a = this.chart) || void 0 === _a ? void 0 : _a.getOption().onError) && void 0 !== _b ? _b : error)("Method not implemented.");
  }
  unregister() {
    var _a, _b;
    (null !== (_b = null === (_a = this.chart) || void 0 === _a ? void 0 : _a.getOption().onError) && void 0 !== _b ? _b : error)("Method not implemented.");
  }
  getTargetDimensionInfo(x, y) {
    var _a, _b;
    const cartesianInfo = null !== (_a = getCartesianDimensionInfo(this.chart, {
      x,
      y
    })) && void 0 !== _a ? _a : [], polarInfo = null !== (_b = getPolarDimensionInfo(this.chart, {
      x,
      y
    })) && void 0 !== _b ? _b : [], result2 = [].concat(cartesianInfo, polarInfo);
    return 0 === result2.length ? null : result2;
  }
  dispatch(v, opt) {
    var _a;
    const axes = null === (_a = this.chart) || void 0 === _a ? void 0 : _a.getAllComponents().filter((c3) => "axes" === c3.specKey && (!(null == opt ? void 0 : opt.filter) || opt.filter(c3))), discreteAxes = axes.filter((axis2) => {
      const scale4 = axis2.getScale();
      return isDiscrete(scale4.type);
    }), dimAxes = discreteAxes.length ? discreteAxes : axes.filter((axis2) => {
      const orient = axis2.getOrient();
      return isXAxis(orient) || "angle" === orient;
    }), dimensionInfo = [];
    return dimAxes.forEach((a3) => {
      const info = getDimensionInfoByValue(a3, v);
      info && dimensionInfo.push(info);
    }), this._callback.call(null, {
      action: "enter",
      dimensionInfo
    }), dimensionInfo;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/event/events/dimension/dimension-click
var DimensionClickEvent = class extends DimensionEvent {
  constructor() {
    super(...arguments), this.onClick = (params2) => {
      if (!params2)
        return;
      const x = params2.event.viewX, y = params2.event.viewY, targetDimensionInfo = this.getTargetDimensionInfo(x, y);
      targetDimensionInfo && this._callback.call(null, Object.assign(Object.assign({}, params2), {
        action: "click",
        dimensionInfo: targetDimensionInfo.slice()
      }));
    };
  }
  register(eType, handler) {
    this._callback = handler.callback, this._eventDispatcher.register("pointertap", {
      query: Object.assign(Object.assign({}, handler.query), {
        source: Event_Source_Type.chart
      }),
      callback: this.onClick
    });
  }
  unregister() {
    this._eventDispatcher.unregister("pointertap", {
      query: null,
      callback: this.onClick
    });
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/event/events/dimension/dimension-hover
var DimensionHoverEvent = class extends DimensionEvent {
  constructor() {
    super(...arguments), this._cacheDimensionInfo = null, this.onMouseMove = (params2) => {
      if (!params2)
        return;
      const x = params2.event.viewX, y = params2.event.viewY, targetDimensionInfo = this.getTargetDimensionInfo(x, y);
      null === targetDimensionInfo && null !== this._cacheDimensionInfo ? (this._callback.call(null, Object.assign(Object.assign({}, params2), {
        action: "leave",
        dimensionInfo: this._cacheDimensionInfo.slice()
      })), this._cacheDimensionInfo = targetDimensionInfo) : null === targetDimensionInfo || null !== this._cacheDimensionInfo && targetDimensionInfo.length === this._cacheDimensionInfo.length && !targetDimensionInfo.some((info, i) => !isSameDimensionInfo(info, this._cacheDimensionInfo[i])) ? null !== targetDimensionInfo && this._callback.call(null, Object.assign(Object.assign({}, params2), {
        action: "move",
        dimensionInfo: targetDimensionInfo.slice()
      })) : (this._callback.call(null, Object.assign(Object.assign({}, params2), {
        action: "enter",
        dimensionInfo: targetDimensionInfo.slice()
      })), this._cacheDimensionInfo = targetDimensionInfo);
    }, this.onMouseOut = (params2) => {
      params2 && (this._callback.call(null, Object.assign(Object.assign({}, params2), {
        action: "leave",
        dimensionInfo: this._cacheDimensionInfo ? this._cacheDimensionInfo.slice() : []
      })), this._cacheDimensionInfo = null);
    };
  }
  register(eType, handler) {
    this._callback = handler.callback, this._eventDispatcher.register("pointermove", {
      query: Object.assign(Object.assign({}, handler.query), {
        source: Event_Source_Type.chart
      }),
      callback: this.onMouseMove
    }), this._eventDispatcher.register("pointerout", {
      query: Object.assign(Object.assign({}, handler.query), {
        source: Event_Source_Type.canvas
      }),
      callback: this.onMouseOut
    }), isMobileLikeMode(this._mode) && this._eventDispatcher.register("pointerdown", {
      query: Object.assign(Object.assign({}, handler.query), {
        source: Event_Source_Type.chart
      }),
      callback: this.onMouseMove
    });
  }
  unregister() {
    this._eventDispatcher.unregister("pointermove", {
      query: null,
      callback: this.onMouseMove
    }), isMobileLikeMode(this._mode) && this._eventDispatcher.unregister("pointerdown", {
      query: null,
      callback: this.onMouseMove
    });
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/event/events/dimension/interface
var DimensionEventEnum;
!function(DimensionEventEnum2) {
  DimensionEventEnum2.dimensionHover = "dimensionHover", DimensionEventEnum2.dimensionClick = "dimensionClick";
}(DimensionEventEnum || (DimensionEventEnum = {}));

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/event/events
var ComposedEventMapper = {
  [DimensionEventEnum.dimensionHover]: DimensionHoverEvent,
  [DimensionEventEnum.dimensionClick]: DimensionClickEvent
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/event/event
var Event2 = class {
  getComposedEventMap() {
    return this._composedEventMap;
  }
  constructor(eventDispatcher, mode) {
    this._composedEventMap = /* @__PURE__ */ new Map(), this._eventDispatcher = eventDispatcher, this._mode = mode;
  }
  on(eType, query, callback) {
    const handler = "function" == typeof query ? {
      query: null,
      callback: query
    } : {
      query,
      callback
    };
    if (ComposedEventMapper[eType]) {
      const composedEvent = new ComposedEventMapper[eType](this._eventDispatcher, this._mode);
      composedEvent.register(eType, handler), this._composedEventMap.set(callback, {
        eventType: eType,
        event: composedEvent
      });
    } else
      this._eventDispatcher.register(eType, handler);
    return this;
  }
  off(eType, query, cb) {
    var _a, _b;
    const callback = null != cb ? cb : query;
    if (ComposedEventMapper[eType])
      if (callback)
        null === (_a = this._composedEventMap.get(callback)) || void 0 === _a || _a.event.unregister(), this._composedEventMap.delete(callback);
      else
        for (const entry of this._composedEventMap.entries())
          entry[1].eventType === eType && (null === (_b = this._composedEventMap.get(entry[0])) || void 0 === _b || _b.event.unregister(), this._composedEventMap.delete(entry[0]));
    else if (callback) {
      const handler = {
        callback,
        query: null,
        filter: {
          nodeName: null,
          type: eType,
          level: null,
          source: query.source,
          markName: null,
          filter: null,
          userId: null
        }
      };
      this._eventDispatcher.unregister(eType, handler);
    } else
      this._eventDispatcher.unregister(eType);
    return this;
  }
  emit(eType, params2, level) {
    return this._eventDispatcher.dispatch(eType, params2, level), this;
  }
  release() {
    this._eventDispatcher.clear(), this._composedEventMap.clear();
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/event/bubble
var Bubble = class {
  constructor() {
    this._map = /* @__PURE__ */ new Map(), this._levelNodes = /* @__PURE__ */ new Map(), this._levelNodes.set(Event_Bubble_Level.vchart, []), this._levelNodes.set(Event_Bubble_Level.chart, []), this._levelNodes.set(Event_Bubble_Level.model, []), this._levelNodes.set(Event_Bubble_Level.mark, []);
  }
  addHandler(handler, level) {
    var _a;
    const node = {
      level,
      handler
    };
    return null === (_a = this._levelNodes.get(level)) || void 0 === _a || _a.push(node), this._map.set(handler.callback, node), this;
  }
  removeHandler(handler) {
    const node = this._map.get(handler.callback);
    if (!node)
      return this;
    this._map.delete(handler.callback);
    const nodes = this._levelNodes.get(node.level), index = null == nodes ? void 0 : nodes.findIndex((n) => n.handler.callback === handler.callback);
    return void 0 !== index && index >= 0 && (null == nodes || nodes.splice(index, 1)), this;
  }
  getHandlers(level) {
    var _a;
    return (null === (_a = this._levelNodes.get(level)) || void 0 === _a ? void 0 : _a.map((node) => node.handler)) || [];
  }
  getCount() {
    return this._map.size;
  }
  release() {
    this._map.clear(), this._levelNodes.clear();
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/event/event-dispatcher
var componentTypeMap = {
  cartesianAxis: "axis",
  "cartesianAxis-band": "axis",
  "cartesianAxis-linear": "axis",
  "cartesianAxis-time": "axis",
  polarAxis: "axis",
  "polarAxis-band": "axis",
  "polarAxis-linear": "axis",
  discreteLegend: "legend",
  continuousLegend: "legend",
  colorLegend: "legend",
  sizeLegend: "legend",
  label: "label",
  markLine: "markLine",
  markArea: "markArea",
  markPoint: "markPoint",
  polarMarkLine: "polarMarkLine",
  polarMarkArea: "polarMarkArea",
  polarMarkPoint: "polarMarkPoint",
  geoMarkPoint: "geoMarkPoint"
};
var EventDispatcher = class {
  constructor(vchart, compiler) {
    this._viewBubbles = /* @__PURE__ */ new Map(), this._windowBubbles = /* @__PURE__ */ new Map(), this._canvasBubbles = /* @__PURE__ */ new Map(), this._viewListeners = /* @__PURE__ */ new Map(), this._windowListeners = /* @__PURE__ */ new Map(), this._canvasListeners = /* @__PURE__ */ new Map(), this._onDelegate = (listenerParams) => {
      var _a;
      const chart = this.globalInstance.getChart(), model = isValid_default(listenerParams.modelId) && (null == chart ? void 0 : chart.getModelById(listenerParams.modelId)) || void 0, mark = isValid_default(listenerParams.markId) && (null == chart ? void 0 : chart.getMarkById(listenerParams.markId)) || null, itemMap = /* @__PURE__ */ new Map();
      let targetMark = null === (_a = listenerParams.item) || void 0 === _a ? void 0 : _a.mark;
      for (targetMark && isValid_default(targetMark.id()) && itemMap.set(targetMark.id(), listenerParams.item); null == targetMark ? void 0 : targetMark.elements; ) {
        const id2 = targetMark.id();
        isValid_default(id2) && !itemMap.has(id2) && itemMap.set(id2, targetMark.elements[0]), targetMark = targetMark.group;
      }
      const params2 = {
        event: listenerParams.event,
        item: listenerParams.item,
        datum: listenerParams.datum,
        source: listenerParams.source,
        itemMap,
        chart,
        model,
        mark: null != mark ? mark : void 0,
        node: get_default(listenerParams.event, "target")
      };
      this.dispatch(listenerParams.type, params2);
    }, this._onDelegateInteractionEvent = (listenerParams) => {
      const chart = this.globalInstance.getChart(), event = listenerParams.event;
      let items = null;
      event.elements && (items = event.elements);
      const params2 = {
        event: listenerParams.event,
        chart,
        items,
        datums: items && items.map((item) => item.getDatum())
      };
      this.dispatch(listenerParams.type, params2);
    }, this.globalInstance = vchart, this._compiler = compiler;
  }
  register(eType, handler) {
    var _a, _b, _c, _d, _e;
    this._parseQuery(handler);
    const bubbles = this.getEventBubble((null === (_a = handler.filter) || void 0 === _a ? void 0 : _a.source) || Event_Source_Type.chart), listeners = this.getEventListeners((null === (_b = handler.filter) || void 0 === _b ? void 0 : _b.source) || Event_Source_Type.chart);
    bubbles.get(eType) || bubbles.set(eType, new Bubble());
    if (bubbles.get(eType).addHandler(handler, null === (_c = handler.filter) || void 0 === _c ? void 0 : _c.level), this._isValidEvent(eType) && !listeners.has(eType)) {
      const callback = this._onDelegate.bind(this);
      this._compiler.addEventListener(null === (_d = handler.filter) || void 0 === _d ? void 0 : _d.source, eType, callback), listeners.set(eType, callback);
    } else if (this._isInteractionEvent(eType) && !listeners.has(eType)) {
      const callback = this._onDelegateInteractionEvent.bind(this);
      this._compiler.addEventListener(null === (_e = handler.filter) || void 0 === _e ? void 0 : _e.source, eType, callback), listeners.set(eType, callback);
    }
    return this;
  }
  unregister(eType, handler) {
    var _a, _b, _c, _d;
    let clean = false;
    const bubbles = this.getEventBubble((null === (_a = null == handler ? void 0 : handler.filter) || void 0 === _a ? void 0 : _a.source) || Event_Source_Type.chart), listeners = this.getEventListeners((null === (_b = null == handler ? void 0 : handler.filter) || void 0 === _b ? void 0 : _b.source) || Event_Source_Type.chart);
    if (handler) {
      const bubble = bubbles.get(eType);
      null == bubble || bubble.removeHandler(handler), 0 === (null == bubble ? void 0 : bubble.getCount()) && (null == bubble || bubble.release(), bubbles.delete(eType), clean = true), (null === (_c = null == handler ? void 0 : handler.wrappedCallback) || void 0 === _c ? void 0 : _c.cancel) && handler.wrappedCallback.cancel();
    } else {
      const bubble = bubbles.get(eType);
      null == bubble || bubble.release(), bubbles.delete(eType), clean = true;
    }
    if (clean && this._isValidEvent(eType)) {
      const callback = listeners.get(eType);
      this._compiler.removeEventListener((null === (_d = null == handler ? void 0 : handler.filter) || void 0 === _d ? void 0 : _d.source) || Event_Source_Type.chart, eType, callback), listeners.delete(eType);
    }
    return this;
  }
  dispatch(eType, params2, level) {
    const bubble = this.getEventBubble(params2.source || Event_Source_Type.chart).get(eType);
    if (!bubble)
      return this;
    let stopBubble = false;
    if (level) {
      const handlers = bubble.getHandlers(level);
      stopBubble = this._invoke(handlers, eType, params2);
    } else {
      const handlers = bubble.getHandlers(Event_Bubble_Level.mark);
      if (stopBubble = this._invoke(handlers, eType, params2), !stopBubble) {
        const handlers2 = bubble.getHandlers(Event_Bubble_Level.model);
        stopBubble = this._invoke(handlers2, eType, params2);
      }
      if (!stopBubble) {
        const handlers2 = bubble.getHandlers(Event_Bubble_Level.chart);
        stopBubble = this._invoke(handlers2, eType, params2);
      }
      if (!stopBubble) {
        const handlers2 = bubble.getHandlers(Event_Bubble_Level.vchart);
        stopBubble = this._invoke(handlers2, eType, params2);
      }
    }
    return this;
  }
  clear() {
    for (const entry of this._viewListeners.entries())
      this._compiler.removeEventListener(Event_Source_Type.chart, entry[0], entry[1]);
    this._viewListeners.clear();
    for (const entry of this._windowListeners.entries())
      this._compiler.removeEventListener(Event_Source_Type.window, entry[0], entry[1]);
    this._windowListeners.clear();
    for (const entry of this._canvasListeners.entries())
      this._compiler.removeEventListener(Event_Source_Type.canvas, entry[0], entry[1]);
    this._canvasListeners.clear();
    for (const bubble of this._viewBubbles.values())
      bubble.release();
    this._viewBubbles.clear();
    for (const bubble of this._windowBubbles.values())
      bubble.release();
    this._windowBubbles.clear();
    for (const bubble of this._canvasBubbles.values())
      bubble.release();
    this._canvasBubbles.clear();
  }
  release() {
    this.clear(), this.globalInstance = null, this._compiler = null;
  }
  _filter(filter2, evt, params2) {
    var _a, _b, _c;
    if (isFunction_default(filter2.filter) && !filter2.filter(params2))
      return false;
    if (filter2.nodeName && get_default(params2, "node.name") !== filter2.nodeName)
      return false;
    if (filter2.markName && (null === (_a = null == params2 ? void 0 : params2.mark) || void 0 === _a ? void 0 : _a.name) !== filter2.markName)
      return false;
    let modelType = null === (_b = params2.model) || void 0 === _b ? void 0 : _b.type;
    return componentTypeMap[modelType] && (modelType = componentTypeMap[modelType]), (!filter2.type || modelType === filter2.type) && (!("mark" === filter2.level && !filter2.type && !(null == params2 ? void 0 : params2.mark)) && (!("model" === filter2.level && !filter2.type && !(null == params2 ? void 0 : params2.model)) && (!isValid_default(filter2.userId) || (null === (_c = params2.model) || void 0 === _c ? void 0 : _c.userId) === filter2.userId)));
  }
  _prepareParams(filter2, params2) {
    if (filter2.markName && params2.mark && params2.itemMap) {
      const markId = params2.mark.getProductId(), item = params2.itemMap.get(markId), datum = null == item ? void 0 : item.getDatum();
      return Object.assign(Object.assign({}, params2), {
        item,
        datum
      });
    }
    return Object.assign({}, params2);
  }
  _invoke(handlers, type, params2) {
    return handlers.map((handler) => {
      var _a, _b, _c;
      const filter2 = handler.filter;
      if (!handler.query || this._filter(filter2, type, params2)) {
        const stopBubble = (handler.wrappedCallback || handler.callback).call(null, this._prepareParams(filter2, params2)), doStopBubble = null != stopBubble ? stopBubble : null === (_a = handler.query) || void 0 === _a ? void 0 : _a.consume;
        return doStopBubble && (null === (_b = params2.event) || void 0 === _b || _b.stopPropagation(), null === (_c = params2.event) || void 0 === _c || _c.preventDefault()), !!doStopBubble;
      }
    }).some((r) => true === r);
  }
  _getQueryLevel(query) {
    return query ? query.level ? query.level : isValid_default(query.id) ? Event_Bubble_Level.model : Event_Bubble_Level.vchart : Event_Bubble_Level.vchart;
  }
  _parseQuery(handler) {
    var _a;
    const query = handler.query;
    (null == query ? void 0 : query.throttle) ? handler.wrappedCallback = throttle_default(handler.callback, query.throttle) : (null == query ? void 0 : query.debounce) && (handler.wrappedCallback = debounce_default(handler.callback, query.debounce));
    let level = this._getQueryLevel(query), type = null, source = Event_Source_Type.chart, nodeName = null, markName = null, userId = null;
    return (null == query ? void 0 : query.nodeName) && (nodeName = query.nodeName), (null == query ? void 0 : query.markName) && (markName = query.markName), !(null == query ? void 0 : query.type) || level !== Event_Bubble_Level.model && level !== Event_Bubble_Level.mark || (type = query.type), (null == query ? void 0 : query.source) && (source = query.source), isValid_default(null == query ? void 0 : query.id) && (userId = null == query ? void 0 : query.id, level = Event_Bubble_Level.model), handler.filter = {
      level,
      markName,
      type,
      source,
      nodeName,
      userId,
      filter: null !== (_a = null == query ? void 0 : query.filter) && void 0 !== _a ? _a : null
    }, handler;
  }
  getEventBubble(source) {
    switch (source) {
      case Event_Source_Type.chart:
        return this._viewBubbles;
      case Event_Source_Type.window:
        return this._windowBubbles;
      case Event_Source_Type.canvas:
        return this._canvasBubbles;
      default:
        return this._viewBubbles;
    }
  }
  getEventListeners(source) {
    switch (source) {
      case Event_Source_Type.chart:
        return this._viewListeners;
      case Event_Source_Type.window:
        return this._windowListeners;
      case Event_Source_Type.canvas:
        return this._canvasListeners;
      default:
        return this._viewListeners;
    }
  }
  _isValidEvent(eType) {
    return BASE_EVENTS.includes(eType) || Object.values(HOOK_EVENT).includes(eType);
  }
  _isInteractionEvent(eType) {
    let interactionType;
    return eType && (interactionType = eType.split(":")[0], interactionType) && Factory.hasInteraction(interactionType);
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/data/register
function registerDataSetInstanceTransform(dataSet, name, transform5) {
  dataSet.getTransform(name) || dataSet.registerTransform(name, transform5);
}
function registerDataSetInstanceParser(dataSet, name, parse2) {
  dataSet.getParser(name) || dataSet.registerParser(name, parse2);
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/map/geo-source
var geoSourceMap = /* @__PURE__ */ new Map();
function getMapSource(type) {
  return geoSourceMap.get(type);
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/data/transforms/copy-data-view
function copyOneDataView(d, deep = false) {
  let _deep = deep;
  return d.latestData instanceof DataView && (_deep = false), _deep ? cloneDeep(d.latestData) : d.latestData.slice();
}
var copyDataView = (data, options) => 0 === data.length ? [] : 1 === data.length ? copyOneDataView(data[0], null == options ? void 0 : options.deep) : data.map((d) => copyOneDataView(d, null == options ? void 0 : options.deep));

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/data/initialize
function dataViewFromDataView(rawData, dataSet, op) {
  dataSet = dataSet instanceof DataSet ? dataSet : rawData.dataSet, registerDataSetInstanceTransform(dataSet, "copyDataView", copyDataView);
  const viewData = new DataView(dataSet, op);
  return viewData.parse([rawData], {
    type: "dataview"
  }), viewData.transform({
    type: "copyDataView",
    level: TransformLevel.copyDataView
  }), viewData;
}
function dataToDataView(data, dataSet, sourceDataViews = [], ctx = {}) {
  var _a, _b, _c;
  if (data instanceof DataView)
    return data;
  const { id: id2, values = [], fromDataIndex, fromDataId, transforms = [] } = data, parser = data.parser ? cloneDeep(data.parser) : {
    clone: true
  }, fields2 = cloneDeep(data.fields);
  let dataView;
  parser.clone = !(false === parser.clone);
  const existDataView = sourceDataViews.find((dv) => dv.name === id2);
  if (existDataView)
    dataView = existDataView;
  else {
    const initOption = {
      name: id2
    };
    if (fields2 && (initOption.fields = fields2), dataView = new DataView(dataSet, initOption), "string" == typeof fromDataId) {
      const fromDataView = sourceDataViews.find((dv) => dv.name === fromDataId);
      if (!fromDataView)
        return (null !== (_a = ctx.onError) && void 0 !== _a ? _a : error)(`no data matches fromDataId ${fromDataId}`), null;
      dataView.parse([fromDataView], {
        type: "dataview"
      }), dataView.transform({
        type: "copyDataView"
      });
    } else if ("number" == typeof fromDataIndex) {
      const fromDataView = sourceDataViews[fromDataIndex];
      if (!fromDataView)
        return (null !== (_b = ctx.onError) && void 0 !== _b ? _b : error)(`no data matches fromDataIndex ${fromDataIndex}`), null;
      dataView.parse([fromDataView], {
        type: "dataview"
      }), dataView.transform({
        type: "copyDataView"
      });
    } else
      Array.isArray(values) ? dataView.parse(values, parser) : !isString_default(values) || parser && !["csv", "dsv", "tsv"].includes(parser.type) ? (dataView.parse([]), warn("values should be array")) : dataView.parse(values, null !== (_c = parser) && void 0 !== _c ? _c : {
        type: "csv"
      });
    transforms && transforms.length && transforms.forEach((transform5) => {
      dataSet.getTransform(transform5.type) && dataView.transform(transform5);
    });
  }
  return dataView;
}
function updateDataViewInData(dataView, data, forceMerge) {
  dataView && (data.fields && dataView.setFields(data.fields, forceMerge), dataView.parseNewData(data.values, data.parser));
}
var TransformLevel;
!function(TransformLevel2) {
  TransformLevel2[TransformLevel2.copyDataView = -10] = "copyDataView", TransformLevel2[TransformLevel2.treemapFilter = -8] = "treemapFilter", TransformLevel2[TransformLevel2.treemapFlatten = -7] = "treemapFlatten", TransformLevel2[TransformLevel2.dotObjFlat = -7] = "dotObjFlat", TransformLevel2[TransformLevel2.linkDotInfo = -7] = "linkDotInfo", TransformLevel2[TransformLevel2.sankeyLayout = -7] = "sankeyLayout", TransformLevel2[TransformLevel2.dataZoomFilter = -6] = "dataZoomFilter", TransformLevel2[TransformLevel2.legendFilter = -5] = "legendFilter";
}(TransformLevel || (TransformLevel = {}));

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/data/transforms/stack-split
var stackSplit = (data, op) => {
  const result2 = {
    nodes: {}
  }, { fields: fields2 } = op;
  if (!(null == fields2 ? void 0 : fields2.length))
    return result2;
  const lastFieldIndex = fields2.length - 1;
  let nextNode, leaf, temp3 = result2;
  return data.forEach((dv) => {
    dv.latestData.forEach((d) => {
      temp3 = result2;
      for (let i = 0; i < fields2.length; i++) {
        const fV = d[fields2[i]];
        if (isNil_default(fV))
          break;
        temp3.nodes[fV] || (i === lastFieldIndex ? temp3.nodes[fV] = {
          values: []
        } : (nextNode = {
          nodes: {}
        }, temp3.nodes[fV] = nextNode)), i === lastFieldIndex ? (leaf = temp3.nodes[fV], leaf.values.push(d)) : temp3 = temp3.nodes[fV];
      }
    });
  }), result2;
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/animation/interface
var AnimationStateEnum;
!function(AnimationStateEnum2) {
  AnimationStateEnum2.appear = "appear", AnimationStateEnum2.disappear = "disappear", AnimationStateEnum2.enter = "enter", AnimationStateEnum2.update = "update", AnimationStateEnum2.state = "state", AnimationStateEnum2.exit = "exit", AnimationStateEnum2.normal = "normal", AnimationStateEnum2.none = "none";
}(AnimationStateEnum || (AnimationStateEnum = {}));

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/compile/interface/compilable-item
var GrammarType;
!function(GrammarType2) {
  GrammarType2.data = "data", GrammarType2.signal = "signal", GrammarType2.mark = "mark";
}(GrammarType || (GrammarType = {}));

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/compile/util
function toRenderMode(mode) {
  switch (mode) {
    case RenderModeEnum["desktop-browser"]:
    case RenderModeEnum["mobile-browser"]:
      return "browser";
    case RenderModeEnum.node:
    case RenderModeEnum.worker:
      return "node";
    case RenderModeEnum.miniApp:
    case RenderModeEnum["desktop-miniApp"]:
      return "feishu";
    case RenderModeEnum.lynx:
      return "lynx";
    case RenderModeEnum.wx:
      return "wx";
    case RenderModeEnum.tt:
      return "tt";
    case RenderModeEnum.harmony:
      return "harmony";
  }
  return "browser";
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/compile/compiler
var Compiler = class {
  getVGrammarView() {
    return this._view;
  }
  getModel() {
    return this._model;
  }
  constructor(container2, option) {
    this._viewListeners = /* @__PURE__ */ new Map(), this._windowListeners = /* @__PURE__ */ new Map(), this._canvasListeners = /* @__PURE__ */ new Map(), this.isInited = false, this._isRunning = false, this._released = false, this._model = {
      [GrammarType.signal]: {},
      [GrammarType.data]: {},
      [GrammarType.mark]: {}
    }, this._compileChart = null, this.handleStageRender = () => {
      var _a, _b;
      null === (_b = null === (_a = this._compileChart) || void 0 === _a ? void 0 : _a.getEvent()) || void 0 === _b || _b.emit(ChartEvent.afterRender, {
        chart: this._compileChart
      });
    }, this._container = container2, this._option = option;
  }
  getRenderer() {
    var _a;
    return null === (_a = this._view) || void 0 === _a ? void 0 : _a.renderer;
  }
  getCanvas() {
    var _a;
    return null === (_a = this._view) || void 0 === _a ? void 0 : _a.renderer.canvas();
  }
  getStage() {
    var _a;
    return null === (_a = this._view) || void 0 === _a ? void 0 : _a.renderer.stage();
  }
  initView() {
    var _a, _b, _c, _d;
    if (this._released)
      return;
    if (this.isInited = true, this._view)
      return;
    const logger = new Logger(null !== (_a = this._option.logLevel) && void 0 !== _a ? _a : LoggerLevel.Error);
    (null === (_b = this._option) || void 0 === _b ? void 0 : _b.onError) && logger.addErrorHandler((...args) => {
      var _a2, _b2;
      null === (_b2 = null === (_a2 = this._option) || void 0 === _a2 ? void 0 : _a2.onError) || void 0 === _b2 || _b2.call(_a2, ...args);
    }), this._view = new View(Object.assign(Object.assign({
      width: this._width,
      height: this._height,
      container: null !== (_c = this._container.dom) && void 0 !== _c ? _c : null,
      renderCanvas: null !== (_d = this._container.canvas) && void 0 !== _d ? _d : null,
      hooks: this._option.performanceHook
    }, this._option), {
      mode: toRenderMode(this._option.mode),
      autoFit: false,
      eventConfig: {
        gesture: isMobileLikeMode(this._option.mode),
        disable: false === this._option.interactive
      },
      doLayout: () => {
        var _a2;
        null === (_a2 = this._compileChart) || void 0 === _a2 || _a2.onLayout(this._view);
      },
      logger,
      logLevel: logger.level()
    })), this._setCanvasStyle(), this.getStage().hooks.afterRender.tap("chart-event", this.handleStageRender);
    false !== this._option.interactive && this._viewListeners.forEach((listener) => {
      var _a2;
      null === (_a2 = this._view) || void 0 === _a2 || _a2.addEventListener(listener.type, listener.callback);
    });
  }
  _setCanvasStyle() {
    if (this._view && this._container.dom && !isString_default(this._container.dom)) {
      this._container.dom.style.display = "block", this._container.dom.style.position = "relative";
      const canvas = this.getCanvas();
      canvas && (canvas.style.display = "block");
    }
  }
  compileInteractions() {
    var _a;
    if (this._view.removeAllInteractions(), null === (_a = this._interactions) || void 0 === _a ? void 0 : _a.length) {
      const regionCombindInteractions = {};
      this._interactions.forEach((interaction) => {
        var _a2;
        if (interaction.regionId) {
          const interactionId = `${interaction.regionId}-${interaction.type}-${null !== (_a2 = interaction.id) && void 0 !== _a2 ? _a2 : ""}`, spec = regionCombindInteractions[interactionId];
          regionCombindInteractions[interactionId] = spec ? Object.assign(Object.assign(Object.assign({}, spec), interaction), {
            selector: [...spec.selector, ...interaction.selector]
          }) : interaction;
        } else
          this._view.interaction(interaction.type, interaction);
      }), Object.keys(regionCombindInteractions).forEach((key) => {
        const interaction = this._view.interaction(regionCombindInteractions[key].type, regionCombindInteractions[key]);
        if (this._compileChart) {
          const region = this._compileChart.getRegionsInIds([regionCombindInteractions[key].regionId])[0];
          region && region.interaction.addVgrammarInteraction(interaction.getStartState(), interaction);
        }
      });
    }
  }
  compile(ctx, option) {
    if (this._released)
      return;
    const { chart } = ctx;
    this._compileChart = chart, this.initView(), this._view && (chart.compile(), chart.afterCompile(), this.updateDepend(), this.compileInteractions());
  }
  clear(ctx, removeGraphicItems = false) {
    const { chart } = ctx;
    chart.clear(), this.releaseGrammar(removeGraphicItems);
  }
  renderNextTick(morphConfig) {
    this._released || this._nextRafId || (this._nextRafId = vglobal.getRequestAnimationFrame()(() => {
      this._nextRafId = null, this.render(morphConfig);
    }));
  }
  render(morphConfig) {
    var _a, _b;
    this._released || (this._nextRafId && (vglobal.getCancelAnimationFrame()(this._nextRafId), this._nextRafId = null), this._isRunning || (this.initView(), this._view && (this._isRunning = true, null === (_a = this._view) || void 0 === _a || _a.run(morphConfig), this._isRunning = false, this._nextRafId && (vglobal.getCancelAnimationFrame()(this._nextRafId), this._nextRafId = null, this._isRunning = true, null === (_b = this._view) || void 0 === _b || _b.run(morphConfig), this._isRunning = false))));
  }
  updateViewBox(viewBox, reRender = true) {
    this._view && this._view.renderer.setViewBox(viewBox, reRender);
  }
  resize(width, height, reRender = true) {
    this._view && (this._width = width, this._height = height, this._view.resize(width, height), reRender && this.render({
      morph: false
    }));
  }
  setBackground(color) {
    var _a;
    null === (_a = this._view) || void 0 === _a || _a.background(color);
  }
  setSize(width, height) {
    this._width = width, this._height = height, this._view && (this._view.width(width), this._view.height(height));
  }
  setViewBox(viewBox, reRender = true) {
    this._view && this._view.renderer.setViewBox(viewBox, reRender);
  }
  addEventListener(source, type, callback) {
    var _a, _b;
    if (false !== this._option.interactive) {
      if (source === Event_Source_Type.chart) {
        const wrappedCallback = function(event, element) {
          var _a2, _b2, _c;
          const context = null !== (_b2 = null === (_a2 = null == element ? void 0 : element.mark) || void 0 === _a2 ? void 0 : _a2.getContext()) && void 0 !== _b2 ? _b2 : {}, modelId = isValid_default(context.modelId) ? context.modelId : null, markId = isValid_default(context.markId) ? context.markId : null, modelUserId = isValid_default(context.modelUserId) ? context.modelUserId : null, markUserId = isValid_default(context.markUserId) ? context.markUserId : null, params2 = {
            event,
            type,
            source,
            item: element,
            datum: (null === (_c = null == element ? void 0 : element.getDatum) || void 0 === _c ? void 0 : _c.call(element)) || null,
            markId,
            modelId,
            markUserId,
            modelUserId
          };
          callback.call(null, params2);
        }.bind(this);
        this._viewListeners.set(callback, {
          type,
          callback: wrappedCallback
        }), null === (_a = this._view) || void 0 === _a || _a.addEventListener(type, wrappedCallback);
      } else if (source === Event_Source_Type.window) {
        const wrappedCallback = function(event) {
          const params2 = {
            event,
            type,
            source,
            item: null,
            datum: null,
            markId: null,
            modelId: null,
            markUserId: null,
            modelUserId: null
          };
          callback.call(null, params2);
        }.bind(this);
        this._windowListeners.set(callback, {
          type,
          callback: wrappedCallback
        });
        const windowObject = this._getGlobalThis();
        null == windowObject || windowObject.addEventListener(type, wrappedCallback);
      } else if (source === Event_Source_Type.canvas) {
        const wrappedCallback = function(event) {
          const params2 = {
            event,
            type,
            source,
            item: null,
            datum: null,
            markId: null,
            modelId: null,
            markUserId: null,
            modelUserId: null
          };
          callback.call(null, params2);
        }.bind(this);
        this._canvasListeners.set(callback, {
          type,
          callback: wrappedCallback
        });
        const canvasObject = null === (_b = this.getStage()) || void 0 === _b ? void 0 : _b.window;
        null == canvasObject || canvasObject.addEventListener(type, wrappedCallback);
      }
    }
  }
  removeEventListener(source, type, callback) {
    var _a, _b, _c, _d, _e;
    if (false !== this._option.interactive) {
      if (source === Event_Source_Type.chart) {
        const wrappedCallback = null === (_a = this._viewListeners.get(callback)) || void 0 === _a ? void 0 : _a.callback;
        wrappedCallback && (null === (_b = this._view) || void 0 === _b || _b.removeEventListener(type, wrappedCallback)), this._viewListeners.delete(callback);
      } else if (source === Event_Source_Type.window) {
        const windowObject = this._getGlobalThis(), wrappedCallback = null === (_c = this._windowListeners.get(callback)) || void 0 === _c ? void 0 : _c.callback;
        wrappedCallback && (null == windowObject || windowObject.removeEventListener(type, wrappedCallback)), this._windowListeners.delete(callback);
      } else if (source === Event_Source_Type.canvas) {
        const canvasObject = null === (_d = this.getStage()) || void 0 === _d ? void 0 : _d.window, wrappedCallback = null === (_e = this._canvasListeners.get(callback)) || void 0 === _e ? void 0 : _e.callback;
        canvasObject && wrappedCallback && (null == canvasObject || canvasObject.removeEventListener(type, wrappedCallback)), this._canvasListeners.delete(callback);
      }
    }
  }
  releaseEvent() {
    const stage = this.getStage();
    stage && stage.hooks.afterRender.unTap("chart-event", this.handleStageRender), this._viewListeners.clear(), this._windowListeners.clear(), this._canvasListeners.clear();
  }
  release() {
    var _a;
    this.releaseEvent(), this._option = this._container = null, this._releaseModel(), null === (_a = this._view) || void 0 === _a || _a.release(), this._view = null, this.isInited = false, this._compileChart = null, this._released = true;
  }
  releaseGrammar(removeGraphicItems = false) {
    var _a, _b;
    this._releaseModel(), removeGraphicItems && (null === (_a = this._view) || void 0 === _a || _a.removeAllGraphicItems()), null === (_b = this._view) || void 0 === _b || _b.removeAllGrammars();
  }
  _releaseModel() {
    Object.keys(this._model).forEach((type) => {
      Object.values(this._model[type]).forEach((grammarItemMap) => {
        Object.values(grammarItemMap).forEach((item) => {
          item.removeProduct(true);
        });
      }), this._model[type] = {};
    });
  }
  addGrammarItem(grammarItem) {
    const product = grammarItem.getProduct();
    if (isNil_default(product))
      return;
    const id2 = product.id(), type = grammarItem.grammarType;
    isNil_default(this._model[type][id2]) && (this._model[type][id2] = {}), this._model[type][id2][grammarItem.id] = grammarItem;
  }
  removeGrammarItem(grammarItem, reserveVGrammarModel) {
    var _a;
    const product = grammarItem.getProduct();
    if (isNil_default(product))
      return;
    const id2 = product.id(), type = grammarItem.grammarType, map4 = this._model[type][id2];
    isValid_default(map4) && (delete map4[grammarItem.id], 0 === Object.keys(map4).length && delete this._model[type][id2]), reserveVGrammarModel || null === (_a = this._view) || void 0 === _a || _a.removeGrammar(product);
  }
  addInteraction(interaction) {
    this._interactions || (this._interactions = []), this._interactions.push(interaction);
  }
  removeInteraction(seriesId) {
    this._interactions && (this._interactions = this._interactions.filter((entry) => entry.seriesId !== seriesId));
  }
  updateDepend(items) {
    return isValid_default(items) && items.length > 0 ? items.every((item) => item.updateDepend()) : (Object.values(this._model).forEach((productMap) => {
      Object.values(productMap).forEach((grammarItemMap) => {
        const grammarItems = Object.values(grammarItemMap), product = grammarItems[0].getProduct(), dependList = grammarItems.reduce((depend, item) => item.getDepend().length > 0 ? depend.concat(item.getDepend()) : depend, []).filter((grammarItem) => !!grammarItem).map((grammarItem) => grammarItem.getProduct());
        product.depend(dependList);
      });
    }), true);
  }
  _getGlobalThis() {
    var _a;
    return isTrueBrowser(this._option.mode) ? globalThis : null === (_a = this.getStage()) || void 0 === _a ? void 0 : _a.window;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/util/image
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function URLToImage(name = "vchart", url) {
  const link3 = document.createElement("a");
  link3.setAttribute("href", url), link3.setAttribute("target", "_blank"), link3.setAttribute("download", `${name}.png`), link3.dispatchEvent(new MouseEvent("click"));
}
function OffscreenCanvasToDataURL(c3) {
  return new Promise((r) => {
    c3.convertToBlob().then((b) => {
      const reader = new FileReader();
      reader.readAsDataURL(b), reader.onload = () => {
        r(reader.result);
      };
    });
  });
}
function getCanvasDataURL(c3, ctx) {
  var _a;
  return __awaiter7(this, void 0, void 0, function* () {
    if (!c3)
      return "";
    try {
      if (void 0 !== OffscreenCanvas && c3 instanceof OffscreenCanvas)
        return OffscreenCanvasToDataURL(c3);
    } catch (_error) {
      (null !== (_a = null == ctx ? void 0 : ctx.onError) && void 0 !== _a ? _a : error)(`getCanvasDataURL error : ${_error.toString()}`);
    }
    return c3.toDataURL();
  });
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/util
function setDefaultCrosshairForCartesianChart(spec) {
  spec.crosshair = array(spec.crosshair || {}).map((crosshairCfg) => mergeSpec({
    ["horizontal" === spec.direction ? "yField" : "xField"]: {
      visible: true,
      line: {
        visible: true,
        type: "rect"
      }
    }
  }, crosshairCfg));
}
function calculateChartSize(spec, option, defaultSize) {
  var _a;
  const { width: userWidth, height: userHeight } = spec;
  if (isValid_default(userWidth) && isValid_default(userHeight))
    return {
      width: userWidth,
      height: userHeight
    };
  let width = defaultSize.width, height = defaultSize.height;
  const container2 = option.container, canvas = option.canvas;
  if (container2) {
    const { width: containerWidth, height: containerHeight } = getContainerSize(container2, defaultSize.width, defaultSize.height);
    width = containerWidth, height = containerHeight;
  } else if (canvas && isTrueBrowser(option.mode)) {
    let canvasNode;
    canvasNode = isString_default(canvas) ? null === document || void 0 === document ? void 0 : document.getElementById(canvas) : canvas;
    const { width: containerWidth, height: containerHeight } = getContainerSize(canvasNode, defaultSize.width, defaultSize.height);
    width = containerWidth, height = containerHeight;
  } else if (isMiniAppLikeMode(option.mode) && (null === (_a = option.modeParams) || void 0 === _a ? void 0 : _a.domref)) {
    const domRef = option.modeParams.domref;
    width = domRef.width, height = domRef.height;
  }
  return width = null != userWidth ? userWidth : width, height = null != userHeight ? userHeight : height, {
    width,
    height
  };
}
function mergeUpdateResult(target, ...sources) {
  const merge3 = (key) => sources.reduce((value, cur) => value || (null == cur ? void 0 : cur[key]), target[key]);
  return Object.assign(target, {
    change: merge3("change"),
    reCompile: merge3("reCompile"),
    reMake: merge3("reMake"),
    reRender: merge3("reRender"),
    reSize: merge3("reSize"),
    reTransformSpec: merge3("reTransformSpec")
  }), target;
}
function getTrimPaddingConfig(chartType, spec) {
  return "line" === chartType || "area" === chartType || "common" === chartType && spec.series.every((item) => "area" === item.type || "line" === item.type) ? {
    paddingInner: 1,
    paddingOuter: 0
  } : {
    paddingOuter: 0
  };
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/compile/mark/interface
var STATE_VALUE_ENUM;
!function(STATE_VALUE_ENUM2) {
  STATE_VALUE_ENUM2.STATE_NORMAL = "normal", STATE_VALUE_ENUM2.STATE_HOVER = "hover", STATE_VALUE_ENUM2.STATE_HOVER_REVERSE = "hover_reverse", STATE_VALUE_ENUM2.STATE_DIMENSION_HOVER = "dimension_hover", STATE_VALUE_ENUM2.STATE_DIMENSION_HOVER_REVERSE = "dimension_hover_reverse", STATE_VALUE_ENUM2.STATE_SELECTED = "selected", STATE_VALUE_ENUM2.STATE_SELECTED_REVERSE = "selected_reverse", STATE_VALUE_ENUM2.STATE_SANKEY_EMPHASIS = "selected", STATE_VALUE_ENUM2.STATE_SANKEY_EMPHASIS_REVERSE = "blur";
}(STATE_VALUE_ENUM || (STATE_VALUE_ENUM = {}));
var STATE_VALUE_ENUM_REVERSE;
!function(STATE_VALUE_ENUM_REVERSE2) {
  STATE_VALUE_ENUM_REVERSE2.STATE_HOVER_REVERSE = "hover_reverse", STATE_VALUE_ENUM_REVERSE2.STATE_DIMENSION_HOVER_REVERSE = "dimension_hover_reverse", STATE_VALUE_ENUM_REVERSE2.STATE_SELECTED_REVERSE = "selected_reverse";
}(STATE_VALUE_ENUM_REVERSE || (STATE_VALUE_ENUM_REVERSE = {}));

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/mark/mark-set
var MarkSet = class _MarkSet {
  constructor() {
    this._children = [], this._markNameMap = {}, this._infoMap = /* @__PURE__ */ new Map();
  }
  getMarkNameMap() {
    return this._markNameMap;
  }
  addMark(mark, markInfo) {
    isNil_default(mark) || (this._children.push(mark), this._markNameMap[mark.name] = mark, this._infoMap.set(mark, merge({}, _MarkSet.defaultMarkInfo, markInfo)));
  }
  removeMark(markName) {
    const index = this._children.findIndex((m4) => m4.name === markName);
    index >= 0 && (this._infoMap.delete(this._children[index]), delete this._markNameMap[markName], this._children.splice(index, 1));
  }
  clear() {
    this._children = [], this._markNameMap = {}, this._infoMap.clear();
  }
  forEach(callbackfn) {
    this._children.forEach(callbackfn);
  }
  includes(mark, fromIndex) {
    return this._children.includes(mark, fromIndex);
  }
  get(key) {
    return isNaN(Number(key)) ? this._markNameMap[key] : this._children[key];
  }
  getMarks() {
    return this._children.slice();
  }
  getMarksInType(type) {
    const types = array(type);
    return this._children.filter((m4) => types.includes(m4.type));
  }
  getMarkInId(markId) {
    return this._children.find((m4) => m4.id === markId);
  }
  getMarkWithInfo(info) {
    return this._children.find((mark) => Object.keys(info).every((key) => info[key] === this._infoMap.get(mark)[key]));
  }
};
MarkSet.defaultMarkInfo = {};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/interaction/dimension-trigger
var DimensionTrigger = class {
  get hover() {
    return this._hover;
  }
  get select() {
    return this._select;
  }
  constructor(option) {
    this._marks = new MarkSet(), this._markReverse = new MarkSet(), this.onHover = (params2) => {
      switch (params2.action) {
        case "enter":
          this.interaction.getEventElement(STATE_VALUE_ENUM.STATE_DIMENSION_HOVER).forEach((e) => this.interaction.addEventElement(STATE_VALUE_ENUM.STATE_DIMENSION_HOVER_REVERSE, e)), this.interaction.clearEventElement(STATE_VALUE_ENUM.STATE_DIMENSION_HOVER, false);
          this.getEventElement(params2).forEach((el) => this.interaction.addEventElement(STATE_VALUE_ENUM.STATE_DIMENSION_HOVER, el)), this.interaction.reverseEventElement(STATE_VALUE_ENUM.STATE_DIMENSION_HOVER);
          break;
        case "leave":
          this.interaction.clearEventElement(STATE_VALUE_ENUM.STATE_DIMENSION_HOVER, true), params2 = null;
      }
    }, this._option = option, this.event = this._option.model.getOption().getChart().getEvent(), this.interaction = option.interaction, this.initConfig(option.mode);
  }
  setStateKeys(fields2) {
  }
  registerMark(mark) {
    isEmpty_default(mark.stateStyle[STATE_VALUE_ENUM.STATE_DIMENSION_HOVER]) || this._marks.addMark(mark), isEmpty_default(mark.stateStyle[STATE_VALUE_ENUM.STATE_DIMENSION_HOVER_REVERSE]) || this._markReverse.addMark(mark);
  }
  init() {
    this.initEvent();
  }
  release() {
    this.releaseEvent();
  }
  initEvent() {
    this.event.on(DimensionEventEnum.dimensionHover, this.onHover);
  }
  releaseEvent() {
    this.event.release();
  }
  initConfig(mode) {
  }
  getEventElement(params2, reverse = false) {
    const items = [];
    return params2.dimensionInfo.forEach((df) => {
      df.data.forEach((dd) => {
        (reverse ? this._markReverse : this._marks).getMarks().filter((m4) => m4.model === dd.series && m4.getVisible()).forEach((m4) => {
          const markProduct = m4.getProduct();
          if (!markProduct || !markProduct.elements)
            return;
          const elements = markProduct.elements.filter((e) => {
            const datum = e.getDatum();
            let c3;
            return c3 = isArray_default(datum) ? datum.every((oneData, i) => oneData === dd.datum[i]) : dd.datum.some((dd_d) => dd_d === datum), reverse ? !c3 : c3;
          });
          items.push(...elements);
        });
      });
    }), items;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/compile/mark/util
function isStateAttrChangeable(key, stateStyle, facetField) {
  var _a;
  const style = null === (_a = stateStyle[key]) || void 0 === _a ? void 0 : _a.style;
  if (isGradientAttribute(key, style))
    return true;
  if (isFunction_default(style))
    return true;
  return !(!(null == style ? void 0 : style.scale) || style.field === facetField);
}
function isGradientAttribute(key, style) {
  return ("fill" === key || "stroke" === key) && (null == style ? void 0 : style.gradient) && (null == style ? void 0 : style.stops);
}
var DEFAULT_STATE_VALUE_ENUM = {};
Object.values(STATE_VALUE_ENUM).forEach((v) => {
  DEFAULT_STATE_VALUE_ENUM[v] = true;
});
function stateInDefaultEnum(state) {
  return !!DEFAULT_STATE_VALUE_ENUM[state];
}
var DEFAULT_STATE_VALUE_TO_REVERSE = {
  [STATE_VALUE_ENUM.STATE_HOVER]: STATE_VALUE_ENUM.STATE_HOVER_REVERSE,
  [STATE_VALUE_ENUM.STATE_SELECTED]: STATE_VALUE_ENUM.STATE_SELECTED_REVERSE,
  [STATE_VALUE_ENUM.STATE_DIMENSION_HOVER]: STATE_VALUE_ENUM.STATE_DIMENSION_HOVER_REVERSE
};
function stateToReverse(state) {
  return DEFAULT_STATE_VALUE_TO_REVERSE[state];
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/interaction/interaction
var Interaction = class {
  constructor() {
    this._stateMarks = /* @__PURE__ */ new Map(), this._stateElements = /* @__PURE__ */ new Map(), this._vgrammarInteractions = /* @__PURE__ */ new Map(), this._disableTriggerEvent = false;
  }
  addVgrammarInteraction(state, i) {
    state && (this._vgrammarInteractions.get(state) ? this._vgrammarInteractions.get(state).push(i) : this._vgrammarInteractions.set(state, [i]));
  }
  static markStateEnable(mark, state) {
    return !isEmpty_default(mark.stateStyle[state]);
  }
  setDisableActiveEffect(disable) {
    this._disableTriggerEvent = disable;
  }
  registerMark(state, mark) {
    var _a;
    this._stateMarks.has(state) || this._stateMarks.set(state, []), null === (_a = this._stateMarks.get(state)) || void 0 === _a || _a.push(mark);
  }
  getStateMark(state) {
    return this._stateMarks.get(state);
  }
  filterEventMark(params2, state) {
    var _a;
    return !(!params2.mark || !(null === (_a = this._stateMarks.get(state)) || void 0 === _a ? void 0 : _a.includes(params2.mark)));
  }
  getEventElement(stateValue) {
    var _a;
    return null !== (_a = this._stateElements.get(stateValue)) && void 0 !== _a ? _a : [];
  }
  getEventElementData(stateValue) {
    return this.getEventElement(stateValue).map((e) => e.getDatum());
  }
  exchangeEventElement(stateValue, element) {
    var _a;
    if (this._disableTriggerEvent)
      return;
    const reState = stateToReverse(stateValue);
    null === (_a = this._stateElements.get(stateValue)) || void 0 === _a || _a.forEach((e) => {
      e.removeState(stateValue), reState && this.addEventElement(reState, e);
    }), element.getStates().includes(stateValue) || (element.addState(stateValue), reState && element.removeState(reState)), this._stateElements.set(stateValue, [element]);
  }
  removeEventElement(stateValue, element) {
    var _a, _b;
    if (this._disableTriggerEvent)
      return;
    element.removeState(stateValue);
    const list = null !== (_b = null === (_a = this._stateElements.get(stateValue)) || void 0 === _a ? void 0 : _a.filter((e) => e !== element)) && void 0 !== _b ? _b : [];
    this._stateElements.set(stateValue, list);
    const reState = stateToReverse(stateValue);
    reState && (0 === list.length ? this.clearEventElement(reState, false) : this.addEventElement(reState, element));
  }
  addEventElement(stateValue, element) {
    var _a;
    if (this._disableTriggerEvent)
      return;
    element.getStates().includes(stateValue) || element.addState(stateValue);
    const list = null !== (_a = this._stateElements.get(stateValue)) && void 0 !== _a ? _a : [];
    list.push(element), this._stateElements.set(stateValue, list);
  }
  clearEventElement(stateValue, clearReverse) {
    var _a;
    if (!this._disableTriggerEvent && (null === (_a = this._stateElements.get(stateValue)) || void 0 === _a || _a.forEach((e) => {
      e.removeState(stateValue);
    }), this._stateElements.set(stateValue, []), clearReverse)) {
      const reState = stateToReverse(stateValue);
      reState && this.clearEventElement(reState, false);
    }
  }
  reverseEventElement(stateValue) {
    if (this._disableTriggerEvent)
      return;
    const state = stateToReverse(stateValue);
    if (!state)
      return;
    const marks = this.getStateMark(state);
    if (!marks)
      return;
    const activeElements = this.getEventElement(stateValue);
    if (!activeElements.length)
      return;
    this.getEventElement(state).length || (1 === activeElements.length ? marks.forEach((m4) => {
      m4.getProduct().elements.filter((e) => e !== activeElements[0]).forEach((e) => {
        this.addEventElement(state, e);
      });
    }) : marks.forEach((m4) => {
      m4.getProduct().elements.filter((e) => !activeElements.includes(e)).forEach((e) => {
        this.addEventElement(state, e);
      });
    }));
  }
  startInteraction(stateValue, element) {
    const interactions = this._vgrammarInteractions.get(stateValue);
    interactions && interactions.forEach((vgInteraction) => {
      vgInteraction.start(element);
    });
  }
  resetInteraction(stateValue, element) {
    const interactions = this._vgrammarInteractions.get(stateValue);
    interactions && interactions.forEach((vgInteraction) => {
      vgInteraction.reset(element);
    });
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/compile/compilable-base
var CompilableBase = class {
  getOption() {
    return this._option;
  }
  constructor(option) {
    this._option = option, this.getCompiler = this._option.getCompiler;
  }
  getVGrammarView() {
    var _a;
    return null === (_a = this.getCompiler()) || void 0 === _a ? void 0 : _a.getVGrammarView();
  }
  release() {
    this._option = null, this.getCompiler = null;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/compile/grammar-item
var GrammarItem = class extends CompilableBase {
  constructor() {
    super(...arguments), this.id = createID(), this._compiledProductId = null, this._depend = [];
  }
  getProduct() {
    if (isValid_default(this._product))
      return this._product;
    const view = this.getVGrammarView(), id2 = this.getProductId();
    return isValid_default(id2) && isValid_default(view) && (this._product = this._lookupGrammar(id2)), this._product;
  }
  getProductId() {
    var _a;
    return null !== (_a = this._compiledProductId) && void 0 !== _a ? _a : this.generateProductId();
  }
  getDepend() {
    return this._depend;
  }
  setDepend(...depend) {
    this._depend = depend;
  }
  compile(option) {
    this._compileProduct(option), this._afterCompile(option);
  }
  _afterCompile(option) {
    var _a;
    isValid_default(this._product) && (null === (_a = this.getCompiler()) || void 0 === _a || _a.addGrammarItem(this));
  }
  updateDepend() {
    if (isValid_default(this._product)) {
      const depend = this.getDepend().map((item) => item.getProduct()).filter(isValid_default);
      return this._product.depend(depend), depend.length === this.getDepend().length;
    }
    return false;
  }
  release() {
    this.removeProduct(), super.release(), this._depend = [];
  }
  removeProduct(reserveVGrammarModel) {
    this.getCompiler().removeGrammarItem(this, reserveVGrammarModel), this._product = null, this._compiledProductId = null;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/compile/signal/compilable-signal
var CompilableSignal = class extends GrammarItem {
  getValue() {
    return this._value;
  }
  getUpdateFunc() {
    return this._updateFunc;
  }
  constructor(option, name, value, updateFunc) {
    super(option), this.grammarType = GrammarType.signal, this.name = name, this._value = value, this._updateFunc = updateFunc;
  }
  updateSignal(value, updateFunc) {
    this._value = value, this._updateFunc = updateFunc, this.compile();
  }
  _compileProduct() {
    const view = this.getVGrammarView();
    if (!view)
      return;
    if (!this.getProduct()) {
      const id2 = this.getProductId();
      this._product = view.signal().id(id2), this._compiledProductId = id2;
    }
    isValid_default(this._value) && this._product.value(this._value), isValid_default(this._updateFunc) && this._product.update(this._updateFunc);
  }
  generateProductId() {
    return this.name;
  }
  _lookupGrammar(id2) {
    var _a;
    return null === (_a = this.getCompiler().getVGrammarView()) || void 0 === _a ? void 0 : _a.getSignalById(id2);
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/compile/signal/signal-manager
var SignalManager = class extends CompilableBase {
  constructor() {
    super(...arguments), this._signalMap = {};
  }
  getSignalMap() {
    return this._signalMap;
  }
  getSignal(name) {
    return this._signalMap[name];
  }
  updateSignal(name, value, updateFunc) {
    this._signalMap[name] ? this._signalMap[name].updateSignal(value, updateFunc) : (this._signalMap[name] = new CompilableSignal(this._option, name, value, updateFunc), this._signalMap[name].compile());
  }
  compile() {
    Object.values(this._signalMap).forEach((signal) => {
      signal.compile();
    });
  }
  release() {
    super.release(), Object.values(this._signalMap).forEach((signal) => {
      signal.release();
    }), this._signalMap = {};
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/compile/signal/state-manager
var StateManager = class extends SignalManager {
  getStateMap() {
    return this._stateMap;
  }
  _getDefaultStateMap() {
    return {};
  }
  constructor(option) {
    super(option), option.stateKeyToSignalName ? this.stateKeyToSignalName = option.stateKeyToSignalName : this.stateKeyToSignalName = () => "state_signal", this.initStateMap();
  }
  initStateMap(state) {
    this._stateMap = null != state ? state : this._getDefaultStateMap();
  }
  compile(stateMap) {
    const state = null != stateMap ? stateMap : this._stateMap;
    Object.keys(state).forEach((key) => {
      const name = this.stateKeyToSignalName(key), value = state[key];
      this.updateSignal(name, value);
    });
  }
  updateState(newState, noRender) {
    if (newState && (merge(this._stateMap, newState), this.compile(newState), !noRender))
      return this.getCompiler().renderNextTick();
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/animation/animate-manager
var AnimateManager = class extends StateManager {
  constructor() {
    super(...arguments), this.id = createID(), this.stateKeyToSignalName = (key) => `${PREFIX}_animate_${this.id}_${key}`;
  }
  getAnimationStateSignalName() {
    return this.stateKeyToSignalName("animationState");
  }
  updateAnimateState(state, noRender) {
    state === AnimationStateEnum.update ? this.updateState({
      animationState: {
        callback: (datum, element) => element.diffState
      }
    }, noRender) : state === AnimationStateEnum.appear ? this.updateState({
      animationState: {
        callback: (datum, element) => "exit" === element.diffState ? AnimationStateEnum.none : AnimationStateEnum.appear
      }
    }, noRender) : this.updateState({
      animationState: {
        callback: (datum, element) => state
      }
    }, noRender);
  }
  _getDefaultStateMap() {
    return {
      animationState: {
        callback: (datum, element) => "exit" === element.diffState ? AnimationStateEnum.exit : AnimationStateEnum.appear
      }
    };
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/model/base-model-transformer
var BaseModelSpecTransformer = class {
  constructor(option) {
    this._option = option, this.type = option.type;
  }
  _initTheme(spec, chartSpec) {
    return this._theme = this.getTheme(spec, chartSpec), this._mergeThemeToSpec(spec, chartSpec);
  }
  getTheme(spec, chartSpec) {
  }
  transformSpec(spec, chartSpec, chartSpecInfo) {
    this._transformSpecBeforeMergingTheme(spec, chartSpec, chartSpecInfo);
    const result2 = this._initTheme(spec, chartSpec);
    return this._transformSpecAfterMergingTheme(result2.spec, chartSpec, chartSpecInfo), result2;
  }
  _transformSpecBeforeMergingTheme(spec, chartSpec, chartSpecInfo) {
  }
  _transformSpecAfterMergingTheme(spec, chartSpec, chartSpecInfo) {
  }
  _mergeThemeToSpec(spec, chartSpec) {
    const theme2 = this._theme;
    if (this._shouldMergeThemeToSpec()) {
      const specFromChart = this._getDefaultSpecFromChart(chartSpec), merge3 = (originalSpec) => mergeSpec({}, theme2, specFromChart, originalSpec);
      return isArray_default(spec) ? {
        spec: spec.map((specItem) => merge3(specItem)),
        theme: theme2
      } : {
        spec: merge3(spec),
        theme: theme2
      };
    }
    return {
      spec,
      theme: theme2
    };
  }
  _shouldMergeThemeToSpec() {
    return true;
  }
  _getDefaultSpecFromChart(chartSpec) {
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/model/base-model
var BaseModel = class extends CompilableBase {
  getSpec() {
    return this._spec || {};
  }
  getSpecPath() {
    var _a;
    return null === (_a = this._option) || void 0 === _a ? void 0 : _a.specPath;
  }
  getSpecInfoPath() {
    var _a, _b, _c;
    return null !== (_b = null === (_a = this._option) || void 0 === _a ? void 0 : _a.specInfoPath) && void 0 !== _b ? _b : null === (_c = this._option) || void 0 === _c ? void 0 : _c.specPath;
  }
  getData() {
    return this._data;
  }
  get layout() {
    return this._layout;
  }
  getOption() {
    return this._option;
  }
  getMarks() {
    var _a, _b;
    return null !== (_b = null === (_a = this._marks) || void 0 === _a ? void 0 : _a.getMarks()) && void 0 !== _b ? _b : [];
  }
  getMarkNameMap() {
    var _a;
    return null === (_a = this._marks) || void 0 === _a ? void 0 : _a.getMarkNameMap();
  }
  getMarkSet() {
    return this._marks;
  }
  getMarkInfoList() {
    return this.getMarks().map((mark) => ({
      type: mark.type,
      name: mark.name
    }));
  }
  getChart() {
    return this._option.getChart();
  }
  get _theme() {
    var _a;
    return null === (_a = this.getSpecInfo()) || void 0 === _a ? void 0 : _a.theme;
  }
  constructor(spec, option) {
    var _a;
    super(option), this.transformerConstructor = BaseModelSpecTransformer, this.type = "null", this.modelType = "null", this.userId = void 0, this._data = null, this._layout = null, this.specKey = "", this._marks = new MarkSet(), this._lastLayoutRect = null, this.id = createID(), this.userId = spec.id, this._spec = spec, this.effect = {}, this.event = new Event2(option.eventDispatcher, option.mode), null === (_a = option.map) || void 0 === _a || _a.set(this.id, this);
  }
  _releaseEvent() {
    this.event.release();
  }
  created() {
    this.setAttrFromSpec();
  }
  init(option) {
  }
  afterInit() {
  }
  getVisible() {
    var _a;
    return false !== (null === (_a = this._spec) || void 0 === _a ? void 0 : _a.visible);
  }
  onLayoutStart(layoutRect, viewRect, ctx) {
    var _a;
    null === (_a = this._layout) || void 0 === _a || _a.onLayoutStart(layoutRect, viewRect, ctx);
  }
  onLayoutEnd(ctx) {
    var _a;
    null === (_a = this._layout) || void 0 === _a || _a.onLayoutEnd(ctx), this.getMarks().forEach((m4) => m4.updateLayoutState(true, true));
  }
  onEvaluateEnd(ctx) {
  }
  onDataUpdate() {
  }
  beforeRelease() {
  }
  release() {
    var _a;
    this._releaseEvent(), this._spec = void 0, this.getMarks().forEach((m4) => m4.release()), null === (_a = this._data) || void 0 === _a || _a.release(), this._data = null, this._marks.clear(), super.release();
  }
  updateSpec(spec) {
    const result2 = this._compareSpec(spec, this._spec);
    return this._spec = spec, result2;
  }
  _compareSpec(spec, prevSpec) {
    return {
      change: false,
      reMake: false,
      reRender: false,
      reSize: false,
      reCompile: false
    };
  }
  reInit(spec) {
    spec && (this._spec = spec), this.setAttrFromSpec();
  }
  updateLayoutAttribute() {
  }
  setAttrFromSpec() {
    var _a;
    null === (_a = this._layout) || void 0 === _a || _a.setAttrFromSpec(this._spec, this._option.getChartViewRect());
  }
  _convertMarkStyle(style) {
    return Object.assign({}, style);
  }
  setMarkStyle(mark, style, state, level) {
    isValid_default(mark) && isValid_default(style) && mark.setStyle(this._convertMarkStyle(style), state, level);
  }
  initMarkStyleWithSpec(mark, spec, key) {
    if (!isValid_default(mark) || !isValid_default(spec))
      return;
    const { style, state } = spec, newSpec = Object.assign({}, spec);
    style && (newSpec.style = this._convertMarkStyle(style)), state && (newSpec.state = {}, Object.keys(state).forEach((key2) => {
      newSpec.state[key2] = this._convertMarkStyle(state[key2]);
    })), mark.initStyleWithSpec(newSpec, key);
  }
  stateKeyToSignalName(key, opt) {
    let name = `${PREFIX}_${this.modelType}_${this.type}_${this.id}_${key}`;
    return opt && (name += `_${opt}`), name;
  }
  compileData() {
    var _a;
    null === (_a = this._data) || void 0 === _a || _a.compile();
  }
  compileMarks(group) {
    this.getMarks().forEach((m4) => {
      m4.compile({
        group
      });
    });
  }
  _createMark(markInfo, option = {}) {
    const { type, name } = markInfo, m4 = Factory2.createMark(type, name, Object.assign({
      model: this,
      map: this._option.map,
      getCompiler: this.getCompiler,
      globalScale: this._option.globalScale
    }, option));
    return null == m4 || m4.created(), m4;
  }
  _getDataIdKey() {
  }
  getColorScheme() {
    var _a, _b;
    return null === (_b = (_a = this._option).getTheme) || void 0 === _b ? void 0 : _b.call(_a).colorScheme;
  }
  getSpecInfo() {
    var _a, _b, _c;
    const specInfo = null !== (_c = null === (_b = (_a = this._option).getSpecInfo) || void 0 === _b ? void 0 : _b.call(_a)) && void 0 !== _c ? _c : {};
    return getProperty(specInfo, this.getSpecInfoPath());
  }
  getSpecIndex() {
    const path = this.getSpecPath();
    if (!(null == path ? void 0 : path.length))
      return 0;
    const index = Number(path[path.length - 1]);
    return isNaN(index) ? 0 : index;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/layout/layout-item
var LayoutItem = class {
  getSpec() {
    return this._spec || {};
  }
  getLayoutStartPoint() {
    return this._layoutStartPoint;
  }
  get layoutRectLevelMap() {
    return this._layoutRectLevelMap;
  }
  get minWidth() {
    return this._minWidth;
  }
  set minWidth(v) {
    this._minWidth = v;
  }
  get maxWidth() {
    return this._maxWidth;
  }
  set maxWidth(v) {
    this._maxWidth = v;
  }
  get minHeight() {
    return this._minHeight;
  }
  set minHeight(v) {
    this._minHeight = v;
  }
  get maxHeight() {
    return this._maxHeight;
  }
  set maxHeight(v) {
    this._maxHeight = v;
  }
  getLastComputeOutBounds() {
    return this._lastComputeOutBounds;
  }
  get layoutOrient() {
    return this._layoutOrient;
  }
  set layoutOrient(v) {
    this._layoutOrient = v;
  }
  get model() {
    return this._model;
  }
  get type() {
    return this._model.type;
  }
  constructor(model, option) {
    var _a;
    this.layoutClip = false, this.autoIndent = false, this._layoutStartPoint = {
      x: 0,
      y: 0
    }, this._layoutRect = {
      width: 0,
      height: 0
    }, this._layoutRectLevelMap = {
      width: DEFAULT_LAYOUT_RECT_LEVEL,
      height: DEFAULT_LAYOUT_RECT_LEVEL
    }, this._minWidth = null, this._maxWidth = null, this._minHeight = null, this._maxHeight = null, this._lastComputeRect = null, this._lastComputeOutBounds = {
      x1: 0,
      x2: 0,
      y1: 0,
      y2: 0
    }, this.getLayoutRect = () => this._layoutRect, this.layoutType = "normal", this._layoutOrient = "left", this.layoutPaddingLeft = 0, this.layoutPaddingTop = 0, this.layoutPaddingRight = 0, this.layoutPaddingBottom = 0, this.layoutOffsetX = 0, this.layoutOffsetY = 0, this.layoutLevel = LayoutLevel.Region, this._model = model, this._option = option, this.layoutLevel = option.layoutLevel, this.layoutType = option.layoutType, option.layoutOrient && (this.layoutOrient = option.layoutOrient), this._spec = null === (_a = null == model ? void 0 : model.getSpec) || void 0 === _a ? void 0 : _a.call(model);
  }
  _setLayoutAttributeFromSpec(spec, chartViewRect) {
    var _a, _b, _c, _d;
    if (this._spec && false !== this._spec.visible) {
      const padding = normalizeLayoutPaddingSpec(spec.padding), paddingValue = calcPadding(padding, chartViewRect, chartViewRect);
      this.layoutPaddingLeft = paddingValue.left, this.layoutPaddingRight = paddingValue.right, this.layoutPaddingTop = paddingValue.top, this.layoutPaddingBottom = paddingValue.bottom, this._minHeight = isNil_default(spec.minHeight) ? null !== (_a = this._minHeight) && void 0 !== _a ? _a : null : calcLayoutNumber(spec.minHeight, chartViewRect.height, chartViewRect), this._maxHeight = isNil_default(spec.maxHeight) ? null !== (_b = this._maxHeight) && void 0 !== _b ? _b : null : calcLayoutNumber(spec.maxHeight, chartViewRect.height, chartViewRect), this._minWidth = isNil_default(spec.minWidth) ? null !== (_c = this._minWidth) && void 0 !== _c ? _c : null : calcLayoutNumber(spec.minWidth, chartViewRect.width, chartViewRect), this._maxWidth = isNil_default(spec.maxWidth) ? null !== (_d = this._maxWidth) && void 0 !== _d ? _d : null : calcLayoutNumber(spec.maxWidth, chartViewRect.width, chartViewRect), spec.width && this.setLayoutRect({
        width: calcLayoutNumber(spec.width, chartViewRect.width, chartViewRect)
      }, {
        width: USER_LAYOUT_RECT_LEVEL
      }), spec.height && this.setLayoutRect({
        height: calcLayoutNumber(spec.height, chartViewRect.height, chartViewRect)
      }, {
        height: USER_LAYOUT_RECT_LEVEL
      }), isNil_default(spec.offsetX) || (this.layoutOffsetX = calcLayoutNumber(spec.offsetX, chartViewRect.width, chartViewRect)), isNil_default(spec.offsetY) || (this.layoutOffsetY = calcLayoutNumber(spec.offsetY, chartViewRect.height, chartViewRect)), spec.alignSelf && (this.alignSelf = spec.alignSelf);
    }
  }
  setAttrFromSpec(spec, chartViewRect) {
    var _a, _b, _c, _d;
    this._spec = spec, this.layoutType = null !== (_a = spec.layoutType) && void 0 !== _a ? _a : this.layoutType, this.layoutLevel = null !== (_b = spec.layoutLevel) && void 0 !== _b ? _b : this.layoutLevel, this.layoutOrient = null !== (_c = spec.orient) && void 0 !== _c ? _c : this.layoutOrient, this._setLayoutAttributeFromSpec(spec, chartViewRect), this.layoutClip = null !== (_d = spec.clip) && void 0 !== _d ? _d : this.layoutClip;
  }
  onLayoutStart(layoutRect, viewRect, ctx) {
    this._setLayoutAttributeFromSpec(this._spec, viewRect);
  }
  onLayoutEnd(option) {
  }
  _getAbsoluteSpecValue(layoutRect) {
    const result2 = {
      top: null,
      bottom: null,
      left: null,
      right: null
    };
    return ["top", "bottom", "left", "right"].forEach((k2) => {
      isNil_default(this._spec[k2]) || (result2[k2] = calcLayoutNumber(this._spec[k2], "top" === k2 || "bottom" === k2 ? layoutRect.height : layoutRect.width, layoutRect));
    }), result2;
  }
  absoluteLayoutInRect(layoutRect) {
    const { top, bottom, left: left2, right: right2 } = this._getAbsoluteSpecValue(layoutRect), layoutSize = {
      width: layoutRect.width - this.layoutPaddingLeft - this.layoutPaddingRight,
      height: layoutRect.height - this.layoutPaddingTop - this.layoutPaddingBottom
    };
    isNil_default(left2) || (layoutSize.width -= left2), isNil_default(right2) || (layoutSize.width -= right2), isNil_default(top) || (layoutSize.height -= top), isNil_default(bottom) || (layoutSize.height -= bottom), this.setLayoutRect(layoutSize);
    const { width, height } = this.computeBoundsInRect(this.getLayoutRect());
    this.setLayoutRect({
      width,
      height
    });
    const pos = {
      x: layoutRect.x,
      y: layoutRect.y
    };
    true === this._spec.center ? (pos.x = layoutRect.x + 0.5 * layoutRect.width - 0.5 * width, pos.y = layoutRect.y + 0.5 * layoutRect.height - 0.5 * height) : (isNil_default(left2) ? isNil_default(right2) || (pos.x = layoutRect.x + layoutRect.width - this.layoutPaddingRight - right2 - width) : pos.x = layoutRect.x + left2 + this.layoutPaddingLeft, isNil_default(top) ? isNil_default(bottom) || (pos.y = layoutRect.y + layoutRect.height - this.layoutPaddingBottom - bottom - height) : pos.y = layoutRect.y + top + this.layoutPaddingTop), this.setLayoutStartPosition(pos);
  }
  setLayoutStartPosition(pos) {
    var _a, _b;
    this._option.transformLayoutPosition && (pos = this._option.transformLayoutPosition(pos)), isValidNumber_default(pos.x) && (this._layoutStartPoint.x = pos.x), isValidNumber_default(pos.y) && (this._layoutStartPoint.y = pos.y), null === (_b = (_a = this._model).afterSetLayoutStartPoint) || void 0 === _b || _b.call(_a, this._layoutStartPoint);
  }
  setLayoutRect({ width, height }, levelMap) {
    var _a, _b, _c, _d;
    isValidNumber_default(width) && (null !== (_a = null == levelMap ? void 0 : levelMap.width) && void 0 !== _a ? _a : DEFAULT_LAYOUT_RECT_LEVEL) >= this._layoutRectLevelMap.width && (this._layoutRect.width = width, this._layoutRectLevelMap.width = null !== (_b = null == levelMap ? void 0 : levelMap.width) && void 0 !== _b ? _b : DEFAULT_LAYOUT_RECT_LEVEL), isValidNumber_default(height) && (null !== (_c = null == levelMap ? void 0 : levelMap.height) && void 0 !== _c ? _c : DEFAULT_LAYOUT_RECT_LEVEL) >= this._layoutRectLevelMap.height && (this._layoutRect.height = height, this._layoutRectLevelMap.height = null !== (_d = null == levelMap ? void 0 : levelMap.height) && void 0 !== _d ? _d : DEFAULT_LAYOUT_RECT_LEVEL), this.setRectInSpec(this._layoutRect);
  }
  getLayout() {
    return {
      x: this._layoutStartPoint.x,
      y: this._layoutStartPoint.y,
      width: this._layoutRect.width,
      height: this._layoutRect.height
    };
  }
  mergeLayoutRect({ width, height }) {
    const rect = {
      width,
      height
    };
    return this._layoutRectLevelMap.width > DEFAULT_LAYOUT_RECT_LEVEL && (rect.width = this._layoutRect.width), this._layoutRectLevelMap.height > DEFAULT_LAYOUT_RECT_LEVEL && (rect.height = this._layoutRect.height), rect;
  }
  getOrientPosAttribute() {
    return "bottom" === this._layoutOrient || "top" === this._layoutOrient ? "x" : "y";
  }
  getOrientSizeAttribute() {
    return "bottom" === this._layoutOrient || "top" === this._layoutOrient ? "width" : "height";
  }
  changeBoundsBySetting(bounds) {
    return this._layoutRectLevelMap.width > DEFAULT_LAYOUT_RECT_LEVEL && (bounds.x2 = bounds.x1 + this._layoutRect.width), this._layoutRectLevelMap.height > DEFAULT_LAYOUT_RECT_LEVEL && (bounds.y2 = bounds.y1 + this._layoutRect.height), bounds.x1 -= this._layoutStartPoint.x, bounds.x2 -= this._layoutStartPoint.x, bounds.y1 -= this._layoutStartPoint.y, bounds.y2 -= this._layoutStartPoint.y, bounds;
  }
  setRectInSpec(rect) {
    const result2 = Object.assign({}, rect);
    return this._layoutRectLevelMap.width < USER_LAYOUT_RECT_LEVEL ? (isNil_default(this._minWidth) || (result2.width = Math.max(result2.width, this._minWidth)), isNil_default(this._maxWidth) || (result2.width = Math.min(result2.width, this._maxWidth))) : result2.width = this._layoutRect.width, this._layoutRectLevelMap.height < USER_LAYOUT_RECT_LEVEL ? (isNil_default(this._minHeight) || (result2.height = Math.max(result2.height, this._minHeight)), isNil_default(this._maxHeight) || (result2.height = Math.min(result2.height, this._maxHeight))) : result2.height = this._layoutRect.height, result2;
  }
  computeBoundsInRect(rect) {
    if (this._lastComputeRect = rect, !("region-relative" !== this.layoutType && "region-relative-overlap" !== this.layoutType || (this._layoutRectLevelMap.width !== USER_LAYOUT_RECT_LEVEL || "left" !== this.layoutOrient && "right" !== this.layoutOrient) && (this._layoutRectLevelMap.height !== USER_LAYOUT_RECT_LEVEL || "bottom" !== this.layoutOrient && "top" !== this.layoutOrient)))
      return this._layoutRect;
    const bounds = Object.assign({}, this._model.getBoundsInRect(this.setRectInSpec(rect), rect));
    this.changeBoundsBySetting(bounds), this.autoIndent && bounds.x2 - bounds.x1 > 0 && bounds.y2 - bounds.y1 > 0 && (this._lastComputeOutBounds.x1 = Math.ceil(-bounds.x1), this._lastComputeOutBounds.x2 = Math.ceil(bounds.x2 - rect.width), this._lastComputeOutBounds.y1 = Math.ceil(-bounds.y1), this._lastComputeOutBounds.y2 = Math.ceil(bounds.y2 - rect.height));
    let result2 = this.setRectInSpec(boundsInRect(bounds, rect));
    return this._option.transformLayoutRect && (result2 = this._option.transformLayoutRect(result2)), result2;
  }
  getModelId() {
    return this._model.id;
  }
  getModelVisible() {
    return this._model.getVisible();
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/model/layout-model
var LayoutModel = class extends BaseModel {
  constructor() {
    super(...arguments), this.layoutType = "normal", this.layoutLevel = 0, this.layoutZIndex = 0, this._forceLayoutTag = false, this._layout = null, this._orient = null, this._layoutRect = {
      width: 0,
      height: 0
    }, this._layoutStartPos = {
      x: 0,
      y: 0
    }, this._isLayout = true, this.getGraphicBounds = () => this._layout ? {
      x1: this._layout.getLayoutStartPoint().x,
      y1: this._layout.getLayoutStartPoint().y,
      x2: this._layout.getLayoutStartPoint().x + this._layout.getLayoutRect().width,
      y2: this._layout.getLayoutStartPoint().y + this._layout.getLayoutRect().height
    } : {
      x1: 0,
      x2: 0,
      y1: 0,
      y2: 0
    }, this._transformLayoutRect = null, this._transformLayoutPosition = null;
  }
  get layoutOrient() {
    return this._orient;
  }
  set layoutOrient(v) {
    this._orient = v, this._layout && (this._layout.layoutOrient = v);
  }
  initLayout() {
    "none" !== this.layoutType && (this._layout = new LayoutItem(this, {
      layoutType: this.layoutType,
      layoutLevel: this.layoutLevel,
      layoutOrient: this._orient,
      transformLayoutRect: this._transformLayoutRect,
      transformLayoutPosition: this._transformLayoutPosition
    }), this._orient && "radius" !== this._orient && "angle" !== this._orient && this._layout && (this._layout.layoutOrient = this._orient));
  }
  onLayoutStart(layoutRect, viewRect, ctx) {
    this._isLayout = true, super.onLayoutStart(layoutRect, viewRect, ctx);
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx), this.updateLayoutAttribute();
    const layoutRect = this.getLayoutRect();
    !this._forceLayoutTag && isEqual(this._lastLayoutRect, layoutRect) || (this._lastLayoutRect = Object.assign({}, layoutRect)), this._forceLayoutTag = false, this._isLayout = false;
  }
  afterSetLayoutStartPoint(_pos) {
  }
  _forceLayout() {
    var _a;
    this._isLayout || (this._forceLayoutTag = true, null === (_a = this._option.globalInstance.getChart()) || void 0 === _a || _a.setLayoutTag(true));
  }
  getLayoutStartPoint() {
    return this._layout ? this._layout.getLayoutStartPoint() : this._layoutStartPos;
  }
  setLayoutStartPosition(pos) {
    return this._layout ? this._layout.setLayoutStartPosition(pos) : this._layoutStartPos = merge(this._layoutStartPos, pos);
  }
  getLayoutRect() {
    return this._layout ? this._layout.getLayoutRect() : this._layoutRect;
  }
  setLayoutRect(rect, levelMap) {
    return this._layout ? this._layout.setLayoutRect(rect) : this._lastLayoutRect = merge(this._layoutRect, rect);
  }
  getLastComputeOutBounds() {
    var _a;
    return null === (_a = this._layout) || void 0 === _a ? void 0 : _a.getLastComputeOutBounds();
  }
  setAttrFromSpec() {
    var _a, _b, _c, _d, _e;
    super.setAttrFromSpec(), this.layoutClip = null !== (_a = this._spec.clip) && void 0 !== _a ? _a : this.layoutClip, this.layoutZIndex = null !== (_b = this._spec.zIndex) && void 0 !== _b ? _b : this.layoutZIndex, this.layoutType = null !== (_c = this._spec.layoutType) && void 0 !== _c ? _c : this.layoutType, this._orient = null !== (_d = this._spec.orient) && void 0 !== _d ? _d : this._orient, this.layoutLevel = null !== (_e = this._spec.layoutLevel) && void 0 !== _e ? _e : this.layoutLevel;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/region/region-transformer
var RegionSpecTransformer = class extends BaseModelSpecTransformer {
  _initTheme(spec, chartSpec) {
    return {
      spec,
      theme: this._theme
    };
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/region/region
var Region = class _Region extends LayoutModel {
  getMaxWidth() {
    return this._layout.maxWidth;
  }
  setMaxWidth(value) {
    this._layout.maxWidth = value;
  }
  getMaxHeight() {
    return this._layout.maxHeight;
  }
  setMaxHeight(value) {
    this._layout.maxHeight = value;
  }
  getGroupMark() {
    return this._groupMark;
  }
  getInteractionMark() {
    return this._interactionMark;
  }
  getStackInverse() {
    return true === this._spec.stackInverse;
  }
  getStackSort() {
    return true === this._spec.stackSort;
  }
  constructor(spec, ctx) {
    var _a;
    super(spec, ctx), this.transformerConstructor = RegionSpecTransformer, this.modelType = "region", this.specKey = "region", this.type = _Region.type, this._series = [], this.layoutType = "region", this.layoutZIndex = LayoutZIndex.Region, this.interaction = new Interaction(), this.seriesDataFilterOver = () => {
      this.event.emit(ChartEvent.regionSeriesDataFilterOver, {
        model: this,
        chart: this.getChart()
      }), this._series.forEach((s2) => {
        s2.getViewDataFilter() && s2.reTransformViewData();
      });
    }, this.getBoundsInRect = () => ({
      x1: this._layout.getLayoutStartPoint().x,
      y1: this._layout.getLayoutStartPoint().y,
      x2: this._layout.getLayoutStartPoint().x + this._layout.getLayoutRect().width,
      y2: this._layout.getLayoutStartPoint().y + this._layout.getLayoutRect().height
    }), this.userId = spec.id, this.coordinate = null !== (_a = spec.coordinate) && void 0 !== _a ? _a : "cartesian", this._option.animation && (this.animate = new AnimateManager({
      getCompiler: ctx.getCompiler
    })), this.interaction.setDisableActiveEffect(this._option.disableTriggerEvent);
  }
  _getClipDefaultValue() {
    var _a, _b, _c, _d;
    const chartSpec = this._option.getChart().getSpec(), hasDataZoom = null === (_b = null === (_a = chartSpec.dataZoom) || void 0 === _a ? void 0 : _a.some) || void 0 === _b ? void 0 : _b.call(_a, (entry) => {
      var _a2;
      return "axis" === (null !== (_a2 = entry.filterMode) && void 0 !== _a2 ? _a2 : "filter");
    }), hasScrollBar = null === (_d = null === (_c = chartSpec.scrollBar) || void 0 === _c ? void 0 : _c.some) || void 0 === _d ? void 0 : _d.call(_c, (entry) => {
      var _a2;
      return "axis" === (null !== (_a2 = entry.filterMode) && void 0 !== _a2 ? _a2 : "axis");
    });
    return !(!hasDataZoom && !hasScrollBar) || this._layout.layoutClip;
  }
  created() {
    var _a;
    this.initLayout(), super.created();
    const clip = null !== (_a = this._spec.clip) && void 0 !== _a ? _a : this._getClipDefaultValue();
    this._groupMark = this._createGroupMark("regionGroup", this.userId, this.layoutZIndex), this._interactionMark = this._createGroupMark("regionInteractionGroup", this.userId + "_interaction", LayoutZIndex.Interaction), isEmpty_default(this._spec.style) || (this._backgroundMark = this._createMark({
      type: "rect",
      name: "regionBackground"
    }), clip && (this._foregroundMark = this._createMark({
      type: "rect",
      name: "regionForeground"
    })), [this._backgroundMark, this._foregroundMark].forEach((mark) => {
      mark && (mark.created(), this.setMarkStyle(mark, {
        width: () => this.getLayoutRect().width,
        height: () => this.getLayoutRect().height
      }, "normal", AttributeLevel.Built_In), this._groupMark.addMark(mark));
    }), this._backgroundMark && this._backgroundMark.setZIndex(0), this._foregroundMark && this._foregroundMark.setZIndex(LayoutZIndex.Mark + 1)), this.createTrigger();
  }
  _createGroupMark(name, userId, zIndex) {
    var _a, _b;
    const groupMark = this._createMark({
      type: "group",
      name
    });
    groupMark.setUserId(userId), groupMark.setZIndex(zIndex);
    const clip = null !== (_a = this._spec.clip) && void 0 !== _a ? _a : this._getClipDefaultValue();
    return this.setMarkStyle(groupMark, {
      x: () => this.getLayoutStartPoint().x,
      y: () => this.getLayoutStartPoint().y,
      width: () => this.getLayoutRect().width,
      height: () => this.getLayoutRect().height,
      clip
    }, "normal", AttributeLevel.Built_In), this.setMarkStyle(groupMark, {
      cornerRadius: null === (_b = this._spec.style) || void 0 === _b ? void 0 : _b.cornerRadius
    }, "normal", AttributeLevel.User_Mark), this._marks.addMark(groupMark), groupMark;
  }
  init(option) {
    super.init(option), this.initMark(), this.initSeriesDataflow(), this.initInteraction(), this.initTrigger();
  }
  initMark() {
    this._initBackgroundMarkStyle(), this._initForegroundMarkStyle();
  }
  _initBackgroundMarkStyle() {
    var _a, _b;
    this._backgroundMark && (this.setMarkStyle(this._backgroundMark, Object.assign({
      fillOpacity: (null === (_a = this._spec.style) || void 0 === _a ? void 0 : _a.fill) ? 1 : 0
    }, this._spec.style), "normal", AttributeLevel.User_Mark), (null !== (_b = this._spec.clip) && void 0 !== _b ? _b : this._getClipDefaultValue()) && this.setMarkStyle(this._backgroundMark, {
      strokeOpacity: 0
    }, "normal", AttributeLevel.Built_In));
  }
  _initForegroundMarkStyle() {
    this._foregroundMark && this.setMarkStyle(this._foregroundMark, Object.assign(Object.assign({}, this._spec.style), {
      fillOpacity: 0
    }), "normal", AttributeLevel.User_Mark);
  }
  _compareSpec(spec, prevSpec) {
    const result2 = super._compareSpec(spec, prevSpec);
    return isEqual(null == prevSpec ? void 0 : prevSpec.style, null == spec ? void 0 : spec.style) || (result2.reMake = true), result2;
  }
  reInit(spec) {
    super.reInit(spec), this._initBackgroundMarkStyle(), this._initForegroundMarkStyle();
  }
  addSeries(s2) {
    s2 && (this._series.includes(s2) || this._series.push(s2));
  }
  removeSeries(s2) {
    if (!s2)
      return;
    const index = this._series.findIndex((s_) => s_ === s2);
    index >= 0 && this._series.splice(index, 1);
  }
  getSeries(opt = {}) {
    return this._series.filter((s2) => {
      var _a, _b;
      return (!opt.name || (null == s2 ? void 0 : s2.name) === opt.name) && (!opt.userId || array(opt.userId).includes(s2.userId)) && (!isValid_default(opt.specIndex) || array(opt.specIndex).includes(s2.getSpecIndex())) && (!opt.id || s2.id === opt.id) && (!opt.type || s2.type === opt.type) && (!opt.coordinateType || s2.coordinate === opt.coordinateType) && (!opt.dataName || (null === (_b = null === (_a = s2.getRawData) || void 0 === _a ? void 0 : _a.call(s2)) || void 0 === _b ? void 0 : _b.name) === opt.dataName);
    });
  }
  getSeriesInName(name) {
    return this.getSeries({
      name
    })[0];
  }
  getSeriesInUserId(userId) {
    return this.getSeries({
      userId
    })[0];
  }
  getSeriesInId(id2) {
    return this.getSeries({
      id: id2
    })[0];
  }
  getSeriesInType(type) {
    return this.getSeries({
      type
    });
  }
  getSeriesInCoordinateType(coordinateType) {
    return this.getSeries({
      coordinateType
    });
  }
  getSeriesInDataName(dataName) {
    return this.getSeries({
      dataName
    });
  }
  onRender(ctx) {
  }
  initSeriesDataflow() {
    const viewDataFilters = this._series.map((s2) => {
      var _a;
      return null !== (_a = s2.getViewDataFilter()) && void 0 !== _a ? _a : s2.getViewData();
    }).filter((v) => !!v);
    this._option.dataSet.multipleDataViewAddListener(viewDataFilters, "change", this.seriesDataFilterOver);
  }
  release() {
    super.release(), this._series = [];
  }
  createTrigger() {
    const triggerOptions = Object.assign(Object.assign({}, this._option), {
      model: this,
      interaction: this.interaction
    });
    this._trigger = new DimensionTrigger(triggerOptions);
  }
  initTrigger() {
    this._series.forEach((s2) => {
      s2.getMarksWithoutRoot().forEach((m4) => {
        this._trigger.registerMark(m4);
      });
    }), this._trigger.init();
  }
  initInteraction() {
    this._option.disableTriggerEvent || this._series.forEach((s2) => {
      s2.getMarksWithoutRoot().forEach((m4) => {
        for (const key in STATE_VALUE_ENUM_REVERSE)
          isEmpty_default(m4.stateStyle[STATE_VALUE_ENUM_REVERSE[key]]) || this.interaction.registerMark(STATE_VALUE_ENUM_REVERSE[key], m4);
      });
    });
  }
  compileMarks(group) {
    this.getMarks().forEach((m4) => {
      var _a;
      m4.compile({
        group
      }), null === (_a = m4.getProduct()) || void 0 === _a || _a.configure({
        context: {
          model: this
        }
      }).layout((group2, children, parentLayoutBounds, options) => {
      });
    });
  }
  compile() {
    var _a;
    null === (_a = this.animate) || void 0 === _a || _a.compile(), this.compileMarks();
  }
  onLayoutEnd(ctx) {
    this._series.forEach((s2) => s2.onLayoutEnd(ctx)), super.onLayoutEnd(ctx);
  }
};
Region.type = "region", Region.transformerConstructor = RegionSpecTransformer, Region.specKey = "region";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/layout/util
function getPositionItems(items) {
  const startItems = [], middleItems = [], endItems = [];
  return items.forEach((item) => {
    isNil_default(item.getSpec().position) || "start" === item.getSpec().position ? startItems.push(item) : "middle" === item.getSpec().position ? middleItems.push(item) : "end" === item.getSpec().position && endItems.push(item);
  }), {
    startItems,
    endItems,
    middleItems
  };
}
function adjustItemsToCenter(allItems, isVertical3, containerLength) {
  isVertical3 ? allItems.forEach((items) => {
    const lastItem = last(items), length2 = lastItem.getLayoutStartPoint().y + lastItem.getLayoutRect().height - items[0].getLayoutStartPoint().y, centerY = (containerLength - length2) / 2;
    items.forEach((item) => {
      item.setLayoutStartPosition({
        x: item.getLayoutStartPoint().x,
        y: item.getLayoutStartPoint().y + centerY
      });
    });
  }) : allItems.forEach((items) => {
    const lastItem = last(items), length2 = lastItem.getLayoutStartPoint().x + lastItem.getLayoutRect().width - items[0].getLayoutStartPoint().x, centerX = (containerLength - length2) / 2;
    items.forEach((item) => {
      item.setLayoutStartPosition({
        x: item.getLayoutStartPoint().x + centerX,
        y: item.getLayoutStartPoint().y
      });
    });
  });
}
function alignSelfOfItems(allItems, isVertical3, maxSizes, sign3) {
  let maxSize;
  allItems.forEach((lineItems, index) => {
    lineItems.length > 1 && (maxSize = maxSizes[index], lineItems.forEach((item) => {
      if (!item.alignSelf || "start" === item.alignSelf)
        return;
      const pos = item.getLayoutStartPoint(), ratio = "middle" === item.alignSelf ? 0.5 : 1, delta = isVertical3 ? maxSize - (item.getLayoutRect().width + item.layoutPaddingLeft + item.layoutPaddingRight) : maxSize - (item.getLayoutRect().height + item.layoutPaddingTop + item.layoutPaddingBottom);
      isVertical3 ? item.setLayoutStartPosition({
        x: pos.x + sign3 * delta * ratio,
        y: pos.y
      }) : item.setLayoutStartPosition({
        x: pos.x,
        y: pos.y + sign3 * delta * ratio
      });
    }));
  });
}
function layoutLeftRightStartOrMiddleItems(items, layout, limitHeight, isMiddle, position) {
  if (items.length) {
    let maxWidth = 0;
    const isRight = "right" === position, xSign = isRight ? -1 : 1;
    let preX = isRight ? layout.rightCurrent : layout.leftCurrent, preTop = layout.topCurrent;
    const allItems = [];
    let singleLineItems = [];
    const maxWidths = [];
    items.forEach((item) => {
      const layoutRect = layout.getItemComputeLayoutRect(item), rect = item.computeBoundsInRect(layoutRect);
      item.setLayoutRect(rect);
      const itemTotalHeight = rect.height + item.layoutPaddingTop + item.layoutPaddingBottom, itemTotalWidth = rect.width + item.layoutPaddingLeft + item.layoutPaddingRight, itemOffsetX = isRight ? -rect.width - item.layoutPaddingRight : item.layoutPaddingLeft;
      item.setLayoutStartPosition({
        x: preX + item.layoutOffsetX + itemOffsetX,
        y: preTop + item.layoutOffsetY + item.layoutPaddingTop
      }), preTop += itemTotalHeight, preTop > limitHeight && singleLineItems.length ? (maxWidths.push(maxWidth), preX += xSign * maxWidth, maxWidth = itemTotalWidth, preTop = layout.topCurrent + itemTotalHeight, item.setLayoutStartPosition({
        x: preX + item.layoutOffsetX + itemOffsetX,
        y: layout.topCurrent + item.layoutOffsetY + item.layoutPaddingTop
      }), allItems.push(singleLineItems), singleLineItems = [item]) : (maxWidth = Math.max(maxWidth, itemTotalWidth), singleLineItems.push(item));
    }), maxWidths.push(maxWidth), allItems.push(singleLineItems), alignSelfOfItems(allItems, true, maxWidths, xSign), isMiddle && adjustItemsToCenter(allItems, true, limitHeight), isRight ? layout.rightCurrent = preX + xSign * maxWidth : layout.leftCurrent = preX + xSign * maxWidth;
  }
}
function layoutLeftRightEndItems(items, layout, limitWidth, position) {
  if (items.length) {
    let maxWidth = 0;
    const isRight = "right" === position, xSign = isRight ? -1 : 1;
    let preX = isRight ? layout.rightCurrent : layout.leftCurrent, preBottom = layout.bottomCurrent;
    const allItems = [];
    let singleLineItems = [];
    const maxWidths = [];
    items.forEach((item) => {
      const layoutRect = layout.getItemComputeLayoutRect(item), rect = item.computeBoundsInRect(layoutRect);
      item.setLayoutRect(rect);
      const itemTotalHeight = rect.height + item.layoutPaddingTop + item.layoutPaddingBottom, itemTotalWidth = rect.width + item.layoutPaddingLeft + item.layoutPaddingRight, itemOffsetX = isRight ? -rect.width - item.layoutPaddingRight : item.layoutPaddingLeft;
      preBottom < itemTotalHeight && singleLineItems.length ? (maxWidths.push(maxWidth), preX += xSign * maxWidth, maxWidth = itemTotalWidth, preBottom = layout.bottomCurrent, item.setLayoutStartPosition({
        x: preX + item.layoutOffsetX + itemOffsetX,
        y: preBottom + item.layoutOffsetY - rect.height - item.layoutPaddingBottom
      }), allItems.push(singleLineItems), singleLineItems = [item]) : (item.setLayoutStartPosition({
        x: preX + item.layoutOffsetX + itemOffsetX,
        y: preBottom + item.layoutOffsetY - rect.height - item.layoutPaddingBottom
      }), maxWidth = Math.max(maxWidth, itemTotalWidth), preBottom -= itemTotalHeight, singleLineItems.push(item));
    }), maxWidths.push(maxWidth), allItems.push(singleLineItems), alignSelfOfItems(allItems, true, maxWidths, xSign), isRight ? layout.rightCurrent = preX + xSign * maxWidth : layout.leftCurrent = preX + xSign * maxWidth;
  }
}
function layoutTopBottomStartOrMiddleItems(items, layout, limitWidth, isMiddle, position) {
  if (items.length) {
    const isTop = "top" === position, ySign = isTop ? 1 : -1;
    let maxHeight = 0, preLeft = layout.leftCurrent, preY = isTop ? layout.topCurrent : layout.bottomCurrent;
    const allItems = [];
    let singleLineItems = [];
    const maxHeights = [];
    items.forEach((item) => {
      const layoutRect = layout.getItemComputeLayoutRect(item), rect = item.computeBoundsInRect(layoutRect);
      item.setLayoutRect(rect);
      const itemTotalHeight = rect.height + item.layoutPaddingTop + item.layoutPaddingBottom, itemTotalWidth = rect.width + item.layoutPaddingLeft + item.layoutPaddingRight, itemOffsetY = isTop ? item.layoutPaddingTop : -rect.height - item.layoutPaddingBottom;
      item.setLayoutStartPosition({
        x: preLeft + item.layoutOffsetX + item.layoutPaddingLeft,
        y: preY + item.layoutOffsetY + itemOffsetY
      }), preLeft += itemTotalWidth, preLeft > limitWidth && singleLineItems.length ? (maxHeights.push(maxHeight), preLeft = layout.leftCurrent + itemTotalWidth, preY += ySign * maxHeight, maxHeight = itemTotalHeight, item.setLayoutStartPosition({
        x: layout.leftCurrent + item.layoutOffsetX + item.layoutPaddingLeft,
        y: preY + item.layoutOffsetY + itemOffsetY
      }), allItems.push(singleLineItems), singleLineItems = [item]) : (maxHeight = Math.max(maxHeight, itemTotalHeight), singleLineItems.push(item));
    }), maxHeights.push(maxHeight), allItems.push(singleLineItems), alignSelfOfItems(allItems, false, maxHeights, ySign), isMiddle && adjustItemsToCenter(allItems, false, limitWidth), isTop ? layout.topCurrent = preY + ySign * maxHeight : layout.bottomCurrent = preY + ySign * maxHeight;
  }
}
function layoutTopBottomEndItems(items, layout, limitWidth, position) {
  if (items.length) {
    const isTop = "top" === position, ySign = isTop ? 1 : -1;
    let maxHeight = 0, preRight = layout.rightCurrent, preY = isTop ? layout.topCurrent : layout.bottomCurrent;
    const allItems = [];
    let singleLineItems = [];
    const maxHeights = [];
    items.forEach((item) => {
      const layoutRect = layout.getItemComputeLayoutRect(item), rect = item.computeBoundsInRect(layoutRect);
      item.setLayoutRect(rect);
      const itemTotalHeight = rect.height + item.layoutPaddingTop + item.layoutPaddingBottom, itemTotalWidth = rect.width + item.layoutPaddingLeft + item.layoutPaddingRight, itemOffsetY = isTop ? item.layoutPaddingTop : -rect.height - item.layoutPaddingBottom;
      preRight < itemTotalWidth && singleLineItems.length ? (preRight = layout.rightCurrent, preY += ySign * maxHeight, maxHeight = itemTotalHeight, item.setLayoutStartPosition({
        x: layout.rightCurrent + item.layoutOffsetX - rect.width - item.layoutPaddingRight,
        y: preY + item.layoutOffsetY + itemOffsetY
      }), allItems.push(singleLineItems), singleLineItems = [item]) : (singleLineItems.push(item), item.setLayoutStartPosition({
        x: preRight + item.layoutOffsetX - rect.width - item.layoutPaddingRight,
        y: preY + item.layoutOffsetY + itemOffsetY
      }), maxHeight = Math.max(maxHeight, itemTotalHeight), preRight -= itemTotalWidth);
    }), maxHeights.push(maxHeight), allItems.push(singleLineItems), alignSelfOfItems(allItems, false, maxHeights, ySign), isTop ? layout.topCurrent = preY + ySign * maxHeight : layout.bottomCurrent = preY + ySign * maxHeight;
  }
}
function layoutLeftInlineItems(items, layout, limitHeight) {
  const { startItems, middleItems, endItems } = getPositionItems(items);
  startItems.length && layoutLeftRightStartOrMiddleItems(startItems, layout, limitHeight, false, "left"), middleItems.length && layoutLeftRightStartOrMiddleItems(middleItems, layout, limitHeight, true, "left"), endItems.length && layoutLeftRightEndItems(endItems, layout, limitHeight, "left");
}
function layoutRightInlineItems(items, layout, limitHeight) {
  const { startItems, middleItems, endItems } = getPositionItems(items);
  startItems.length && layoutLeftRightStartOrMiddleItems(startItems, layout, limitHeight, false, "right"), middleItems.length && layoutLeftRightStartOrMiddleItems(middleItems, layout, limitHeight, true, "right"), endItems.length && layoutLeftRightEndItems(endItems, layout, limitHeight, "right");
}
function layoutTopInlineItems(items, layout, limitWidth) {
  const { startItems, middleItems, endItems } = getPositionItems(items);
  startItems.length && layoutTopBottomStartOrMiddleItems(startItems, layout, limitWidth, false, "top"), middleItems.length && layoutTopBottomStartOrMiddleItems(middleItems, layout, limitWidth, true, "top"), endItems.length && layoutTopBottomEndItems(endItems, layout, limitWidth, "top");
}
function layoutBottomInlineItems(items, layout, limitWidth) {
  const { startItems, middleItems, endItems } = getPositionItems(items);
  startItems.length && layoutTopBottomStartOrMiddleItems(startItems, layout, limitWidth, false, "bottom"), middleItems.length && layoutTopBottomStartOrMiddleItems(middleItems, layout, limitWidth, true, "bottom"), endItems.length && layoutTopBottomEndItems(endItems, layout, limitWidth, "bottom");
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/layout/base-layout
var Layout = class {
  constructor(_spec, ctx) {
    this.leftCurrent = 0, this.topCurrent = 0, this.rightCurrent = 0, this.bottomCurrent = 0, this._onError = null == ctx ? void 0 : ctx.onError;
  }
  _layoutInit(_chart, items, chartLayoutRect, chartViewBox) {
    this._chartLayoutRect = chartLayoutRect, this._chartViewBox = chartViewBox, this.leftCurrent = chartLayoutRect.x, this.topCurrent = chartLayoutRect.y, this.rightCurrent = chartLayoutRect.x + chartLayoutRect.width, this.bottomCurrent = chartLayoutRect.height + chartLayoutRect.y, items.sort((a3, b) => b.layoutLevel - a3.layoutLevel);
  }
  _layoutNormalItems(items) {
    this.layoutNormalInlineItems(items.filter((x) => "normal-inline" === x.layoutType)), this.layoutNormalItems(items.filter((x) => "normal" === x.layoutType));
  }
  _groupItems(items) {
    const regionItems = items.filter((x) => "region" === x.layoutType), relativeItems = items.filter((x) => "region-relative" === x.layoutType), relativeOverlapItems = items.filter((x) => "region-relative-overlap" === x.layoutType), allRelatives = relativeItems.concat(relativeOverlapItems), overlapItems = {
      left: {
        items: [],
        rect: {
          width: 0,
          height: 0
        }
      },
      right: {
        items: [],
        rect: {
          width: 0,
          height: 0
        }
      },
      top: {
        items: [],
        rect: {
          width: 0,
          height: 0
        }
      },
      bottom: {
        items: [],
        rect: {
          width: 0,
          height: 0
        }
      },
      z: {
        items: [],
        rect: {
          width: 0,
          height: 0
        }
      }
    };
    return relativeOverlapItems.forEach((i) => {
      overlapItems[i.layoutOrient].items.push(i);
    }), {
      regionItems,
      relativeItems,
      relativeOverlapItems,
      allRelatives,
      overlapItems
    };
  }
  layoutItems(_chart, items, chartLayoutRect, chartViewBox) {
    this._layoutInit(_chart, items, chartLayoutRect, chartViewBox), this._layoutNormalItems(items);
    const layoutTemp = {
      left: this.leftCurrent,
      top: this.topCurrent,
      right: this.rightCurrent,
      bottom: this.bottomCurrent
    }, { regionItems, relativeItems, relativeOverlapItems, allRelatives, overlapItems } = this._groupItems(items);
    this.layoutRegionItems(regionItems, relativeItems, relativeOverlapItems, overlapItems), this._processAutoIndent(regionItems, relativeItems, relativeOverlapItems, overlapItems, allRelatives, layoutTemp), this.layoutAbsoluteItems(items.filter((x) => "absolute" === x.layoutType));
  }
  _processAutoIndent(regionItems, relativeItems, relativeOverlapItems, overlapItems = {
    left: {
      items: [],
      rect: {
        width: 0,
        height: 0
      }
    },
    right: {
      items: [],
      rect: {
        width: 0,
        height: 0
      }
    },
    top: {
      items: [],
      rect: {
        width: 0,
        height: 0
      }
    },
    bottom: {
      items: [],
      rect: {
        width: 0,
        height: 0
      }
    },
    z: {
      items: [],
      rect: {
        width: 0,
        height: 0
      }
    }
  }, allRelatives, layoutTemp) {
    if (allRelatives.some((i) => i.autoIndent)) {
      const { top, bottom, left: left2, right: right2 } = this._checkAutoIndent(allRelatives, layoutTemp);
      (top || bottom || left2 || right2) && (this.topCurrent = layoutTemp.top + top, this.bottomCurrent = layoutTemp.bottom - bottom, this.leftCurrent = layoutTemp.left + left2, this.rightCurrent = layoutTemp.right - right2, this.layoutRegionItems(regionItems, relativeItems, relativeOverlapItems, overlapItems));
    }
  }
  layoutNormalItems(normalItems) {
    normalItems.forEach((item) => {
      const layoutRect = this.getItemComputeLayoutRect(item), rect = item.computeBoundsInRect(layoutRect);
      item.setLayoutRect(rect), "left" === item.layoutOrient ? (item.setLayoutStartPosition({
        x: this.leftCurrent + item.layoutOffsetX + item.layoutPaddingLeft,
        y: this.topCurrent + item.layoutOffsetY + item.layoutPaddingTop
      }), this.leftCurrent += rect.width + item.layoutPaddingLeft + item.layoutPaddingRight) : "top" === item.layoutOrient ? (item.setLayoutStartPosition({
        x: this.leftCurrent + item.layoutOffsetX + item.layoutPaddingLeft,
        y: this.topCurrent + item.layoutOffsetY + item.layoutPaddingTop
      }), this.topCurrent += rect.height + item.layoutPaddingTop + item.layoutPaddingBottom) : "right" === item.layoutOrient ? (item.setLayoutStartPosition({
        x: this.rightCurrent + item.layoutOffsetX - rect.width - item.layoutPaddingRight,
        y: this.topCurrent + item.layoutOffsetY + item.layoutPaddingTop
      }), this.rightCurrent -= rect.width + item.layoutPaddingLeft + item.layoutPaddingRight) : "bottom" === item.layoutOrient && (item.setLayoutStartPosition({
        x: this.leftCurrent + item.layoutOffsetX + item.layoutPaddingRight,
        y: this.bottomCurrent + item.layoutOffsetY - rect.height - item.layoutPaddingBottom
      }), this.bottomCurrent -= rect.height + item.layoutPaddingTop + item.layoutPaddingBottom);
    });
  }
  layoutNormalInlineItems(normalItems) {
    const leftItems = normalItems.filter((item) => "left" === item.layoutOrient), rightItems = normalItems.filter((item) => "right" === item.layoutOrient), topItems = normalItems.filter((item) => "top" === item.layoutOrient), bottomItems = normalItems.filter((item) => "bottom" === item.layoutOrient), limitWidth = this._chartLayoutRect.width + this._chartLayoutRect.x, limitHeight = this._chartLayoutRect.height + this._chartLayoutRect.y;
    leftItems.length && layoutLeftInlineItems(leftItems, this, limitHeight), topItems.length && layoutTopInlineItems(topItems, this, limitWidth), rightItems.length && layoutRightInlineItems(rightItems, this, limitHeight), bottomItems.length && layoutBottomInlineItems(bottomItems, this, limitWidth);
  }
  _layoutRelativeOverlap(orient, info) {
    info.items.forEach((item) => {
      const layoutRect = this.getItemComputeLayoutRect(item), rect = item.computeBoundsInRect(layoutRect);
      info.rect.width = Math.max(rect.width + item.layoutPaddingLeft + item.layoutPaddingRight, info.rect.width), info.rect.height = Math.max(rect.height + item.layoutPaddingTop + item.layoutPaddingBottom, info.rect.height);
    }), info.items.forEach((item) => {
      item.setLayoutRect(info.rect), "left" === orient ? item.setLayoutStartPosition({
        x: this.leftCurrent + item.layoutOffsetX
      }) : "right" === orient ? item.setLayoutStartPosition({
        x: this.rightCurrent - info.rect.width + item.layoutOffsetX
      }) : "top" === orient ? item.setLayoutStartPosition({
        x: this.topCurrent + item.layoutOffsetY
      }) : item.setLayoutStartPosition({
        x: this.bottomCurrent - info.rect.height + item.layoutOffsetY
      });
    }), "left" === orient ? this.leftCurrent += info.rect.width : "right" === orient ? this.rightCurrent -= info.rect.width : "top" === orient ? this.topCurrent += info.rect.height : this.bottomCurrent -= info.rect.height;
  }
  _layoutRelativeItem(item, layoutRect) {
    const rect = item.computeBoundsInRect(layoutRect);
    "left" === item.layoutOrient || "right" === item.layoutOrient ? item.setLayoutRect({
      width: rect.width
    }) : item.setLayoutRect({
      height: rect.height
    }), "left" === item.layoutOrient ? (item.setLayoutStartPosition({
      x: this.leftCurrent + item.layoutOffsetX + item.layoutPaddingLeft
    }), this.leftCurrent += rect.width + item.layoutPaddingLeft + item.layoutPaddingRight) : "right" === item.layoutOrient ? (this.rightCurrent -= rect.width + item.layoutPaddingLeft + item.layoutPaddingRight, item.setLayoutStartPosition({
      x: this.rightCurrent + item.layoutOffsetX + item.layoutPaddingLeft
    })) : "top" === item.layoutOrient ? (item.setLayoutStartPosition({
      y: this.topCurrent + item.layoutOffsetY + item.layoutPaddingTop
    }), this.topCurrent += rect.height + item.layoutPaddingTop + item.layoutPaddingBottom) : "bottom" === item.layoutOrient && (this.bottomCurrent -= rect.height + item.layoutPaddingTop + item.layoutPaddingBottom, item.setLayoutStartPosition({
      y: this.bottomCurrent + item.layoutOffsetY + item.layoutPaddingTop
    }));
  }
  _layoutRegionItem(regionItems, regionRelativeTotalWidth, regionRelativeTotalHeight) {
    const regionWidth = Math.max(Math.min(regionRelativeTotalWidth, ...regionItems.map((region) => {
      var _a;
      return null !== (_a = region.maxWidth) && void 0 !== _a ? _a : Number.MAX_VALUE;
    })), 0), regionHeight = Math.max(Math.min(regionRelativeTotalHeight, ...regionItems.map((region) => {
      var _a;
      return null !== (_a = region.maxHeight) && void 0 !== _a ? _a : Number.MAX_VALUE;
    })), 0);
    return regionItems.forEach((region) => {
      region.setLayoutRect({
        width: regionWidth,
        height: regionHeight
      }), region.setLayoutStartPosition({
        x: this.leftCurrent + region.layoutOffsetX + region.layoutPaddingLeft,
        y: this.topCurrent + region.layoutOffsetY + region.layoutPaddingTop
      });
    }), {
      regionHeight,
      regionWidth
    };
  }
  layoutRegionItems(regionItems, regionRelativeItems, regionRelativeOverlapItems, overlapItems = {
    left: {
      items: [],
      rect: {
        width: 0,
        height: 0
      }
    },
    right: {
      items: [],
      rect: {
        width: 0,
        height: 0
      }
    },
    top: {
      items: [],
      rect: {
        width: 0,
        height: 0
      }
    },
    bottom: {
      items: [],
      rect: {
        width: 0,
        height: 0
      }
    },
    z: {
      items: [],
      rect: {
        width: 0,
        height: 0
      }
    }
  }) {
    let regionRelativeTotalWidth = this.rightCurrent - this.leftCurrent, regionRelativeTotalHeight = this.bottomCurrent - this.topCurrent;
    regionRelativeItems.filter((x) => "left" === x.layoutOrient || "right" === x.layoutOrient).forEach((item) => {
      this._layoutRelativeItem(item, this.getItemComputeLayoutRect(item));
    }), this._layoutRelativeOverlap("left", overlapItems.left), this._layoutRelativeOverlap("right", overlapItems.right), regionRelativeTotalWidth = this.rightCurrent - this.leftCurrent, regionRelativeItems.filter((x) => "top" === x.layoutOrient || "bottom" === x.layoutOrient).forEach((item) => {
      this._layoutRelativeItem(item, this.getItemComputeLayoutRect(item));
    }), this._layoutRelativeOverlap("top", overlapItems.top), this._layoutRelativeOverlap("bottom", overlapItems.bottom), regionRelativeTotalHeight = this.bottomCurrent - this.topCurrent;
    const { regionWidth, regionHeight } = this._layoutRegionItem(regionItems, regionRelativeTotalWidth, regionRelativeTotalHeight);
    regionRelativeItems.concat(regionRelativeOverlapItems).forEach((item) => {
      if (["left", "right"].includes(item.layoutOrient)) {
        const relativeRegion = this.filterRegionsWithID(regionItems, item.layoutBindRegionID[0]);
        item.setLayoutRect({
          height: relativeRegion.getLayoutRect().height
        }), item.setLayoutStartPosition({
          y: relativeRegion.getLayoutStartPoint().y + item.layoutOffsetY + item.layoutPaddingTop
        }), "right" === item.layoutOrient && item.setLayoutStartPosition({
          x: item.getLayoutStartPoint().x + regionWidth - regionRelativeTotalWidth
        });
      } else if (["top", "bottom"].includes(item.layoutOrient)) {
        const relativeRegion = this.filterRegionsWithID(regionItems, item.layoutBindRegionID[0]);
        item.setLayoutRect({
          width: relativeRegion.getLayoutRect().width
        }), item.setLayoutStartPosition({
          x: relativeRegion.getLayoutStartPoint().x + item.layoutOffsetX + item.layoutPaddingLeft
        }), "bottom" === item.layoutOrient && item.setLayoutStartPosition({
          y: item.getLayoutStartPoint().y + regionHeight - regionRelativeTotalHeight
        });
      }
    });
  }
  layoutAbsoluteItems(absoluteItems) {
    absoluteItems.forEach((item) => {
      item.absoluteLayoutInRect(this._chartLayoutRect);
    });
  }
  filterRegionsWithID(items, id2) {
    var _a;
    const target = items.find((x) => x.getModelId() === id2);
    return target || (null !== (_a = this._onError) && void 0 !== _a ? _a : error)("can not find target region item, invalid id"), target;
  }
  getItemComputeLayoutRect(item) {
    return {
      width: this.rightCurrent - this.leftCurrent - item.layoutPaddingLeft - item.layoutPaddingRight,
      height: this.bottomCurrent - this.topCurrent - item.layoutPaddingTop - item.layoutPaddingBottom
    };
  }
  _checkAutoIndent(items, layoutTemp) {
    const result2 = {
      top: 0,
      left: 0,
      bottom: 0,
      right: 0
    };
    return items.forEach((i) => {
      if (!i.getModelVisible() || !i.autoIndent)
        return;
      const vOrH = "left" === i.layoutOrient || "right" === i.layoutOrient, itemOuter = i.getLastComputeOutBounds(), outer = this._getOutInLayout(itemOuter, i, layoutTemp);
      vOrH ? (result2.top = Math.max(result2.top, outer.top), result2.bottom = Math.max(result2.bottom, outer.bottom)) : (result2.left = Math.max(result2.left, outer.left), result2.right = Math.max(result2.right, outer.right));
    }), result2;
  }
  _getOutInLayout(itemOuter, i, tempBorder) {
    const { x, y } = i.getLayoutStartPoint(), { width, height } = i.getLayoutRect();
    return {
      left: tempBorder.left - (x - itemOuter.x1),
      right: x + width + itemOuter.x2 - tempBorder.right,
      top: tempBorder.top - (y - itemOuter.y1),
      bottom: y + height + itemOuter.y2 - tempBorder.bottom
    };
  }
};
Layout.type = "base";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/mark/utils/common
var MultiDatumMark = ["line", "area", "trail"];
function isMultiDatumMark(type) {
  return MultiDatumMark.includes(type);
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/compile/mark/mark-state-manager
var MarkStateManager = class extends StateManager {
  getStateInfoList() {
    return this._stateInfoList;
  }
  constructor(option, mark) {
    super(option), this._stateInfoList = [], this._mark = mark;
  }
  _getDefaultStateMap() {
    return {
      markUpdateRank: 1
    };
  }
  getStateInfo(stateValue) {
    return this._stateInfoList.find((s2) => s2.stateValue === stateValue);
  }
  addStateInfo(stateInfo) {
    if (this.getStateInfo(stateInfo.stateValue))
      return;
    stateInfo.level = stateInfo.level || 0;
    let needPush = true;
    for (let i = 0; i < this._stateInfoList.length; i++) {
      const level = this._stateInfoList[i].level;
      if (level && level > stateInfo.level) {
        this._stateInfoList.splice(i, 0, stateInfo), needPush = false;
        break;
      }
    }
    needPush && this._stateInfoList.push(stateInfo);
  }
  _clearStateBeforeSet(state) {
    state.datums = null, state.items = null, state.fields = null, state.filter = null;
  }
  changeStateInfo(stateInfo) {
    const s2 = this.getStateInfo(stateInfo.stateValue);
    if (s2) {
      if (void 0 !== stateInfo.datums && (this._clearStateBeforeSet(s2), s2.datums = stateInfo.datums, s2.datumKeys = stateInfo.datumKeys), void 0 !== stateInfo.items && (this._clearStateBeforeSet(s2), s2.items = stateInfo.items), void 0 !== stateInfo.fields)
        if (this._clearStateBeforeSet(s2), null === stateInfo.fields)
          s2.fields = stateInfo.fields;
        else {
          s2.fields = s2.fields || {};
          for (const key in stateInfo.fields) {
            const new_f = stateInfo.fields[key];
            s2.fields[key] = s2.fields[key] || {};
            const old_f = s2.fields[key];
            isValid_default(new_f.domain) && (old_f.domain = new_f.domain), isValid_default(new_f.type) && (old_f.type = new_f.type);
          }
        }
      stateInfo.filter && (this._clearStateBeforeSet(s2), s2.filter = stateInfo.filter);
    } else
      this.addStateInfo(stateInfo);
  }
  clearStateInfo(stateValues) {
    stateValues.forEach((stateValue) => {
      this.getStateInfo(stateValue) && this.changeStateInfo({
        stateValue,
        datumKeys: null,
        datums: null,
        fields: null,
        items: null,
        filter: null,
        cache: {}
      });
    });
  }
  checkOneState(renderNode, datum, state, isMultiMark) {
    var _a;
    isMultiMark = isBoolean_default(isMultiDatumMark) ? isMultiMark : !renderNode.mark || isMultiDatumMark(renderNode.mark.markType);
    let inState = false, stateChecked = false;
    if (isValid_default(state.datums) && state.datums.length > 0)
      inState = this.checkDatumState(state, datum, isMultiMark), stateChecked = true;
    else if (state.items)
      inState = null !== (_a = this.checkItemsState(state, renderNode)) && void 0 !== _a && _a, stateChecked = true;
    else if (state.fields)
      inState = this.checkFieldsState(state, datum, renderNode, isMultiMark), stateChecked = true;
    else if (!inState && state.filter) {
      const options = {
        mark: this._mark,
        renderNode,
        type: renderNode.mark.markType
      };
      inState = state.filter(datum, options), stateChecked = true;
    }
    return stateChecked ? inState ? "in" : "out" : "skip";
  }
  checkState(renderNode, datum) {
    const result2 = renderNode.getStates().filter((s2) => stateInDefaultEnum(s2)).map((s2) => [s2, 10]), isMultiMark = !renderNode.mark || isMultiDatumMark(renderNode.mark.markType);
    for (let i = 0; i < this._stateInfoList.length; i++) {
      const state = this._stateInfoList[i], inOut = this.checkOneState(renderNode, datum, state, isMultiMark);
      "skip" !== inOut && ("in" === inOut && result2.push([state.stateValue, state.level]));
    }
    return result2.map((res) => res[0]);
  }
  checkDatumState(state, datum, isMultiMark) {
    let inState = false;
    const datum_v = isMultiMark ? datum[0] : datum;
    if (isArray_default(state.datums)) {
      const keys2 = state.datumKeys || Object.keys(state.datums[0]).filter((k2) => !k2.startsWith(PREFIX));
      inState = state.datums.some((d) => isMultiMark && isArray_default(null == d ? void 0 : d.items) ? keys2.every((k2) => {
        var _a, _b;
        return (null === (_b = null === (_a = null == d ? void 0 : d.items) || void 0 === _a ? void 0 : _a[0]) || void 0 === _b ? void 0 : _b[k2]) === (null == datum_v ? void 0 : datum_v[k2]);
      }) : keys2.every((k2) => (null == d ? void 0 : d[k2]) === (null == datum_v ? void 0 : datum_v[k2])));
    } else if (isObject_default(state.datums)) {
      inState = (state.datumKeys || Object.keys(state.datums).filter((k2) => !k2.startsWith(PREFIX))).every((k2) => {
        var _a, _b;
        return isMultiMark ? (null === (_a = state.datums.items) || void 0 === _a ? void 0 : _a[0][k2]) === datum_v[k2] : (null === (_b = state.datums) || void 0 === _b ? void 0 : _b[k2]) === datum_v[k2];
      });
    } else
      inState = datum === state.datums;
    return inState;
  }
  checkItemsState(state, item) {
    var _a;
    return null === (_a = state.items) || void 0 === _a ? void 0 : _a.includes(item);
  }
  checkFieldsState(state, datum, item, isMultiMark) {
    var _a;
    let inState = true;
    for (const key in state.fields) {
      const field3 = state.fields[key], type = field3.type, domain = field3.domain, datum_v = isMultiMark ? null === (_a = datum[0]) || void 0 === _a ? void 0 : _a[key] : datum[key];
      if (isContinuous(type) && domain.length > 1) {
        if (this.checkLinearFieldState(domain, key, datum, item, isMultiMark)) {
          inState = false;
          break;
        }
        inState = true;
      } else {
        if (!domain.some((d) => d === datum_v)) {
          inState = false;
          break;
        }
        inState = true;
      }
    }
    return inState;
  }
  checkLinearFieldState(domain, key, datum, item, isMultiMark) {
    var _a;
    const datum_v = isMultiMark ? null === (_a = datum[0]) || void 0 === _a ? void 0 : _a[key] : datum[key];
    return datum_v < domain[0] || datum_v > domain[domain.length - 1];
  }
  updateLayoutState(noRender) {
    return this._stateMap.markUpdateRank++, this.updateState({
      markUpdateRank: this._stateMap.markUpdateRank
    }, noRender);
  }
  compileState(product, stateSort) {
    product.state({
      callback: (datum, element) => this.checkState(element, datum)
    }, stateSort);
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/compile/data/compilable-data
var CompilableData = class extends GrammarItem {
  getDataView() {
    return this._data;
  }
  setDataView(d) {
    this._data = d;
  }
  getLatestData() {
    var _a;
    return null === (_a = this._data) || void 0 === _a ? void 0 : _a.latestData;
  }
  constructor(option, dataView) {
    super(option), this.grammarType = GrammarType.data, this._data = null, this._data = dataView;
  }
  release() {
    super.release(), this._data = null;
  }
  updateData(noRender) {
    const product = this.getProduct(), data = this.getLatestData();
    if (product && data && (product.values(data), !noRender))
      return this.getCompiler().renderNextTick();
  }
  _compileProduct() {
    const data = this.getLatestData();
    isNil_default(data) || (isNil_default(this.getProduct()) ? this._initProduct(data) : this._product.values(data));
  }
  _initProduct(data) {
    var _a, _b;
    const view = this.getVGrammarView();
    if (!view || !data)
      return;
    const id2 = this.getProductId();
    this._product = null === (_b = null === (_a = null == view ? void 0 : view.data) || void 0 === _a ? void 0 : _a.call(view, data)) || void 0 === _b ? void 0 : _b.id(id2), this._compiledProductId = id2;
  }
  generateProductId() {
    var _a;
    return `${null === (_a = this.getDataView()) || void 0 === _a ? void 0 : _a.name}`;
  }
  _lookupGrammar(id2) {
    var _a, _b;
    return null === (_b = null === (_a = this.getCompiler().getVGrammarView()) || void 0 === _a ? void 0 : _a.getDataById) || void 0 === _b ? void 0 : _b.call(_a, id2);
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/compile/mark/mark-data
var MarkData = class extends CompilableData {
  constructor(option) {
    super(option), this._mark = option.mark;
  }
  setCompiledProductId(name) {
    this._compiledProductId = name;
  }
  generateProductId() {
    const name = super.generateProductId();
    return isValid_default(name) ? name : `${PREFIX}_markData_${this._mark.id}`;
  }
  _compileProduct() {
    var _a;
    const data = null === (_a = this._data) || void 0 === _a ? void 0 : _a.latestData;
    isNil_default(data) || isValid_default(this.getProduct()) || this._initProduct(data);
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/compile/mark/compilable-mark
var __rest7 = function(s2, e) {
  var t = {};
  for (var p in s2)
    Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++)
      e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var CompilableMark = class extends GrammarItem {
  getSkipTheme() {
    return this._skipTheme;
  }
  setSkipTheme(skipTheme) {
    this._skipTheme = skipTheme;
  }
  getSupport3d() {
    return this._support3d;
  }
  setSupport3d(support3d) {
    this._support3d = support3d;
  }
  getFacet() {
    return this._facet;
  }
  setFacet(facet) {
    this._facet = facet;
  }
  getInteractive() {
    return this._interactive;
  }
  setInteractive(interactive) {
    this._interactive = interactive;
  }
  getZIndex() {
    return this._zIndex;
  }
  setZIndex(zIndex) {
    this._zIndex = zIndex;
  }
  getVisible() {
    return this._visible;
  }
  setVisible(visible) {
    this._visible = visible;
  }
  getUserId() {
    return this._userId;
  }
  setUserId(userId) {
    isValid_default(userId) && (this._userId = userId);
  }
  getDataView() {
    var _a;
    return null === (_a = this._data) || void 0 === _a ? void 0 : _a.getDataView();
  }
  setDataView(d, productId) {
    isNil_default(this._data) && this.initMarkData(Object.assign(Object.assign({}, this._option), {
      mark: this
    })), isValid_default(productId) && this._data.setCompiledProductId(productId), this._data.setDataView(d);
  }
  getData() {
    return this._data;
  }
  setData(d) {
    this._data = d;
  }
  hasState(state) {
    return state in this.state.getStateMap();
  }
  getState(state) {
    return this.state.getStateMap()[state];
  }
  getAnimationConfig() {
    return this._animationConfig;
  }
  setAnimationConfig(config2) {
    this._animationConfig = config2;
  }
  setSkipBeforeLayouted(skip) {
    this._skipBeforeLayouted = skip;
  }
  getSkipBeforeLayouted() {
    return this._skipBeforeLayouted;
  }
  getMorph() {
    return this._morph;
  }
  setMorph(morph) {
    this._morph = morph;
  }
  getMorphKey() {
    return this._morphKey;
  }
  setMorphKey(morphKey) {
    this._morphKey = morphKey;
  }
  getMorphElementKey() {
    return this._morphElementKey;
  }
  setMorphElementKey(key) {
    this._morphElementKey = key;
  }
  getGroupKey() {
    return this._groupKey;
  }
  setGroupKey(groupKey) {
    this._groupKey = groupKey;
  }
  getProgressiveConfig() {
    return this._progressiveConfig;
  }
  setProgressiveConfig(config2) {
    this._progressiveConfig = config2;
  }
  setCustomizedShapeCallback(callback) {
    this._setCustomizedShape = callback;
  }
  setEnableSegments(enable) {
    this._enableSegments = enable;
  }
  getClip() {
    return this._clip;
  }
  setClip(clip) {
    this._clip = clip;
  }
  setStateSortCallback(stateSort) {
    this._stateSort = stateSort;
  }
  constructor(option, name, model) {
    super(option), this.grammarType = GrammarType.mark, this.type = void 0, this.name = "mark", this._interactive = true, this._zIndex = LayoutZIndex.Mark, this._visible = true, this.stateStyle = {}, this._unCompileChannel = {}, this._skipBeforeLayouted = false, this._morph = false, this.name = name, this.model = model, this.key = option.key, this.state = new MarkStateManager(Object.assign(Object.assign({}, option), {
      stateKeyToSignalName: this.stateKeyToSignalName.bind(this)
    }), this), this._option.support3d && this.setSupport3d(true), this._option.skipTheme && this.setSkipTheme(true), this._event = new Event2(model.getOption().eventDispatcher, model.getOption().mode);
  }
  setTransform(transform5) {
    this._transform = transform5;
  }
  initMarkData(option) {
    this._data = new MarkData(option);
  }
  stateKeyToSignalName(key) {
    return `${PREFIX}_${this.type}_${this.id}_${key}`;
  }
  getAttribute(key, datum, state, opt) {
  }
  _compileProduct(option) {
    const product = this.getProduct();
    if (!this.getVisible())
      return void (isValid_default(product) && this.removeProduct());
    if (isValid_default(product))
      return;
    this.getCompiler().isInited && (this._initProduct(null == option ? void 0 : option.group), isNil_default(this._product) || (this.compileSignal(), this.compileData(), this.compileState(), this.compileEncode(), this.compileAnimation(), this.compileContext(), this.compileTransform()));
  }
  _initProduct(group) {
    const view = this.getVGrammarView(), id2 = this.getProductId();
    this._product = view.mark(this.type, null != group ? group : view.rootMark).id(id2), this._compiledProductId = id2;
  }
  generateProductId() {
    return this._userId ? `${this._userId}` : `${this.name}_${this.id}`;
  }
  compileData() {
    var _a;
    if (isNil_default(this._data))
      return;
    this._data.compile();
    const dataProduct = this._data.getProduct();
    isValid_default(this._product) && isValid_default(dataProduct) && this._product.join(dataProduct, this.key, void 0, null !== (_a = this._groupKey) && void 0 !== _a ? _a : this._facet);
  }
  updateStaticEncode() {
    if (!this._product)
      return;
    const { enterStyles, updateStyles } = this._separateStyle();
    this._product.encodeState("group", enterStyles, true), this._product.encode(updateStyles, true);
  }
  _separateStyle() {
    const _a = this.stateStyle, _b = STATE_VALUE_ENUM.STATE_NORMAL, normalStyle = _a[_b], enterStyles = (__rest7(_a, ["symbol" == typeof _b ? _b : _b + ""]), this._option.noSeparateStyle ? null : {}), updateStyles = {};
    return Object.keys(normalStyle).forEach((key) => {
      this._unCompileChannel[key] || (this._option.noSeparateStyle || isStateAttrChangeable(key, normalStyle, this.getFacet()) ? updateStyles[key] = {
        callback: this.compileCommonAttributeCallback(key, "normal"),
        dependency: [this.stateKeyToSignalName("markUpdateRank")]
      } : enterStyles[key] = this.compileCommonAttributeCallback(key, "normal"));
    }), {
      enterStyles,
      updateStyles
    };
  }
  compileEncode() {
    const _a = this.stateStyle, _b = STATE_VALUE_ENUM.STATE_NORMAL, temp3 = (_a[_b], __rest7(_a, ["symbol" == typeof _b ? _b : _b + ""])), { enterStyles, updateStyles } = this._separateStyle();
    this._product.encode(updateStyles, true), this._product.encodeState("group", enterStyles, true), Object.keys(temp3).forEach((state) => {
      const styles = {};
      Object.keys(temp3[state]).forEach((key) => {
        this._unCompileChannel[key] || (styles[key] = {
          callback: this.compileCommonAttributeCallback(key, state),
          dependency: [this.stateKeyToSignalName("markUpdateRank")]
        });
      }), this._product.encodeState(state, styles, true);
    }), this._skipBeforeLayouted && this._product.layout({
      skipBeforeLayouted: this._skipBeforeLayouted
    });
  }
  compileState() {
    this.state.compileState(this._product, this._stateSort);
  }
  compileAnimation() {
    var _a, _b, _c, _d;
    if (this._animationConfig) {
      let stateSignal;
      if ("component" === this.type)
        stateSignal = null === (_a = this.model.animate) || void 0 === _a ? void 0 : _a.getAnimationStateSignalName();
      else {
        const region = null === (_c = (_b = this.model).getRegion) || void 0 === _c ? void 0 : _c.call(_b);
        stateSignal = null === (_d = null == region ? void 0 : region.animate) || void 0 === _d ? void 0 : _d.getAnimationStateSignalName();
      }
      this._product.animation(this._animationConfig), this._product.animationState({
        callback: (datum, element, parameters) => {
          var _a2;
          return null === (_a2 = parameters[stateSignal]) || void 0 === _a2 ? void 0 : _a2.callback(datum, element);
        },
        dependency: stateSignal
      }), this._animationConfig.normal && this._event.on(HOOK_EVENT.ANIMATION_END, ({ event }) => {
        event.mark === this.getProduct() && event.animationState === AnimationStateEnum.appear && this.runAnimationByState(AnimationStateEnum.normal);
      });
    }
  }
  compileContext() {
    const config2 = {
      interactive: this.getInteractive(),
      zIndex: this.getZIndex(),
      context: {
        markId: this.id,
        modelId: this.model.id,
        markUserId: this._userId,
        modelUserId: this.model.userId
      },
      skipTheme: this.getSkipTheme(),
      support3d: this.getSupport3d(),
      enableSegments: !!this._enableSegments,
      clip: !!this._clip || false !== this._clip && void 0,
      clipPath: this._clip || void 0
    };
    this._progressiveConfig && (config2.progressiveStep = this._progressiveConfig.progressiveStep, config2.progressiveThreshold = this._progressiveConfig.progressiveThreshold, config2.large = this._progressiveConfig.large, config2.largeThreshold = this._progressiveConfig.largeThreshold), this._morph && this._morphKey && (config2.morph = this._morph, config2.morphKey = this._morphKey, config2.morphElementKey = this._morphElementKey), this._setCustomizedShape && (config2.setCustomizedShape = this._setCustomizedShape), this._product.configure(config2);
  }
  compileSignal() {
    this.state.compile();
  }
  _computeAttribute(key, state) {
    return (datum, opt) => {
    };
  }
  compileCommonAttributeCallback(key, state) {
    const attributeFunctor = this._computeAttribute(key, state), opt = {
      mark: null,
      parent: null,
      element: null
    };
    return (datum, element) => (opt.mark = element.mark, opt.parent = element.mark.group, opt.element = element, attributeFunctor(datum, opt));
  }
  compileTransform() {
    var _a;
    (null === (_a = this._transform) || void 0 === _a ? void 0 : _a.length) && this.getProduct().transform(this._transform);
  }
  _lookupGrammar(id2) {
    var _a;
    return null === (_a = this.getCompiler().getVGrammarView()) || void 0 === _a ? void 0 : _a.getMarkById(id2);
  }
  updateState(newState, noRender) {
    return this.state.updateState(newState, noRender);
  }
  updateLayoutState(noRender, recursion) {
    return recursion && this.getMarks().length > 0 && this.getMarks().forEach((m4) => m4.state.updateLayoutState(true)), this.state.updateLayoutState(noRender);
  }
  updateMarkState(key) {
    if (!this._product)
      return;
    const stateInfo = this.state.getStateInfo(key);
    this._product.elements.forEach((e) => {
      "in" === this.state.checkOneState(e, e.getDatum(), stateInfo) ? e.addState(key) : e.removeState(key);
    });
  }
  getMarks() {
    return [];
  }
  runAnimationByState(state) {
    var _a, _b;
    return null === (_b = null === (_a = this.getProduct()) || void 0 === _a ? void 0 : _a.animate) || void 0 === _b ? void 0 : _b.runAnimationByState(state);
  }
  stopAnimationByState(state) {
    var _a, _b;
    return null === (_b = null === (_a = this.getProduct()) || void 0 === _a ? void 0 : _a.animate) || void 0 === _b ? void 0 : _b.stopAnimationByState(state);
  }
  pauseAnimationByState(state) {
    var _a, _b;
    return null === (_b = null === (_a = this.getProduct()) || void 0 === _a ? void 0 : _a.animate) || void 0 === _b ? void 0 : _b.pauseAnimationByState(state);
  }
  resumeAnimationByState(state) {
    var _a, _b;
    return null === (_b = null === (_a = this.getProduct()) || void 0 === _a ? void 0 : _a.animate) || void 0 === _b ? void 0 : _b.resumeAnimationByState(state);
  }
  getProductElements() {
    const product = this.getProduct();
    if (product)
      return product.elements;
  }
  release() {
    super.release(), this.state.release();
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/mark/base/base-mark
var __rest8 = function(s2, e) {
  var t = {};
  for (var p in s2)
    Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++)
      e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var BaseMark = class extends CompilableMark {
  constructor(name, option) {
    var _a;
    super(option, name, option.model), this._extensionChannel = {}, this._computeExChannel = {}, this._attributeContext = option.attributeContext, null === (_a = option.map) || void 0 === _a || _a.set(this.id, this);
  }
  created() {
    this._initStyle();
  }
  initStyleWithSpec(spec, key) {
    spec && (isValid_default(spec.id) && (this._userId = spec.id), isBoolean_default(spec.interactive) && (this._interactive = spec.interactive), isValid_default(spec.zIndex) && this.setZIndex(spec.zIndex), isBoolean_default(spec.visible) && this.setVisible(spec.visible), this._initSpecStyle(spec, this.stateStyle, key));
  }
  _transformStyleValue(styleConverter, transform5) {
    if (styleConverter.scale) {
      const scale4 = styleConverter.scale, range2 = scale4.range();
      return scale4.range(range2.map(transform5)), styleConverter;
    }
    return "function" == typeof styleConverter ? (...args) => transform5(styleConverter(...args)) : transform5(styleConverter);
  }
  convertAngleToRadian(styleConverter) {
    return this._transformStyleValue(styleConverter, degreeToRadian);
  }
  isUserLevel(level) {
    return [AttributeLevel.User_Mark, AttributeLevel.User_Series, AttributeLevel.User_Chart].includes(level);
  }
  setStyle(style, state = "normal", level = 0, stateStyle = this.stateStyle) {
    if (isNil_default(style))
      return;
    void 0 === stateStyle[state] && (stateStyle[state] = {});
    const isUserLevel = this.isUserLevel(level);
    Object.keys(style).forEach((attr) => {
      let attrStyle = style[attr];
      isNil_default(attrStyle) || (attrStyle = this._filterAttribute(attr, attrStyle, state, level, isUserLevel, stateStyle), this.setAttribute(attr, attrStyle, state, level, stateStyle));
    });
  }
  getStyle(key, state = "normal") {
    var _a;
    return null === (_a = this.stateStyle[state][key]) || void 0 === _a ? void 0 : _a.style;
  }
  _filterAttribute(attr, style, state, level, isUserLevel, stateStyle = this.stateStyle) {
    let newStyle = this._styleConvert(style);
    if (isUserLevel)
      switch (attr) {
        case "angle":
          newStyle = this.convertAngleToRadian(newStyle);
          break;
        case "innerPadding":
        case "outerPadding":
          newStyle = this._transformStyleValue(newStyle, (value) => -value);
      }
    return newStyle;
  }
  setReferer(mark, styleKey, state, stateStyle = this.stateStyle) {
    var _a;
    if (mark)
      if (styleKey && state) {
        const style = null !== (_a = stateStyle[state]) && void 0 !== _a ? _a : {
          [styleKey]: {}
        };
        stateStyle[state][styleKey] = Object.assign(Object.assign({}, style[styleKey]), {
          referer: mark
        });
      } else
        Object.entries(stateStyle).forEach(([state2, style]) => {
          Object.entries(style).forEach(([styleKey2, style2]) => {
            stateStyle[state2][styleKey2].referer = mark;
          });
        });
  }
  setPostProcess(key, postProcessFunc, state = "normal") {
    var _a;
    (null === (_a = this.stateStyle[state]) || void 0 === _a ? void 0 : _a[key]) && (this.stateStyle[state][key].postProcess = postProcessFunc);
  }
  getAttribute(key, datum, state = "normal", opt) {
    return this._computeAttribute(key, state)(datum, opt);
  }
  setAttribute(attr, style, state = "normal", level = 0, stateStyle = this.stateStyle) {
    var _a;
    void 0 === stateStyle[state] && (stateStyle[state] = {}), void 0 === stateStyle[state][attr] && (stateStyle[state][attr] = {
      level,
      style,
      referer: void 0
    });
    const attrLevel = null === (_a = stateStyle[state][attr]) || void 0 === _a ? void 0 : _a.level;
    isValid_default(attrLevel) && attrLevel <= level && mergeSpec(stateStyle[state][attr], {
      style,
      level
    }), "normal" !== state && attr in this._extensionChannel && this._extensionChannel[attr].forEach((key) => {
      void 0 === stateStyle[state][key] && (stateStyle[state][key] = stateStyle.normal[key]);
    });
  }
  _getDefaultStyle() {
    return {
      visible: true,
      x: 0,
      y: 0
    };
  }
  _styleConvert(style) {
    if (!style)
      return style;
    if (isValidScaleType(style.type) || style.scale) {
      const scale4 = createScaleWithSpec(style, {
        globalScale: this._option.globalScale,
        seriesId: this._option.seriesId
      });
      if (scale4)
        return {
          scale: scale4,
          field: style.field,
          changeDomain: style.changeDomain
        };
    }
    return style;
  }
  _computeAttribute(key, state) {
    var _a;
    let stateStyle = null === (_a = this.stateStyle[state]) || void 0 === _a ? void 0 : _a[key];
    stateStyle || (stateStyle = this.stateStyle.normal[key]);
    const baseValueFunctor = this._computeStateAttribute(stateStyle, key, state), hasPostProcess = isFunction_default(null == stateStyle ? void 0 : stateStyle.postProcess), hasExCompute = key in this._computeExChannel;
    if (hasPostProcess && hasExCompute) {
      const exCompute = this._computeExChannel[key];
      return (datum, opt) => {
        let baseValue = baseValueFunctor(datum, opt);
        return baseValue = stateStyle.postProcess(baseValue, datum, this._attributeContext, opt, this.getDataView()), exCompute(key, datum, state, opt, baseValue);
      };
    }
    if (hasPostProcess)
      return (datum, opt) => stateStyle.postProcess(baseValueFunctor(datum, opt), datum, this._attributeContext, opt, this.getDataView());
    if (hasExCompute) {
      const exCompute = this._computeExChannel[key];
      return (datum, opt) => exCompute(key, datum, state, opt, baseValueFunctor(datum, opt));
    }
    return baseValueFunctor;
  }
  _computeStateAttribute(stateStyle, key, state) {
    var _a;
    return stateStyle ? stateStyle.referer ? stateStyle.referer._computeAttribute(key, state) : stateStyle.style ? "function" == typeof stateStyle.style ? (datum, opt) => stateStyle.style(datum, this._attributeContext, opt, this.getDataView()) : GradientType.includes(stateStyle.style.gradient) ? this._computeGradientAttr(stateStyle.style) : ["outerBorder", "innerBorder"].includes(key) ? this._computeBorderAttr(stateStyle.style) : isValidScaleType(null === (_a = stateStyle.style.scale) || void 0 === _a ? void 0 : _a.type) ? (datum, opt) => stateStyle.style.scale.scale(datum[stateStyle.style.field]) : (datum, opt) => stateStyle.style : (datum, opt) => stateStyle.style : (datum, opt) => {
    };
  }
  _initStyle() {
    const defaultStyle = this._getDefaultStyle();
    this.setStyle(defaultStyle, "normal", 0);
  }
  _initSpecStyle(spec, stateStyle, key) {
    spec.style && this.setStyle(spec.style, "normal", AttributeLevel.User_Mark, stateStyle);
    const state = spec.state;
    state && Object.keys(state).forEach((key2) => {
      const stateTemp = state[key2];
      if ("style" in stateTemp) {
        const style = stateTemp.style;
        let stateInfo = {
          stateValue: key2
        };
        "level" in stateTemp && (stateInfo.level = stateTemp.level), "filter" in stateTemp && (stateInfo = isFunction_default(stateTemp.filter) ? Object.assign({
          filter: stateTemp.filter
        }, stateInfo) : Object.assign(Object.assign({}, stateTemp.filter), stateInfo)), this.state.addStateInfo(stateInfo), this.setStyle(style, key2, AttributeLevel.User_Mark, stateStyle);
      } else
        this.setStyle(stateTemp, key2, AttributeLevel.User_Mark, stateStyle);
    });
  }
  _computeGradientAttr(gradientStyle) {
    var _a, _b;
    const { gradient, scale: scale4, field: field3 } = gradientStyle, rest = __rest8(gradientStyle, ["gradient", "scale", "field"]);
    let colorScale = scale4, colorField = field3;
    if (!(scale4 && field3 || "series" !== this.model.modelType)) {
      const { scale: globalColorScale, field: globalField } = this.model.getColorAttribute();
      scale4 || (colorScale = globalColorScale), colorField || (colorField = globalField);
    }
    const themeColor = computeActualDataScheme(getDataScheme(this.model.getColorScheme(), "series" === this.model.modelType ? null === (_b = (_a = this.model).getSpec) || void 0 === _b ? void 0 : _b.call(_a) : void 0), this.model.getDefaultColorDomain()), mergedStyle = Object.assign(Object.assign({}, DEFAULT_GRADIENT_CONFIG[gradient]), rest);
    return (data, opt) => {
      const computeStyle = {}, markData = this.getDataView();
      return Object.keys(mergedStyle).forEach((key) => {
        const value = mergedStyle[key];
        "stops" === key ? computeStyle.stops = value.map((stop) => {
          const { opacity, color, offset } = stop;
          let computeColor = null != color ? color : null == colorScale ? void 0 : colorScale.scale(data[colorField]);
          return isFunction_default(color) && (computeColor = color(data, this._attributeContext, opt, markData)), isValid_default(opacity) && (computeColor = Color.SetOpacity(computeColor, opacity)), {
            offset: isFunction_default(offset) ? offset(data, this._attributeContext, opt, markData) : offset,
            color: computeColor || themeColor[0]
          };
        }) : isFunction_default(value) ? computeStyle[key] = value(data, this._attributeContext, opt, markData) : computeStyle[key] = value;
      }), computeStyle.gradient = gradient, computeStyle;
    };
  }
  _computeBorderAttr(borderStyle) {
    const { scale: scale4, field: field3 } = borderStyle, mergedStyle = __rest8(borderStyle, ["scale", "field"]);
    return (data, opt) => {
      var _a, _b, _c;
      const computeStyle = {};
      if (Object.keys(mergedStyle).forEach((key) => {
        const value = mergedStyle[key];
        isFunction_default(value) ? computeStyle[key] = value(data, this._attributeContext, opt, this.getDataView()) : computeStyle[key] = value;
      }), "stroke" in computeStyle)
        GradientType.includes(null === (_c = mergedStyle.stroke) || void 0 === _c ? void 0 : _c.gradient) && (computeStyle.stroke = this._computeGradientAttr(mergedStyle.stroke)(data, opt));
      else {
        const themeColor = computeActualDataScheme(getDataScheme(this.model.getColorScheme(), "series" === this.model.modelType ? null === (_b = (_a = this.model).getSpec) || void 0 === _b ? void 0 : _b.call(_a) : void 0), this.model.getDefaultColorDomain());
        let colorScale = scale4, colorField = field3;
        if (!(scale4 && field3 || "series" !== this.model.modelType)) {
          const { scale: globalColorScale, field: globalField } = this.model.getColorAttribute();
          scale4 || (colorScale = globalColorScale), colorField || (colorField = globalField), computeStyle.stroke = (null == colorScale ? void 0 : colorScale.scale(data[colorField])) || themeColor[0];
        }
      }
      return computeStyle;
    };
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/mark/group
var GroupMark2 = class _GroupMark extends BaseMark {
  constructor() {
    super(...arguments), this.type = _GroupMark.type, this._marks = [];
  }
  getMarks() {
    return this._marks;
  }
  _getDefaultStyle() {
    return Object.assign({}, super._getDefaultStyle());
  }
  isMarkExist(mark) {
    return void 0 !== this._marks.find((m4) => m4.id === mark.id || m4.name === mark.name);
  }
  addMark(mark) {
    return this.isMarkExist(mark) ? (warn("Mark already exists, add mark failed."), false) : (this._marks.push(mark), true);
  }
  removeMark(mark) {
    const index = this._marks.findIndex((m4) => m4.id === mark.id || m4.name === mark.name);
    return -1 === index ? (warn("Mark does not exists, removeMark failed."), false) : (this._marks.splice(index, 1), true);
  }
  getMarkInType(type) {
    return this._marks.filter((m4) => m4.type === type);
  }
  getMarkInId(id2) {
    return this._marks.find((m4) => m4.id === id2);
  }
  getMarkInName(name) {
    return this._marks.find((m4) => m4.name === name);
  }
  _compileProduct(option) {
    super._compileProduct(option), this._product.configure({
      zIndex: this.getZIndex()
    }), (null == option ? void 0 : option.ignoreChildren) || this.getMarks().forEach((mark) => {
      mark.getProduct() && mark.removeProduct(), mark.compile({
        group: this._product
      });
    });
  }
};
GroupMark2.type = "group";
var registerGroupMark = () => {
  registerGroupGraphic2(), Factory2.registerMark(GroupMark2.type, GroupMark2);
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/line/animation
var Appear_ClipIn = {
  type: "clipIn"
};
var Appear_FadeIn = {
  type: "fadeIn"
};
var Appear_Grow = (params2) => ({
  type: "horizontal" === params2.direction ? "growPointsXIn" : "growPointsYIn",
  options: {
    orient: "horizontal" === params2.direction ? "positive" : "negative"
  }
});
function linePresetAnimation(params2, preset) {
  switch (preset) {
    case "grow":
      return Appear_Grow(params2);
    case "fadeIn":
      return Appear_FadeIn;
    default:
      return Appear_ClipIn;
  }
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/animation/config
var DEFAULT_ANIMATION_CONFIG = {
  appear: {
    duration: 1e3,
    easing: "cubicOut"
  },
  update: {
    type: "update",
    duration: 300,
    easing: "linear"
  },
  enter: {
    duration: 300,
    easing: "linear"
  },
  exit: {
    duration: 300,
    easing: "linear"
  },
  disappear: {
    duration: 500,
    easing: "cubicIn"
  }
};
var ScaleInOutAnimation = {
  appear: {
    type: "scaleIn"
  },
  enter: {
    type: "scaleIn"
  },
  exit: {
    type: "scaleOut"
  },
  disappear: {
    type: "scaleOut"
  }
};
var registerScaleInOutAnimation = () => {
  Factory2.registerAnimation("scaleInOut", () => ScaleInOutAnimation);
};
var lineOrAreaAnimation = (params2, preset) => ({
  appear: linePresetAnimation(params2, preset),
  enter: {
    type: "fadeIn"
  },
  exit: {
    type: "fadeOut"
  },
  update: [{
    type: "update",
    options: {
      excludeChannels: ["points", "defined"]
    }
  }, {
    channel: ["points"],
    custom: TagPointsUpdate,
    duration: DEFAULT_ANIMATION_CONFIG.update.duration,
    easing: DEFAULT_ANIMATION_CONFIG.update.easing
  }],
  disappear: {
    type: "clipOut"
  }
});
var registerLineAnimation = () => {
  Factory2.registerAnimation("line", lineOrAreaAnimation);
};
var registerVGrammarCommonAnimation = () => {
  View.useRegisters([registerScaleInAnimation, registerScaleOutAnimation, registerFadeInAnimation, registerFadeOutAnimation, registerMoveInAnimation, registerMoveOutAnimation, registerRotateInAnimation, registerRotateOutAnimation, registerUpdateAnimation]);
};
var registerVGrammarRectAnimation = () => {
  View.useRegisters([registerGrowHeightInAnimation, registerGrowHeightOutAnimation, registerGrowWidthInAnimation, registerGrowWidthOutAnimation, registerGrowCenterInAnimation, registerGrowCenterOutAnimation]);
};
var registerVGrammarArcAnimation = () => {
  View.useRegisters([registerGrowRadiusInAnimation, registerGrowRadiusOutAnimation, registerGrowAngleInAnimation, registerGrowAngleOutAnimation]);
};
var registerVGrammarLineOrAreaAnimation = () => {
  View.useRegisters([registerGrowPointsInAnimation, registerGrowPointsOutAnimation, registerGrowPointsXInAnimation, registerGrowPointsXOutAnimation, registerGrowPointsYInAnimation, registerGrowPointsYOutAnimation, registerClipInAnimation, registerClipOutAnimation]);
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/core/util
var VCHART_UTILS = {
  measureText
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/core/expression-function
var ExpressionFunction = class _ExpressionFunction {
  static instance() {
    return _ExpressionFunction.instance_ || (_ExpressionFunction.instance_ = new _ExpressionFunction()), _ExpressionFunction.instance_;
  }
  constructor() {
    this.functions = {};
  }
  registerFunction(name, fun) {
    name && fun && (this.functions[name] = fun);
  }
  unregisterFunction(name) {
    name && delete this.functions[name];
  }
  getFunction(name) {
    return this.functions[name] || null;
  }
  getFunctionNameList() {
    return Object.keys(this.functions);
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/env/env
var registerBrowserEnv = () => {
  loadBrowserEnv(container);
};
var registerNodeEnv = () => {
  loadNodeEnv(container);
};
var registerWXEnv = () => {
  loadWxEnv(container);
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/plugin/base/base-plugin-service
var BasePluginService = class {
  constructor() {
    this.id = createID(), this._plugins = [];
  }
  add(plugins) {
    if (!plugins || 0 === plugins.length)
      return null;
    const unloadedPlugins = [];
    return plugins.forEach((plugin) => {
      this._plugins.find((p) => p.id === plugin.id) ? warn("\u4E0D\u8981\u91CD\u590D\u6DFB\u52A0\u76F8\u540C\u7684plugin") : (this._plugins.push(plugin), unloadedPlugins.push(plugin), plugin.onAdd && plugin.onAdd(this));
    }), unloadedPlugins;
  }
  load(plugins) {
    const unloadedPlugins = this.add(plugins);
    unloadedPlugins && unloadedPlugins.length && this.activate(plugins);
  }
  activate(plugins) {
    plugins.length && plugins.forEach((plugin) => {
      plugin.init && plugin.init();
    });
  }
  get(id2) {
    return this._plugins.find((p) => p.id === id2);
  }
  getAll() {
    return this._plugins.slice();
  }
  release(pluginsId) {
    const plugin = this.get(pluginsId);
    plugin && (plugin.release(this), this._plugins = this._plugins.filter((entry) => entry !== plugin));
  }
  releaseAll() {
    this._plugins.forEach((plugin) => {
      plugin.release(this);
    }), this._plugins = [];
  }
  clear(pluginsId) {
    const plugin = this.get(pluginsId);
    plugin && plugin.clear(this);
  }
  clearAll() {
    this._plugins.forEach((plugin) => {
      var _a;
      null === (_a = plugin.clear) || void 0 === _a || _a.call(plugin, this);
    });
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/plugin/chart/plugin-service
var ChartPluginService = class extends BasePluginService {
  constructor(globalInstance) {
    super(), this.globalInstance = globalInstance;
  }
  onInit(chartSpec) {
    this._plugins.forEach((plugin) => {
      plugin.onInit && plugin.onInit(this, chartSpec);
    });
  }
  onBeforeResize(width, height) {
    this._plugins.forEach((plugin) => {
      plugin.onBeforeResize && plugin.onBeforeResize(this, width, height);
    });
  }
  onAfterChartSpecTransform(chartSpec, actionSource) {
    this._plugins.forEach((plugin) => {
      plugin.onAfterChartSpecTransform && plugin.onAfterChartSpecTransform(this, chartSpec, actionSource);
    });
  }
  onBeforeInitChart(chartSpec, actionSource) {
    this._plugins.forEach((plugin) => {
      plugin.onBeforeInitChart && plugin.onBeforeInitChart(this, chartSpec, actionSource);
    });
  }
  releaseAll() {
    super.releaseAll(), this.globalInstance = null;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/core/vchart
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      var value;
      result2.done ? resolve(result2.value) : (value = result2.value, value instanceof P ? value : new P(function(resolve2) {
        resolve2(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest9 = function(s2, e) {
  var t = {};
  for (var p in s2)
    Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++)
      e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var VChart = class _VChart {
  static useRegisters(comps) {
    comps.forEach((fn) => {
      "function" == typeof fn ? fn() : console.error("Invalid function:", fn);
    });
  }
  static useChart(charts) {
    charts.forEach((c3) => Factory2.registerChart(c3.type, c3));
  }
  static useSeries(series2) {
    series2.forEach((s2) => Factory2.registerSeries(s2.type, s2));
  }
  static useComponent(components) {
    components.forEach((c3) => Factory2.registerComponent(c3.type, c3));
  }
  static useMark(marks) {
    marks.forEach((m4) => {
      var _a;
      return Factory2.registerMark(null !== (_a = m4.constructorType) && void 0 !== _a ? _a : m4.type, m4);
    });
  }
  static useLayout(layouts) {
    layouts.forEach((l) => Factory2.registerLayout(l.type, l));
  }
  static registerDataSetTransform(name, transform5) {
    Factory2.registerTransform(name, transform5);
  }
  static registerFunction(key, fun) {
    key && fun && ExpressionFunction.instance().registerFunction(key, fun);
  }
  static unregisterFunction(key) {
    key && ExpressionFunction.instance().unregisterFunction(key);
  }
  static getFunction(key) {
    return key ? ExpressionFunction.instance().getFunction(key) : null;
  }
  static getFunctionList() {
    return ExpressionFunction.instance().getFunctionNameList();
  }
  static registerMap(key, source, option) {
    const impl = Factory2.getImplementInKey("registerMap");
    impl && impl(key, source, option);
  }
  static unregisterMap(key) {
    const impl = Factory2.getImplementInKey("unregisterMap");
    impl && impl(key);
  }
  static getMap(key) {
    return getMapSource(key);
  }
  static hideTooltip(excludeId = []) {
    InstanceManager.forEach((instance) => {
      var _a;
      return null === (_a = null == instance ? void 0 : instance.hideTooltip) || void 0 === _a ? void 0 : _a.call(instance);
    }, excludeId);
  }
  static getLogger() {
    return Logger.getInstance();
  }
  getSpec() {
    return this._spec;
  }
  getSpecInfo() {
    return this._specInfo;
  }
  getDataSet() {
    return this._dataSet;
  }
  constructor(spec, options) {
    var _a, _b, _c, _d, _e, _f, _g;
    this.id = createID(), this._userEvents = [], this._autoSize = true, this._option = {
      mode: RenderModeEnum["desktop-browser"],
      onError: (msg) => {
        throw new Error(msg);
      },
      optimize: {
        disableCheckGraphicWidthOutRange: true
      }
    }, this._observer = null, this._context = {}, this._onResize = debounce_default((...args) => {
      this._doResize();
    }, 100), this._option = merge(this._option, {
      animation: false !== spec.animation
    }, options), this._onError = null === (_a = this._option) || void 0 === _a ? void 0 : _a.onError;
    const _h = this._option, { dom, renderCanvas, mode, stage, poptip: poptip2 } = _h, restOptions = __rest9(_h, ["dom", "renderCanvas", "mode", "stage", "poptip"]), isTrueBrowseEnv = isTrueBrowser(mode);
    isTrueBrowseEnv && dom && (this._container = isString_default(dom) ? null === document || void 0 === document ? void 0 : document.getElementById(dom) : dom), renderCanvas && (this._canvas = renderCanvas), stage && (this._stage = stage), "node" === mode || this._container || this._canvas || this._stage ? (isTrueBrowseEnv ? registerBrowserEnv() : "node" === mode && registerNodeEnv(), this._viewBox = this._option.viewBox, this._currentThemeName = ThemeManager2.getCurrentThemeName(), this._setNewSpec(spec), this._updateCurrentTheme(), this._currentSize = this.getCurrentSize(), this._compiler = new Compiler({
      dom: null !== (_c = this._container) && void 0 !== _c ? _c : "none",
      canvas: renderCanvas
    }, Object.assign(Object.assign({
      mode: this._option.mode,
      stage,
      pluginList: false !== poptip2 ? ["poptipForText"] : []
    }, restOptions), {
      background: this._getBackground(),
      onError: this._onError
    })), this._compiler.setSize(this._currentSize.width, this._currentSize.height), this._eventDispatcher = new EventDispatcher(this, this._compiler), this._event = new Event2(this._eventDispatcher, mode), this._compiler.initView(), null === (_d = this.getStage()) || void 0 === _d || _d.setTheme({
      text: {
        fontFamily: null === (_e = this._currentTheme) || void 0 === _e ? void 0 : _e.fontFamily
      }
    }), this._initDataSet(this._option.dataSet), this._autoSize = !!isTrueBrowseEnv && (null === (_g = null !== (_f = spec.autoFit) && void 0 !== _f ? _f : this._option.autoFit) || void 0 === _g || _g), this._bindResizeEvent(), this._bindVGrammarViewEvent(), this._initChartPlugin(), InstanceManager.registerInstance(this)) : null === (_b = this._option) || void 0 === _b || _b.onError("please specify container or renderCanvas!");
  }
  _setNewSpec(spec, forceMerge) {
    return !!spec && (isString_default(spec) && (spec = JSON.parse(spec)), forceMerge && this._originalSpec && (spec = mergeSpec({}, this._originalSpec, spec)), this._originalSpec = spec, this._spec = this._getSpecFromOriginalSpec(), true);
  }
  _getSpecFromOriginalSpec() {
    var _a;
    const spec = specTransform(this._originalSpec);
    return spec.data = null !== (_a = spec.data) && void 0 !== _a ? _a : [], spec;
  }
  _initChartSpec(spec, actionSource) {
    var _a, _b;
    _VChart.getFunctionList() && _VChart.getFunctionList().length && (spec = functionTransform(spec, _VChart)), this._spec = spec, this._chartSpecTransformer || (this._chartSpecTransformer = Factory2.createChartSpecTransformer(this._spec.type, this._getChartOption(this._spec.type))), null === (_a = this._chartSpecTransformer) || void 0 === _a || _a.transformSpec(this._spec), this._chartPluginApply("onAfterChartSpecTransform", this._spec, actionSource), this._specInfo = null === (_b = this._chartSpecTransformer) || void 0 === _b ? void 0 : _b.transformModelSpec(this._spec), this._chartPluginApply("onAfterModelSpecTransform", this._spec, this._specInfo, actionSource);
  }
  _updateSpecInfo() {
    var _a;
    this._chartSpecTransformer || (this._chartSpecTransformer = Factory2.createChartSpecTransformer(this._spec.type, this._getChartOption(this._spec.type))), this._specInfo = null === (_a = this._chartSpecTransformer) || void 0 === _a ? void 0 : _a.createSpecInfo(this._spec);
  }
  _initChart(spec) {
    var _a, _b, _c;
    if (!this._compiler)
      return void (null === (_a = this._option) || void 0 === _a || _a.onError("compiler is not initialized"));
    if (this._chart)
      return void (null === (_b = this._option) || void 0 === _b || _b.onError("chart is already initialized"));
    const chart = Factory2.createChart(spec.type, spec, this._getChartOption(spec.type));
    chart ? (this._chart = chart, this._chart.setCanvasRect(this._currentSize.width, this._currentSize.height), this._chart.created(), this._chart.init(), this._event.emit(ChartEvent.initialized, {
      chart,
      vchart: this
    })) : null === (_c = this._option) || void 0 === _c || _c.onError("init chart fail");
  }
  _releaseData() {
    this._dataSet && (this._dataSet.dataViewMap = {}, this._dataSet = null);
  }
  _bindVGrammarViewEvent() {
    this._compiler && (this._compiler.getVGrammarView().addEventListener(HOOK_EVENT.ALL_ANIMATION_END, () => {
      this._event.emit(ChartEvent.animationFinished, {
        chart: this._chart,
        vchart: this
      });
    }), this._compiler.getVGrammarView().addEventListener(HOOK_EVENT.AFTER_VRENDER_NEXT_RENDER, () => {
      this._event.emit(ChartEvent.renderFinished, {
        chart: this._chart,
        vchart: this
      });
    }));
  }
  _bindResizeEvent() {
    var _a;
    if (this._autoSize) {
      if (this._container) {
        const ResizeObserverWindow = window.ResizeObserver;
        ResizeObserverWindow && (this._observer = new ResizeObserverWindow(this._onResize), null === (_a = this._observer) || void 0 === _a || _a.observe(this._container));
      }
      window.addEventListener("resize", this._onResize);
    }
  }
  _unBindResizeEvent() {
    this._autoSize && (window.removeEventListener("resize", this._onResize), this._observer && (this._observer.disconnect(), this._observer = null));
  }
  getCurrentSize() {
    var _a, _b, _c, _d;
    return calculateChartSize(this._spec, {
      container: this._container,
      canvas: this._canvas,
      mode: this._getMode(),
      modeParams: this._option.modeParams
    }, {
      width: null !== (_b = null === (_a = this._currentSize) || void 0 === _a ? void 0 : _a.width) && void 0 !== _b ? _b : DEFAULT_CHART_WIDTH,
      height: null !== (_d = null === (_c = this._currentSize) || void 0 === _c ? void 0 : _c.height) && void 0 !== _d ? _d : DEFAULT_CHART_HEIGHT
    });
  }
  _doResize() {
    const { width, height } = this.getCurrentSize();
    this._currentSize.width === width && this._currentSize.height === height || (this._currentSize = {
      width,
      height
    }, this.resizeSync(width, height));
  }
  _initDataSet(dataSet) {
    this._dataSet = dataSet instanceof DataSet ? dataSet : new DataSet(), registerDataSetInstanceParser(this._dataSet, "dataview", dataViewParser), registerDataSetInstanceParser(this._dataSet, "array", arrayParser), registerDataSetInstanceTransform(this._dataSet, "stackSplit", stackSplit), registerDataSetInstanceTransform(this._dataSet, "copyDataView", copyDataView);
    for (const key in Factory2.transforms)
      registerDataSetInstanceTransform(this._dataSet, key, Factory2.transforms[key]);
    for (const key in Factory2.dataParser)
      registerDataSetInstanceParser(this._dataSet, key, Factory2.dataParser[key]);
  }
  updateCustomConfigAndRerender(updateSpecResult, sync, option = {}) {
    if (!this._isReleased && updateSpecResult)
      return isFunction_default(updateSpecResult) && (updateSpecResult = updateSpecResult()), this._reCompile(updateSpecResult), sync ? this._renderSync(option) : this._renderAsync(option);
  }
  _updateCustomConfigAndRecompile(updateSpecResult, option = {}) {
    return !!updateSpecResult && (this._reCompile(updateSpecResult), this._beforeRender(option));
  }
  _reCompile(updateResult, morphConfig) {
    var _a, _b, _c, _d, _e, _f;
    if (updateResult.reMake)
      this._releaseData(), this._initDataSet(), this._chartSpecTransformer = null, null === (_a = this._chart) || void 0 === _a || _a.release(), this._chart = null, null === (_b = this._compiler) || void 0 === _b || _b.releaseGrammar(false === (null === (_c = this._option) || void 0 === _c ? void 0 : _c.animation) || false === (null === (_d = this._spec) || void 0 === _d ? void 0 : _d.animation)), this._userEvents.forEach((e) => {
        var _a2;
        return null === (_a2 = this._event) || void 0 === _a2 ? void 0 : _a2.on(e.eType, e.query, e.handler);
      }), updateResult.reSize && this._doResize();
    else if (updateResult.reCompile && (null === (_e = this._compiler) || void 0 === _e || _e.clear({
      chart: this._chart,
      vChart: this
    }, !this._option.animation || !this._spec.animation), null === (_f = this._compiler) || void 0 === _f || _f.compile({
      chart: this._chart,
      vChart: this
    }, {})), updateResult.reSize) {
      const { width, height } = this.getCurrentSize();
      this._chart.onResize(width, height, false), this._compiler.resize(width, height, false);
    }
  }
  _beforeRender(option = {}) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (this._isReleased)
      return false;
    if (this._chart)
      return true;
    const { transformSpec, actionSource } = option;
    return transformSpec && this._initChartSpec(this._spec, "render"), this._chartPluginApply("onBeforeInitChart", this._spec, actionSource), null === (_b = null === (_a = this._option.performanceHook) || void 0 === _a ? void 0 : _a.beforeInitializeChart) || void 0 === _b || _b.call(_a), this._initChart(this._spec), null === (_d = null === (_c = this._option.performanceHook) || void 0 === _c ? void 0 : _c.afterInitializeChart) || void 0 === _d || _d.call(_c), !(!this._chart || !this._compiler) && (null === (_f = null === (_e = this._option.performanceHook) || void 0 === _e ? void 0 : _e.beforeCompileToVGrammar) || void 0 === _f || _f.call(_e), this._compiler.compile({
      chart: this._chart,
      vChart: this
    }, {
      performanceHook: this._option.performanceHook
    }), null === (_h = null === (_g = this._option.performanceHook) || void 0 === _g ? void 0 : _g.afterCompileToVGrammar) || void 0 === _h || _h.call(_g), true);
  }
  _afterRender() {
    return !this._isReleased && (this._updateAnimateState(), this._event.emit(ChartEvent.rendered, {
      chart: this._chart,
      vchart: this
    }), true);
  }
  renderSync(morphConfig) {
    return this._renderSync({
      morphConfig,
      transformSpec: true,
      actionSource: "render"
    });
  }
  renderAsync(morphConfig) {
    return __awaiter8(this, void 0, void 0, function* () {
      return this._renderAsync({
        morphConfig,
        transformSpec: true,
        actionSource: "render"
      });
    });
  }
  _renderSync(option = {}) {
    var _a;
    const self = this;
    return this._beforeRender(option) ? (null === (_a = this._compiler) || void 0 === _a || _a.render(option.morphConfig), this._afterRender(), self) : self;
  }
  _renderAsync(option = {}) {
    return __awaiter8(this, void 0, void 0, function* () {
      return this._renderSync(option);
    });
  }
  _updateAnimateState() {
    var _a, _b;
    this._option.animation && (null === (_a = this._chart) || void 0 === _a || _a.getAllRegions().forEach((region) => {
      var _a2;
      null === (_a2 = region.animate) || void 0 === _a2 || _a2.updateAnimateState(AnimationStateEnum.update, true);
    }), null === (_b = this._chart) || void 0 === _b || _b.getAllComponents().forEach((component2) => {
      var _a2;
      null === (_a2 = component2.animate) || void 0 === _a2 || _a2.updateAnimateState(AnimationStateEnum.update, true);
    }));
  }
  release() {
    var _a, _b, _c, _d;
    (null === (_a = this._onResize) || void 0 === _a ? void 0 : _a.cancel) && this._onResize.cancel(), this._chartPluginApply("releaseAll"), this._chartPlugin = null, this._chartSpecTransformer = null, null === (_b = this._chart) || void 0 === _b || _b.release(), null === (_c = this._eventDispatcher) || void 0 === _c || _c.release(), null === (_d = this._compiler) || void 0 === _d || _d.release(), this._unBindResizeEvent(), this._releaseData(), this._onError = null, this._onResize = null, this._container = null, this._currentTheme = null, this._option = null, this._chart = null, this._compiler = null, this._spec = null, this._specInfo = null, this._originalSpec = null, this._userEvents = null, this._event = null, this._eventDispatcher = null, this._isReleased = true, InstanceManager.unregisterInstance(this);
  }
  updateData(id2, data, options) {
    return __awaiter8(this, void 0, void 0, function* () {
      return this.updateDataSync(id2, data, options);
    });
  }
  _updateDataById(id2, data, options) {
    const preDV = this._spec.data.find((dv) => dv.name === id2 || dv.id === id2);
    preDV ? preDV.id === id2 ? preDV.values = data : preDV.name === id2 && preDV.parse(data, options) : isArray_default(data) ? this._spec.data.push({
      id: id2,
      values: data
    }) : this._spec.data.push(data);
  }
  updateDataInBatches(list) {
    return __awaiter8(this, void 0, void 0, function* () {
      return this._chart ? (this._chart.updateFullData(list.map(({ id: id2, data, options }) => ({
        id: id2,
        values: data,
        parser: options
      }))), this._chart.updateGlobalScaleDomain(), this._compiler.render(), this) : (this._spec.data = array(this._spec.data), list.forEach(({ id: id2, data, options }) => {
        this._updateDataById(id2, data, options);
      }), this);
    });
  }
  updateDataSync(id2, data, options) {
    return isNil_default(this._dataSet) ? this : this._chart ? (this._chart.updateData(id2, data, true, options), this._compiler.render(), this) : (this._spec.data = array(this._spec.data), this._updateDataById(id2, data, options), this);
  }
  updateFullDataSync(data, reRender = true) {
    if (this._chart)
      return this._chart.updateFullData(data), reRender && this._compiler.render(), this;
    const prevData = array(this._spec.data);
    return array(data).forEach((d) => {
      var _a;
      const { id: id2, values, parser, fields: fields2 } = d, preDV = prevData.find((dv) => dv.name === id2);
      if (preDV)
        preDV instanceof DataView ? (preDV.setFields(cloneDeep(fields2)), preDV.parse(values, cloneDeep(parser))) : (preDV.values = values, isValid_default(parser) && (preDV.parser = parser), isValid_default(fields2) && (preDV.fields = fields2));
      else {
        const dataView = dataToDataView(d, this._dataSet, prevData, {
          onError: null === (_a = this._option) || void 0 === _a ? void 0 : _a.onError
        });
        isArray_default(this._spec.data) && this._spec.data.push(dataView);
      }
    }), this;
  }
  updateFullData(data, reRender = true) {
    return __awaiter8(this, void 0, void 0, function* () {
      return this.updateFullDataSync(data, reRender);
    });
  }
  updateSpec(spec, forceMerge = false, morphConfig) {
    return __awaiter8(this, void 0, void 0, function* () {
      const result2 = this._updateSpec(spec, forceMerge);
      return result2 ? (yield this.updateCustomConfigAndRerender(result2, false, {
        morphConfig,
        transformSpec: result2.reTransformSpec,
        actionSource: "updateSpec"
      }), this) : this;
    });
  }
  updateSpecSync(spec, forceMerge = false, morphConfig) {
    const result2 = this._updateSpec(spec, forceMerge);
    return result2 ? (this.updateCustomConfigAndRerender(result2, true, {
      morphConfig,
      transformSpec: result2.reTransformSpec,
      actionSource: "updateSpec"
    }), this) : this;
  }
  updateSpecAndRecompile(spec, forceMerge = false, option = {}) {
    const result2 = this._updateSpec(spec, forceMerge);
    return this._updateCustomConfigAndRecompile(result2, Object.assign({
      actionSource: "updateSpecAndRecompile"
    }, option));
  }
  _updateSpec(spec, forceMerge = false) {
    var _a, _b;
    const lastSpec = this._spec;
    if (!this._setNewSpec(spec, forceMerge))
      return;
    isEqual(lastSpec.theme, this._spec.theme) || this._setCurrentTheme();
    const reSize = this._shouldChartResize(lastSpec);
    return null === (_b = null === (_a = this._compiler) || void 0 === _a ? void 0 : _a.getVGrammarView()) || void 0 === _b || _b.updateLayoutTag(), this._spec.type !== lastSpec.type ? {
      reTransformSpec: true,
      change: true,
      reMake: true,
      reCompile: false,
      reSize
    } : (this._initChartSpec(this._spec, "render"), mergeUpdateResult(this._chart.updateSpec(this._spec), {
      reTransformSpec: false,
      change: reSize,
      reMake: false,
      reCompile: false,
      reSize
    }));
  }
  updateModelSpec(filter2, spec, forceMerge = false, morphConfig) {
    return __awaiter8(this, void 0, void 0, function* () {
      if (!spec || !this._spec)
        return this;
      if (isString_default(spec) && (spec = JSON.parse(spec)), isFunction_default(filter2) || mergeSpecWithFilter(this._spec, filter2, spec, forceMerge), this._chart) {
        const model = this._chart.getModelInFilter(filter2);
        if (model)
          return this._updateModelSpec(model, spec, false, forceMerge, morphConfig);
      }
      return this;
    });
  }
  updateModelSpecSync(filter2, spec, forceMerge = false, morphConfig) {
    if (!spec || !this._spec)
      return this;
    if (isString_default(spec) && (spec = JSON.parse(spec)), isFunction_default(filter2) || mergeSpecWithFilter(this._spec, filter2, spec, forceMerge), this._chart) {
      const model = this._chart.getModelInFilter(filter2);
      if (model)
        return this._updateModelSpec(model, spec, true, forceMerge, morphConfig);
    }
    return this;
  }
  _updateModelSpec(model, spec, sync = false, forceMerge = false, morphConfig) {
    forceMerge && (spec = mergeSpec({}, model.getSpec(), spec));
    const result2 = model.updateSpec(spec);
    return model.reInit(spec), (result2.change || result2.reCompile || result2.reMake || result2.reSize || result2.reRender) && this._chart.reDataFlow(), this.updateCustomConfigAndRerender(result2, sync, {
      morphConfig,
      transformSpec: false,
      actionSource: "updateModelSpec"
    });
  }
  resize(width, height) {
    return __awaiter8(this, void 0, void 0, function* () {
      return this.resizeSync(width, height);
    });
  }
  resizeSync(width, height) {
    var _a, _b;
    return this._beforeResize(width, height) ? (null === (_b = (_a = this._compiler).resize) || void 0 === _b || _b.call(_a, width, height), this._afterResize()) : this;
  }
  _beforeResize(width, height) {
    var _a, _b, _c, _d;
    if (!this._chart || !this._compiler)
      return false;
    const chartCanvasRect = this._chart.getCanvasRect();
    return (!chartCanvasRect || chartCanvasRect.width !== width || chartCanvasRect.height !== height) && (this._chartPluginApply("onBeforeResize", width, height), null === (_b = null === (_a = this._option.performanceHook) || void 0 === _a ? void 0 : _a.beforeResizeWithUpdate) || void 0 === _b || _b.call(_a), this._chart.onResize(width, height, false), null === (_d = null === (_c = this._option.performanceHook) || void 0 === _c ? void 0 : _c.afterResizeWithUpdate) || void 0 === _d || _d.call(_c), true);
  }
  _afterResize() {
    return this._isReleased || this._event.emit(ChartEvent.afterResize, {
      chart: this._chart
    }), this;
  }
  updateViewBox(viewBox, reRender = true, reLayout = true) {
    return this._chart && this._compiler ? (this._viewBox = viewBox, this._chart.updateViewBox(viewBox, reLayout), reLayout && (this._compiler.render(), this._chart.onEvaluateEnd()), this._compiler.updateViewBox(viewBox, reRender), this) : this;
  }
  on(eType, query, handler) {
    var _a;
    this._userEvents && (this._userEvents.push({
      eType,
      query: "function" == typeof query ? null : query,
      handler: "function" == typeof query ? query : handler
    }), null === (_a = this._event) || void 0 === _a || _a.on(eType, query, handler));
  }
  off(eType, handler) {
    var _a;
    if (this._userEvents && 0 !== this._userEvents.length)
      if (handler) {
        const index = this._userEvents.findIndex((e) => e.eType === eType && e.handler === handler);
        index >= 0 && (this._userEvents.splice(index, 1), null === (_a = this._event) || void 0 === _a || _a.off(eType, handler));
      } else
        this._userEvents.forEach((e) => {
          var _a2;
          e.eType === eType && (null === (_a2 = this._event) || void 0 === _a2 || _a2.off(eType, e.handler));
        }), this._userEvents = this._userEvents.filter((e) => e.eType !== eType);
  }
  updateState(state, filter2) {
    this._chart && this._chart.updateState(state, filter2);
  }
  setSelected(datum, filter2, region) {
    this._chart && this._chart.setSelected(datum, filter2, region);
  }
  setHovered(datum, filter2, region) {
    this._chart && this._chart.setHovered(datum, filter2, region);
  }
  clearState(state) {
    this._chart && this._chart.clearState(state);
  }
  clearSelected() {
    this._chart && this._chart.clearSelected();
  }
  clearHovered() {
    this._chart && this._chart.clearHovered();
  }
  _updateCurrentTheme(nextThemeName) {
    var _a, _b;
    const optionTheme = this._option.theme, specTheme = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.theme;
    if (nextThemeName && (this._currentThemeName = nextThemeName), isEmpty_default(optionTheme) && isEmpty_default(specTheme))
      this._currentTheme = getThemeObject(this._currentThemeName, true);
    else if (isString_default(optionTheme) && (!specTheme || isString_default(specTheme)) || isString_default(specTheme) && (!optionTheme || isString_default(optionTheme))) {
      const finalTheme = mergeTheme({}, getThemeObject(this._currentThemeName, true), getThemeObject(optionTheme, true), getThemeObject(specTheme, true));
      this._currentTheme = finalTheme;
    } else {
      const finalTheme = mergeTheme({}, getThemeObject(this._currentThemeName), getThemeObject(optionTheme), getThemeObject(specTheme));
      this._currentTheme = preprocessTheme(finalTheme);
    }
    setPoptipTheme(get_default(this._currentTheme, "component.poptip")), null === (_b = this._compiler) || void 0 === _b || _b.setBackground(this._getBackground());
  }
  _shouldChartResize(oldSpec) {
    var _a, _b;
    let resize = false;
    isNil_default(this._spec.width) ? !isNil_default(oldSpec.width) && (this._spec.width = oldSpec.width) : this._spec.width !== oldSpec.width && (resize = true), isNil_default(this._spec.height) ? !isNil_default(oldSpec.height) && (this._spec.height = oldSpec.height) : this._spec.height !== oldSpec.height && (resize = true);
    const lasAutoSize = this._autoSize;
    return this._autoSize = !!isTrueBrowser(this._option.mode) && (null === (_b = null !== (_a = this._spec.autoFit) && void 0 !== _a ? _a : this._option.autoFit) || void 0 === _b || _b), this._autoSize !== lasAutoSize && (resize = true), resize;
  }
  _getBackground() {
    return ("string" == typeof this._spec.background ? this._spec.background : null) || this._currentTheme.background || this._option.background;
  }
  getCurrentTheme() {
    return getThemeObject(this._currentThemeName);
  }
  getCurrentThemeName() {
    return this._currentThemeName;
  }
  setCurrentTheme(name) {
    return __awaiter8(this, void 0, void 0, function* () {
      if (!ThemeManager2.themeExist(name))
        return this;
      const result2 = this._setCurrentTheme(name);
      return yield this.updateCustomConfigAndRerender(result2, false, {
        transformSpec: false,
        actionSource: "setCurrentTheme"
      }), this;
    });
  }
  setCurrentThemeSync(name) {
    if (!ThemeManager2.themeExist(name))
      return this;
    const result2 = this._setCurrentTheme(name);
    return this.updateCustomConfigAndRerender(result2, true, {
      transformSpec: false,
      actionSource: "setCurrentTheme"
    }), this;
  }
  _setCurrentTheme(name) {
    var _a;
    return this._updateCurrentTheme(name), this._initChartSpec(this._getSpecFromOriginalSpec(), "setCurrentTheme"), null === (_a = this._chart) || void 0 === _a || _a.setCurrentTheme(), {
      change: true,
      reMake: false
    };
  }
  _getTooltipComponent() {
    var _a;
    return null === (_a = this._chart) || void 0 === _a ? void 0 : _a.getComponentsByType(ComponentTypeEnum.tooltip)[0];
  }
  setTooltipHandler(tooltipHandler) {
    var _a, _b;
    this._context.tooltipHandler = tooltipHandler;
    const tooltip3 = this._getTooltipComponent();
    tooltip3 && (null === (_b = null === (_a = tooltip3.tooltipHandler) || void 0 === _a ? void 0 : _a.release) || void 0 === _b || _b.call(_a), tooltip3.tooltipHandler = tooltipHandler);
  }
  getTooltipHandlerByUser() {
    var _a;
    return null === (_a = this._context) || void 0 === _a ? void 0 : _a.tooltipHandler;
  }
  getTooltipHandler() {
    const tooltip3 = this._getTooltipComponent();
    return tooltip3 ? tooltip3.tooltipHandler : this._context.tooltipHandler;
  }
  showTooltip(datum, options) {
    var _a;
    const tooltip3 = this._getTooltipComponent();
    return null !== (_a = isValid_default(datum) && "none" !== (null == tooltip3 ? void 0 : tooltip3.showTooltip(datum, options))) && void 0 !== _a && _a;
  }
  hideTooltip() {
    var _a;
    const tooltip3 = this._getTooltipComponent();
    return null !== (_a = null == tooltip3 ? void 0 : tooltip3.hideTooltip()) && void 0 !== _a && _a;
  }
  getLegendDataById(id2) {
    var _a;
    const legendComponent = null === (_a = this._chart) || void 0 === _a ? void 0 : _a.getComponentByUserId(id2);
    return legendComponent ? legendComponent.getLegendData() : [];
  }
  getLegendDataByIndex(index = 0) {
    var _a;
    const legends = null === (_a = this._chart) || void 0 === _a ? void 0 : _a.getComponentsByType(ComponentTypeEnum.discreteLegend);
    return legends && legends[index] ? legends[index].getLegendData() : [];
  }
  getLegendSelectedDataById(id2) {
    var _a;
    const legendComponent = null === (_a = this._chart) || void 0 === _a ? void 0 : _a.getComponentByUserId(id2);
    return legendComponent ? legendComponent.getSelectedData() : [];
  }
  getLegendSelectedDataByIndex(index = 0) {
    var _a;
    const legends = null === (_a = this._chart) || void 0 === _a ? void 0 : _a.getComponentsByType(ComponentTypeEnum.discreteLegend);
    return legends && legends[index] ? legends[index].getSelectedData() : [];
  }
  setLegendSelectedDataById(id2, selectedData) {
    var _a;
    const legendComponent = null === (_a = this._chart) || void 0 === _a ? void 0 : _a.getComponentByUserId(id2);
    legendComponent && legendComponent.setSelectedData(selectedData);
  }
  setLegendSelectedDataByIndex(index = 0, selectedData) {
    var _a;
    const legends = null === (_a = this._chart) || void 0 === _a ? void 0 : _a.getComponentsByType(ComponentTypeEnum.discreteLegend);
    legends && legends[index] && legends[index].setSelectedData(selectedData);
  }
  getDataURL() {
    var _a;
    return __awaiter8(this, void 0, void 0, function* () {
      const stage = this.getStage();
      if (this._chart && stage) {
        stage.render();
        const canvas = this._chart.getCanvas();
        return yield getCanvasDataURL(canvas, {
          onError: this._onError
        });
      }
      return null === (_a = this._option) || void 0 === _a || _a.onError(new ReferenceError("render is not defined")), null;
    });
  }
  exportImg(name) {
    var _a, _b;
    return __awaiter8(this, void 0, void 0, function* () {
      if (!isTrueBrowser(this._option.mode))
        return void (null === (_a = this._option) || void 0 === _a || _a.onError(new TypeError("non-browser environment can not export img")));
      const dataURL = yield this.getDataURL();
      dataURL ? URLToImage(name, dataURL) : null === (_b = this._option) || void 0 === _b || _b.onError(new ReferenceError("render is not defined"));
    });
  }
  exportCanvas() {
    var _a;
    const stage = this.getStage();
    if (this._chart && stage)
      return stage.toCanvas();
    null === (_a = this._option) || void 0 === _a || _a.onError(new ReferenceError("render is not defined"));
  }
  getImageBuffer() {
    var _a, _b;
    if ("node" !== this._option.mode)
      return void (null === (_a = this._option) || void 0 === _a || _a.onError(new TypeError("getImageBuffer() now only support node environment.")));
    const stage = this.getStage();
    if (stage) {
      stage.render();
      return stage.window.getImageBuffer();
    }
    return null === (_b = this._option) || void 0 === _b || _b.onError(new ReferenceError("render is not defined")), null;
  }
  setLayout(layout) {
    var _a;
    this._option.layout = layout, null === (_a = this._chart) || void 0 === _a || _a.setLayout(layout);
  }
  reLayout() {
    var _a;
    null === (_a = this._chart) || void 0 === _a || _a.setLayoutTag(true);
  }
  getCompiler() {
    return this._compiler;
  }
  getChart() {
    return this._chart;
  }
  getStage() {
    return this._compiler.getStage();
  }
  getCanvas() {
    var _a;
    return null === (_a = this._compiler) || void 0 === _a ? void 0 : _a.getCanvas();
  }
  getContainer() {
    var _a;
    if (isValid_default(this._container))
      return this._container;
    let canvasNode;
    return canvasNode = isString_default(this._canvas) ? null === document || void 0 === document ? void 0 : document.getElementById(this._canvas) : this._canvas, isValid_default(canvasNode) ? canvasNode.parentElement : null === (_a = this.getCanvas()) || void 0 === _a ? void 0 : _a.parentElement;
  }
  getComponents() {
    return this._chart.getAllComponents();
  }
  getScale(scaleId) {
    var _a;
    const globalScale = null === (_a = this._chart) || void 0 === _a ? void 0 : _a.getGlobalScale();
    return null == globalScale ? void 0 : globalScale.getScale(scaleId);
  }
  setDimensionIndex(value, opt = {}) {
    var _a;
    return null === (_a = this._chart) || void 0 === _a ? void 0 : _a.setDimensionIndex(value, opt);
  }
  stopAnimation() {
    var _a, _b, _c;
    null === (_c = null === (_b = null === (_a = this._compiler) || void 0 === _a ? void 0 : _a.getVGrammarView()) || void 0 === _b ? void 0 : _b.animate) || void 0 === _c || _c.stop();
  }
  pauseAnimation() {
    var _a, _b, _c;
    null === (_c = null === (_b = null === (_a = this._compiler) || void 0 === _a ? void 0 : _a.getVGrammarView()) || void 0 === _b ? void 0 : _b.animate) || void 0 === _c || _c.pause();
  }
  resumeAnimation() {
    var _a, _b, _c;
    null === (_c = null === (_b = null === (_a = this._compiler) || void 0 === _a ? void 0 : _a.getVGrammarView()) || void 0 === _b ? void 0 : _b.animate) || void 0 === _c || _c.resume();
  }
  convertDatumToPosition(datum, dataLinkInfo = {}, isRelativeToCanvas = false, checkInViewData) {
    var _a;
    if (!this._chart)
      return null;
    if (isEmpty_default(datum))
      return null;
    const { seriesId, seriesIndex = 0 } = dataLinkInfo;
    let series2;
    if (isValid_default(seriesId) ? series2 = this._chart.getSeriesInUserId(seriesId) : isValid_default(seriesIndex) && (series2 = null === (_a = this._chart.getSeriesInIndex([seriesIndex])) || void 0 === _a ? void 0 : _a[0]), series2) {
      const keys2 = Object.keys(datum), handledDatum = series2.getViewData().latestData.find((viewDatum) => keys2.every((k2) => viewDatum[k2] == datum[k2])), seriesLayoutStartPoint = series2.getRegion().getLayoutStartPoint();
      let point5;
      return point5 = handledDatum ? series2.dataToPosition(handledDatum, checkInViewData) : series2.dataToPosition(datum, checkInViewData), point5 ? convertPoint(point5, seriesLayoutStartPoint, isRelativeToCanvas) : null;
    }
    return null;
  }
  convertValueToPosition(value, dataLinkInfo, isRelativeToCanvas = false) {
    var _a, _b;
    if (!this._chart || isNil_default(value) || isEmpty_default(dataLinkInfo))
      return null;
    if (!isArray_default(value)) {
      const { axisId, axisIndex } = dataLinkInfo;
      let axis2;
      if (isValid_default(axisId) ? axis2 = this._chart.getComponentsByKey("axes").find((s2) => s2.userId === axisId) : isValid_default(axisIndex) && (axis2 = null === (_a = this._chart.getComponentsByKey("axes")) || void 0 === _a ? void 0 : _a[axisIndex]), !axis2)
        return warn("Please check whether the `axisId` or `axisIndex` is set!"), null;
      const pointValue = null == axis2 ? void 0 : axis2.valueToPosition(value);
      if (isRelativeToCanvas) {
        const axisLayoutStartPoint = axis2.getLayoutStartPoint(), axisOrient = axis2.getOrient();
        return pointValue + ("bottom" === axisOrient || "top" === axisOrient ? axisLayoutStartPoint.x : axisLayoutStartPoint.y);
      }
      return pointValue;
    }
    const { seriesId, seriesIndex } = dataLinkInfo;
    let series2;
    return isValid_default(seriesId) ? series2 = this._chart.getSeriesInUserId(seriesId) : isValid_default(seriesIndex) && (series2 = null === (_b = this._chart.getSeriesInIndex([seriesIndex])) || void 0 === _b ? void 0 : _b[0]), series2 ? convertPoint(series2.valueToPosition(value[0], value[1]), series2.getRegion().getLayoutStartPoint(), isRelativeToCanvas) : (warn("Please check whether the `seriesId` or `seriesIndex` is set!"), null);
  }
  getFunction(key) {
    return ExpressionFunction.instance().getFunction(key);
  }
  registerFunction(key, fun) {
    key && fun && ExpressionFunction.instance().registerFunction(key, fun);
  }
  unregisterFunction(key) {
    key && ExpressionFunction.instance().unregisterFunction(key);
  }
  getFunctionList() {
    return ExpressionFunction.instance().getFunctionNameList();
  }
  setRuntimeSpec(spec) {
    this._spec = spec, this._updateSpecInfo();
  }
  _initChartPlugin() {
    const pluginList = Factory2.getChartPlugins();
    pluginList.length > 0 && (this._chartPlugin = new ChartPluginService(this), this._chartPlugin.load(pluginList.map((p) => new p())), this._chartPluginApply("onInit", this._spec));
  }
  _chartPluginApply(funcName, ...args) {
    this._chartPlugin && this._chartPlugin[funcName] && this._chartPlugin[funcName].apply(this._chartPlugin, args);
  }
  _getMode() {
    return this._option.mode || RenderModeEnum["desktop-browser"];
  }
  _getChartOption(type) {
    return {
      type,
      globalInstance: this,
      eventDispatcher: this._eventDispatcher,
      dataSet: this._dataSet,
      container: this._container,
      canvas: this._canvas,
      map: /* @__PURE__ */ new Map(),
      mode: this._getMode(),
      modeParams: this._option.modeParams,
      getCompiler: () => this._compiler,
      performanceHook: this._option.performanceHook,
      viewBox: this._viewBox,
      animation: this._option.animation,
      getTheme: () => {
        var _a;
        return null !== (_a = this._currentTheme) && void 0 !== _a ? _a : {};
      },
      getSpecInfo: () => {
        var _a;
        return null !== (_a = this._specInfo) && void 0 !== _a ? _a : {};
      },
      layout: this._option.layout,
      onError: this._onError,
      disableTriggerEvent: true === this._option.disableTriggerEvent
    };
  }
};
VChart.InstanceManager = InstanceManager, VChart.ThemeManager = ThemeManager2, VChart.globalConfig = {
  uniqueTooltip: true
}, VChart.Utils = VCHART_UTILS, VChart.vglobal = vglobal;
Factory2.registerRegion("region", Region), Factory2.registerLayout("base", Layout), registerGroupMark(), View.useRegisters([registerFilterTransform, registerMapTransform]), registerVGrammarCommonAnimation(), registerElementHighlight(), registerElementSelect(), registerTheme(darkTheme2.name, darkTheme2), Logger.getInstance(LoggerLevel.Error);

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/plugin/chart/media-query/util/query
var checkMediaQuery = (query, mediaInfo, globalInstance) => {
  for (const conditionKey in query)
    switch (conditionKey) {
      case "maxHeight":
        if (isValid_default(query.maxHeight) && mediaInfo.height > query.maxHeight)
          return false;
        break;
      case "minHeight":
        if (isValid_default(query.minHeight) && mediaInfo.height < query.minHeight)
          return false;
        break;
      case "maxWidth":
        if (isValid_default(query.maxWidth) && mediaInfo.width > query.maxWidth)
          return false;
        break;
      case "minWidth":
        if (isValid_default(query.minWidth) && mediaInfo.width < query.minWidth)
          return false;
        break;
      case "onResize":
        if (isValid_default(query.onResize) && !query.onResize(mediaInfo, globalInstance))
          return false;
    }
  return true;
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/plugin/chart/media-query/util/filter
var executeMediaQueryActionFilter = (filterType = "chart", filter2, action, query, chartSpec, chartSpecInfo) => {
  const result2 = executeMediaQueryActionFilterType(filterType, chartSpec, chartSpecInfo);
  return Object.assign(Object.assign({}, result2), {
    modelInfo: result2.modelInfo.filter((info) => !!isNil_default(filter2) || array(filter2).some((f) => isFunction_default(f) ? f(info, action, query) : includeSpec(info.spec, f)))
  });
};
var executeMediaQueryActionFilterType = (filterType = "chart", chartSpec, chartSpecInfo) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
  const result2 = {
    modelInfo: []
  };
  if ("chart" === filterType)
    result2.isChart = true, result2.modelInfo.push({
      spec: chartSpec,
      type: "chart"
    });
  else if ("region" === filterType)
    result2.modelType = "region", result2.specKey = "region", null === (_a = chartSpec.region) || void 0 === _a || _a.forEach((regionSpec, i) => {
      result2.modelInfo.push({
        spec: regionSpec,
        specPath: ["region", i],
        type: "region"
      });
    });
  else if ("series" === filterType)
    result2.modelType = "series", result2.specKey = "series", null === (_b = chartSpec.series) || void 0 === _b || _b.forEach((seriesSpec, i) => {
      result2.modelInfo.push({
        spec: seriesSpec,
        specPath: ["series", i],
        type: seriesSpec.type
      });
    });
  else if (Object.values(SeriesTypeEnum).includes(filterType))
    result2.modelType = "series", result2.specKey = "series", result2.type = filterType, null === (_c = chartSpec.series) || void 0 === _c || _c.forEach((seriesSpec, i) => {
      seriesSpec.type === filterType && result2.modelInfo.push({
        spec: seriesSpec,
        specPath: ["series", i],
        type: filterType
      });
    });
  else if (Object.values(ComponentTypeEnum).includes(filterType)) {
    result2.modelType = "component", result2.type = filterType, result2.specKey = null === (_d = Factory2.getComponentInKey(filterType)) || void 0 === _d ? void 0 : _d.specKey;
    const { specKey } = result2, infoList = array(null !== (_f = null === (_e = chartSpecInfo.component) || void 0 === _e ? void 0 : _e[specKey]) && void 0 !== _f ? _f : []);
    null === (_h = array(null !== (_g = chartSpec[specKey]) && void 0 !== _g ? _g : [])) || void 0 === _h || _h.forEach((componentSpec, i) => {
      const specInfo = infoList[i];
      specInfo.type === filterType && result2.modelInfo.push(Object.assign(Object.assign({}, specInfo), {
        spec: componentSpec
      }));
    });
  } else {
    const componentTypes = Factory2.getComponents().filter(({ cmp }) => cmp.specKey === filterType).map(({ cmp }) => cmp.type);
    if (componentTypes.length > 0) {
      result2.modelType = "component";
      const specKey = filterType;
      result2.specKey = specKey;
      const infoList = array(null !== (_k = null === (_j = chartSpecInfo.component) || void 0 === _j ? void 0 : _j[specKey]) && void 0 !== _k ? _k : []);
      array(null !== (_l = chartSpec[specKey]) && void 0 !== _l ? _l : []).forEach((componentSpec, i) => {
        const specInfo = infoList[i];
        componentTypes.includes(specInfo.type) && result2.modelInfo.push(Object.assign(Object.assign({}, specInfo), {
          spec: componentSpec
        }));
      });
    }
  }
  return result2;
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/plugin/chart/media-query/util/action
var executeMediaQueryAction = (action, query, chartSpec, chartSpecInfo) => {
  const { spec, filter: filter2, filterType, forceAppend } = action, { isChart, modelType, specKey, type, modelInfo } = executeMediaQueryActionFilter(filterType, filter2, action, query, chartSpec, chartSpecInfo);
  if (0 === modelInfo.length && !forceAppend)
    return {
      chartSpec,
      hasChanged: false
    };
  const targetSpec = mergeSpec({}, chartSpec), newSpec = isFunction_default(spec) ? spec(modelInfo, action, query) : spec;
  for (const { spec: spec2, specPath } of modelInfo) {
    if (isChart)
      return {
        chartSpec: mergeSpec(targetSpec, newSpec),
        hasChanged: true
      };
    const modelSpec = mergeSpec({}, spec2, newSpec);
    setProperty(targetSpec, specPath, modelSpec);
  }
  if (0 === modelInfo.length && forceAppend) {
    const newSpecToAppend = Object.assign({
      type
    }, newSpec);
    isArray_default(targetSpec[specKey]) ? targetSpec[specKey].push(newSpecToAppend) : isNil_default(targetSpec[specKey]) ? targetSpec[specKey] = "component" === modelType ? newSpecToAppend : [newSpecToAppend] : targetSpec[specKey] = [targetSpec[specKey], newSpecToAppend];
  }
  return {
    chartSpec: targetSpec,
    hasChanged: true
  };
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/plugin/base/base-plugin
var BasePlugin = class {
  constructor(type) {
    this.id = createID(), this.name = `${type}_${this.id}`;
  }
  onAdd(service) {
    this.service = service;
  }
  release() {
    this.service = null;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/plugin/chart/media-query/media-query
var MediaQuery = class _MediaQuery extends BasePlugin {
  constructor() {
    super(_MediaQuery.type), this.type = "MediaQueryPlugin", this._currentMediaInfo = {}, this.currentActiveItems = /* @__PURE__ */ new Set(), this._initialized = false;
  }
  onInit(service, chartSpec) {
    if (!(null == chartSpec ? void 0 : chartSpec[_MediaQuery.specKey]))
      return;
    const { globalInstance } = service;
    this._option = {
      globalInstance: service.globalInstance,
      updateSpec: (spec, compile, render) => {
        render ? globalInstance.updateSpecSync(spec) : compile ? globalInstance.updateSpecAndRecompile(spec, false, {
          transformSpec: true
        }) : globalInstance.setRuntimeSpec(spec);
      }
    }, this._spec = chartSpec[_MediaQuery.specKey], this._initialized = true;
  }
  onBeforeResize(service, width, height) {
    this._initialized && this._changeSize(width, height, true, false);
  }
  onAfterChartSpecTransform(service, chartSpec, actionSource) {
    this._initialized && "setCurrentTheme" === actionSource && this._reInit(false, false);
  }
  onBeforeInitChart(service, chartSpec, actionSource) {
    if (!this._initialized)
      return;
    let resetMediaQuery, checkMediaQuery2;
    switch (actionSource) {
      case "render":
      case "updateModelSpec":
        resetMediaQuery = false, checkMediaQuery2 = true;
        break;
      case "updateSpec":
      case "setCurrentTheme":
        resetMediaQuery = true, checkMediaQuery2 = false;
        break;
      case "updateSpecAndRecompile":
        resetMediaQuery = false, checkMediaQuery2 = false;
    }
    if (resetMediaQuery && this.release(), this._initialized || this.onInit(service, chartSpec), resetMediaQuery || checkMediaQuery2) {
      const { width, height } = this._option.globalInstance.getCurrentSize();
      this._changeSize(width, height, false, false);
    }
  }
  _changeSize(width, height, compile, render) {
    return (this._currentMediaInfo.width !== width || this._currentMediaInfo.height !== height) && (this._currentMediaInfo.width = width, this._currentMediaInfo.height = height, this._applyQueries(compile, render));
  }
  _applyQueries(compile, render) {
    const changeToActive = [], changeToInactive = [];
    if (this._spec.forEach((item) => {
      const { hasChanged: hasChanged2, isActive } = this._check(item);
      hasChanged2 && (isActive ? changeToActive.push(item) : changeToInactive.push(item));
    }), !changeToActive.length && !changeToInactive.length)
      return false;
    let chartSpec, chartSpecInfo;
    this._baseChartSpec || (this._baseChartSpec = cloneDeepSpec(this._option.globalInstance.getSpec(), ["data", _MediaQuery.specKey]), this._baseChartSpecInfo = this._option.globalInstance.getSpecInfo());
    let hasChanged = false;
    return changeToInactive.length > 0 ? (chartSpec = cloneDeepSpec(this._baseChartSpec, ["data", _MediaQuery.specKey]), chartSpecInfo = this._baseChartSpecInfo, Array.from(this.currentActiveItems).forEach((item) => {
      if (changeToInactive.includes(item))
        return void this.currentActiveItems.delete(item);
      const result2 = this._apply(item, chartSpec, chartSpecInfo);
      chartSpec = result2.chartSpec;
    }), hasChanged = true) : (chartSpec = this._option.globalInstance.getSpec(), chartSpecInfo = this._option.globalInstance.getSpecInfo()), changeToActive.forEach((item) => {
      this.currentActiveItems.add(item);
      const result2 = this._apply(item, chartSpec, chartSpecInfo);
      chartSpec = result2.chartSpec, hasChanged || (hasChanged = result2.hasChanged);
    }), hasChanged && this._option.updateSpec(chartSpec, compile, render), true;
  }
  _check(item) {
    const { globalInstance } = this._option, isActive = checkMediaQuery(item.query, this._currentMediaInfo, globalInstance);
    return {
      isActive,
      hasChanged: isActive !== this.currentActiveItems.has(item)
    };
  }
  _apply(item, chartSpec, chartSpecInfo) {
    const { query, action } = item;
    let hasChanged = false;
    return array(action).forEach((actionItem) => {
      const result2 = executeMediaQueryAction(actionItem, query, chartSpec, chartSpecInfo);
      chartSpec = result2.chartSpec, hasChanged || (hasChanged = result2.hasChanged);
    }), {
      chartSpec,
      hasChanged
    };
  }
  _reInit(compile, render) {
    let chartSpec = this._option.globalInstance.getSpec();
    this._baseChartSpec = cloneDeepSpec(chartSpec, ["data", _MediaQuery.specKey]), this._baseChartSpecInfo = this._option.globalInstance.getSpecInfo();
    let hasChanged = false;
    this.currentActiveItems.forEach((item) => {
      const result2 = this._apply(item, chartSpec, this._baseChartSpecInfo);
      chartSpec = result2.chartSpec, hasChanged || (hasChanged = result2.hasChanged);
    }), hasChanged && this._option.updateSpec(chartSpec, compile, render);
  }
  release() {
    super.release(), this._initialized = false, this._spec = [], this._option = void 0, this._currentMediaInfo = {}, this.currentActiveItems.clear();
  }
};
MediaQuery.pluginType = "chart", MediaQuery.specKey = "media", MediaQuery.type = "MediaQueryPlugin";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/plugin/chart/formatter/formatter
var bracketReg = /\{([^}]+)\}/;
var bracketGReg = /\{([^}]+)\}/g;
var semicolonReg = /:/;
var FormatterPlugin = class _FormatterPlugin extends BasePlugin {
  constructor() {
    super(_FormatterPlugin.type), this.type = "formatterPlugin", this._timeModeFormat = {
      utc: TimeUtil.getInstance().timeUTCFormat,
      local: TimeUtil.getInstance().timeFormat
    }, this._formatter = this._format, this._timeFormatter = this._timeModeFormat.local, this._numericFormatter = NumberUtil.getInstance().format, this._numericSpecifier = NumberUtil.getInstance().formatter, this._numericFormatterCache = /* @__PURE__ */ new Map(), this._isNumericFormatterCache = /* @__PURE__ */ new Map();
  }
  onInit(service, chartSpec) {
    var _a;
    const { globalInstance } = service;
    if (!globalInstance)
      return;
    this._spec = null !== (_a = null == chartSpec ? void 0 : chartSpec[_FormatterPlugin.specKey]) && void 0 !== _a ? _a : {};
    const { timeMode, customFormatter, numericFormatter, timeFormatter } = this._spec;
    isFunction_default(customFormatter) ? this._formatter = customFormatter : (this._formatter = this._format.bind(this), isFunction_default(timeFormatter) ? this._timeFormatter = timeFormatter : timeMode && this._timeModeFormat[timeMode] && (this._timeFormatter = this._timeModeFormat[timeMode]), numericFormatter && (this._numericFormatter = numericFormatter, this._numericSpecifier = null, this._numericFormatterCache = null)), Factory2.registerFormatter(this._formatter);
  }
  _format(text2, datum, formatter) {
    return isArray_default(text2) ? text2.map((t, i) => {
      const f = isArray_default(formatter) ? formatter[i] : formatter;
      return f ? this._formatSingleLine(t, datum, f) : t;
    }) : isArray_default(formatter) ? formatter.map((f) => this._formatSingleLine(text2, datum, f)) : this._formatSingleLine(text2, datum, formatter);
  }
  _formatSingleLine(text2, datum, formatter) {
    let isTemplate;
    if (this._isNumericFormatterCache && (this._isNumericFormatterCache.get(formatter) ? isTemplate = this._isNumericFormatterCache.get(formatter) : (isTemplate = bracketReg.test(formatter), this._isNumericFormatterCache.set(formatter, isTemplate))), isTemplate) {
      return formatter.replace(bracketGReg, (match, key) => {
        if (!semicolonReg.test(key)) {
          const value2 = datum[key.trim()];
          return void 0 !== value2 ? value2 : match;
        }
        const parts = key.split(":"), value = datum[parts.shift()], valueFormatter = parts.join(":");
        return this._formatSingleText(value, valueFormatter);
      });
    }
    return this._formatSingleText(text2, formatter);
  }
  _formatSingleText(text2, formatter) {
    if (numberSpecifierReg.test(formatter) && this._numericFormatter) {
      let numericFormat;
      return this._numericFormatterCache && this._numericSpecifier ? (this._numericFormatterCache.get(formatter) ? numericFormat = this._numericFormatterCache.get(formatter) : (numericFormat = this._numericSpecifier(formatter), this._numericFormatterCache.set(formatter, numericFormat)), numericFormat(Number(text2))) : this._numericFormatter(formatter, Number(text2));
    }
    return formatter.includes("%") && this._timeFormatter ? this._timeFormatter(formatter, text2) : text2;
  }
  release() {
    super.release(), this._format = null, this._timeFormatter = null, this._numericFormatter = null, this._numericSpecifier = null, this._numericFormatterCache = null, this._isNumericFormatterCache = null;
  }
};
FormatterPlugin.pluginType = "chart", FormatterPlugin.specKey = "formatter", FormatterPlugin.type = "formatterPlugin";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/plugin/components/axis-sync/zero-align-transform
function isValidAlignDomain(domain) {
  return 2 === domain.length && isValidNumber_default(domain[0]) && isValidNumber_default(domain[1]) && domain[1] >= domain[0];
}
function getScaleInfo(axis2, domain) {
  const total = domain[1] - domain[0], includeZero = domain[1] * domain[0] < 0;
  let negative = domain[0] <= 0 ? 0 - domain[0] : 0, positive = domain[1] > 0 ? domain[1] - 0 : 0;
  0 === total ? domain[0] < 0 ? (negative = 1, positive = 0) : domain[0] > 0 && (negative = 0, positive = 1) : (negative /= total, positive /= total);
  const domainSpec = axis2.getDomainSpec();
  return {
    total,
    negative,
    positive,
    includeZero,
    domain,
    extendable_min: !isValidNumber_default(domainSpec.min),
    extendable_max: !isValidNumber_default(domainSpec.max)
  };
}
function inDifferentCrossZero(info1, info2) {
  const { positive: positive1, negative: negative1, extendable_min: s1Extendable_min, extendable_max: s1Extendable_max, domain: domain1 } = info1, { positive: positive2, negative: negative2, extendable_min: s2Extendable_min, extendable_max: s2Extendable_max, domain: domain2 } = info2;
  if (positive2 > 0) {
    if (!s2Extendable_min)
      return false;
    let comp = negative1 / positive1;
    s1Extendable_max && (comp = negative1 / Math.max(positive1, positive2), domain1[1] = -domain1[0] / comp), domain2[0] = -domain2[1] * comp;
  } else if (negative2 > 0) {
    if (!s2Extendable_max)
      return false;
    let comp = positive1 / negative1;
    s1Extendable_min && (comp = positive1 / Math.max(negative1, negative1), domain1[0] = -domain1[1] / comp), domain2[1] = -domain2[0] * comp;
  }
  return true;
}
function inOnlyZeroDomain(info1, info2) {
  const { extendable_min: s1Extendable_min, extendable_max: s1Extendable_max, domain: domain1 } = info1, { positive: positive2, negative: negative2, domain: domain2 } = info2;
  return (0 !== positive2 || 0 !== negative2) && (!(positive2 > 0 && !s1Extendable_max) && (!(negative2 > 0 && !s1Extendable_min) && (domain1[0] = domain2[0], domain1[1] = domain2[1], true)));
}
function inAllCrossZero(info1, info2) {
  const { positive: positive1, negative: negative1, extendable_max: s1Extendable_max, domain: domain1 } = info1, { positive: positive2, negative: negative2, extendable_min: s2Extendable_min, domain: domain2 } = info2;
  if (s1Extendable_max && s2Extendable_min) {
    const comp = Math.max(negative1, negative2) / Math.max(positive1, positive2);
    domain1[1] = -domain1[0] / comp, domain2[0] = -domain2[1] * comp;
  } else if (s2Extendable_min) {
    const comp = negative1 / positive1;
    domain2[0] = -domain2[1] * comp;
  } else {
    if (!s1Extendable_max)
      return false;
    {
      const comp = negative2 / positive2;
      domain1[1] = -domain1[0] / comp;
    }
  }
  return true;
}
function inNoCrossDifferentSide(info1, info2) {
  const { extendable_min: s1Extendable_min, domain: domain1 } = info1, { extendable_max: s2Extendable_max, domain: domain2 } = info2;
  return !(!s1Extendable_min || !s2Extendable_max) && (domain1[0] = -domain1[1], domain2[1] = -domain2[0], true);
}
var zeroAlign = (targetAxis, currentAxis) => {
  var _a, _b, _c, _d, _e, _f;
  const s1 = targetAxis.getScale(), s2 = currentAxis.getScale();
  if (!s1 || !s2)
    return;
  const domain1 = null !== (_c = null === (_b = (_a = targetAxis).getDomainAfterSpec) || void 0 === _b ? void 0 : _b.call(_a)) && void 0 !== _c ? _c : [0, 1], domain2 = null !== (_f = null === (_e = (_d = currentAxis).getDomainAfterSpec) || void 0 === _e ? void 0 : _e.call(_d)) && void 0 !== _f ? _f : [0, 1];
  if (!(domain1 && domain2 && isValidAlignDomain(domain1) && isValidAlignDomain(domain2)))
    return;
  const info1 = getScaleInfo(targetAxis, domain1), info2 = getScaleInfo(currentAxis, domain2), { positive: positive1, negative: negative1, extendable_min: s1Extendable_min, extendable_max: s1Extendable_max, includeZero: includeZero1 } = info1, { positive: positive2, negative: negative2, extendable_min: s2Extendable_min, extendable_max: s2Extendable_max, includeZero: includeZero2 } = info2;
  if (0 === positive1 && 0 === negative1) {
    if (!inOnlyZeroDomain(info1, info2))
      return;
  } else if (0 === positive2 && 0 === negative2) {
    if (!inOnlyZeroDomain(info2, info1))
      return;
  } else if (includeZero1 || includeZero2)
    if (includeZero1 && !includeZero2) {
      if (!inDifferentCrossZero(info1, info2))
        return;
    } else if (includeZero2 && !includeZero1) {
      if (!inDifferentCrossZero(info2, info1))
        return;
    } else {
      if (negative1 === negative2)
        return;
      if (negative1 > negative2) {
        if (!inAllCrossZero(info1, info2))
          return;
      } else if (!inAllCrossZero(info2, info1))
        return;
    }
  else {
    if (0 === negative1 && 0 === positive2) {
      if (!inNoCrossDifferentSide(info1, info2))
        return;
    } else if (0 === negative2 && 0 === positive1 && !inNoCrossDifferentSide(info2, info1))
      return;
    if (0 === negative1 && 0 === negative2)
      if (0 === domain1[0] && domain2[0] > 0) {
        if (!s2Extendable_min)
          return;
        domain2[0] = 0;
      } else {
        if (!(0 === domain2[0] && domain1[0] > 0))
          return;
        if (!s1Extendable_min)
          return;
        domain1[0] = 0;
      }
    if (0 === positive1 && 0 === positive2)
      if (0 === domain1[1] && domain2[1] > 0) {
        if (!s2Extendable_max)
          return;
        domain2[1] = 0;
      } else {
        if (!(0 === domain2[1] && domain1[1] > 0))
          return;
        if (!s1Extendable_max)
          return;
        domain1[1] = 0;
      }
  }
  s1.domain(domain1), s2.domain(domain2);
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/plugin/components/axis-sync/tick-align-transform
var tickAlign = (data, op) => {
  var _a, _b, _c, _d, _e;
  if (!data)
    return data;
  const targetAxis = null === (_a = null == op ? void 0 : op.targetAxis) || void 0 === _a ? void 0 : _a.call(op);
  if (!targetAxis)
    return data;
  const currentAxis = null === (_b = null == op ? void 0 : op.currentAxis) || void 0 === _b ? void 0 : _b.call(op);
  if (!currentAxis)
    return data;
  const currentData = null === (_c = currentAxis.getTickData()) || void 0 === _c ? void 0 : _c.getDataView();
  if (!currentData)
    return data;
  if (!currentData.transformsArr.find((t) => "ticks" === t.type))
    return data;
  const currentScale = currentAxis.getScale();
  if (!currentScale)
    return data;
  const targetData = null === (_e = null === (_d = targetAxis.getTickData()) || void 0 === _d ? void 0 : _d.getDataView()) || void 0 === _e ? void 0 : _e.latestData;
  if (!(null == targetData ? void 0 : targetData.length))
    return data;
  const targetScale = targetAxis.getScale();
  if (!targetScale)
    return data;
  const targetDomain = targetScale.domain(), targetRange = targetDomain[1] - targetDomain[0];
  if (0 === targetRange)
    return data;
  const currentDomain = currentScale.domain(), currentRange = currentDomain[1] - currentDomain[0];
  if (0 === targetRange)
    return data;
  const newTicks = targetData.map((d) => {
    const percent = (d.value - targetDomain[0]) / targetRange;
    return currentRange * percent + currentDomain[0];
  });
  return convertDomainToTickData(newTicks);
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/plugin/components/axis-sync/axis-sync
var AxisSyncPlugin = class _AxisSyncPlugin extends BasePlugin {
  constructor() {
    super(_AxisSyncPlugin.type), this.type = "AxisSyncPlugin";
  }
  _checkEnableSync(axis2) {
    if (!isContinuous(axis2.getScale().type))
      return false;
    const sync = axis2.getSpec().sync;
    return !!(null == sync ? void 0 : sync.axisId) && sync;
  }
  _getTargetAxis(axis2, sync) {
    const targetAxis = axis2.getOption().getChart().getComponentByUserId(sync.axisId);
    return (null == targetAxis ? void 0 : targetAxis.type.startsWith("cartesianAxis")) ? targetAxis : null;
  }
  onInit(service, axis2) {
    const sync = this._checkEnableSync(axis2);
    if (!sync)
      return;
    if (!sync.zeroAlign)
      return;
    const targetAxis = this._getTargetAxis(axis2, sync);
    targetAxis && axis2.event.on(ChartEvent.scaleDomainUpdate, {
      filter: ({ model }) => model.id === axis2.id || model.id === targetAxis.id
    }, () => {
      zeroAlign(targetAxis, axis2);
    });
  }
  onDidCompile(service, axis2) {
    const sync = this._checkEnableSync(axis2);
    if (!sync)
      return;
    const targetAxis = this._getTargetAxis(axis2, sync);
    if (targetAxis && sync.tickAlign) {
      registerDataSetInstanceTransform(axis2.getOption().dataSet, "tickAlign", tickAlign);
      const opt = {
        targetAxis: () => targetAxis,
        currentAxis: () => axis2
      };
      axis2.addTransformToTickData({
        type: "tickAlign",
        options: opt,
        level: Number.MAX_SAFE_INTEGER
      }, false);
    }
  }
};
AxisSyncPlugin.pluginType = "component", AxisSyncPlugin.type = "AxisSyncPlugin";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/plugin/components/tooltip-handler/utils/common
function escapeHTML(value) {
  return String(value).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\(/g, "&#40;").replace(/  /g, " &nbsp;");
}
var getScale = (element, boundingClientRect) => element ? (boundingClientRect || (boundingClientRect = element.getBoundingClientRect()), element.offsetWidth > 0 ? boundingClientRect.width / element.offsetWidth : boundingClientRect.height / element.offsetHeight) : 1;
var measureTooltipText = (text2, style) => {
  var _a;
  let textLines, textConfig;
  "rich" !== (null == text2 ? void 0 : text2.type) && "html" !== (null == text2 ? void 0 : text2.type) ? (text2 = (null != text2 ? text2 : "").toString(), style.multiLine ? (textLines = text2.split("\n"), textLines = textLines.map((line2, i) => i < textLines.length - 1 ? line2 + "\n" : line2)) : textLines = [text2], textConfig = textLines.map((line2) => Object.assign(Object.assign({}, style), {
    text: line2
  }))) : (textConfig = text2.text, textLines = text2);
  const bound2 = getRichTextBounds({
    wordBreak: null !== (_a = style.wordBreak) && void 0 !== _a ? _a : "break-word",
    maxWidth: style.maxWidth ? style.maxWidth : void 0,
    width: 0,
    height: 0,
    textConfig
  });
  return {
    width: bound2.width(),
    height: bound2.height(),
    text: textLines
  };
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/plugin/components/tooltip-handler/constants
var TOOLTIP_CONTAINER_EL_CLASS_NAME = "vchart-tooltip-container";
var TOOLTIP_EMPTY_STRING = "";
var DEFAULT_OPTIONS = {
  offsetX: 10,
  offsetY: 10,
  sanitize: escapeHTML
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/util
function getComponentThemeFromOption(type, chartTheme) {
  return get_default(chartTheme, `component.${type}`);
}
function getFormatFunction(formatMethod, formatter, text2, datum) {
  if (formatMethod)
    return {
      formatFunc: formatMethod,
      args: [text2, datum]
    };
  const formatterImpl = Factory2.getFormatter();
  return formatter && formatterImpl ? {
    formatFunc: formatterImpl,
    args: [text2, datum, formatter]
  } : {};
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/axis/util
var DEFAULT_TITLE_STYLE = {
  left: {
    textAlign: "center",
    textBaseline: "bottom"
  },
  right: {
    textAlign: "center",
    textBaseline: "bottom"
  },
  radius: {},
  angle: {}
};
function transformAxisLineStyle(lineCfg) {
  return (lineCfg = transformComponentStyle(lineCfg)).startSymbol = transformComponentStyle(lineCfg.startSymbol), lineCfg.endSymbol = transformComponentStyle(lineCfg.endSymbol), lineCfg;
}
function getAxisLabelOffset(axisSpec) {
  let labelOffset = 0;
  return get_default(axisSpec, "tick.visible") && (labelOffset += get_default(axisSpec, "tick.tickSize")), get_default(axisSpec, "label.visible") && (labelOffset += get_default(axisSpec, "label.space")), labelOffset;
}
function getLinearAxisSpecDomain(axisSpec, defaultDomain) {
  var _a, _b, _c, _d, _e, _f;
  return {
    min: null !== (_c = null !== (_a = axisSpec.min) && void 0 !== _a ? _a : null === (_b = axisSpec.range) || void 0 === _b ? void 0 : _b.min) && void 0 !== _c ? _c : null == defaultDomain ? void 0 : defaultDomain.min,
    max: null !== (_f = null !== (_d = axisSpec.max) && void 0 !== _d ? _d : null === (_e = axisSpec.range) || void 0 === _e ? void 0 : _e.max) && void 0 !== _f ? _f : null == defaultDomain ? void 0 : defaultDomain.max
  };
}
function isValidCartesianAxis(spec) {
  const orient = null == spec ? void 0 : spec.orient;
  return "top" === orient || "bottom" === orient || "left" === orient || "right" === orient || "z" === orient;
}
function isValidPolarAxis(spec) {
  const orient = null == spec ? void 0 : spec.orient;
  return "angle" === orient || "radius" === orient;
}
var getCartesianAxisTheme = (orient, type, chartTheme) => {
  var _a;
  const axisTypeTheme = null !== (_a = "band" === type ? getComponentThemeFromOption("axisBand", chartTheme) : ["linear", "log", "symlog"].includes(type) ? getComponentThemeFromOption("axisLinear", chartTheme) : {}) && void 0 !== _a ? _a : {}, axisTheme = isXAxis(orient) ? getComponentThemeFromOption("axisX", chartTheme) : isYAxis(orient) ? getComponentThemeFromOption("axisY", chartTheme) : getComponentThemeFromOption("axisZ", chartTheme);
  return mergeSpec({}, getComponentThemeFromOption("axis", chartTheme), axisTypeTheme, axisTheme);
};
var getPolarAxisTheme = (orient, type, chartTheme) => {
  var _a;
  const axisTypeTheme = null !== (_a = "band" === type ? getComponentThemeFromOption("axisBand", chartTheme) : "linear" === type ? getComponentThemeFromOption("axisLinear", chartTheme) : {}) && void 0 !== _a ? _a : {}, axisTheme = getComponentThemeFromOption("angle" === orient ? "axisAngle" : "axisRadius", chartTheme);
  return mergeSpec({}, getComponentThemeFromOption("axis", chartTheme), axisTypeTheme, axisTheme);
};
var isDiscreteAxis = (axisType) => "band" === axisType || "ordinal" === axisType || "point" === axisType;
function getAxisItem(value, normalizedValue) {
  return {
    id: value,
    label: value,
    value: normalizedValue,
    rawValue: value
  };
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/crosshair/utils/common
function limitTagInBounds(shape, bounds) {
  const { x1: regionMinX, y1: regionMinY, x2: regionMaxX, y2: regionMaxY } = bounds, { x1: x14, y1: y14, x2: x23, y2: y23 } = shape.AABBBounds, { dx: originDx = 0, dy: originDy = 0 } = shape.attribute;
  let dx = 0, dy = 0;
  x14 < regionMinX && (dx = regionMinX - x14), y14 < regionMinY && (dy = regionMinY - y14), x23 > regionMaxX && (dx = regionMaxX - x23), y23 > regionMaxY && (dy = regionMaxY - y23), dx && shape.setAttribute("dx", dx + originDx), dy && shape.setAttribute("dy", dy + originDy);
}
function getDatumByValue(data, value, startField, endField) {
  let left2 = 0, right2 = data.length - 1;
  for (; left2 <= right2; ) {
    const mid = Math.floor((left2 + right2) / 2), record = data[mid];
    if (record[startField] <= value && record[endField || startField] >= value)
      return record;
    record[startField] > value ? right2 = mid - 1 : left2 = mid + 1;
  }
  return null;
}
var getCartesianCrosshairTheme = (chartTheme, chartSpec) => {
  var _a, _b;
  const axes = array(null !== (_a = chartSpec.axes) && void 0 !== _a ? _a : []), { bandField, linearField, xField, yField } = null !== (_b = getComponentThemeFromOption(ComponentTypeEnum.crosshair, chartTheme)) && void 0 !== _b ? _b : {}, xAxis = axes.find((axis2) => isXAxis(axis2.orient));
  let newXField;
  newXField = isValid_default(xAxis) ? mergeSpec({}, isDiscreteAxis(xAxis.type) ? bandField : linearField, xField) : xField;
  const yAxis = axes.find((axis2) => isYAxis(axis2.orient));
  let newYField;
  return newYField = isValid_default(yAxis) ? mergeSpec({}, isDiscrete(yAxis.type) ? bandField : linearField, yField) : yField, {
    xField: newXField,
    yField: newYField
  };
};
var getPolarCrosshairTheme = (chartTheme, chartSpec) => {
  var _a, _b;
  const axes = array(null !== (_a = chartSpec.axes) && void 0 !== _a ? _a : []), { bandField, linearField, categoryField, valueField } = null !== (_b = getComponentThemeFromOption(ComponentTypeEnum.crosshair, chartTheme)) && void 0 !== _b ? _b : {}, angleAxis = axes.find((axis2) => "angle" === axis2.orient);
  let newAngleField;
  newAngleField = isValid_default(angleAxis) ? mergeSpec({}, isDiscreteAxis(angleAxis.type) ? bandField : linearField, categoryField) : categoryField;
  const radiusAxis = axes.find((axis2) => "radius" === axis2.orient);
  let newRadiusField;
  return newRadiusField = isValid_default(radiusAxis) ? mergeSpec({}, isDiscrete(radiusAxis.type) ? bandField : linearField, valueField) : valueField, {
    categoryField: newAngleField,
    valueField: newRadiusField
  };
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/crosshair/utils/cartesian
var layoutByValue = (tag = 3, series2, layoutStartPoint, currValueX, currValueY, xHair, yHair, enableRemain = false, cacheXCrossHairInfo, cacheYCrossHairInfo) => {
  const layoutX = 1 & tag, layoutY = 2 & tag;
  layoutStartPoint || (layoutStartPoint = {
    x: 0,
    y: 0
  });
  let xAxis = null, yAxis = null, x = 0, y = 0;
  if (currValueX.size) {
    const item = Array.from(currValueX.values())[0];
    x = item.axis.getScale().scale(item.value) + item.axis.getLayoutStartPoint().x - layoutStartPoint.x, xAxis = item.axis;
  }
  if (currValueY.size) {
    const item = Array.from(currValueY.values())[0];
    y = item.axis.getScale().scale(item.value) + item.axis.getLayoutStartPoint().y - layoutStartPoint.y, yAxis = item.axis;
  }
  const xVisible = !!currValueX.size && Number.isFinite(x), yVisible = !!currValueY.size && Number.isFinite(y), xUseCache = enableRemain && !xVisible && isValid_default(cacheXCrossHairInfo), yUseCache = enableRemain && !yVisible && isValid_default(cacheYCrossHairInfo);
  let xCrossHairInfo, yCrossHairInfo, bandWidth;
  layoutX && (xCrossHairInfo = xUseCache ? cacheXCrossHairInfo : {
    height: 0,
    leftPos: 0,
    rightPos: 0,
    topPos: 0,
    x: 0,
    bottom: {
      visible: false,
      text: "",
      dx: 0,
      dy: 0
    },
    top: {
      visible: false,
      text: "",
      dx: 0,
      dy: 0
    },
    visible: xVisible,
    axis: xAxis
  }), layoutY && (yCrossHairInfo = yUseCache ? cacheYCrossHairInfo : {
    width: 0,
    leftPos: 0,
    topPos: 0,
    bottomPos: 0,
    y: 0,
    left: {
      visible: false,
      text: "",
      dx: 0,
      dy: 0
    },
    right: {
      visible: false,
      text: "",
      dx: 0,
      dy: 0
    },
    visible: yVisible,
    axis: yAxis
  });
  let bandHeight, offsetWidth = 0, offsetHeight = 0;
  if (xHair && currValueX.forEach(({ axis: axis2, value }) => {
    var _a;
    value = null != value ? value : "";
    let niceLabelFormatter = null;
    const xScale = axis2.getScale();
    if (isDiscrete(xScale.type))
      bandWidth = xScale.bandwidth(), 0 === bandWidth && xScale.step && (offsetWidth = xScale.step());
    else if (isContinuous(xScale.type)) {
      const fieldX = series2.fieldX[0], fieldX2 = series2.fieldX2, datum = getDatumByValue(series2.getViewData().latestData, +value, fieldX, fieldX2);
      if (datum) {
        const startX = series2.dataToPositionX(datum);
        fieldX2 ? (bandWidth = Math.abs(startX - series2.dataToPositionX1(datum)), value = `${datum[fieldX]} ~ ${datum[fieldX2]}`) : bandWidth = 1, x = startX;
      }
      niceLabelFormatter = axis2.niceLabelFormatter;
    }
    if (xCrossHairInfo && (null === (_a = xHair.label) || void 0 === _a ? void 0 : _a.visible) && !xUseCache) {
      const labelOffset = getAxisLabelOffset(axis2.getSpec());
      "bottom" === axis2.getOrient() ? (xCrossHairInfo.bottom.visible = true, xCrossHairInfo.bottom.defaultFormatter = niceLabelFormatter, xCrossHairInfo.bottom.text = value, xCrossHairInfo.bottom.dx = 0, xCrossHairInfo.bottom.dy = labelOffset) : "top" === axis2.getOrient() && (xCrossHairInfo.top.visible = true, xCrossHairInfo.top.defaultFormatter = niceLabelFormatter, xCrossHairInfo.top.text = value, xCrossHairInfo.top.dx = 0, xCrossHairInfo.top.dy = -labelOffset);
    }
  }), yHair && currValueY.forEach(({ axis: axis2, value }) => {
    var _a;
    value = null != value ? value : "";
    let niceLabelFormatter = null;
    const yScale = axis2.getScale();
    if (isDiscrete(yScale.type))
      bandHeight = yScale.bandwidth(), 0 === bandHeight && yScale.step && (offsetHeight = yScale.step());
    else if (isContinuous(yScale.type)) {
      const fieldY = series2.fieldY[0], fieldY2 = series2.fieldY2, datum = getDatumByValue(series2.getViewData().latestData, +value, fieldY, fieldY2);
      if (datum) {
        const startY = series2.dataToPositionY(datum);
        fieldY2 ? (bandHeight = Math.abs(startY - series2.dataToPositionY1(datum)), value = `${datum[fieldY]} ~ ${datum[fieldY2]}`) : bandHeight = 1, y = startY;
      }
      niceLabelFormatter = axis2.niceLabelFormatter;
    }
    if (yCrossHairInfo && (null === (_a = yHair.label) || void 0 === _a ? void 0 : _a.visible) && !yUseCache) {
      const labelOffset = getAxisLabelOffset(axis2.getSpec());
      "left" === axis2.getOrient() ? (yCrossHairInfo.left.visible = true, yCrossHairInfo.left.defaultFormatter = niceLabelFormatter, yCrossHairInfo.left.text = value, yCrossHairInfo.left.dx = -labelOffset, yCrossHairInfo.left.dy = 0) : "right" === axis2.getOrient() && (yCrossHairInfo.right.visible = true, yCrossHairInfo.right.defaultFormatter = niceLabelFormatter, yCrossHairInfo.right.text = value, yCrossHairInfo.right.dx = labelOffset, yCrossHairInfo.right.dy = 0);
    }
  }), xCrossHairInfo && !xUseCache) {
    const xRegion = {
      x1: 1 / 0,
      y1: 1 / 0,
      x2: -1 / 0,
      y2: -1 / 0
    };
    if (setRegionArea(xRegion, currValueX), xCrossHairInfo.leftPos = xRegion.x1, xCrossHairInfo.rightPos = xRegion.x2, xCrossHairInfo.topPos = xRegion.y1, xCrossHairInfo.height = xRegion.y2 - xRegion.y1, xCrossHairInfo.x = x + layoutStartPoint.x, xHair && xHair.label) {
      const { top, bottom } = xCrossHairInfo;
      top.visible && setFormattedCrosshairLabel(top, "top", xHair.label), bottom.visible && setFormattedCrosshairLabel(bottom, "bottom", xHair.label);
    }
  }
  if (yCrossHairInfo && !yUseCache) {
    const yRegion = {
      x1: 1 / 0,
      y1: 1 / 0,
      x2: -1 / 0,
      y2: -1 / 0
    };
    if (setRegionArea(yRegion, currValueY), yCrossHairInfo.leftPos = yRegion.x1, yCrossHairInfo.topPos = yRegion.y1, yCrossHairInfo.bottomPos = yRegion.y2, yCrossHairInfo.width = yRegion.x2 - yRegion.x1, yCrossHairInfo.y = y + layoutStartPoint.y, yHair && yHair.label) {
      const { left: left2, right: right2 } = yCrossHairInfo;
      left2.visible && setFormattedCrosshairLabel(left2, "left", yHair.label), right2.visible && setFormattedCrosshairLabel(right2, "right", yHair.label);
    }
  }
  return {
    x: layoutX && xCrossHairInfo ? xCrossHairInfo : void 0,
    y: layoutY && yCrossHairInfo ? yCrossHairInfo : void 0,
    offsetWidth,
    offsetHeight,
    bandWidth: null != bandWidth ? bandWidth : 0,
    bandHeight: null != bandHeight ? bandHeight : 0
  };
};
var setFormattedCrosshairLabel = (labelInfo, position, labelSpec) => {
  const { formatMethod, formatter } = labelSpec, { formatFunc, args } = getFormatFunction(formatMethod, formatter, labelInfo.text, {
    label: labelInfo.text,
    position
  });
  formatFunc ? labelInfo.text = formatFunc(...args) : labelInfo.defaultFormatter && (labelInfo.text = labelInfo.defaultFormatter(labelInfo.text));
};
var setRegionArea = (outRegion, currentValue) => {
  currentValue.forEach(({ axis: axis2 }) => {
    axis2.getRegions().forEach((r) => {
      outRegion.x1 = Math.min(outRegion.x1, r.getLayoutStartPoint().x), outRegion.y1 = Math.min(outRegion.y1, r.getLayoutStartPoint().y), outRegion.x2 = Math.max(outRegion.x2, r.getLayoutStartPoint().x + r.getLayoutRect().width), outRegion.y2 = Math.max(outRegion.y2, r.getLayoutStartPoint().y + r.getLayoutRect().height);
    });
  });
};
var layoutVerticalCrosshair = (xHair, crosshairInfo, bandWidth, offsetWidth) => {
  const { x, topPos, height } = crosshairInfo, type = xHair.type;
  let positionAttribute;
  if ("line" === type)
    positionAttribute = {
      visible: true,
      start: {
        x: x + bandWidth / 2,
        y: topPos
      },
      end: {
        x: x + bandWidth / 2,
        y: topPos + height
      }
    };
  else if ("rect" === type) {
    const extend = getRectSize(xHair, bandWidth, crosshairInfo.axis), { leftPos, rightPos } = crosshairInfo;
    positionAttribute = {
      visible: true,
      start: {
        x: Math.max(x - extend / 2 - offsetWidth / 2, leftPos),
        y: topPos
      },
      end: {
        x: Math.min(x + bandWidth + extend / 2 + offsetWidth / 2, rightPos),
        y: topPos + height
      }
    };
  }
  return positionAttribute;
};
var layoutHorizontalCrosshair = (yHair, crosshairInfo, bandHeight, offsetHeight) => {
  const { leftPos, width, y } = crosshairInfo, type = yHair.type;
  let positionAttribute;
  if ("line" === type)
    positionAttribute = {
      visible: true,
      start: {
        x: leftPos,
        y: y + bandHeight / 2
      },
      end: {
        x: leftPos + width,
        y: y + bandHeight / 2
      }
    };
  else if ("rect" === type) {
    const extend = getRectSize(yHair, bandHeight, crosshairInfo.axis), { topPos, bottomPos } = crosshairInfo;
    positionAttribute = {
      visible: true,
      start: {
        x: leftPos,
        y: Math.max(y - extend / 2 - offsetHeight / 2, topPos)
      },
      end: {
        x: leftPos + width,
        y: Math.min(y + bandHeight + extend / 2 + offsetHeight / 2, bottomPos)
      }
    };
  }
  return positionAttribute;
};
var getRectSize = (hair, bandSize, axis2) => {
  var _a, _b, _c;
  let extend = 0;
  if (null === (_a = hair.style) || void 0 === _a ? void 0 : _a.sizePercent)
    extend = (hair.style.sizePercent - 1) * bandSize;
  else if ("number" == typeof (null === (_b = hair.style) || void 0 === _b ? void 0 : _b.size))
    extend = hair.style.size - bandSize;
  else if ("function" == typeof (null === (_c = hair.style) || void 0 === _c ? void 0 : _c.size)) {
    const axisRect = axis2.getLayoutRect();
    extend = hair.style.size(axisRect, axis2) - bandSize;
  }
  return extend;
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/plugin/components/tooltip-handler/utils/position
var getActualTooltipPositionValue = (position, event) => {
  let result2;
  if (isValid_default(position)) {
    if (isNumber_default(position))
      result2 = position;
    else if (isFunction_default(position)) {
      const tooltipPosition = position(event);
      isNumber_default(tooltipPosition) && (result2 = tooltipPosition);
    }
  }
  return result2;
};
var positionType = {
  left: ["left", "center"],
  right: ["right", "center"],
  top: ["center", "top"],
  lt: ["left", "top"],
  tl: ["left", "top"],
  rt: ["right", "top"],
  tr: ["right", "top"],
  bottom: ["center", "bottom"],
  bl: ["left", "bottom"],
  lb: ["left", "bottom"],
  br: ["right", "bottom"],
  rb: ["right", "bottom"],
  inside: ["center", "center"],
  center: ["center", "center"],
  centerBottom: ["center", "centerBottom"],
  centerTop: ["center", "centerTop"],
  centerLeft: ["centerLeft", "center"],
  centerRight: ["centerRight", "center"]
};
var getHorizontalPositionType = (position, defaultCase) => {
  var _a, _b;
  return null !== (_b = null === (_a = positionType[position]) || void 0 === _a ? void 0 : _a[0]) && void 0 !== _b ? _b : defaultCase;
};
var getVerticalPositionType = (position, defaultCase) => {
  var _a, _b;
  return null !== (_b = null === (_a = positionType[position]) || void 0 === _a ? void 0 : _a[1]) && void 0 !== _b ? _b : defaultCase;
};
var getCartesianCrosshairRect = (dimensionInfo, series2, layoutStartPoint) => {
  const currValueX = /* @__PURE__ */ new Map(), currValueY = /* @__PURE__ */ new Map();
  dimensionInfo.forEach(({ axis: axis2, value }) => {
    ["top", "bottom"].includes(axis2.getOrient()) ? currValueX.set(axis2.getSpecIndex(), {
      value,
      axis: axis2
    }) : currValueY.set(axis2.getSpecIndex(), {
      value,
      axis: axis2
    });
  });
  const xHair = {
    visible: !!currValueX.size,
    type: "rect"
  }, yHair = {
    visible: !!currValueY.size,
    type: "rect"
  }, { x: crosshairInfoX, y: crosshairInfoY, offsetWidth, offsetHeight, bandWidth, bandHeight } = layoutByValue(3, series2, layoutStartPoint, currValueX, currValueY, xHair, yHair);
  return crosshairInfoX ? layoutVerticalCrosshair(xHair, crosshairInfoX, bandWidth, offsetWidth) : crosshairInfoY ? layoutHorizontalCrosshair(yHair, crosshairInfoY, bandHeight, offsetHeight) : void 0;
};
var isGlobalTooltipPositionPattern = (obj) => isObject_default(obj) && (isValid_default(obj.left) || isValid_default(obj.right) || isValid_default(obj.top) || isValid_default(obj.bottom));
var isFixedTooltipPositionPattern = (obj) => isObject_default(obj) && (isValid_default(obj.x) || isValid_default(obj.y));

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/plugin/components/tooltip-handler/utils/attribute
var DEFAULT_TEXT_ATTRIBUTES = {
  fontFamily: token.fontFamily,
  spacing: 10,
  wordBreak: "break-word"
};
function getTextAttributes(style = {}, globalTheme2, defaultAttributes2) {
  var _a, _b;
  return Object.assign(Object.assign({}, null != defaultAttributes2 ? defaultAttributes2 : DEFAULT_TEXT_ATTRIBUTES), {
    fill: null !== (_a = style.fill) && void 0 !== _a ? _a : style.fontColor,
    textAlign: style.textAlign,
    textBaseline: style.textBaseline,
    fontFamily: null !== (_b = style.fontFamily) && void 0 !== _b ? _b : null == globalTheme2 ? void 0 : globalTheme2.fontFamily,
    fontSize: style.fontSize,
    fontWeight: style.fontWeight,
    lineHeight: style.lineHeight,
    spacing: style.spacing,
    multiLine: style.multiLine,
    maxWidth: style.maxWidth,
    wordBreak: style.wordBreak,
    autoWidth: style.autoWidth
  });
}
var getPanelAttributes = (style) => {
  var _a;
  const { backgroundColor, border, shadow } = style, panelAttrs = {
    lineWidth: null !== (_a = null == border ? void 0 : border.width) && void 0 !== _a ? _a : 0,
    shadow: !!shadow
  };
  (null == border ? void 0 : border.color) && (panelAttrs.stroke = border.color), backgroundColor && (panelAttrs.fill = backgroundColor), shadow && (panelAttrs.shadowColor = shadow.color, panelAttrs.shadowBlur = shadow.blur, panelAttrs.shadowOffsetX = shadow.x, panelAttrs.shadowOffsetY = shadow.y, panelAttrs.shadowSpread = shadow.spread);
  const { radius } = null != border ? border : {};
  return isValid_default(radius) && (panelAttrs.cornerRadius = [radius, radius, radius, radius]), panelAttrs;
};
var getTooltipAttributes = (actualTooltip, spec, globalTheme2) => {
  var _a, _b, _c, _d, _e;
  const { style = {}, enterable, transitionDuration } = spec, { panel = {}, titleLabel, shape, keyLabel, valueLabel, spaceRow: commonSpaceRow, maxContentHeight } = style, padding = normalizePadding(panel.padding), paddingSpec = normalizeLayoutPaddingSpec(panel.padding), titleStyle = getTextAttributes(titleLabel, globalTheme2), keyStyle = getTextAttributes(keyLabel, globalTheme2), valueStyle = getTextAttributes(valueLabel, globalTheme2), shapeStyle = {
    fill: true,
    size: null !== (_a = null == shape ? void 0 : shape.size) && void 0 !== _a ? _a : 8,
    spacing: null !== (_b = null == shape ? void 0 : shape.spacing) && void 0 !== _b ? _b : 6
  }, attributes = {
    panel: getPanelAttributes(panel),
    padding,
    title: {},
    content: [],
    titleStyle: {
      value: titleStyle,
      spaceRow: commonSpaceRow
    },
    contentStyle: {
      shape: shapeStyle,
      key: keyStyle,
      value: valueStyle,
      spaceRow: commonSpaceRow
    },
    hasContentShape: false,
    keyWidth: 0,
    valueWidth: 0,
    maxContentHeight,
    enterable,
    transitionDuration
  }, { title: title3 = {}, content = [] } = actualTooltip;
  let panelWidth = paddingSpec.left + paddingSpec.right, panelHeight = paddingSpec.top + paddingSpec.bottom, panelDomHeight = paddingSpec.top + paddingSpec.bottom, contentMaxWidth = 0;
  const filteredContent = content.filter((item) => (item.key || item.value) && false !== item.visible), hasContent = !!filteredContent.length;
  let maxKeyWidth = 0, maxAdaptiveKeyWidth = 0, maxValueWidth = 0, maxShapeWidth = 0;
  if (hasContent) {
    const keyWidths = [], adaptiveKeyWidths = [], valueWidths = [], shapeWidths = [];
    let contentHeight = 0;
    attributes.content = filteredContent.map((item, i) => {
      let itemHeight = 0;
      const { hasShape: actualHasShape, key: actualKey, shapeType: actualShapeType = "", shapeFill: actualShapeFill, shapeStroke: actualShapeStroke, shapeLineWidth: actualShapeLineWidth, shapeSize: actualShapeSize, value: actualValue, isKeyAdaptive: actualIsKeyAdaptive, spaceRow: actualSpaceRow, keyStyle: actualKeyStyle, valueStyle: actualValueStyle, shapeHollow: actualShapeHollow, shapeColor: actualShapeColor } = item, itemAttrs = {
        height: 0,
        spaceRow: null != actualSpaceRow ? actualSpaceRow : commonSpaceRow
      };
      if (isValid_default(actualKey)) {
        const itemKeyStyle = mergeSpec({}, keyStyle, getTextAttributes(actualKeyStyle, void 0, {})), { width, height, text: text2 } = measureTooltipText(actualKey, itemKeyStyle);
        itemAttrs.key = Object.assign(Object.assign({
          width,
          height
        }, itemKeyStyle), {
          text: text2
        }), actualIsKeyAdaptive ? adaptiveKeyWidths.push(width) : keyWidths.push(width), itemHeight = Math.max(itemHeight, height);
      }
      if (isValid_default(actualValue)) {
        const itemValueStyle = mergeSpec({}, valueStyle, getTextAttributes(actualValueStyle, void 0, {})), { width, height, text: text2 } = measureTooltipText(actualValue, itemValueStyle);
        itemAttrs.value = Object.assign(Object.assign({
          width,
          height
        }, itemValueStyle), {
          text: text2
        }), valueWidths.push(width), itemHeight = Math.max(itemHeight, height);
      }
      if (actualHasShape) {
        const shape2 = {
          visible: true,
          symbolType: actualShapeType
        }, adaptiveShapeFill = null != actualShapeFill ? actualShapeFill : actualShapeColor;
        actualShapeHollow ? shape2.stroke = adaptiveShapeFill : shape2.fill = adaptiveShapeFill, shape2.stroke = null != actualShapeStroke ? actualShapeStroke : adaptiveShapeFill, shape2.lineWidth = actualShapeLineWidth, itemAttrs.shape = shape2;
        const shapeWidth = null != actualShapeSize ? actualShapeSize : shapeStyle.size;
        itemHeight = Math.max(shapeWidth, itemHeight), shapeWidths.push(shapeWidth);
      } else
        itemAttrs.shape = {
          visible: false
        };
      return itemAttrs.height = itemHeight, contentHeight += itemHeight, i < filteredContent.length - 1 && (contentHeight += itemAttrs.spaceRow), itemAttrs;
    }), panelHeight += contentHeight, panelDomHeight += Math.min(contentHeight, null != maxContentHeight ? maxContentHeight : 1 / 0), maxKeyWidth = keyWidths.length ? maxInArray(keyWidths) : 0, maxAdaptiveKeyWidth = adaptiveKeyWidths.length ? maxInArray(adaptiveKeyWidths) : 0, maxValueWidth = valueWidths.length ? maxInArray(valueWidths) : 0, maxShapeWidth = shapeWidths.length ? maxInArray(shapeWidths) + shapeStyle.spacing : 0, contentMaxWidth = Math.max(maxShapeWidth + maxKeyWidth + keyStyle.spacing + maxValueWidth + valueStyle.spacing, maxShapeWidth + maxAdaptiveKeyWidth, contentMaxWidth), attributes.hasContentShape = !!shapeWidths.length, attributes.keyWidth = maxKeyWidth, attributes.valueWidth = maxValueWidth;
  }
  let titleMaxWidth = 0, titleMaxHeight = 0, titleHeightWithSpace = 0;
  const { visible: actualTitleVisible = true, value: actualTitleValue = "", valueStyle: actualTitleValueStyle, spaceRow: actualTitleSpaceRow } = title3;
  attributes.title.visible = actualTitleVisible, attributes.title.spaceRow = null != actualTitleSpaceRow ? actualTitleSpaceRow : commonSpaceRow;
  let titleValueStyle = {};
  const isAutoWidthMode = () => titleValueStyle.autoWidth && false !== titleValueStyle.multiLine;
  if (actualTitleVisible) {
    titleValueStyle = mergeSpec({}, titleStyle, getTextAttributes(actualTitleValueStyle, void 0, {})), isAutoWidthMode() && (titleValueStyle.multiLine = null === (_c = titleValueStyle.multiLine) || void 0 === _c || _c, titleValueStyle.maxWidth = null !== (_d = titleValueStyle.maxWidth) && void 0 !== _d ? _d : hasContent ? Math.ceil(contentMaxWidth) : void 0);
    const { text: text2, width, height } = measureTooltipText(actualTitleValue, titleValueStyle);
    attributes.title.value = Object.assign(Object.assign({
      width: isAutoWidthMode() ? Math.min(width, null !== (_e = titleValueStyle.maxWidth) && void 0 !== _e ? _e : Number.MAX_VALUE) : width,
      height
    }, titleValueStyle), {
      text: text2
    }), titleMaxWidth = attributes.title.value.width, titleMaxHeight = attributes.title.value.height, titleHeightWithSpace = titleMaxHeight + (hasContent ? attributes.title.spaceRow : 0);
  }
  return panelHeight += titleHeightWithSpace, panelDomHeight += titleHeightWithSpace, attributes.title.width = titleMaxWidth, attributes.title.height = titleMaxHeight, isAutoWidthMode() ? panelWidth += contentMaxWidth || titleMaxWidth : panelWidth += Math.max(titleMaxWidth, contentMaxWidth), hasContent && attributes.content.forEach((item) => {
    var _a2;
    const value = item.value;
    value && (null === (_a2 = value.autoWidth) || void 0 === _a2 || _a2) && (value.width = panelWidth - paddingSpec.left - paddingSpec.right - maxShapeWidth - maxKeyWidth - keyStyle.spacing - valueStyle.spacing, value.maxWidth || (value.maxWidth = Math.ceil(value.width)), attributes.valueWidth = Math.max(attributes.valueWidth, value.width));
  }), attributes.panel.width = panelWidth, attributes.panel.height = panelHeight, attributes.panelDomHeight = panelDomHeight, attributes;
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/tooltip/utils/show-tooltip
var getDataArrayFromFieldArray = (fields2, datum) => isValid_default(datum) ? fields2.map((f) => datum[f]) : void 0;
var datumContainsArray = (fields2, data) => (datum) => fields2.every((key, i) => datum[key] === (null == data ? void 0 : data[i]));
var hasData = (data) => !isNil_default(data) && (isArray_default(data) ? data.length > 0 && data.every(isValid_default) : Object.keys(data).length > 0);
function showTooltip(datum, options, component2) {
  var _a, _b, _c;
  const opt = Object.assign({
    regionIndex: 0
  }, options), componentOptions = component2.getOption(), region = componentOptions.getRegionsInUserIdOrIndex(isValid_default(opt.regionId) ? [opt.regionId] : void 0, isValid_default(opt.regionIndex) ? [opt.regionIndex] : void 0)[0];
  if (!region)
    return "none";
  const markInfoList = getMarkInfoList(datum, region), activeType = null !== (_a = opt.activeType) && void 0 !== _a ? _a : markInfoList.length > 1 ? "dimension" : "mark", regionPos = region.getLayoutStartPoint(), regionRect = region.getLayoutRect(), container2 = componentOptions.globalInstance.getContainer(), containerPos = Object.assign({
    x: 0,
    y: 0
  }, container2 ? getElementAbsolutePosition(container2) : {}), getOriginDatum = (info) => {
    var _a2;
    const { dimensionFields, dimensionData, measureFields, measureData, groupField, groupData: groupData2 } = info.data, originDatum = null === (_a2 = info.series.getViewData()) || void 0 === _a2 ? void 0 : _a2.latestData.find((datum2) => datumContainsArray(dimensionFields, dimensionData)(datum2) && datumContainsArray(measureFields, measureData)(datum2) && (isNil_default(groupField) || datumContainsArray([groupField], [groupData2])(datum2)));
    return originDatum;
  }, getMockEvent = (originPos) => {
    var _a2, _b2;
    const pos = ((pos2) => ({
      x: Math.min(Math.max(pos2.x, 0), regionRect.width),
      y: Math.min(Math.max(pos2.y, 0), regionRect.height)
    }))(originPos), canvasX = null !== (_a2 = opt.x) && void 0 !== _a2 ? _a2 : regionPos.x + pos.x, canvasY = null !== (_b2 = opt.y) && void 0 !== _b2 ? _b2 : regionPos.y + pos.y;
    return {
      canvasX,
      canvasY,
      clientX: containerPos.x + canvasX,
      clientY: containerPos.y + canvasY
    };
  };
  if ("dimension" === activeType) {
    const firstInfo = markInfoList[0];
    if (!firstInfo)
      return "none";
    const markInfoSeriesMap = /* @__PURE__ */ new Map();
    markInfoList.forEach((info) => {
      var _a2;
      markInfoSeriesMap.has(info.series) || markInfoSeriesMap.set(info.series, []), null === (_a2 = markInfoSeriesMap.get(info.series)) || void 0 === _a2 || _a2.push(info);
    });
    const mockDimensionInfo = [{
      value: datum[firstInfo.data.dimensionFields[0]],
      data: [...markInfoSeriesMap.keys()].map((series2) => {
        var _a2, _b2;
        return {
          series: series2,
          datum: null !== (_b2 = null === (_a2 = markInfoSeriesMap.get(series2)) || void 0 === _a2 ? void 0 : _a2.map((info) => getOriginDatum(info))) && void 0 !== _b2 ? _b2 : []
        };
      })
    }];
    isValid_default(firstInfo.dimType) && (mockDimensionInfo[0].position = firstInfo.pos[firstInfo.dimType], mockDimensionInfo[0].dimType = firstInfo.dimType);
    const mockParams = {
      changePositionOnly: false,
      action: "enter",
      tooltip: null,
      dimensionInfo: mockDimensionInfo,
      chart: null !== (_b = componentOptions.globalInstance.getChart()) && void 0 !== _b ? _b : void 0,
      datum: void 0,
      model: void 0,
      source: Event_Source_Type.chart,
      event: getMockEvent({
        x: markInfoList.reduce((sum4, info) => sum4 + info.pos.x, 0) / markInfoList.length,
        y: markInfoList.reduce((sum4, info) => sum4 + info.pos.y, 0) / markInfoList.length
      }),
      item: void 0,
      itemMap: /* @__PURE__ */ new Map()
    };
    component2.processor.dimension.showTooltip(mockDimensionInfo, mockParams, false);
    const vchart = componentOptions.globalInstance;
    return VChart.globalConfig.uniqueTooltip && VChart.hideTooltip(vchart.id), activeType;
  }
  if ("mark" === activeType) {
    const info = markInfoList[0];
    if (!info)
      return "none";
    const mockDatum = Object.assign(Object.assign({}, getOriginDatum(info)), datum), mockDimensionData = [{
      datum: [mockDatum],
      series: info.series
    }], mockDimensionInfo = [{
      value: mockDatum[info.data.dimensionFields[0]],
      data: mockDimensionData
    }], mockParams = {
      changePositionOnly: false,
      tooltip: null,
      dimensionInfo: mockDimensionInfo,
      chart: null !== (_c = componentOptions.globalInstance.getChart()) && void 0 !== _c ? _c : void 0,
      datum: mockDatum,
      model: info.series,
      source: Event_Source_Type.chart,
      event: getMockEvent(info.pos),
      item: void 0,
      itemMap: /* @__PURE__ */ new Map()
    };
    component2.processor.mark.showTooltip({
      datum: mockDatum,
      mark: null,
      series: info.series,
      dimensionInfo: mockDimensionInfo
    }, mockParams, false);
    const vchart = componentOptions.globalInstance;
    return VChart.globalConfig.uniqueTooltip && VChart.hideTooltip(vchart.id), activeType;
  }
  return "none";
}
var getMarkInfoList = (datum, region) => {
  const seriesList = region.getSeries(), markInfoList = [];
  return seriesList.forEach((series2) => {
    var _a, _b, _c, _d, _e, _f, _g;
    const dimensionFields = series2.getDimensionField(), measureFields = series2.getMeasureField(), groupField = series2.getSeriesField(), groupData2 = isValid_default(groupField) ? datum[groupField] : void 0, groupDomain = isValid_default(groupField) && null !== (_d = null === (_c = null === (_b = null === (_a = series2.getViewDataStatistics) || void 0 === _a ? void 0 : _a.call(series2)) || void 0 === _b ? void 0 : _b.latestData[groupField]) || void 0 === _c ? void 0 : _c.values) && void 0 !== _d ? _d : [], dimensionData = getDataArrayFromFieldArray(dimensionFields, datum);
    let measureData = getDataArrayFromFieldArray(measureFields, datum);
    const hasMeasureData = hasData(measureData), isMultiGroups = !hasMeasureData && isValid_default(groupField) && isNil_default(groupData2) && groupDomain.length > 0, parseMarkInfoOfSimpleSeries = () => {
      var _a2;
      const originDatum = null === (_a2 = series2.getViewData()) || void 0 === _a2 ? void 0 : _a2.latestData.find(datumContainsArray(dimensionFields, dimensionData));
      if (!hasMeasureData && (measureData = getDataArrayFromFieldArray(measureFields, originDatum), !hasData(measureData)))
        return;
      const pos = series2.type === SeriesTypeEnum.pie ? series2.dataToCentralPosition(originDatum) : series2.dataToPosition(originDatum);
      isNil_default(pos) || isNaN(pos.x) || isNaN(pos.y) || markInfoList.push({
        pos,
        data: {
          dimensionFields,
          dimensionData,
          measureFields,
          measureData,
          hasMeasureData,
          groupField,
          groupData: groupData2
        },
        series: series2
      });
    };
    if ("cartesian" === series2.coordinate) {
      const cartesianSeries = series2, dimType = isDiscrete(null === (_f = null === (_e = series2.getYAxisHelper()) || void 0 === _e ? void 0 : _e.getScale(0)) || void 0 === _f ? void 0 : _f.type) ? "y" : "x", invalidDimensionFields = dimensionFields.map((field3, i) => [field3, i]).filter(([, i]) => isNil_default(null == dimensionData ? void 0 : dimensionData[i]));
      let dimensionDataList = [null != dimensionData ? dimensionData : []];
      invalidDimensionFields.length > 0 && invalidDimensionFields.forEach(([field3, i]) => {
        var _a2, _b2, _c2, _d2;
        const domain = null !== (_d2 = null === (_c2 = null === (_b2 = null === (_a2 = series2.getViewDataStatistics) || void 0 === _a2 ? void 0 : _a2.call(series2)) || void 0 === _b2 ? void 0 : _b2.latestData[field3]) || void 0 === _c2 ? void 0 : _c2.values) && void 0 !== _d2 ? _d2 : [], nextList = [];
        dimensionDataList.forEach((dimensionData2) => {
          domain.forEach((value) => {
            var _a3;
            const newData = null !== (_a3 = null == dimensionData2 ? void 0 : dimensionData2.slice()) && void 0 !== _a3 ? _a3 : [];
            newData[i] = value, nextList.push(newData);
          });
        }), dimensionDataList = nextList;
      }), dimensionDataList.forEach((dimensionData2) => {
        var _a2, _b2;
        if (isMultiGroups) {
          const measureDataList = null === (_a2 = cartesianSeries.getViewData()) || void 0 === _a2 ? void 0 : _a2.latestData.filter(datumContainsArray(dimensionFields, dimensionData2));
          groupDomain.forEach((groupData3) => {
            const originDatum = measureDataList.find((d) => d[groupField] === groupData3);
            if (measureData = getDataArrayFromFieldArray(measureFields, originDatum), !hasData(measureData))
              return;
            const pos = cartesianSeries.dataToPosition(originDatum);
            isNil_default(pos) || isNaN(pos.x) || isNaN(pos.y) || markInfoList.push({
              pos,
              data: {
                dimensionFields,
                dimensionData: dimensionData2,
                measureFields,
                measureData,
                hasMeasureData,
                groupField,
                groupData: groupData3
              },
              series: series2,
              dimType
            });
          });
        } else {
          const originDatum = null === (_b2 = cartesianSeries.getViewData()) || void 0 === _b2 ? void 0 : _b2.latestData.find(datumContainsArray(dimensionFields, dimensionData2));
          if (!hasMeasureData && (measureData = getDataArrayFromFieldArray(measureFields, originDatum), !hasData(measureData)))
            return;
          const pos = cartesianSeries.dataToPosition(originDatum);
          if (isNil_default(pos) || isNaN(pos.x) || isNaN(pos.y))
            return;
          markInfoList.push({
            pos,
            data: {
              dimensionFields,
              dimensionData: dimensionData2,
              measureFields,
              measureData,
              hasMeasureData,
              groupField,
              groupData: groupData2
            },
            dimType,
            series: series2
          });
        }
      });
    } else if ("polar" === series2.coordinate)
      if (series2.type === SeriesTypeEnum.pie)
        parseMarkInfoOfSimpleSeries();
      else {
        const polarSeries = series2;
        if (isMultiGroups) {
          const originDatum = (null === (_g = polarSeries.getViewData()) || void 0 === _g ? void 0 : _g.latestData.filter(datumContainsArray(dimensionFields, dimensionData))).find((d) => d[groupField] === groupData2);
          groupDomain.forEach((groupData3) => {
            if (measureData = getDataArrayFromFieldArray(measureFields, originDatum), !hasData(measureData))
              return;
            const pos = polarSeries.dataToPosition(originDatum);
            isNil_default(pos) || isNaN(pos.x) || isNaN(pos.y) || markInfoList.push({
              pos,
              data: {
                dimensionFields,
                dimensionData,
                measureFields,
                measureData,
                hasMeasureData,
                groupField,
                groupData: groupData3
              },
              series: series2
            });
          });
        } else
          parseMarkInfoOfSimpleSeries();
      }
    else
      "geo" === series2.coordinate && parseMarkInfoOfSimpleSeries();
  }), markInfoList;
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/tooltip/utils/common
var getTooltipActualActiveType = (spec) => {
  var _a, _b, _c;
  if (false === (null == spec ? void 0 : spec.visible))
    return [];
  const activeTypeMap = {
    mark: false !== (null === (_a = null == spec ? void 0 : spec.mark) || void 0 === _a ? void 0 : _a.visible),
    dimension: false !== (null === (_b = null == spec ? void 0 : spec.dimension) || void 0 === _b ? void 0 : _b.visible),
    group: false !== (null === (_c = null == spec ? void 0 : spec.group) || void 0 === _c ? void 0 : _c.visible)
  };
  return isValid_default(null == spec ? void 0 : spec.activeType) && Object.keys(activeTypeMap).forEach((t) => {
    var _a2;
    activeTypeMap[t] = null === (_a2 = null == spec ? void 0 : spec.activeType) || void 0 === _a2 ? void 0 : _a2.includes(t);
  }), Object.keys(activeTypeMap).filter((t) => activeTypeMap[t]);
};
function isEmptyPos(params2) {
  return isNil_default(params2.mark) && isNil_default(params2.model) && isNil_default(params2.datum);
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/tooltip/utils/pattern
var makeDefaultPattern = (series2, activeType, dimensionInfo) => {
  var _a, _b;
  return null !== (_b = null === (_a = series2.tooltipHelper) || void 0 === _a ? void 0 : _a.getDefaultTooltipPattern(activeType, dimensionInfo)) && void 0 !== _b ? _b : null;
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/model/tooltip-helper
var BaseTooltipHelper = class {
  constructor() {
    this.activeTriggerSet = {
      mark: /* @__PURE__ */ new Set(),
      dimension: /* @__PURE__ */ new Set(),
      group: /* @__PURE__ */ new Set()
    }, this.ignoreTriggerSet = {
      mark: /* @__PURE__ */ new Set(),
      dimension: /* @__PURE__ */ new Set(),
      group: /* @__PURE__ */ new Set()
    };
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/base/tooltip-helper
var BaseSeriesTooltipHelper = class extends BaseTooltipHelper {
  constructor(series2) {
    super(), this._getSeriesCacheInfo = () => {
      var _a, _b, _c;
      const { series: series3 } = this, _seriesField = series3.getSeriesField();
      return {
        seriesFields: isValid_default(_seriesField) ? array(_seriesField) : null !== (_a = series3.getSeriesKeys()) && void 0 !== _a ? _a : [],
        dimensionFields: null !== (_b = series3.getDimensionField()) && void 0 !== _b ? _b : [],
        measureFields: null !== (_c = series3.getMeasureField()) && void 0 !== _c ? _c : [],
        type: series3.type
      };
    }, this._getDimensionData = (datum) => {
      const { dimensionFields } = this._seriesCacheInfo;
      return dimensionFields[0] && (null == datum ? void 0 : datum[dimensionFields[0]]);
    }, this._getMeasureData = (datum) => {
      const { measureFields } = this._seriesCacheInfo;
      return measureFields[0] && (null == datum ? void 0 : datum[measureFields[0]]);
    }, this._getSeriesFieldData = (datum) => {
      const { dimensionFields, seriesFields } = this._seriesCacheInfo;
      if (isValid_default(seriesFields[0]) && (null == datum ? void 0 : datum[seriesFields[0]]))
        return null == datum ? void 0 : datum[seriesFields[0]];
      const subDimensionField = dimensionFields[dimensionFields.length - 1];
      return dimensionFields.length > 1 && (0 === seriesFields.length || this.series.getSeriesKeys().length), null == datum ? void 0 : datum[subDimensionField];
    }, this._getSeriesStyle = (datum, styleKey, defaultValue) => {
      var _a;
      for (const key of array(styleKey)) {
        const value = null === (_a = this.series.getSeriesStyle(datum)) || void 0 === _a ? void 0 : _a(key);
        if (isValid_default(value))
          return value;
      }
      return defaultValue;
    }, this.markTooltipKeyCallback = (datum, params2) => this._getSeriesFieldData(datum), this.markTooltipValueCallback = (datum, params2) => this._getMeasureData(datum), this.shapeTypeCallback = (datum, params2) => {
      var _a;
      return null !== (_a = this._getSeriesStyle(datum, "shape", null)) && void 0 !== _a ? _a : this._getSeriesStyle(datum, "symbolType", this.series.getDefaultShapeType());
    }, this.shapeColorCallback = (datum, params2) => this._getSeriesStyle(datum, ["fill", "stroke"]), this.shapeStrokeCallback = (datum, params2) => this._getSeriesStyle(datum, ["stroke", "fill"]), this.dimensionTooltipTitleCallback = (datum, params2) => this._getDimensionData(datum), this.groupTooltipTitleCallback = (datum, params2) => this._getSeriesFieldData(datum), this.groupTooltipKeyCallback = (datum, params2) => {
      const { seriesFields } = this._seriesCacheInfo;
      let dimensionFields = this._seriesCacheInfo.dimensionFields;
      return seriesFields[0] && (dimensionFields = dimensionFields.filter((field3) => field3 !== seriesFields[0])), dimensionFields.map((field3) => null == datum ? void 0 : datum[field3]).join("-");
    }, this.series = series2, this.updateTooltipSpec();
  }
  updateTooltipSpec() {
    var _a, _b, _c, _d;
    const seriesTooltipSpec = null !== (_b = null === (_a = this.series.getSpec()) || void 0 === _a ? void 0 : _a.tooltip) && void 0 !== _b ? _b : {}, chartTooltipSpec = null !== (_d = null === (_c = this.series.getChart().getSpec()) || void 0 === _c ? void 0 : _c.tooltip) && void 0 !== _d ? _d : {}, spec = Object.assign(Object.assign({}, chartTooltipSpec), seriesTooltipSpec);
    ["mark", "dimension", "group"].forEach((activeType) => {
      const pattern = spec[activeType];
      isValid_default(pattern) && (spec[activeType] = Object.assign(Object.assign({}, pattern), {
        title: addExtraInfoToTooltipTitlePattern(pattern.title, {
          seriesId: this.series.id
        }, true),
        content: addExtraInfoToTooltipContentPattern(pattern.content, {
          seriesId: this.series.id
        }, true)
      }));
    }), this.spec = spec, this.activeType = getTooltipActualActiveType(spec), this._seriesCacheInfo = this._getSeriesCacheInfo();
  }
  getDefaultTooltipPattern(activeType, dimensionInfo) {
    switch (activeType) {
      case "mark":
        return {
          visible: true,
          activeType,
          title: {
            key: void 0,
            value: this.dimensionTooltipTitleCallback,
            hasShape: false
          },
          content: [{
            seriesId: this.series.id,
            key: this.markTooltipKeyCallback,
            value: this.markTooltipValueCallback,
            hasShape: true,
            shapeType: this.shapeTypeCallback,
            shapeColor: this.shapeColorCallback,
            shapeStroke: this.shapeStrokeCallback,
            shapeHollow: false
          }]
        };
      case "group":
        return {
          visible: true,
          activeType,
          title: {
            key: void 0,
            value: this.groupTooltipTitleCallback,
            hasShape: false
          },
          content: [{
            seriesId: this.series.id,
            key: this.groupTooltipKeyCallback,
            value: this.markTooltipValueCallback,
            hasShape: true,
            shapeType: this.shapeTypeCallback,
            shapeColor: this.shapeColorCallback,
            shapeStroke: this.shapeStrokeCallback,
            shapeHollow: false
          }]
        };
      case "dimension":
        if (dimensionInfo) {
          const title3 = {
            key: void 0,
            value: this.dimensionTooltipTitleCallback,
            hasShape: false
          }, content = [];
          return dimensionInfo.forEach(({ data }) => data.forEach(({ series: series2 }) => {
            content.push({
              seriesId: series2.id,
              key: this.markTooltipKeyCallback,
              value: this.markTooltipValueCallback,
              hasShape: true,
              shapeType: this.shapeTypeCallback,
              shapeColor: this.shapeColorCallback,
              shapeStroke: this.shapeStrokeCallback,
              shapeHollow: false
            });
          })), {
            visible: true,
            activeType,
            title: title3,
            content
          };
        }
    }
    return null;
  }
};
var merge2 = (source, extraInfo, overwrite) => {
  const info = isFunction_default(extraInfo) ? extraInfo(source) : extraInfo;
  return overwrite ? Object.assign(Object.assign({}, source), info) : Object.assign(Object.assign({}, info), source);
};
var addExtraInfoToTooltipTitlePattern = (pattern, extraInfo, overwrite) => isValid_default(pattern) ? isFunction_default(pattern) ? (...args) => merge2(pattern(...args), extraInfo, overwrite) : merge2(pattern, extraInfo, overwrite) : void 0;
var addExtraInfoToTooltipContentPattern = (pattern, extraInfo, overwrite) => isValid_default(pattern) ? array(pattern).map((patternItem) => isFunction_default(patternItem) ? (...args) => array(patternItem(...args)).map((line2) => merge2(line2, extraInfo, overwrite)) : merge2(patternItem, extraInfo, overwrite)) : void 0;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/tooltip/utils/get-spec
var getTooltipSpecForShow = (activeType, globalSpec, series2, dimensionInfo) => {
  var _a, _b, _c, _d, _e, _f, _g;
  const finalSpec = Object.assign(Object.assign({}, globalSpec), {
    activeType
  }), { style = {} } = globalSpec;
  switch (activeType) {
    case "mark":
    case "group":
      if (series2) {
        const seriesSpec = null !== (_b = null === (_a = series2.tooltipHelper) || void 0 === _a ? void 0 : _a.spec) && void 0 !== _b ? _b : {};
        if (isValid_default(seriesSpec.visible) || isValid_default(seriesSpec.activeType) ? finalSpec.visible = getTooltipActualActiveType(seriesSpec).includes(activeType) : isValid_default(globalSpec.visible) || isValid_default(globalSpec.activeType) ? finalSpec.visible = getTooltipActualActiveType(globalSpec).includes(activeType) : finalSpec.visible = true, finalSpec.handler = null !== (_d = null !== (_c = seriesSpec.handler) && void 0 !== _c ? _c : globalSpec.handler) && void 0 !== _d ? _d : void 0, null === (_e = finalSpec.handler) || void 0 === _e ? void 0 : _e.showTooltip)
          return finalSpec;
      }
      break;
    case "dimension":
      if (null == dimensionInfo ? void 0 : dimensionInfo.length) {
        if (getSeriesListFromDimensionInfo(dimensionInfo).every((series3) => {
          var _a2;
          return !getTooltipActualActiveType(null === (_a2 = series3.tooltipHelper) || void 0 === _a2 ? void 0 : _a2.spec).includes("dimension");
        }) ? finalSpec.visible = false : isValid_default(globalSpec.visible) || isValid_default(globalSpec.activeType) ? finalSpec.visible = getTooltipActualActiveType(globalSpec).includes("dimension") : finalSpec.visible = true, finalSpec.handler = null !== (_f = globalSpec.handler) && void 0 !== _f ? _f : void 0, null === (_g = finalSpec.handler) || void 0 === _g ? void 0 : _g.showTooltip)
          return finalSpec;
      }
  }
  const defaultPattern = getDefaultTooltipPattern(activeType, series2, dimensionInfo), seriesPattern = getSeriesTooltipPattern(activeType, series2, dimensionInfo), userPattern = mergeSpec({}, cloneDeep(globalSpec[activeType]), seriesPattern), defaultPatternTitle = defaultPattern.title, titleShape = getShapePattern(void 0, userPattern, style.shape, void 0, defaultPatternTitle);
  isValid_default(userPattern.title) ? userPattern.title = addExtraInfoToTooltipTitlePattern(userPattern.title, Object.assign(Object.assign({}, defaultPatternTitle), titleShape)) : userPattern.title = addExtraInfoToTooltipTitlePattern(defaultPatternTitle, titleShape, true);
  const defaultPatternContent = array(defaultPattern.content);
  if (isValid_default(userPattern.content)) {
    const shapePatternMap = getShapePatternMapOfEachSeries(defaultPatternContent);
    userPattern.content = addExtraInfoToTooltipContentPattern(userPattern.content, (userLine) => getShapePattern(userLine, userPattern, style.shape, shapePatternMap));
  } else
    userPattern.content = addExtraInfoToTooltipContentPattern(defaultPatternContent, (line2) => getShapePattern(void 0, userPattern, style.shape, void 0, line2), true);
  return finalSpec[activeType] = Object.assign(Object.assign(Object.assign({}, defaultPattern), userPattern), {
    activeType
  }), finalSpec;
};
var getDefaultTooltipPattern = (activeType, series2, dimensionInfo) => {
  var _a;
  let defaultPattern = {};
  switch (activeType) {
    case "mark":
    case "group":
      series2 && (defaultPattern = null !== (_a = makeDefaultPattern(series2, activeType)) && void 0 !== _a ? _a : {});
      break;
    case "dimension":
      if (null == dimensionInfo ? void 0 : dimensionInfo.length) {
        const patternList = [];
        dimensionInfo.forEach(({ data }) => data.forEach((data2) => {
          const { series: series3 } = data2, mockDimensionInfo = [Object.assign(Object.assign({}, dimensionInfo[0]), {
            data: [data2]
          })], pattern = makeDefaultPattern(series3, "dimension", mockDimensionInfo);
          pattern && patternList.push(pattern);
        }));
        const defaultPatternContent = [];
        patternList.forEach(({ content }) => {
          isFunction_default(content) ? defaultPatternContent.push(content) : defaultPatternContent.push(...array(content));
        }), defaultPattern = Object.assign(Object.assign({}, patternList[0]), {
          content: defaultPatternContent
        });
      }
  }
  return defaultPattern;
};
var getSeriesTooltipPattern = (activeType, series2, dimensionInfo) => {
  var _a, _b;
  let seriesPattern = {};
  switch (activeType) {
    case "mark":
    case "group":
      if (series2) {
        const seriesSpec = null !== (_b = null === (_a = series2.tooltipHelper) || void 0 === _a ? void 0 : _a.spec) && void 0 !== _b ? _b : {};
        seriesPattern = seriesSpec[activeType] ? cloneDeep(seriesSpec[activeType]) : {};
      }
      break;
    case "dimension":
      if (null == dimensionInfo ? void 0 : dimensionInfo.length) {
        const seriesPatternList = getSeriesListFromDimensionInfo(dimensionInfo).filter((series3) => {
          var _a2;
          const spec = null === (_a2 = series3.tooltipHelper) || void 0 === _a2 ? void 0 : _a2.spec;
          return isValid_default(null == spec ? void 0 : spec.dimension) && getTooltipActualActiveType(spec).includes("dimension");
        }).map((series3) => series3.tooltipHelper.spec.dimension);
        if (seriesPatternList.length) {
          let seriesPatternContent = [];
          seriesPatternList.every(({ content }) => isNil_default(content)) ? seriesPatternContent = void 0 : seriesPatternList.forEach(({ content }) => {
            isNil_default(content) || (isFunction_default(content) ? null == seriesPatternContent || seriesPatternContent.push(content) : null == seriesPatternContent || seriesPatternContent.push(...array(content)));
          }), seriesPattern = Object.assign(Object.assign({}, seriesPatternList[0]), {
            content: seriesPatternContent
          });
        }
      }
  }
  return seriesPattern;
};
var getSeriesListFromDimensionInfo = memoize((dimensionInfo) => dimensionInfo.reduce((list, cur) => list.concat(cur.data.map((data) => data.series).filter(isValid_default)), []));
var getShapePatternMapOfEachSeries = (content) => {
  const shapePatternMap = {};
  return content.forEach((line2) => {
    var _a;
    const key = null !== (_a = line2.seriesId) && void 0 !== _a ? _a : 0;
    shapePatternMap[key] || (shapePatternMap[key] = line2);
  }), shapePatternMap;
};
var getShapePattern = (userLinePattern, userPattern, userStyle, shapePatternMap, defaultShapePattern) => {
  var _a, _b, _c;
  userStyle && (userStyle.shapeSize = null !== (_a = userStyle.shapeSize) && void 0 !== _a ? _a : userStyle.size);
  const maps = [userLinePattern, userPattern, userStyle, null !== (_c = null == shapePatternMap ? void 0 : shapePatternMap[null !== (_b = null == userLinePattern ? void 0 : userLinePattern.seriesId) && void 0 !== _b ? _b : 0]) && void 0 !== _c ? _c : null == shapePatternMap ? void 0 : shapePatternMap[0], defaultShapePattern].filter(isValid_default), shapeKeys = new Set(maps.reduce((keys2, cur) => keys2.concat(Object.keys(cur)), []).filter((key) => key.toLowerCase().includes("shape"))), shapePattern = {};
  return shapeKeys.forEach((key) => {
    let value, i = 0;
    do {
      value = maps[i++][key];
    } while (i < maps.length && isNil_default(value));
    void 0 !== value && (shapePattern[key] = value);
  }), shapePattern;
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/tooltip/utils/get-value
var getTooltipContentValue = (field3, datum, params2, formatter) => {
  let value;
  if (value = isFunction_default(field3) ? field3(datum, params2) : field3, formatter) {
    const { formatFunc, args } = getFormatFunction(void 0, formatter, field3, datum);
    formatFunc && args && (value = formatFunc(...args));
  }
  return value;
};
var getTooltipPatternValue = (field3, data, params2) => isNil_default(field3) ? field3 : isFunction_default(field3) ? field3(data, params2) : field3;
var getTooltipContentPattern = (field3, data, params2) => {
  if (isNil_default(field3))
    return field3;
  let result2 = [];
  return array(field3).forEach((patternItem) => {
    isFunction_default(patternItem) ? result2 = result2.concat(array(patternItem(data, params2))) : result2.push(patternItem);
  }), result2;
};
function getFirstDatumFromTooltipData(data) {
  var _a;
  const dimInfoList = (null === (_a = data[0]) || void 0 === _a ? void 0 : _a.series) ? [{
    data,
    value: ""
  }] : data;
  for (const { data: dataList } of dimInfoList)
    for (const { datum: datumList } of dataList)
      for (const datumItem of null != datumList ? datumList : [])
        if (datumItem)
          return datumItem;
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/tooltip/constant
var TooltipHandlerType = class {
};
TooltipHandlerType.dom = `${PREFIX}_TOOLTIP_HANDLER_DOM`, TooltipHandlerType.canvas = `${PREFIX}_TOOLTIP_HANDLER_CANVAS`;
var TOOLTIP_EL_CLASS_NAME = "vchart-tooltip-element";
var TOOLTIP_MAX_LINE_COUNT = 20;
var TOOLTIP_OTHERS_LINE = {
  key: "\u5176\u4ED6",
  value: "..."
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/tooltip/utils/compose
var getTimeString = (value, timeFormat, timeFormatMode) => {
  if (!timeFormat && !timeFormatMode)
    return "object" != typeof value ? null == value ? void 0 : value.toString() : value;
  const timeUtil = TimeUtil.getInstance();
  timeFormat = timeFormat || "%Y%m%d";
  return ("local" === (timeFormatMode = timeFormatMode || "local") ? timeUtil.timeFormat : timeUtil.timeUTCFormat)(timeFormat, value);
};
var getShowContent = (pattern, data, params2) => {
  var _a, _b, _c, _d;
  if (!data || "mouseout" === (null === (_a = null == params2 ? void 0 : params2.event) || void 0 === _a ? void 0 : _a.type))
    return null;
  const tooltipActualTitleContent = {
    title: {},
    content: []
  }, patternTitle = getTooltipPatternValue(pattern.title, data, params2), { visible, value, valueTimeFormat, valueTimeFormatMode, valueStyle, hasShape, valueFormatter } = null != patternTitle ? patternTitle : {}, patternTitleVisible = false !== getTooltipContentValue(visible, data, params2);
  if (patternTitle && patternTitleVisible) {
    const datum = getFirstDatumFromTooltipData(data);
    tooltipActualTitleContent.title = {
      value: getTimeString(getTooltipContentValue(value, datum, params2, valueFormatter), valueTimeFormat, valueTimeFormatMode),
      valueStyle: getTooltipContentValue(valueStyle, datum, params2),
      hasShape
    };
  } else
    tooltipActualTitleContent.title = {
      hasShape: false,
      visible: false
    };
  const patternContent = getTooltipContentPattern(pattern.content, data, params2), { maxLineCount = TOOLTIP_MAX_LINE_COUNT } = pattern, othersLine = pattern.othersLine ? Object.assign(Object.assign({}, TOOLTIP_OTHERS_LINE), pattern.othersLine) : TOOLTIP_OTHERS_LINE, getTooltipContentFromDatumList = (datumList) => {
    if (null == datumList ? void 0 : datumList.length)
      for (const datum of datumList)
        for (const content of null != patternContent ? patternContent : []) {
          const oneLineData = getOneLineData(datum, content, params2);
          if (false !== oneLineData.visible) {
            if (tooltipActualTitleContent.content.length === maxLineCount - 1) {
              tooltipActualTitleContent.content.push(Object.assign(Object.assign({}, oneLineData), othersLine));
              break;
            }
            if (!(tooltipActualTitleContent.content.length < maxLineCount))
              break;
            tooltipActualTitleContent.content.push(oneLineData);
          }
        }
  };
  switch (pattern.activeType) {
    case "mark":
      getTooltipContentFromDatumList(null === (_b = data[0]) || void 0 === _b ? void 0 : _b.datum);
      break;
    case "group":
      getTooltipContentFromDatumList(params2.groupDatum);
      break;
    case "dimension":
      for (const { data: d } of data) {
        for (const { datum: datumList, series: series2 } of d) {
          if (!getTooltipActualActiveType(null === (_c = series2.tooltipHelper) || void 0 === _c ? void 0 : _c.spec).includes("dimension"))
            continue;
          const contentPatterns = null !== (_d = null == patternContent ? void 0 : patternContent.filter((c3) => isNil_default(c3.seriesId) || c3.seriesId === series2.id)) && void 0 !== _d ? _d : [];
          for (const datum of datumList) {
            for (const linePattern of contentPatterns) {
              const oneLineData = getOneLineData(datum, linePattern, params2);
              if (false !== oneLineData.visible) {
                if (tooltipActualTitleContent.content.length === maxLineCount - 1) {
                  tooltipActualTitleContent.content.push(Object.assign(Object.assign({}, oneLineData), othersLine));
                  break;
                }
                if (!(tooltipActualTitleContent.content.length < maxLineCount))
                  break;
                tooltipActualTitleContent.content.push(oneLineData);
              }
            }
            if (tooltipActualTitleContent.content.length >= maxLineCount)
              break;
          }
          if (tooltipActualTitleContent.content.length >= maxLineCount)
            break;
        }
        if (tooltipActualTitleContent.content.length >= maxLineCount)
          break;
      }
  }
  return tooltipActualTitleContent.title && (tooltipActualTitleContent.content.length > 0 && tooltipActualTitleContent.content[0].shapeType ? (isNil_default(tooltipActualTitleContent.title.shapeType) && (tooltipActualTitleContent.title.shapeType = tooltipActualTitleContent.content[0].shapeType), isNil_default(tooltipActualTitleContent.title.shapeColor) && (tooltipActualTitleContent.title.shapeColor = tooltipActualTitleContent.content[0].shapeColor)) : tooltipActualTitleContent.title.hasShape = false), tooltipActualTitleContent;
};
var getOneLineData = (datum, config2, params2) => {
  const key = getTimeString(getTooltipContentValue(config2.key, datum, params2, config2.keyFormatter), config2.keyTimeFormat, config2.keyTimeFormatMode), value = getTimeString(getTooltipContentValue(config2.value, datum, params2, config2.valueFormatter), config2.valueTimeFormat, config2.valueTimeFormatMode), visible = false !== getTooltipContentValue(config2.visible, datum, params2) && (isValid_default(key) || isValid_default(value)), isKeyAdaptive = getTooltipContentValue(config2.isKeyAdaptive, datum, params2), spaceRow = getTooltipContentValue(config2.spaceRow, datum, params2), shapeType = getTooltipContentValue(config2.shapeType, datum, params2), shapeColor = getTooltipContentValue(config2.shapeColor, datum, params2), shapeFill = getTooltipContentValue(config2.shapeFill, datum, params2), shapeStroke = getTooltipContentValue(config2.shapeStroke, datum, params2), shapeLineWidth = getTooltipContentValue(config2.shapeLineWidth, datum, params2), shapeHollow = getTooltipContentValue(config2.shapeHollow, datum, params2), keyStyle = getTooltipContentValue(config2.keyStyle, datum, params2), valueStyle = getTooltipContentValue(config2.valueStyle, datum, params2);
  return {
    key,
    value,
    visible,
    isKeyAdaptive,
    hasShape: config2.hasShape,
    shapeType,
    shapeFill,
    shapeStroke,
    shapeLineWidth,
    shapeHollow,
    shapeColor,
    keyStyle,
    valueStyle,
    spaceRow,
    datum
  };
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/plugin/components/tooltip-handler/base
var BaseTooltipHandler = class extends BasePlugin {
  constructor() {
    super(...arguments), this._visible = true, this._attributes = null, this._isReleased = false, this.showTooltip = (activeType, data, params2) => {
      const { changePositionOnly } = params2;
      return changePositionOnly ? this.changeTooltipPosition(params2, data) : this.changeTooltip(true, params2, data);
    }, this._changeTooltip = (visible, params2, data) => this._isReleased ? 1 : visible ? this._changeTooltipPosition(params2, data) : (this._clearAllCache(), this._updateTooltip(false, params2), 0), this._changeTooltipPosition = (params2, data) => {
      var _a, _b, _c;
      if (this._isReleased)
        return 1;
      const event = params2.event, { tooltipSpec, tooltipActual, changePositionOnly } = params2;
      if (tooltipSpec.enterable) {
        if (!this._isPointerEscaped && this._isPointerMovingToTooltip(params2))
          return this._isTooltipPaused || (this._isTooltipPaused = true, this._cachePointerTimer = setTimeout(() => {
            this._isPointerEscaped = true;
          }, 300)), 0;
        this._isTooltipPaused = false, this._isPointerEscaped = false, clearTimeout(this._cachePointerTimer), this._cachePointerPosition = this._getPointerPositionRelativeToTooltipParent(params2);
      }
      const activeType = tooltipActual.activeType;
      if (tooltipSpec.handler)
        return null !== (_c = null === (_b = (_a = tooltipSpec.handler).showTooltip) || void 0 === _b ? void 0 : _b.call(_a, activeType, data, params2)) && void 0 !== _c ? _c : 0;
      const pattern = tooltipSpec[activeType];
      if (!pattern)
        return 1;
      const position = this._getActualTooltipPosition(tooltipActual, params2, this._getTooltipBoxSize(tooltipActual, changePositionOnly));
      tooltipActual.position = position, pattern.updatePosition && (tooltipActual.position = pattern.updatePosition(tooltipActual.position, data, params2));
      let tooltipVisible = false !== (null == pattern ? void 0 : pattern.visible);
      return data && "pointerout" !== event.type && tooltipActual.visible && (tooltipActual.title || tooltipActual.content) || (tooltipVisible = false), this._updateTooltip(tooltipVisible, Object.assign(Object.assign({}, params2), {
        changePositionOnly
      })), 0;
    }, this._getActualTooltipPosition = (actualTooltip, params2, tooltipBoxSize) => {
      var _a, _b, _c, _d, _e, _f, _g;
      const event = params2.event, { tooltipSpec } = params2, firstDimensionInfo = null === (_a = params2.dimensionInfo) || void 0 === _a ? void 0 : _a[0], invalidPosition = {
        x: 1 / 0,
        y: 1 / 0
      };
      let { offsetX, offsetY } = this._option;
      if (!tooltipSpec)
        return this._cacheTooltipPosition = void 0, invalidPosition;
      const { activeType, data } = actualTooltip, pattern = tooltipSpec[activeType], position = getTooltipPatternValue(pattern.position, data, params2), positionMode = null !== (_b = getTooltipPatternValue(pattern.positionMode, data, params2)) && void 0 !== _b ? _b : "mark" === activeType ? "mark" : "pointer", tooltipParentElement = this._getParentElement(tooltipSpec), { width: tooltipBoxWidth = 0, height: tooltipBoxHeight = 0 } = null != tooltipBoxSize ? tooltipBoxSize : {}, isCanvas = "canvas" === tooltipSpec.renderMode, canvasRect = null === (_c = null == params2 ? void 0 : params2.chart) || void 0 === _c ? void 0 : _c.getCanvasRect(), canvasWidth = null !== (_d = null == canvasRect ? void 0 : canvasRect.width) && void 0 !== _d ? _d : DEFAULT_CHART_WIDTH, canvasHeight = null !== (_e = null == canvasRect ? void 0 : canvasRect.height) && void 0 !== _e ? _e : DEFAULT_CHART_HEIGHT;
      let isFixedPosition = false;
      const containerSize = {
        width: 0,
        height: 0
      };
      let relativePosOffset = {
        x: 0,
        y: 0
      }, tooltipParentElementRect = {
        x: 0,
        y: 0
      }, chartElementScale = 1, tooltipParentElementScale = 1;
      if (isTrueBrowser(this._env) && !tooltipSpec.confine) {
        if (containerSize.width = window.innerWidth, containerSize.height = window.innerHeight, !isCanvas) {
          tooltipParentElementRect = null !== (_f = null == tooltipParentElement ? void 0 : tooltipParentElement.getBoundingClientRect()) && void 0 !== _f ? _f : invalidPosition;
          const chartElement = null !== (_g = this._compiler.getCanvas()) && void 0 !== _g ? _g : this._chartContainer, chartElementRect = null == chartElement ? void 0 : chartElement.getBoundingClientRect();
          relativePosOffset = {
            x: chartElementRect.x - tooltipParentElementRect.x,
            y: chartElementRect.y - tooltipParentElementRect.y
          }, chartElementScale = getScale(chartElement, chartElementRect), tooltipParentElementScale = getScale(tooltipParentElement, tooltipParentElementRect);
        }
      } else
        containerSize.width = canvasWidth, containerSize.height = canvasHeight;
      const tooltipSizeScale = tooltipParentElementScale / chartElementScale;
      let left2, top, right2, bottom, pointerFixedPositionX = position, pointerFixedPositionY = position;
      const processCartesianFixedPositionX = ({ orient, mode, offset }) => {
        var _a2;
        let x14, x23;
        const model = params2.model, startPoint = null == model ? void 0 : model.getLayoutStartPoint();
        if (offsetX = null != offset ? offset : offsetX, "mark" === mode) {
          isFixedPosition = true;
          const element = params2.item, bounds = null == element ? void 0 : element.getBounds();
          bounds && startPoint && (x14 = bounds.x1 + startPoint.x, x23 = bounds.x2 + startPoint.x);
        } else if ("crosshair" === mode && "cartesian" === (null === (_a2 = null == firstDimensionInfo ? void 0 : firstDimensionInfo.axis) || void 0 === _a2 ? void 0 : _a2.getCoordinateType())) {
          isFixedPosition = true;
          const rect = getCartesianCrosshairRect(params2.dimensionInfo, getFirstSeries(this._component.getRegions(), "cartesian"), startPoint);
          rect && (x14 = rect.start.x, x23 = rect.end.x);
        } else
          pointerFixedPositionX = orient;
        if (isFixedPosition)
          switch (getHorizontalPositionType(orient)) {
            case "left":
              left2 = x14 - tooltipBoxWidth * tooltipSizeScale - offsetX;
              break;
            case "right":
              left2 = x23 + offsetX;
              break;
            case "center":
              left2 = (x14 + x23) / 2 - tooltipBoxWidth * tooltipSizeScale / 2;
              break;
            case "centerLeft":
              left2 = (x14 + x23) / 2 - tooltipBoxWidth * tooltipSizeScale - offsetX;
              break;
            case "centerRight":
              left2 = (x14 + x23) / 2 + offsetX;
          }
      }, processCartesianFixedPositionY = ({ orient, mode, offset }) => {
        var _a2;
        let y14, y23;
        const model = params2.model, startPoint = null == model ? void 0 : model.getLayoutStartPoint();
        if (offsetY = null != offset ? offset : offsetY, "mark" === mode) {
          isFixedPosition = true;
          const element = params2.item, bounds = null == element ? void 0 : element.getBounds();
          bounds && startPoint && (y14 = bounds.y1 + startPoint.y, y23 = bounds.y2 + startPoint.y);
        } else if ("crosshair" === mode && "cartesian" === (null === (_a2 = null == firstDimensionInfo ? void 0 : firstDimensionInfo.axis) || void 0 === _a2 ? void 0 : _a2.getCoordinateType())) {
          isFixedPosition = true;
          const rect = getCartesianCrosshairRect(params2.dimensionInfo, getFirstSeries(this._component.getRegions(), "cartesian"), startPoint);
          rect && (y14 = rect.start.y, y23 = rect.end.y);
        } else
          pointerFixedPositionY = orient;
        if (isFixedPosition)
          switch (getVerticalPositionType(orient)) {
            case "top":
              top = y14 - tooltipBoxHeight * tooltipSizeScale - offsetY;
              break;
            case "bottom":
              top = y23 + offsetY;
              break;
            case "center":
              top = (y14 + y23) / 2 - tooltipBoxHeight * tooltipSizeScale / 2;
              break;
            case "centerTop":
              top = (y14 + y23) / 2 - tooltipBoxHeight * tooltipSizeScale - offsetY;
              break;
            case "centerBottom":
              top = (y14 + y23) / 2 + offsetY;
          }
      };
      if (isObject_default(position)) {
        if (isGlobalTooltipPositionPattern(position)) {
          const { left: posLeft, right: posRight, top: posTop, bottom: posBottom } = position;
          left2 = getActualTooltipPositionValue(posLeft, event), top = getActualTooltipPositionValue(posTop, event), right2 = getActualTooltipPositionValue(posRight, event), bottom = getActualTooltipPositionValue(posBottom, event);
        } else if (isFixedTooltipPositionPattern(position)) {
          const { x: x3, y: y3 } = position;
          isNumber_default(x3) || isFunction_default(x3) ? left2 = getActualTooltipPositionValue(x3, event) : processCartesianFixedPositionX(x3), isNumber_default(y3) || isFunction_default(y3) ? top = getActualTooltipPositionValue(y3, event) : processCartesianFixedPositionY(y3);
        }
      } else
        isValid_default(position) && (processCartesianFixedPositionX({
          orient: position,
          mode: positionMode
        }), processCartesianFixedPositionY({
          orient: position,
          mode: positionMode
        }));
      let x, y;
      const { canvasX, canvasY } = event;
      if (isValidNumber_default(left2))
        x = left2;
      else if (isValidNumber_default(right2))
        x = canvasWidth - tooltipBoxWidth * tooltipSizeScale - right2;
      else {
        const x05 = canvasX;
        switch (getHorizontalPositionType(pointerFixedPositionX, "right")) {
          case "center":
            x = x05 - tooltipBoxWidth * tooltipSizeScale / 2;
            break;
          case "left":
          case "centerLeft":
            x = x05 - tooltipBoxWidth * tooltipSizeScale - offsetX;
            break;
          case "right":
          case "centerRight":
            x = x05 + offsetX;
        }
      }
      if (isValidNumber_default(top))
        y = top;
      else if (isValidNumber_default(bottom))
        y = canvasHeight - tooltipBoxHeight * tooltipSizeScale - bottom;
      else {
        const y05 = canvasY;
        switch (getVerticalPositionType(pointerFixedPositionY, "bottom")) {
          case "center":
            y = y05 - tooltipBoxHeight * tooltipSizeScale / 2;
            break;
          case "top":
          case "centerTop":
            y = y05 - tooltipBoxHeight * tooltipSizeScale - offsetY;
            break;
          case "bottom":
          case "centerBottom":
            y = y05 + offsetY;
        }
      }
      x *= chartElementScale, y *= chartElementScale, isTrueBrowser(this._env) && (x += relativePosOffset.x, y += relativePosOffset.y), x /= tooltipParentElementScale, y /= tooltipParentElementScale;
      const { width: containerWidth, height: containerHeight } = containerSize, isLeftOut = () => x * tooltipParentElementScale + tooltipParentElementRect.x < 0, isRightOut = () => (x + tooltipBoxWidth) * tooltipParentElementScale + tooltipParentElementRect.x > containerWidth, isTopOut = () => y * tooltipParentElementScale + tooltipParentElementRect.y < 0, isBottomOut = () => (y + tooltipBoxHeight) * tooltipParentElementScale + tooltipParentElementRect.y > containerHeight, detectLeftFirst = () => {
        isLeftOut() && (isFixedPosition ? x = -tooltipParentElementRect.x / tooltipParentElementScale : "center" === getHorizontalPositionType(position, "right") ? x += offsetX + tooltipBoxWidth / 2 : x += 2 * offsetX + tooltipBoxWidth);
      }, detectLeftLast = () => {
        isLeftOut() && (x = -tooltipParentElementRect.x / tooltipParentElementScale);
      }, detectRightFirst = () => {
        isRightOut() && (isFixedPosition ? x = (containerWidth - tooltipParentElementRect.x) / tooltipParentElementScale - tooltipBoxWidth : "center" === getHorizontalPositionType(position, "right") ? x -= offsetX + tooltipBoxWidth / 2 : x -= 2 * offsetX + tooltipBoxWidth);
      }, detectRightLast = () => {
        isRightOut() && (x = (containerWidth - tooltipParentElementRect.x) / tooltipParentElementScale - tooltipBoxWidth);
      }, detectTopFirst = () => {
        isTopOut() && (isFixedPosition ? y = -tooltipParentElementRect.y / tooltipParentElementScale : "center" === getVerticalPositionType(position, "bottom") ? y += offsetY + tooltipBoxHeight / 2 : y += 2 * offsetY + tooltipBoxHeight);
      }, detectTopLast = () => {
        isTopOut() && (y = 0 - tooltipParentElementRect.y / tooltipParentElementScale);
      }, detectBottomFirst = () => {
        isBottomOut() && (isFixedPosition ? y = (containerHeight - tooltipParentElementRect.y) / tooltipParentElementScale - tooltipBoxHeight : "center" === getVerticalPositionType(position, "bottom") ? y -= offsetY + tooltipBoxHeight / 2 : y -= 2 * offsetY + tooltipBoxHeight);
      }, detectBottomLast = () => {
        isBottomOut() && (y = (containerHeight - tooltipParentElementRect.y) / tooltipParentElementScale - tooltipBoxHeight);
      };
      switch (getHorizontalPositionType(position, "right")) {
        case "center":
        case "centerLeft":
        case "centerRight":
          isLeftOut() ? (detectLeftFirst(), detectRightLast()) : (detectRightFirst(), detectLeftLast());
          break;
        case "left":
          detectLeftFirst(), detectRightLast();
          break;
        case "right":
          detectRightFirst(), detectLeftLast();
      }
      switch (getVerticalPositionType(position, "bottom")) {
        case "center":
        case "centerTop":
        case "centerBottom":
          isTopOut() ? (detectTopFirst(), detectBottomLast()) : (detectBottomFirst(), detectTopLast());
          break;
        case "top":
          detectTopFirst(), detectBottomLast();
          break;
        case "bottom":
          detectBottomFirst(), detectTopLast();
      }
      const result2 = {
        x,
        y
      };
      return this._cacheTooltipPosition = result2, this._cacheTooltipSize = {
        width: tooltipBoxWidth,
        height: tooltipBoxHeight
      }, result2;
    };
  }
  get env() {
    return this._env;
  }
  onAdd(service) {
    super.onAdd(service);
    const component2 = service.component;
    this._component = component2, this._chartOption = component2.getOption(), this._env = this._chartOption.mode, this._chartContainer = this._chartOption.globalInstance.getContainer(), this._compiler = component2.getCompiler(), this._initFromSpec();
  }
  hideTooltip(params2) {
    return this.changeTooltip(false, params2);
  }
  release() {
    var _a, _b, _c;
    this._clearAllCache();
    const spec = null !== (_a = this._component.getSpec()) && void 0 !== _a ? _a : {};
    spec.handler ? null === (_c = (_b = spec.handler).release) || void 0 === _c || _c.call(_b) : (this._removeTooltip(), this._isReleased = true);
  }
  _clearAllCache() {
    this._isTooltipPaused = false, this._isPointerEscaped = false, clearTimeout(this._cachePointerTimer), this._cachePointerTimer = -1, this._cachePointerPosition = void 0, this._cacheTooltipPosition = void 0, this._cacheTooltipSize = void 0;
  }
  _throttle(callback) {
    const tooltipSpec = this._component.getSpec();
    let wait;
    return wait = isNumber_default(tooltipSpec.throttleInterval) ? tooltipSpec.throttleInterval : "html" === tooltipSpec.renderMode && tooltipSpec.transitionDuration ? 50 : 10, throttle_default(callback, wait);
  }
  _getDefaultOption() {
    var _a, _b;
    const { offset } = this._component.getSpec();
    return Object.assign(Object.assign({}, DEFAULT_OPTIONS), {
      offsetX: null !== (_a = null == offset ? void 0 : offset.x) && void 0 !== _a ? _a : DEFAULT_OPTIONS.offsetX,
      offsetY: null !== (_b = null == offset ? void 0 : offset.y) && void 0 !== _b ? _b : DEFAULT_OPTIONS.offsetY
    });
  }
  _getTooltipBoxSize(actualTooltip, changePositionOnly) {
    var _a, _b, _c;
    if (!changePositionOnly || isNil_default(this._attributes)) {
      const chartTheme = null !== (_b = null === (_a = this._chartOption) || void 0 === _a ? void 0 : _a.getTheme()) && void 0 !== _b ? _b : {};
      this._attributes = getTooltipAttributes(actualTooltip, this._component.getSpec(), chartTheme);
    }
    const { panel, panelDomHeight } = null !== (_c = this._attributes) && void 0 !== _c ? _c : {}, isCanvas = "canvas" === this._component.getSpec().renderMode;
    return {
      width: (null == panel ? void 0 : panel.width) + (isCanvas ? panel.lineWidth : 0),
      height: (null != panelDomHeight ? panelDomHeight : null == panel ? void 0 : panel.height) + (isCanvas ? panel.lineWidth : 0)
    };
  }
  _getPointerPositionRelativeToTooltipParent(params2) {
    var _a, _b;
    let { canvasX: x, canvasY: y } = params2.event;
    const { tooltipSpec } = params2, invalidPosition = {
      x: 1 / 0,
      y: 1 / 0
    }, isCanvas = "canvas" === tooltipSpec.renderMode, tooltipParentElement = this._getParentElement(tooltipSpec);
    let relativePosOffset = {
      x: 0,
      y: 0
    }, tooltipParentElementRect = {
      x: 0,
      y: 0
    }, chartElementScale = 1, tooltipParentElementScale = 1;
    if (isTrueBrowser(this._env) && !tooltipSpec.confine && !isCanvas) {
      tooltipParentElementRect = null !== (_a = null == tooltipParentElement ? void 0 : tooltipParentElement.getBoundingClientRect()) && void 0 !== _a ? _a : invalidPosition;
      const chartElement = null !== (_b = this._compiler.getCanvas()) && void 0 !== _b ? _b : this._chartContainer, chartElementRect = null == chartElement ? void 0 : chartElement.getBoundingClientRect();
      relativePosOffset = {
        x: chartElementRect.x - tooltipParentElementRect.x,
        y: chartElementRect.y - tooltipParentElementRect.y
      }, chartElementScale = getScale(chartElement, chartElementRect), tooltipParentElementScale = getScale(tooltipParentElement, tooltipParentElementRect);
    }
    return x *= chartElementScale, y *= chartElementScale, isTrueBrowser(this._env) && (x += relativePosOffset.x, y += relativePosOffset.y), x /= tooltipParentElementScale, y /= tooltipParentElementScale, {
      x,
      y
    };
  }
  _isPointerMovingToTooltip(params2) {
    if (!this._cacheTooltipPosition || !this._cacheTooltipSize || !this._cachePointerPosition)
      return false;
    const { width: tooltipWidth, height: tooltipHeight } = this._cacheTooltipSize, { x: tooltipX = 0, y: tooltipY } = this._cacheTooltipPosition, pos = this._getPointerPositionRelativeToTooltipParent(params2);
    if (pointInRect(pos, {
      x1: tooltipX,
      y1: tooltipY,
      x2: tooltipX + tooltipWidth,
      y2: tooltipY + tooltipHeight
    }, false))
      return true;
    const a3 = {
      x: tooltipX,
      y: tooltipY
    }, b = {
      x: a3.x + tooltipWidth,
      y: a3.y
    }, c3 = {
      x: a3.x,
      y: a3.y + tooltipHeight
    }, d = {
      x: b.x,
      y: c3.y
    }, oldPos = this._cachePointerPosition;
    return polygonContainPoint([oldPos, a3, b], pos.x, pos.y) || polygonContainPoint([oldPos, c3, d], pos.x, pos.y) || polygonContainPoint([oldPos, a3, d], pos.x, pos.y) || polygonContainPoint([oldPos, b, c3], pos.x, pos.y);
  }
  _getParentElement(spec) {
    return spec.parentElement;
  }
  getTooltipContainer() {
    return this._container;
  }
  _initFromSpec() {
    this._option = this._getDefaultOption(), this.changeTooltip = this._throttle(this._changeTooltip), this.changeTooltipPosition = this._throttle(this._changeTooltipPosition);
  }
  reInit() {
    this._initFromSpec();
  }
};
BaseTooltipHandler.specKey = "tooltip";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/plugin/components/tooltip-handler/dom/utils/common
var getPixelPropertyStr = (num, defaultStr) => isValid_default(num) ? isArray_default(num) ? num.map((n) => `${n}px`).join(" ") : `${num}px` : null != defaultStr ? defaultStr : "initial";
var pixelPropertyStrToNumber = (str) => {
  const numArr = str.split(" ").map((n) => Number.isNaN(n) ? Number.parseFloat(n.substring(0, n.length - 2)) : Number.parseFloat(n));
  return 1 === numArr.length ? numArr[0] : numArr;
};
var cacheScrollbarWidth;
var getScrollbarWidth = (container2 = document.body) => {
  if (isNil_default(cacheScrollbarWidth)) {
    const outer = document.createElement("div");
    outer.style.visibility = "hidden", outer.style.overflow = "scroll", container2.appendChild(outer);
    const inner = document.createElement("div");
    outer.appendChild(inner), cacheScrollbarWidth = outer.offsetWidth - inner.offsetWidth, outer.parentNode.removeChild(outer);
  }
  return cacheScrollbarWidth;
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/plugin/components/tooltip-handler/dom/utils/style
function getDomStyles(attributes) {
  var _a, _b, _c;
  const { panel = {}, title: titleAttribute, content: contentAttribute, titleStyle = {}, contentStyle = {}, padding, keyWidth, valueWidth, enterable, transitionDuration, panelDomHeight = 0 } = null != attributes ? attributes : {}, { fill: backgroundColor, shadow, shadowBlur, shadowColor, shadowOffsetX, shadowOffsetY, shadowSpread, cornerRadius, stroke: strokeColor, lineWidth = 0, width = 0 } = panel, { value: title3 = {} } = titleStyle, { shape = {}, key = {}, value = {} } = contentStyle, shapeStyle = getShapeStyle(shape), keyStyle = getLabelStyle(key), valueStyle = getLabelStyle(value), { bottom, left: left2, right: right2, top } = normalizeLayoutPaddingSpec(padding);
  return {
    panel: {
      width: getPixelPropertyStr(width + 2 * lineWidth),
      minHeight: getPixelPropertyStr(panelDomHeight + 2 * lineWidth),
      paddingBottom: getPixelPropertyStr(bottom),
      paddingLeft: getPixelPropertyStr(left2),
      paddingRight: getPixelPropertyStr(right2),
      paddingTop: getPixelPropertyStr(top),
      borderColor: strokeColor,
      borderWidth: getPixelPropertyStr(lineWidth),
      borderRadius: getPixelPropertyStr(cornerRadius),
      backgroundColor: backgroundColor ? `${backgroundColor}` : "transparent",
      boxShadow: shadow ? `${shadowOffsetX}px ${shadowOffsetY}px ${shadowBlur}px ${shadowSpread}px ${shadowColor}` : "initial",
      pointerEvents: enterable ? "auto" : "none",
      transitionDuration: transitionDuration ? `${transitionDuration}ms` : "initial",
      transitionProperty: transitionDuration ? "transform" : "initial",
      transitionTimingFunction: transitionDuration ? "ease-out" : "initial"
    },
    title: Object.assign({
      marginTop: "0px",
      marginBottom: (null == contentAttribute ? void 0 : contentAttribute.length) ? getPixelPropertyStr(null == titleAttribute ? void 0 : titleAttribute.spaceRow) : "0px"
    }, getLabelStyle(mergeSpec({}, title3, null == titleAttribute ? void 0 : titleAttribute.value))),
    content: {},
    shapeColumn: {
      common: shapeStyle,
      items: null == contentAttribute ? void 0 : contentAttribute.map(({ spaceRow }, i) => ({
        marginTop: "0px",
        marginBottom: i < contentAttribute.length - 1 ? getPixelPropertyStr(spaceRow) : "0px"
      })),
      width: getPixelPropertyStr(shape.size),
      marginRight: getPixelPropertyStr(null !== (_a = shape.spacing) && void 0 !== _a ? _a : 8)
    },
    keyColumn: {
      common: keyStyle,
      items: null == contentAttribute ? void 0 : contentAttribute.map(({ key: key2, spaceRow }, i) => Object.assign(Object.assign(Object.assign({
        marginTop: "0px",
        marginBottom: i < contentAttribute.length - 1 ? getPixelPropertyStr(spaceRow) : "0px"
      }, keyStyle), getLabelStyle(key2)), (null == key2 ? void 0 : key2.multiLine) ? {
        width: getPixelPropertyStr(Math.ceil(key2.width))
      } : void 0)),
      width: getPixelPropertyStr(keyWidth),
      marginRight: getPixelPropertyStr(null !== (_b = key.spacing) && void 0 !== _b ? _b : 26)
    },
    valueColumn: {
      common: valueStyle,
      items: null == contentAttribute ? void 0 : contentAttribute.map(({ value: value2, spaceRow }, i) => Object.assign(Object.assign(Object.assign({
        marginTop: "0px",
        marginBottom: i < contentAttribute.length - 1 ? getPixelPropertyStr(spaceRow) : "0px"
      }, valueStyle), getLabelStyle(value2)), (null == value2 ? void 0 : value2.multiLine) ? {
        width: getPixelPropertyStr(Math.ceil(value2.width))
      } : void 0)),
      width: getPixelPropertyStr(valueWidth),
      marginRight: getPixelPropertyStr(null !== (_c = value.spacing) && void 0 !== _c ? _c : 0)
    }
  };
}
function getLabelStyle(labelStyle, defaultStyle) {
  if (!labelStyle)
    return;
  const { fontFamily: labelFont, fontSize: labelFontSize, fill: labelColor, textAlign, lineHeight, fontWeight, multiLine, wordBreak, maxWidth } = mergeSpec({}, defaultStyle, labelStyle), styleObj = {};
  return styleObj.fontFamily = labelFont, styleObj.fontSize = getPixelPropertyStr(labelFontSize), styleObj.color = labelColor, styleObj.textAlign = textAlign, styleObj.lineHeight = getPixelPropertyStr(calculateLineHeight(lineHeight, labelFontSize)), styleObj.fontWeight = fontWeight, styleObj.whiteSpace = multiLine ? "initial" : "nowrap", styleObj.wordBreak = multiLine ? null != wordBreak ? wordBreak : "break-word" : "normal", styleObj.maxWidth = getPixelPropertyStr(maxWidth), styleObj;
}
function getShapeStyle(shapeStyle, defaultStyle) {
  if (!shapeStyle)
    return;
  const { size } = mergeSpec({}, defaultStyle, shapeStyle), styleObj = {};
  return styleObj.width = getPixelPropertyStr(size), styleObj;
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/plugin/components/tooltip-handler/dom/model/base-tooltip-model
var BaseTooltipModel = class _BaseTooltipModel {
  static isInstance(obj) {
    return !!obj && obj.type === _BaseTooltipModel.type;
  }
  setOption(option) {
    this._option = option, Object.values(this.children).forEach((c3) => c3.setOption(option));
  }
  getParentEl() {
    return _BaseTooltipModel.isInstance(this.parent) ? this.parent.product : this.parent;
  }
  constructor(parent, option, childIndex) {
    this.type = _BaseTooltipModel.type, this._renderContentCache = null, this.children = {}, this.parent = parent, this._option = option, this.childIndex = null != childIndex ? childIndex : 0;
  }
  init(classList, id2) {
  }
  initAll() {
    this.init(), Object.values(this.children).forEach((c3) => c3.initAll());
  }
  setStyle(style) {
    this.product && style && Object.keys(style).forEach((key) => {
      this.product.style[key] !== style[key] && (this.product.style[key] = style[key]);
    });
  }
  setContent(content) {
  }
  setVisibility(visibility) {
    if (!this.product)
      return;
    const { style } = this.product;
    style.visibility = visibility ? "visible" : "hidden", Object.values(this.children).forEach((c3) => c3.setVisibility(visibility));
  }
  getVisibility() {
    var _a, _b;
    return !!(null === (_b = null === (_a = this.product) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.visibility) && "hidden" !== this.product.style.visibility;
  }
  release() {
    var _a;
    if (Object.values(this.children).forEach((c3) => c3.release()), this.children = {}, this.product) {
      try {
        null === (_a = this.getParentEl()) || void 0 === _a || _a.removeChild(this.product);
      } catch (_b) {
      }
      this.product = null;
    }
  }
  createElement(tag, classList, style, id2) {
    const element = null == domDocument ? void 0 : domDocument.createElement(tag), parentEl = this.getParentEl();
    if (!element || !parentEl)
      return;
    classList && element.classList.add(...classList), style && Object.keys(style).forEach((key) => {
      element.style[key] = style[key];
    }), id2 && (element.id = id2);
    let ptr = this.childIndex;
    if (_BaseTooltipModel.isInstance(this.parent)) {
      let nextChildIndex = Number.MAX_VALUE;
      for (let i = 0; i < parentEl.children.length; i++) {
        const childModel = Object.values(this.parent.children).find((c3) => c3.product === parentEl.children[i]);
        childModel.childIndex > this.childIndex && childModel.childIndex < nextChildIndex && (nextChildIndex = childModel.childIndex, ptr = i);
      }
    }
    return ptr >= parentEl.children.length ? parentEl.appendChild(element) : parentEl.insertBefore(element, parentEl.children[ptr]), element;
  }
};
BaseTooltipModel.type = "tooltipModel";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/plugin/components/tooltip-handler/dom/model/style-constants
var defaultH2Style = {
  fontSize: "13px",
  marginBottom: "0px",
  fontWeight: "normal"
};
var defaultContainerStyle = {
  boxSizing: "border-box"
};
var defaultContentColumnStyle = {
  display: "inline-block",
  verticalAlign: "top"
};
var defaultKeyStyle = {
  paddingTop: "0px",
  paddingBottom: "0px",
  textAlign: "left",
  fontWeight: "normal"
};
var defaultAdaptiveKeyStyle = {
  paddingTop: "0px",
  paddingBottom: "0px",
  textAlign: "left",
  fontWeight: "normal"
};
var defaultValueStyle = {
  paddingTop: "0px",
  paddingBottom: "0px",
  textAlign: "right",
  fontWeight: "normal"
};
var defaultShapeStyle = {
  lineHeight: "normal",
  boxSizing: "border-box"
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/plugin/components/tooltip-handler/dom/model/shape-model
var ShapeModel = class extends BaseTooltipModel {
  init(classList, id2, tag) {
    if (!this.product) {
      const container2 = this.createElement(null != tag ? tag : "div", [...null != classList ? classList : [], "shape"], void 0, id2);
      this.product = container2;
    }
  }
  setStyle(style, option) {
    super.setStyle(style), this.setSvg(option);
  }
  setContent(option) {
    this.setSvg(option);
  }
  setSvg(option) {
    const html = getSvgHtml(option, this._option.valueToHtml);
    this.product && html !== this._svgHtmlCache && (this._svgHtmlCache = html, this.product.innerHTML = html);
  }
  release() {
    super.release(), this._svgHtmlCache = "";
  }
};
var builtInShape = {
  star: "M0 -1L0.22451398828979266 -0.3090169943749474L0.9510565162951535 -0.30901699437494745L0.3632712640026804 0.1180339887498948L0.5877852522924732 0.8090169943749473L8.326672684688674e-17 0.3819660112501051L-0.587785252292473 0.8090169943749476L-0.3632712640026804 0.11803398874989487L-0.9510565162951536 -0.30901699437494723L-0.22451398828979274 -0.30901699437494734Z"
};
function getSvgHtml(option, valueToHtml) {
  var _a, _b, _c, _d, _e, _f, _g;
  if (!(null == option ? void 0 : option.hasShape) || !option.symbolType)
    return "";
  const { symbolType, fill, stroke: stroke2, hollow = false } = option, size = option.size ? valueToHtml(option.size) : "8px", lineWidth = option.lineWidth ? valueToHtml(option.lineWidth) + "px" : "0px";
  let fillString = "currentColor";
  const getStroke = () => stroke2 ? valueToHtml(stroke2) : fillString, sizeNumber = pixelPropertyStrToNumber(size), createSymbol2 = (symbolType2) => new Symbol2({
    symbolType: symbolType2,
    size: sizeNumber,
    fill: true
  });
  let symbol = createSymbol2(null !== (_a = builtInShape[symbolType]) && void 0 !== _a ? _a : symbolType);
  const parsedPath = symbol.getParsedPath();
  parsedPath.path || (symbol = createSymbol2(parsedPath.pathStr));
  const pathModel = symbol.getParsedPath().path, path = pathModel.toString(), bounds = pathModel.bounds;
  let viewBox = `${bounds.x1} ${bounds.y1} ${bounds.width()} ${bounds.height()}`;
  if ("0px" !== lineWidth) {
    const [x, y, w, h] = viewBox.split(" ").map((n) => Number(n)), lw = Number(lineWidth.slice(0, -2));
    viewBox = `${x - lw / 2} ${y - lw / 2} ${w + lw} ${h + lw}`;
  }
  if (!fill || isString_default(fill) || hollow)
    return fillString = hollow ? "none" : fill ? valueToHtml(fill) : "currentColor", `
    <svg width="${size}" height="${size}" viewBox="${viewBox}"
      style="display: block;">
      <path
        d="${path}"
        style="fill: ${fillString}; stroke: ${getStroke()}; stroke-width: ${lineWidth}"
      >
      </path>
    </svg>`;
  if (isObject_default(fill)) {
    fillString = null !== (_b = "gradientColor" + option.index) && void 0 !== _b ? _b : "";
    let gradient = "";
    const stops = (null !== (_c = fill.stops) && void 0 !== _c ? _c : []).map((s2) => `<stop offset="${valueToHtml(s2.offset.toString())}" stop-color="${valueToHtml(s2.color)}"/>`).join("");
    return "radial" === fill.gradient ? gradient = `<radialGradient id="${fillString}" cx="50%" cy="50%" r="50%" fx="0%" fy="0%">
      ${stops}
      </radialGradient>` : "linear" === fill.gradient && (gradient = `<linearGradient id="${fillString}" x1="${100 * (null !== (_d = fill.x0) && void 0 !== _d ? _d : 0)}%" y1="${100 * (null !== (_e = fill.y0) && void 0 !== _e ? _e : 0)}%" x2="${100 * (null !== (_f = fill.x1) && void 0 !== _f ? _f : 0)}%" y2="${100 * (null !== (_g = fill.y1) && void 0 !== _g ? _g : 0)}%">
      ${stops}
      </linearGradient>`), `
    <svg width="${size}" height="${size}" viewBox="-0.5 -0.5 1 1"
      style="display: block;">
      ${gradient}
      <path
        d="${path}"
        style="fill: url(#${fillString}); stroke: ${getStroke()}; stroke-width: ${lineWidth}"
      >
      </path>
    </svg>`;
  }
  return "";
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/plugin/components/tooltip-handler/dom/model/text-model
var TextModel = class extends BaseTooltipModel {
  init(classList, id2, tag) {
    this.product || (this.product = this.createElement(null != tag ? tag : "span", classList, void 0, id2));
  }
  setContent(content, multiLine) {
    if (!this.product)
      return;
    let html = this._option.valueToHtml(content);
    multiLine && (html = html.replaceAll("\n", "<br>")), html !== this.product.innerHTML && (this.product.innerHTML = html);
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/plugin/components/tooltip-handler/dom/model/content-column-model
var defaultLabelStyle = {
  overflowWrap: "normal",
  wordWrap: "normal"
};
var ContentColumnModel = class extends BaseTooltipModel {
  constructor(parent, option, className, childIndex) {
    super(parent, option, childIndex), this.className = className;
  }
  init() {
    var _a, _b;
    this.product || (this.product = this.createElement("div", [this.className]));
    const renderContent = null !== (_b = null === (_a = this._option.getTooltipActual()) || void 0 === _a ? void 0 : _a.content) && void 0 !== _b ? _b : [];
    if ("shape-box" !== this.className || renderContent.some((c3) => c3.hasShape && c3.shapeType)) {
      Object.keys(this.children).forEach((key) => {
        const i = toNumber(key);
        i >= renderContent.length && (this.children[i].release(), delete this.children[i]);
      });
      for (let i = 0; i < renderContent.length; i++)
        if (!this.children[i]) {
          if ("key-box" === this.className || "value-box" === this.className) {
            const text2 = new TextModel(this.product, this._option, i);
            text2.init([this.className.substring(0, this.className.indexOf("-"))], void 0, "div"), this.children[i] = text2;
          } else if ("shape-box" === this.className) {
            const shape = new ShapeModel(this.product, this._option, i);
            shape.init(["shape"], void 0, "div"), this.children[i] = shape;
          }
        }
    } else
      Object.keys(this.children).forEach((key) => {
        const i = toNumber(key);
        this.children[i].release(), delete this.children[i];
      });
  }
  setStyle() {
    var _a, _b, _c, _d;
    const tooltipStyle = this._option.getTooltipStyle();
    super.setStyle(mergeSpec({}, defaultContentColumnStyle, tooltipStyle.content, this._getContentColumnStyle()));
    const renderContent = null !== (_b = null === (_a = this._option.getTooltipActual()) || void 0 === _a ? void 0 : _a.content) && void 0 !== _b ? _b : [], contentAttributes = null !== (_d = null === (_c = this._option.getTooltipAttributes()) || void 0 === _c ? void 0 : _c.content) && void 0 !== _d ? _d : [], getKeyItemStyle = (line2, i) => {
      var _a2, _b2;
      const { key, isKeyAdaptive } = line2, { height } = contentAttributes[i], { keyColumn } = tooltipStyle, style = mergeSpec({}, isKeyAdaptive ? defaultAdaptiveKeyStyle : defaultKeyStyle, Object.assign(Object.assign(Object.assign({
        height: getPixelPropertyStr(height)
      }, defaultLabelStyle), keyColumn.common), null === (_a2 = keyColumn.items) || void 0 === _a2 ? void 0 : _a2[i]));
      return isString_default(key) && "" !== (null === (_b2 = null == key ? void 0 : key.trim) || void 0 === _b2 ? void 0 : _b2.call(key)) || isNumber_default(key) || style.visibility ? style.visibility = "visible" : style.visibility = "hidden", style;
    };
    renderContent.forEach((line2, i) => {
      var _a2;
      "key-box" === this.className ? this.children[i].setStyle(getKeyItemStyle(line2, i)) : "value-box" === this.className ? this.children[i].setStyle(((line3, i2) => {
        var _a3;
        const { height } = contentAttributes[i2], { valueColumn } = tooltipStyle;
        return mergeSpec({}, defaultValueStyle, Object.assign(Object.assign(Object.assign({
          height: getPixelPropertyStr(height)
        }, defaultLabelStyle), valueColumn.common), null === (_a3 = valueColumn.items) || void 0 === _a3 ? void 0 : _a3[i2]));
      })(0, i)) : "shape-box" === this.className && (null === (_a2 = this.children[i]) || void 0 === _a2 || _a2.setStyle(((line3, i2) => {
        var _a3, _b2, _c2, _d2;
        const { height } = contentAttributes[i2], { shapeColumn } = tooltipStyle, keyStyle = getKeyItemStyle(line3, i2), paddingTop = `calc((${null !== (_b2 = null !== (_a3 = keyStyle.lineHeight) && void 0 !== _a3 ? _a3 : keyStyle.fontSize) && void 0 !== _b2 ? _b2 : "18px"} - ${null !== (_c2 = shapeColumn.width) && void 0 !== _c2 ? _c2 : "8px"}) / 2)`;
        return mergeSpec({}, defaultShapeStyle, Object.assign(Object.assign({
          height: getPixelPropertyStr(height),
          paddingTop
        }, shapeColumn.common), null === (_d2 = shapeColumn.items) || void 0 === _d2 ? void 0 : _d2[i2]));
      })(line2, i), this._getShapeSvgOption(line2, i)));
    });
  }
  setContent() {
    var _a, _b, _c, _d;
    const renderContent = null !== (_b = null === (_a = this._option.getTooltipActual()) || void 0 === _a ? void 0 : _a.content) && void 0 !== _b ? _b : [], contentAttributes = null !== (_d = null === (_c = this._option.getTooltipAttributes()) || void 0 === _c ? void 0 : _c.content) && void 0 !== _d ? _d : [];
    renderContent.forEach((line2, i) => {
      var _a2, _b2, _c2, _d2, _e, _f, _g;
      let childContent;
      if ("key-box" === this.className) {
        const keyContent = line2.key;
        childContent = isString_default(keyContent) && "" !== (null === (_a2 = null == keyContent ? void 0 : keyContent.trim) || void 0 === _a2 ? void 0 : _a2.call(keyContent)) || isNumber_default(keyContent) ? keyContent : TOOLTIP_EMPTY_STRING, null === (_b2 = this.children[i]) || void 0 === _b2 || _b2.setContent(childContent, null === (_c2 = contentAttributes[i].key) || void 0 === _c2 ? void 0 : _c2.multiLine);
      } else if ("value-box" === this.className) {
        const valueContent = line2.value;
        childContent = isString_default(valueContent) && "" !== (null === (_d2 = null == valueContent ? void 0 : valueContent.trim) || void 0 === _d2 ? void 0 : _d2.call(valueContent)) || isNumber_default(valueContent) ? valueContent : TOOLTIP_EMPTY_STRING, null === (_e = this.children[i]) || void 0 === _e || _e.setContent(childContent, null === (_f = contentAttributes[i].value) || void 0 === _f ? void 0 : _f.multiLine);
      } else
        "shape-box" === this.className && (childContent = this._getShapeSvgOption(line2, i), null === (_g = this.children[i]) || void 0 === _g || _g.setContent(childContent));
    });
  }
  _getContentColumnStyle() {
    var _a, _b;
    const tooltipStyle = this._option.getTooltipStyle();
    switch (this.className) {
      case "shape-box":
        const renderContent = null !== (_b = null === (_a = this._option.getTooltipActual()) || void 0 === _a ? void 0 : _a.content) && void 0 !== _b ? _b : [];
        return Object.assign(Object.assign({}, tooltipStyle.shapeColumn), "shape-box" !== this.className || renderContent.some((c3) => c3.hasShape && c3.shapeType) ? {} : {
          display: "none"
        });
      case "key-box":
        return tooltipStyle.keyColumn;
      case "value-box":
        return tooltipStyle.valueColumn;
    }
  }
  _getShapeSvgOption(line2, index) {
    var _a, _b;
    const tooltipStyle = this._option.getTooltipStyle(), shapeColumn = Object.assign(Object.assign({}, tooltipStyle.shapeColumn), null === (_a = tooltipStyle.shapeColumn.items) || void 0 === _a ? void 0 : _a[index]);
    return {
      hasShape: line2.hasShape,
      symbolType: line2.shapeType,
      size: shapeColumn.width,
      fill: null !== (_b = line2.shapeFill) && void 0 !== _b ? _b : line2.shapeColor,
      stroke: line2.shapeStroke,
      lineWidth: line2.shapeLineWidth,
      hollow: line2.shapeHollow,
      index
    };
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/plugin/components/tooltip-handler/dom/model/content-model
var ContentModel = class extends BaseTooltipModel {
  init() {
    this.product || (this.product = this.createElement("div", ["container-box"])), this.shapeBox || this._initShapeBox(), this.keyBox || this._initKeyBox(), this.valueBox || this._initValueBox();
  }
  _initShapeBox() {
    const shapeBox = new ContentColumnModel(this.product, this._option, "shape-box", 0);
    shapeBox.init(), this.shapeBox = shapeBox, this.children[shapeBox.childIndex] = shapeBox;
  }
  _initKeyBox() {
    const keyBox = new ContentColumnModel(this.product, this._option, "key-box", 1);
    keyBox.init(), this.keyBox = keyBox, this.children[keyBox.childIndex] = keyBox;
  }
  _initValueBox() {
    const valueBox = new ContentColumnModel(this.product, this._option, "value-box", 2);
    valueBox.init(), this.valueBox = valueBox, this.children[valueBox.childIndex] = valueBox;
  }
  setStyle(style) {
    super.setStyle(mergeSpec(this._getContentContainerStyle(), style)), Object.values(this.children).forEach((c3) => {
      c3.setStyle();
    });
  }
  setContent() {
    Object.values(this.children).forEach((c3) => {
      c3.setContent();
    });
  }
  _getContentContainerStyle() {
    const defaultStyle = {
      whiteSpace: "nowrap",
      lineHeight: "0px"
    }, { panelDomHeight, panel: panelAttribute, maxContentHeight } = this._option.getTooltipAttributes();
    if (isValid_default(maxContentHeight) && panelDomHeight < panelAttribute.height) {
      const { shapeColumn = {}, keyColumn = {}, valueColumn = {}, panel = {} } = this._option.getTooltipStyle(), width = [shapeColumn.width, shapeColumn.marginRight, keyColumn.width, keyColumn.marginRight, valueColumn.width, valueColumn.marginRight, panel.paddingRight].reduce((sum4, cur) => sum4 + pixelPropertyStrToNumber(cur), 0);
      return Object.assign(Object.assign({}, defaultStyle), {
        width: `${width + getScrollbarWidth(this._option.getContainer())}px`,
        maxHeight: getPixelPropertyStr(maxContentHeight),
        overflow: "auto"
      });
    }
    return defaultStyle;
  }
  release() {
    super.release(), this.shapeBox = null, this.keyBox = null, this.valueBox = null;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/plugin/components/tooltip-handler/dom/model/title-model
var TitleModel = class extends BaseTooltipModel {
  init() {
    const tooltipActual = this._option.getTooltipActual();
    this.product || (this.product = this.createElement("h2"));
    const { title: title3 } = tooltipActual;
    (null == title3 ? void 0 : title3.hasShape) && (null == title3 ? void 0 : title3.shapeType) ? this.shape || this._initShape() : this.shape && this._releaseShape(), this.textSpan || this._initTextSpan();
  }
  _initShape() {
    const shape = new ShapeModel(this.product, this._option, 0);
    shape.init(), this.shape = shape, this.children[shape.childIndex] = shape;
  }
  _releaseShape() {
    this.shape && (this.shape.release(), delete this.children[this.shape.childIndex], this.shape = null);
  }
  _initTextSpan() {
    const textSpan = new TextModel(this.product, this._option, 1);
    textSpan.init(), this.textSpan = textSpan, this.children[textSpan.childIndex] = textSpan;
  }
  setStyle(style) {
    var _a, _b, _c, _d;
    const tooltipStyle = this._option.getTooltipStyle(), tooltipActual = this._option.getTooltipActual(), { title: title3 } = tooltipActual;
    super.setStyle(mergeSpec({}, defaultH2Style, tooltipStyle.title, style)), null === (_a = this.shape) || void 0 === _a || _a.setStyle({
      paddingRight: null === (_b = tooltipStyle.shapeColumn.common) || void 0 === _b ? void 0 : _b.marginRight
    }, {
      hasShape: null == title3 ? void 0 : title3.hasShape,
      symbolType: null == title3 ? void 0 : title3.shapeType,
      size: null === (_c = tooltipStyle.shapeColumn.common) || void 0 === _c ? void 0 : _c.width,
      fill: null == title3 ? void 0 : title3.shapeColor,
      hollow: null == title3 ? void 0 : title3.shapeHollow
    }), null === (_d = this.textSpan) || void 0 === _d || _d.setStyle({
      color: "inherit"
    });
  }
  setContent() {
    var _a, _b, _c, _d, _e, _f;
    const tooltipStyle = this._option.getTooltipStyle(), tooltipActual = this._option.getTooltipActual(), tooltipAttributes = this._option.getTooltipAttributes(), { title: title3 } = tooltipActual;
    this.init(), null === (_a = this.shape) || void 0 === _a || _a.setStyle(void 0, {
      hasShape: null == title3 ? void 0 : title3.hasShape,
      symbolType: null == title3 ? void 0 : title3.shapeType,
      size: null === (_b = tooltipStyle.shapeColumn.common) || void 0 === _b ? void 0 : _b.width,
      fill: null == title3 ? void 0 : title3.shapeColor,
      hollow: null == title3 ? void 0 : title3.shapeHollow
    }), null === (_c = this.textSpan) || void 0 === _c || _c.setStyle({
      color: "inherit"
    }), null === (_d = this.textSpan) || void 0 === _d || _d.setContent(null == title3 ? void 0 : title3.value, null === (_f = null === (_e = tooltipAttributes.title) || void 0 === _e ? void 0 : _e.value) || void 0 === _f ? void 0 : _f.multiLine);
  }
  release() {
    super.release(), this.shape = null, this.textSpan = null;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/plugin/components/tooltip-handler/dom/constant
var DEFAULT_TOOLTIP_Z_INDEX = "99999999999999";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/plugin/components/tooltip-handler/dom/model/tooltip-model
var TooltipModel = class extends BaseTooltipModel {
  constructor(option, classList, id2) {
    super(option.getContainer(), option, 0), this.title = null, this.content = null, this._classList = classList, this._id = id2;
  }
  setVisibility(visibility) {
    if (super.setVisibility(visibility), !this.product)
      return;
    const { classList } = this.product;
    visibility ? classList.add("visible") : classList.remove("visible");
  }
  init() {
    var _a;
    const tooltipActual = this._option.getTooltipActual();
    this.product || this._initPanel(this._classList, this._id);
    const { title: title3 } = tooltipActual;
    false !== (null == title3 ? void 0 : title3.visible) && isValid_default(null == title3 ? void 0 : title3.value) ? this.title || this._initTitle() : this.title && this._releaseTitle();
    (null !== (_a = tooltipActual.content) && void 0 !== _a ? _a : []).length > 0 ? this.content || this._initContent() : this.content && this._releaseContent();
  }
  _initPanel(classList, id2) {
    const panel = this.createElement("div", classList, {
      left: "0",
      top: "0",
      pointerEvents: "none",
      padding: "12px",
      position: "absolute",
      zIndex: DEFAULT_TOOLTIP_Z_INDEX,
      fontFamily: "sans-serif",
      fontSize: "11px",
      borderRadius: "3px",
      borderStyle: "solid",
      lineHeight: "initial",
      background: "#fff",
      boxShadow: "2px 2px 4px rgba(0, 0, 0, 0.1)",
      maxWidth: "100wh",
      maxHeight: "100vh"
    }, id2);
    this.product = panel;
  }
  _initTitle() {
    const title3 = new TitleModel(this.product, this._option, 0);
    title3.init(), this.title = title3, this.children[title3.childIndex] = title3;
  }
  _releaseTitle() {
    this.title && (this.title.release(), delete this.children[this.title.childIndex], this.title = null);
  }
  _initContent() {
    const content = new ContentModel(this.product, this._option, 1);
    content.init(), this.content = content, this.children[content.childIndex] = content;
  }
  _releaseContent() {
    this.content && (this.content.release(), delete this.children[this.content.childIndex], this.content = null);
  }
  setStyle() {
    const tooltipStyle = this._option.getTooltipStyle();
    super.setStyle(mergeSpec({}, defaultContainerStyle, tooltipStyle.panel)), Object.values(this.children).forEach((c3) => c3.setStyle());
  }
  setContent() {
    Object.values(this.children).forEach((c3) => {
      c3.setContent();
    });
  }
  release() {
    super.release(), this.title = null, this.content = null;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/plugin/components/tooltip-handler/dom/dom-tooltip-handler
var DomTooltipHandler = class _DomTooltipHandler extends BaseTooltipHandler {
  getVisibility() {
    var _a;
    return !!(null === (_a = this.model) || void 0 === _a ? void 0 : _a.getVisibility());
  }
  setVisibility(_value) {
    var _a;
    _value !== this.getVisibility() && (null === (_a = this.model) || void 0 === _a || _a.setVisibility(_value));
  }
  constructor() {
    super(_DomTooltipHandler.type), this.type = TooltipHandlerType.dom, this._tooltipContainer = null == domDocument ? void 0 : domDocument.body;
  }
  onAdd(service) {
    super.onAdd(service), this._initStyle(), this.initEl();
  }
  initEl() {
    const tooltipSpec = this._component.getSpec(), parentElement = tooltipSpec.parentElement;
    if (domDocument && parentElement) {
      for (let i = 0; i < parentElement.children.length; i++)
        if (parentElement.children[i].classList.contains(TOOLTIP_CONTAINER_EL_CLASS_NAME)) {
          this._container = parentElement.children[i];
          break;
        }
      this._container || (this._container = domDocument.createElement("div"), this._container.style.position = "relative", this._container.style.zIndex = DEFAULT_TOOLTIP_Z_INDEX, this._container.classList.add(TOOLTIP_CONTAINER_EL_CLASS_NAME), parentElement.appendChild(this._container)), this.model = new TooltipModel({
        valueToHtml: this._option.sanitize,
        getTooltipStyle: () => this._domStyle,
        getTooltipActual: () => this._tooltipActual,
        getTooltipAttributes: () => this._attributes,
        getContainer: () => this._container
      }, [tooltipSpec.className], this.name);
    }
  }
  _removeTooltip() {
    var _a;
    null === (_a = this.model) || void 0 === _a || _a.release(), this._container = null;
  }
  _updateTooltip(visible, params2) {
    var _a, _b;
    const { tooltipActual, tooltipSpec } = params2;
    if (visible && this.model) {
      if (!params2.changePositionOnly) {
        this._tooltipActual = tooltipActual, this._initStyle();
        const firstInit = !this.model.product;
        this.model.initAll(), firstInit && this._initEvent(this.model.product), this.model.setStyle(), this.model.setContent();
      }
      this.setVisibility(visible);
      const el = this.model.product;
      if (el) {
        const { x = 0, y = 0 } = null !== (_a = tooltipActual.position) && void 0 !== _a ? _a : {};
        if (tooltipSpec.updateElement) {
          this._updatePosition(null !== (_b = this._cacheCustomTooltipPosition) && void 0 !== _b ? _b : {
            x,
            y
          }), tooltipSpec.updateElement(el, tooltipActual, params2);
          const position = this._getActualTooltipPosition(tooltipActual, params2, {
            width: el.offsetWidth,
            height: el.offsetHeight
          });
          this._updatePosition(position), this._cacheCustomTooltipPosition = position;
        } else
          this._updatePosition({
            x,
            y
          });
      }
    } else
      this.setVisibility(visible), this._cacheCustomTooltipPosition = void 0;
  }
  _initStyle() {
    this._domStyle = getDomStyles(this._attributes);
  }
  _getParentElement(spec) {
    var _a;
    return null !== (_a = this._container) && void 0 !== _a ? _a : super._getParentElement(spec);
  }
  isTooltipShown() {
    return this.getVisibility();
  }
  reInit() {
    super.reInit(), this._initStyle();
  }
  _updatePosition({ x, y }) {
    const el = this.model.product;
    el && (el.style.transform = `translate3d(${x}px, ${y}px, 0)`);
  }
  _initEvent(el) {
    el.addEventListener("pointerleave", (event) => {
      const { renderMode, enterable } = this._component.getSpec(), relatedTarget = event.relatedTarget;
      "html" === renderMode && enterable && (isNil_default(relatedTarget) || relatedTarget !== this._compiler.getCanvas() && !hasParentElement(relatedTarget, this.getTooltipContainer())) && this._component.hideTooltip();
    });
  }
};
DomTooltipHandler.type = TooltipHandlerType.dom;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/plugin/components/tooltip-handler/canvas/canvas-tooltip-handler
var CanvasTooltipHandler = class _CanvasTooltipHandler extends BaseTooltipHandler {
  constructor() {
    super(_CanvasTooltipHandler.type), this.type = TooltipHandlerType.canvas;
  }
  onAdd(service) {
    var _a;
    super.onAdd(service), this._tooltipCanvasId = null === (_a = this._chartOption.modeParams) || void 0 === _a ? void 0 : _a.tooltipCanvasId;
  }
  _initTooltipComponent(stage) {
    const layer = this._getLayer(stage);
    this._tooltipComponent = new Tooltip({
      autoCalculatePosition: false,
      autoMeasure: false
    }), layer.add(this._tooltipComponent);
  }
  _getLayer(stage) {
    if (this._layer)
      return this._layer;
    this._layer = stage.createLayer(this._tooltipCanvasId);
    const layerCanvas = this._layer.layerHandler.canvas.nativeCanvas;
    return layerCanvas && layerCanvas.style && (layerCanvas.style.touchAction = "none", layerCanvas.style.pointerEvents = "none"), this._layer;
  }
  _removeTooltip() {
    this._layer && this._layer.removeAllChild(), this._attributes = null;
  }
  _updateTooltip(visible, params2) {
    this._visible = visible;
    const stage = this._compiler.getStage();
    if (!stage)
      return;
    if (!visible)
      return void (this._tooltipComponent && this._tooltipComponent.attribute.visible && (this._tooltipComponent.hideAll(), this._tooltipComponent.setAttributes({
        visibleAll: false
      })));
    this._tooltipComponent || this._initTooltipComponent(stage);
    const { tooltipActual } = params2, pos = tooltipActual.position;
    params2.changePositionOnly ? isValid_default(pos) && this._tooltipComponent.setAttributes(pos) : this._tooltipComponent.setAttributes(Object.assign(Object.assign({}, this._attributes), pos)), this._tooltipComponent.attribute.visible || (this._tooltipComponent.showAll(), this._tooltipComponent.setAttributes({
      visibleAll: true
    }));
  }
  isTooltipShown() {
    var _a;
    return null === (_a = this._tooltipComponent) || void 0 === _a ? void 0 : _a.attribute.visibleAll;
  }
  release() {
    var _a;
    super.release(), null === (_a = this._layer) || void 0 === _a || _a.release();
  }
};
CanvasTooltipHandler.type = TooltipHandlerType.canvas;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/typings/interpolate
var DEFAULT_SMOOTH_INTERPOLATE = "monotone";
var DEFAULT_LINEAR_INTERPOLATE = "linear";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/typings/line-stroke
var DEFAULT_CLOSE_STROKE_JOIN = "bevel";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/animation/utils
var AnimationStates = ["appear", "enter", "update", "exit", "disappear", "normal"];
function animationConfig(defaultConfig = {}, userConfig, params2) {
  const config2 = {};
  for (let i = 0; i < AnimationStates.length; i++) {
    const state = AnimationStates[i], userStateConfig = userConfig ? userConfig[state] : void 0;
    if (false === userStateConfig)
      continue;
    if ("normal" === state) {
      userStateConfig && (config2.normal = userStateConfig);
      continue;
    }
    if ("update" !== state && !userStateConfig && !defaultConfig[state])
      continue;
    let defaultStateConfig, stateConfig;
    (defaultStateConfig = isArray_default(defaultConfig[state]) ? defaultConfig[state] : [Object.assign(Object.assign({}, DEFAULT_ANIMATION_CONFIG[state]), defaultConfig[state])], "exit" === state && defaultStateConfig.forEach((exitConfig) => {
      exitConfig.controlOptions = {
        stopWhenStateChange: true
      };
    }), userStateConfig) ? (stateConfig = isArray_default(userStateConfig) ? userStateConfig.map((userConfig2, i2) => {
      var _a;
      let singleConfig = userConfig2;
      return isChannelAnimation(singleConfig) && delete singleConfig.type, singleConfig.oneByOne && (singleConfig = produceOneByOne(singleConfig, null !== (_a = null == params2 ? void 0 : params2.dataIndex) && void 0 !== _a ? _a : defaultDataIndex, null == params2 ? void 0 : params2.dataCount)), singleConfig;
    }) : defaultStateConfig.map((stateConfig2, i2) => {
      var _a;
      let singleConfig = mergeSpec({}, defaultStateConfig[i2], userStateConfig);
      return isChannelAnimation(singleConfig) && delete singleConfig.type, singleConfig.oneByOne && (singleConfig = produceOneByOne(singleConfig, null !== (_a = null == params2 ? void 0 : params2.dataIndex) && void 0 !== _a ? _a : defaultDataIndex, null == params2 ? void 0 : params2.dataCount)), singleConfig;
    }), config2[state] = stateConfig) : config2[state] = defaultStateConfig;
  }
  return config2.state = config2.update, config2;
}
function userAnimationConfig(markName, spec, ctx) {
  var _a, _b, _c, _d, _e;
  const userConfig = {};
  return isValid_default(spec.animationAppear) && (userConfig.appear = null !== (_a = spec.animationAppear[markName]) && void 0 !== _a ? _a : spec.animationAppear), isValid_default(spec.animationDisappear) && (userConfig.disappear = null !== (_b = spec.animationDisappear[markName]) && void 0 !== _b ? _b : spec.animationDisappear), isValid_default(spec.animationEnter) && (userConfig.enter = null !== (_c = spec.animationEnter[markName]) && void 0 !== _c ? _c : spec.animationEnter), isValid_default(spec.animationExit) && (userConfig.exit = null !== (_d = spec.animationExit[markName]) && void 0 !== _d ? _d : spec.animationExit), isValid_default(spec.animationUpdate) && (userConfig.update = null !== (_e = spec.animationUpdate[markName]) && void 0 !== _e ? _e : spec.animationUpdate), spec.animationNormal && spec.animationNormal[markName] && (userConfig.normal = spec.animationNormal[markName]), uniformAnimationConfig(userConfig, ctx);
}
function produceOneByOne(stateConfig, dataIndex, dataCount) {
  const { oneByOne, duration, delay, delayAfter } = stateConfig;
  return stateConfig.delay = (datum, element, params2) => {
    const index = dataIndex(datum, params2), durationTime = isFunction_default(duration) ? duration(datum, element, params2) : isValidNumber_default(duration) ? duration : 0, userDelay = isFunction_default(delay) ? delay(datum, element, params2) : isValidNumber_default(delay) ? delay : 0;
    let oneByOneTime = isFunction_default(oneByOne) ? oneByOne(datum, element, params2) : oneByOne;
    return false === oneByOneTime ? userDelay : (oneByOneTime = true === oneByOneTime ? 0 : oneByOneTime, userDelay + index * (durationTime + oneByOneTime));
  }, stateConfig.delayAfter = (datum, element, params2) => {
    const index = dataIndex(datum, params2), durationTime = isFunction_default(duration) ? duration(datum, element, params2) : isValidNumber_default(duration) ? duration : 0, userDelayAfter = isFunction_default(delayAfter) ? delayAfter(datum, element, params2) : isValidNumber_default(delayAfter) ? delayAfter : 0;
    let oneByOneTime = isFunction_default(oneByOne) ? oneByOne(datum, element, params2) : oneByOne;
    if (false === oneByOneTime)
      return userDelayAfter;
    return oneByOneTime = true === oneByOneTime ? 0 : oneByOneTime, userDelayAfter + ((dataCount ? dataCount() : element.mark.elements.length) - index) * (durationTime + oneByOneTime);
  }, delete stateConfig.oneByOne, stateConfig;
}
function defaultDataIndex(datum, params2) {
  var _a, _b;
  return null !== (_a = null == datum ? void 0 : datum[DEFAULT_DATA_INDEX]) && void 0 !== _a ? _a : null === (_b = null == params2 ? void 0 : params2.VGRAMMAR_ANIMATION_PARAMETERS) || void 0 === _b ? void 0 : _b.elementIndex;
}
function shouldMarkDoMorph(spec, markName) {
  var _a, _b, _c, _d, _e;
  if (false === spec.animation)
    return false;
  if (false === (null === (_a = spec.morph) || void 0 === _a ? void 0 : _a.enable))
    return false;
  const appearAnimationEnabled = false !== (null !== (_c = null === (_b = spec.animationAppear) || void 0 === _b ? void 0 : _b[markName]) && void 0 !== _c ? _c : spec.animationAppear), updateAnimationEnabled = false !== (null !== (_e = null === (_d = spec.animationUpdate) || void 0 === _d ? void 0 : _d[markName]) && void 0 !== _e ? _e : spec.animationUpdate);
  return !(!appearAnimationEnabled || !updateAnimationEnabled);
}
function isTimeLineAnimation(animationConfig2) {
  return isValid_default(animationConfig2.timeSlices);
}
function isChannelAnimation(animationConfig2) {
  return !isTimeLineAnimation(animationConfig2) && isValid_default(animationConfig2.channel);
}
function uniformAnimationConfig(config2, ctx) {
  return config2 ? (traverseSpec(config2 = cloneDeep(config2), (node) => {
    var _a;
    if (isFunction_default(node) && (null === (_a = node.prototype) || void 0 === _a ? void 0 : _a.constructor) !== node) {
      return (...args) => node(...args, ctx);
    }
    return node;
  }), config2) : config2;
}
function traverseSpec(spec, transform5) {
  if (isArray_default(spec))
    spec.forEach((i, index) => {
      spec[index] = transform5(spec[index], index), traverseSpec(spec[index], transform5);
    });
  else if (isObject_default(spec))
    for (const key in spec)
      spec[key] = transform5(spec[key], key), traverseSpec(spec[key], transform5);
}
function isAnimationEnabledForSeries(series2) {
  var _a, _b, _c, _d;
  const seriesSpec = series2.getSpec();
  if (false === seriesSpec.animation)
    return false;
  if (!isValid_default(series2.getRegion().animate))
    return false;
  let animationThreshold = null !== (_a = seriesSpec.animationThreshold) && void 0 !== _a ? _a : Number.MAX_SAFE_INTEGER;
  return null === (_b = series2.getMarks()) || void 0 === _b || _b.forEach((m4) => {
    const config2 = m4.getProgressiveConfig();
    config2 && (config2.large && config2.largeThreshold && (animationThreshold = Math.min(animationThreshold, config2.largeThreshold)), config2.progressiveThreshold && (animationThreshold = Math.min(animationThreshold, config2.progressiveThreshold)));
  }), !((null === (_d = null === (_c = series2.getRawData()) || void 0 === _c ? void 0 : _c.latestData) || void 0 === _d ? void 0 : _d.length) >= animationThreshold);
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/mixin/line-mixin
var LineLikeSeriesMixin = class {
  addSamplingCompile() {
    if (this._spec.sampling) {
      const { width, height } = this._region.getLayoutRect(), samplingTrans = [], fieldsY = this._fieldY, fieldsX = this._fieldX;
      samplingTrans.push({
        type: "sampling",
        size: "horizontal" === this._direction ? height : width,
        factor: this._spec.samplingFactor,
        yfield: "horizontal" === this._direction ? fieldsX[0] : fieldsY[0],
        groupBy: this._seriesField,
        mode: this._spec.sampling
      }), this._data.getProduct().transform(samplingTrans);
    }
  }
  addOverlapCompile() {
    var _a;
    if (this._spec.markOverlap) {
      const overlapTrans = [];
      overlapTrans.push({
        type: "markoverlap",
        direction: "horizontal" === this._direction && "cartesian" === this.coordinate ? 2 : 1,
        delta: this._spec.pointDis,
        deltaMul: this._spec.pointDisMul,
        groupBy: this._seriesField
      }), null === (_a = this._symbolMark) || void 0 === _a || _a.getProduct().transform(overlapTrans);
    }
  }
  reCompileSampling() {
    this._spec.sampling && this.compile();
  }
  initLineMark(progressive, isSeriesMark) {
    var _a, _b;
    return this._lineMark = this._createMark(lineLikeSeriesMark.line, {
      defaultMorphElementKey: this.getDimensionField()[0],
      groupKey: this._seriesField,
      isSeriesMark: null == isSeriesMark || isSeriesMark,
      progressive,
      customShape: null === (_a = this._spec.line) || void 0 === _a ? void 0 : _a.customShape,
      stateSort: null === (_b = this._spec.line) || void 0 === _b ? void 0 : _b.stateSort
    }), this._lineMark;
  }
  initLineMarkStyle(direction2, areaCurveType) {
    var _a, _b;
    const lineMark = this._lineMark;
    if (lineMark) {
      if (this.setMarkStyle(lineMark, {
        stroke: this.getColorAttribute()
      }, "normal", AttributeLevel.Series), "zero" !== this._invalidType && this.setMarkStyle(lineMark, {
        defined: this._getInvalidDefined.bind(this),
        connectedType: this._getInvalidConnectType()
      }, "normal", AttributeLevel.Series), this.event.on(ChartEvent.viewDataStatisticsUpdate, {
        filter: (param) => param.model === this
      }, () => {
        this.encodeDefined(lineMark, "defined");
      }), "polar" === this.coordinate)
        this.setMarkStyle(lineMark, {
          lineJoin: DEFAULT_CLOSE_STROKE_JOIN,
          curveType: DEFAULT_LINEAR_INTERPOLATE,
          closePath: true
        }, "normal", AttributeLevel.Series);
      else {
        const userCurveType = null != areaCurveType ? areaCurveType : null === (_b = null === (_a = this.getSpec().line) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.curveType, curveType = userCurveType === DEFAULT_SMOOTH_INTERPOLATE ? "horizontal" === direction2 ? "monotoneY" : "monotoneX" : userCurveType;
        this.setMarkStyle(lineMark, {
          curveType
        }, "normal", AttributeLevel.Built_In);
      }
      this.setMarkStyle(lineMark, {
        x: this.dataToPositionX.bind(this),
        y: this.dataToPositionY.bind(this),
        z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
      }, "normal", AttributeLevel.Series);
    }
    return lineMark;
  }
  _getEventElement(params2, reverse = false) {
    let data = [];
    return params2.dimensionInfo.some((df) => (df.data.some((dd) => dd.series === this && (data = dd.datum, true)), !data.length)), data;
  }
  _dimensionTrigger(params2) {
    const elements = this._getEventElement(params2);
    switch (params2.action) {
      case "enter":
        this._symbolActiveMark.getDataView().parse(elements), this._symbolActiveMark.getData().updateData(false);
        break;
      case "leave":
        this._symbolActiveMark.getDataView().parse([]), this._symbolActiveMark.getData().updateData(false);
    }
  }
  initSymbolMark(progressive, isSeriesMark) {
    const pointSpec = this._spec.point || {};
    if (false !== pointSpec.visible && (this._symbolMark = this._createMark(lineLikeSeriesMark.point, {
      morph: shouldMarkDoMorph(this._spec, lineLikeSeriesMark.point.name),
      defaultMorphElementKey: this.getDimensionField()[0],
      groupKey: this._seriesField,
      progressive,
      isSeriesMark: !!isSeriesMark,
      customShape: pointSpec.customShape,
      stateSort: pointSpec.stateSort
    })), true === this._spec.activePoint) {
      const activeData = new DataView(this._option.dataSet, {
        name: `${PREFIX}_series_${this.id}_active_point`
      });
      activeData.parse([]), this._symbolActiveMark = this._createMark({
        name: `active_point_${this.id}`,
        type: "symbol"
      }, {
        morph: false,
        groupKey: this._seriesField,
        isSeriesMark: false,
        dataView: activeData,
        parent: this._region.getInteractionMark(),
        customShape: pointSpec.customShape,
        stateSort: pointSpec.stateSort
      }), this._symbolActiveMark.setVisible(false);
    }
    return this._symbolMark;
  }
  initSymbolMarkStyle() {
    const symbolMark = this._symbolMark;
    if (!symbolMark)
      return this._initSymbolActiveMarkAlone(), symbolMark;
    if (this._initSymbolMark(symbolMark), this._symbolActiveMark && this._symbolMark.stateStyle.dimension_hover) {
      this._symbolActiveMark.setVisible(true), this.event.on(DimensionEventEnum.dimensionHover, this._dimensionTrigger.bind(this));
      for (const state in this._symbolMark.stateStyle) {
        this._symbolActiveMark.stateStyle[state] = {};
        for (const key in this._symbolMark.stateStyle[state])
          this._symbolActiveMark.stateStyle[state][key] = {
            style: null,
            level: AttributeLevel.Series,
            referer: symbolMark
          };
      }
      this._symbolActiveMark.state.changeStateInfo({
        stateValue: STATE_VALUE_ENUM.STATE_DIMENSION_HOVER,
        filter: () => true
      });
    }
    return symbolMark;
  }
  _initSymbolMark(symbolMark) {
    symbolMark && (this.setMarkStyle(symbolMark, {
      fill: this.getColorAttribute()
    }, "normal", AttributeLevel.Series), "zero" !== this._invalidType && this.setMarkStyle(symbolMark, {
      visible: this._getInvalidDefined.bind(this)
    }, "normal", AttributeLevel.Series), this.event.on(ChartEvent.viewDataStatisticsUpdate, {
      filter: (param) => param.model === this
    }, () => {
      this.encodeDefined(symbolMark, "visible");
    }), this.setMarkStyle(symbolMark, {
      x: this.dataToPositionX.bind(this),
      y: this.dataToPositionY.bind(this),
      z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
    }, "normal", AttributeLevel.Series));
  }
  _initSymbolActiveMarkAlone() {
    var _a, _b;
    const symbolMark = this._symbolActiveMark;
    symbolMark && (this._initSymbolMark(symbolMark), symbolMark && (null === (_b = null === (_a = this._spec[lineLikeSeriesMark.point.name]) || void 0 === _a ? void 0 : _a.state) || void 0 === _b ? void 0 : _b.dimension_hover) && (symbolMark.setVisible(true), this.event.on(DimensionEventEnum.dimensionHover, this._dimensionTrigger.bind(this)), this.initMarkStyleWithSpec(symbolMark, mergeSpec({}, this._spec[lineLikeSeriesMark.point.name], {
      visible: true
    })), this._symbolActiveMark.state.changeStateInfo({
      stateValue: STATE_VALUE_ENUM.STATE_DIMENSION_HOVER,
      filter: () => true
    })));
  }
  initLabelMarkStyle(labelMark) {
    var _a;
    labelMark && ("symbol" !== (null === (_a = labelMark.getTarget()) || void 0 === _a ? void 0 : _a.type) && labelMark.setRule("line-data"), this.setMarkStyle(labelMark, {
      fill: this.getColorAttribute(),
      text: (datum) => datum[this.getStackValueField()],
      z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
    }), "zero" !== this._invalidType && this.setMarkStyle(labelMark, {
      visible: this._getInvalidDefined.bind(this)
    }, "normal", AttributeLevel.Series), this.event.on(ChartEvent.viewDataStatisticsUpdate, {
      filter: (param) => param.model === this
    }, () => {
      this.encodeDefined(labelMark, "visible");
    }));
  }
  initLineLabelMarkStyle(labelMark) {
    labelMark && this.setMarkStyle(labelMark, {
      fill: this.getColorAttribute(),
      text: (datum) => datum[this.getSeriesField()],
      z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
    });
  }
  encodeDefined(mark, attr) {
    var _a, _b, _c, _d;
    if (!mark)
      return;
    const allValid = this._isFieldAllValid();
    if ("zero" === this._invalidType || allValid) {
      if (true === (null === (_b = null === (_a = mark.stateStyle.normal) || void 0 === _a ? void 0 : _a[attr]) || void 0 === _b ? void 0 : _b.style))
        return;
      this.setMarkStyle(mark, {
        [attr]: true
      }, "normal", AttributeLevel.Series);
    } else {
      if (true !== (null === (_d = null === (_c = mark.stateStyle.normal) || void 0 === _c ? void 0 : _c[attr]) || void 0 === _d ? void 0 : _d.style))
        return;
      this.setMarkStyle(mark, {
        [attr]: this._getInvalidDefined.bind(this)
      }, "normal", AttributeLevel.Series);
    }
    mark.getProduct() && mark.compileEncode();
  }
  _isFieldAllValid() {
    const viewStatistics = this.getViewDataStatistics(), field3 = this.getStackValueField();
    return !!(viewStatistics && viewStatistics.latestData && field3) && (viewStatistics.latestData[field3] && viewStatistics.latestData[field3].allValid);
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/constant/index
var DEFAULT_MEASURE_CANVAS_ID2 = `${PREFIX}_MEASURE_CANVAS_ID`;
var DEFAULT_DATA_INDEX2 = `${PREFIX}_DEFAULT_DATA_INDEX`;
var DEFAULT_DATA_KEY2 = `${PREFIX}_DEFAULT_DATA_KEY`;
var DEFAULT_DATA_SERIES_FIELD2 = `${PREFIX}_DEFAULT_DATA_SERIES_FIELD`;
var DEFAULT_SERIES_STYLE_NAME2 = `${PREFIX}_DEFAULT_SERIES_STYLE_NAME`;
var AttributeLevel2;
!function(AttributeLevel3) {
  AttributeLevel3[AttributeLevel3.Default = 0] = "Default", AttributeLevel3[AttributeLevel3.Theme = 1] = "Theme", AttributeLevel3[AttributeLevel3.Chart = 2] = "Chart", AttributeLevel3[AttributeLevel3.Base_Series = 3] = "Base_Series", AttributeLevel3[AttributeLevel3.Series = 4] = "Series", AttributeLevel3[AttributeLevel3.Mark = 5] = "Mark", AttributeLevel3[AttributeLevel3.User_Chart = 6] = "User_Chart", AttributeLevel3[AttributeLevel3.User_Series = 7] = "User_Series", AttributeLevel3[AttributeLevel3.User_Mark = 8] = "User_Mark", AttributeLevel3[AttributeLevel3.Built_In = 99] = "Built_In";
}(AttributeLevel2 || (AttributeLevel2 = {}));
var STACK_FIELD_KEY2 = `${PREFIX}_STACK_KEY`;
var STACK_FIELD_START2 = `${PREFIX}_STACK_START`;
var STACK_FIELD_END2 = `${PREFIX}_STACK_END`;
var STACK_FIELD_START_PERCENT2 = `${PREFIX}_STACK_START_PERCENT`;
var STACK_FIELD_END_PERCENT2 = `${PREFIX}_STACK_END_PERCENT`;
var STACK_FIELD_START_OffsetSilhouette2 = `${PREFIX}_STACK_START_OffsetSilhouette`;
var STACK_FIELD_END_OffsetSilhouette2 = `${PREFIX}_STACK_END_OffsetSilhouette`;
var STACK_FIELD_TOTAL2 = `${PREFIX}_STACK_TOTAL`;
var STACK_FIELD_TOTAL_PERCENT2 = `${PREFIX}_STACK_TOTAL_PERCENT`;
var STACK_FIELD_TOTAL_TOP2 = `${PREFIX}_STACK_TOTAL_TOP`;
var SEGMENT_FIELD_START2 = `${PREFIX}_SEGMENT_START`;
var SEGMENT_FIELD_END2 = `${PREFIX}_SEGMENT_END`;
var LayoutZIndex2;
!function(LayoutZIndex3) {
  LayoutZIndex3[LayoutZIndex3.Axis_Grid = 50] = "Axis_Grid", LayoutZIndex3[LayoutZIndex3.CrossHair_Grid = 100] = "CrossHair_Grid", LayoutZIndex3[LayoutZIndex3.Region = 450] = "Region", LayoutZIndex3[LayoutZIndex3.Mark = 300] = "Mark", LayoutZIndex3[LayoutZIndex3.Node = 400] = "Node", LayoutZIndex3[LayoutZIndex3.Axis = 100] = "Axis", LayoutZIndex3[LayoutZIndex3.MarkLine = 500] = "MarkLine", LayoutZIndex3[LayoutZIndex3.MarkArea = 100] = "MarkArea", LayoutZIndex3[LayoutZIndex3.MarkPoint = 500] = "MarkPoint", LayoutZIndex3[LayoutZIndex3.DataZoom = 500] = "DataZoom", LayoutZIndex3[LayoutZIndex3.ScrollBar = 500] = "ScrollBar", LayoutZIndex3[LayoutZIndex3.Player = 500] = "Player", LayoutZIndex3[LayoutZIndex3.Legend = 500] = "Legend", LayoutZIndex3[LayoutZIndex3.CrossHair = 500] = "CrossHair", LayoutZIndex3[LayoutZIndex3.Indicator = 500] = "Indicator", LayoutZIndex3[LayoutZIndex3.Title = 500] = "Title", LayoutZIndex3[LayoutZIndex3.Label = 500] = "Label", LayoutZIndex3[LayoutZIndex3.Brush = 500] = "Brush", LayoutZIndex3[LayoutZIndex3.CustomMark = 500] = "CustomMark", LayoutZIndex3[LayoutZIndex3.Interaction = 700] = "Interaction";
}(LayoutZIndex2 || (LayoutZIndex2 = {}));
var LayoutLevel2;
!function(LayoutLevel3) {
  LayoutLevel3[LayoutLevel3.Indicator = 10] = "Indicator", LayoutLevel3[LayoutLevel3.Region = 20] = "Region", LayoutLevel3[LayoutLevel3.Axis = 30] = "Axis", LayoutLevel3[LayoutLevel3.DataZoom = 40] = "DataZoom", LayoutLevel3[LayoutLevel3.Player = 40] = "Player", LayoutLevel3[LayoutLevel3.ScrollBar = 40] = "ScrollBar", LayoutLevel3[LayoutLevel3.Legend = 50] = "Legend", LayoutLevel3[LayoutLevel3.Title = 70] = "Title", LayoutLevel3[LayoutLevel3.CustomMark = 70] = "CustomMark";
}(LayoutLevel2 || (LayoutLevel2 = {}));
var DEFAULT_CONICAL_GRADIENT_CONFIG2 = {
  x: 0.5,
  y: 0.5,
  startAngle: 0,
  endAngle: 2 * Math.PI
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/data/transforms/add-property
var addVChartProperty = (data, op) => {
  const context = op.beforeCall();
  return data.forEach((d, i) => op.call(d, i, context)), context.keyMap && (context.keyMap.clear(), context.keyMap = null), data;
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/data/transforms/dimension-statistics
var methods3 = {
  min: (arr) => arr.length ? minInArray(arr.map((n) => 1 * n)) : 0,
  max: (arr) => arr.length ? maxInArray(arr.map((n) => 1 * n)) : 0,
  "array-min": (arr) => arr.length ? minInArray(arr.map((n) => 1 * n)) : 0,
  "array-max": (arr) => arr.length ? maxInArray(arr.map((n) => 1 * n)) : 0,
  values: (arr) => {
    const map4 = {}, res = [];
    for (const entry of arr)
      map4[entry] || (res.push(entry), map4[entry] = 1);
    return res;
  }
};
var dimensionStatistics = (data, op) => {
  var _a, _b;
  let fields2 = op.fields;
  if (isFunction_default(fields2) && (fields2 = fields2()), !(null == fields2 ? void 0 : fields2.length) || !(null == data ? void 0 : data.length))
    return {};
  fields2 = mergeFields([], fields2);
  const dataKey = "parser" === op.target ? "parserData" : "latestData", latestData = data[0][dataKey] ? data[0][dataKey] : data || [], dataFields = null === (_b = (_a = data[0]).getFields) || void 0 === _b ? void 0 : _b.call(_a);
  return dimensionStatisticsOfSimpleData(latestData, fields2, dataFields);
};
var dimensionStatisticsOfSimpleData = (latestData, fields2, dataFields) => {
  const result2 = {};
  let fValues = [], nextFValues = [];
  return fields2.forEach((f) => {
    const key = f.key;
    result2[key] = {};
    const dataFieldInKey = null == dataFields ? void 0 : dataFields[key], operations = f.operations, isNumberField = operations.some((op) => "min" === op || "max" === op || "allValid" === op);
    let allValid = true;
    fValues.length = 0, latestData.forEach((d) => {
      d && fValues.push(d[key]);
    });
    const len = fValues.length;
    if (isNumberField) {
      nextFValues.length = 0, fValues.forEach((item, i) => {
        couldBeValidNumber(item) && nextFValues.push(item);
      });
      const t = fValues;
      fValues = nextFValues, nextFValues = t, allValid = fValues.length === len;
    } else
      fValues = operations.some((op) => "array-min" === op || "array-max" === op) ? fValues.reduce((res, entry) => (entry && entry.forEach((d) => {
        couldBeValidNumber(d) && res.push(d);
      }), res), []) : fValues.filter((entry) => void 0 !== entry);
    f.filter && (fValues = fValues.filter(f.filter)), operations.forEach((op) => {
      if (f.customize)
        result2[key][op] = f.customize;
      else {
        if (dataFieldInKey && dataFieldInKey.lockStatisticsByDomain && !isNil_default(dataFieldInKey.domain)) {
          if ("values" === op)
            return void (result2[key][op] = dataFieldInKey.domain.slice());
        } else if ("allValid" === op)
          return;
        result2[key][op] = methods3[op](fValues), "array-max" === op && (result2[key].max = result2[key][op]), "array-min" === op && (result2[key].min = result2[key][op]);
      }
    }), isNumberField && (result2[key].allValid = allValid);
  }), result2;
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/data/transforms/invalid-travel
var invalidTravel = (data, op) => {
  const { config: config2 } = op;
  if (!config2)
    return data;
  const { invalidType, checkField } = config2();
  return "zero" !== invalidType || checkField && checkField.length && data.forEach((datum) => {
    checkField.forEach((field3) => {
      couldBeValidNumber(datum[field3]) || (datum[field3] = 0);
    });
  }), data;
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/base/series-data
var SeriesData = class extends CompilableData {
  _compileProduct() {
    var _a;
    const data = null === (_a = this._data) || void 0 === _a ? void 0 : _a.latestData;
    isNil_default(data) || isValid_default(this.getProduct()) || this._initProduct([]);
  }
  generateProductId() {
    var _a;
    return null === (_a = this._data) || void 0 === _a ? void 0 : _a.name;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/constant/hierarchy
var DEFAULT_HIERARCHY_DEPTH = `${PREFIX}_HIERARCHY_DEPTH`;
var DEFAULT_HIERARCHY_ROOT = `${PREFIX}_HIERARCHY_ROOT`;
var DEFAULT_HIERARCHY_ROOT_INDEX = `${PREFIX}_HIERARCHY_ROOT_INDEX`;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/data/transforms/data-key
function initKeyMap() {
  return {
    keyMap: /* @__PURE__ */ new Map(),
    needDefaultSeriesField: !this._seriesField,
    defaultSeriesField: this._seriesField ? null : this.getSeriesKeys()[0],
    getKey: this.generateDefaultDataKey(this._spec.dataKey)
  };
}
function addDataKey(d, i, context) {
  d && (context.needDefaultSeriesField && (d[DEFAULT_DATA_SERIES_FIELD] = context.defaultSeriesField), d[DEFAULT_DATA_INDEX] = i, d[DEFAULT_DATA_KEY] = context.getKey(d, i, context));
}
function initHierarchyKeyMap() {
  return {
    keyMap: /* @__PURE__ */ new Map(),
    needDefaultSeriesField: true,
    defaultSeriesField: this.getSeriesKeys()[0],
    getKey: this.generateDefaultDataKey(this._spec.dataKey),
    categoryField: this.getCategoryField()
  };
}
function addHierarchyDataKey(d, i, context, depth = 0, root, rootIndex) {
  void 0 === rootIndex && (rootIndex = i), addDataKey(d, i, context), d[DEFAULT_HIERARCHY_DEPTH] = depth, d[DEFAULT_HIERARCHY_ROOT] = root || d[context.categoryField], d[DEFAULT_HIERARCHY_ROOT_INDEX] = rootIndex, d.children && d.children.length && d.children.forEach((_d, _i) => addHierarchyDataKey(_d, _i, context, d[DEFAULT_HIERARCHY_DEPTH] + 1, d[DEFAULT_HIERARCHY_ROOT], rootIndex));
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/base/base-series-transformer
var BaseSeriesSpecTransformer = class extends BaseModelSpecTransformer {
  constructor() {
    super(...arguments), this.markLabelSpec = {};
  }
  getLabelSpec(markName) {
    return this.markLabelSpec[markName];
  }
  setLabelSpec(markName, label) {
    this.markLabelSpec[markName] = array(label);
  }
  addLabelSpec(markName, label, head = false) {
    this.markLabelSpec[markName] || (this.markLabelSpec[markName] = []), head ? this.markLabelSpec[markName].unshift(label) : this.markLabelSpec[markName].push(label);
  }
  getTheme(spec, chartSpec) {
    var _a, _b, _c;
    const direction2 = getDirectionFromSeriesSpec(spec), chartTheme = null === (_a = this._option) || void 0 === _a ? void 0 : _a.getTheme(), { markByName: markByName2, mark } = chartTheme, type = this._option.type, theme2 = transformSeriesThemeToMerge(get_default(chartTheme, `series.${type}`), type, mark, markByName2), themeWithDirection = get_default(chartTheme, `series.${type}_${direction2}`), themeWithStack = (null !== (_c = null !== (_b = this.stack) && void 0 !== _b ? _b : null == themeWithDirection ? void 0 : themeWithDirection.stack) && void 0 !== _c ? _c : null == theme2 ? void 0 : theme2.stack) ? get_default(chartTheme, `series.${type}_stack`) : void 0;
    return mergeSpec({}, theme2, themeWithDirection, themeWithStack);
  }
  transformSpec(spec, chartSpec, chartSpecInfo) {
    this._transformStack(spec);
    const result2 = super.transformSpec(spec, chartSpec, chartSpecInfo);
    return this._transformLabelSpec(result2.spec), Object.assign(Object.assign({}, result2), {
      markLabelSpec: this.markLabelSpec,
      stack: this.stack
    });
  }
  _transformLabelSpec(spec) {
  }
  _transformStack(spec) {
    isBoolean_default(spec.stack) && (this.stack = spec.stack), isBoolean_default(spec.percent) && (this.stack = spec.percent || this.stack), isBoolean_default(spec.stackOffsetSilhouette) && (this.stack = spec.stackOffsetSilhouette || this.stack), isValid_default(spec.stackValue) && (this.stack = true), isNil_default(this.stack) && this._supportStack && spec.seriesField && (this.stack = true);
  }
  _addMarkLabelSpec(spec, markName, labelSpecKey = "label", styleHandlerName = "initLabelMarkStyle", hasAnimation, head) {
    if (!spec)
      return;
    array(spec[labelSpecKey]).forEach((labelSpec) => {
      labelSpec && labelSpec.visible && this.addLabelSpec(markName, Object.assign(Object.assign({
        animation: null != hasAnimation ? hasAnimation : spec.animation
      }, labelSpec), {
        getStyleHandler: (series2) => {
          var _a;
          return null === (_a = series2[styleHandlerName]) || void 0 === _a ? void 0 : _a.bind(series2);
        }
      }), head);
    });
  }
  _getDefaultSpecFromChart(chartSpec) {
    var _a;
    const spec = null !== (_a = super._getDefaultSpecFromChart(chartSpec)) && void 0 !== _a ? _a : {}, { outerRadius, innerRadius, direction: direction2 } = chartSpec;
    return isValid_default(outerRadius) && (spec.outerRadius = outerRadius), isValid_default(innerRadius) && (spec.innerRadius = innerRadius), isValid_default(direction2) && (spec.direction = direction2), Object.keys(spec).length > 0 ? spec : void 0;
  }
  _mergeThemeToSpec(spec, chartSpec) {
    const theme2 = this._theme;
    if (this._shouldMergeThemeToSpec()) {
      const specFromChart = this._getDefaultSpecFromChart(chartSpec), merge3 = (originalSpec) => {
        const result2 = mergeSpec({}, theme2, specFromChart, originalSpec), labelTheme = theme2.label;
        return labelTheme && isObject_default(labelTheme) && isArray_default(result2.label) && (result2.label = result2.label.map((label) => mergeSpec({}, labelTheme, label))), result2;
      };
      return isArray_default(spec) ? {
        spec: spec.map((specItem) => merge3(specItem)),
        theme: theme2
      } : {
        spec: merge3(spec),
        theme: theme2
      };
    }
    return {
      spec,
      theme: theme2
    };
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/interaction/config
function getDefaultInteractionConfigByMode(mode) {
  return mode === RenderModeEnum["desktop-browser"] || mode === RenderModeEnum["desktop-miniApp"] ? {
    hover: {
      enable: true,
      trigger: "pointermove",
      triggerOff: "view:pointerleave"
    },
    select: {
      enable: true,
      trigger: "pointertap"
    }
  } : isMobileLikeMode(mode) || isMiniAppLikeMode(mode) ? {
    hover: {
      enable: true,
      trigger: ["pointerdown", "pointermove"],
      triggerOff: "view:pointerleave"
    },
    select: {
      enable: true,
      trigger: "tap"
    }
  } : null;
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/base/base-series
var BaseSeries = class extends BaseModel {
  getRegion() {
    return this._region;
  }
  getLayoutStartPoint() {
    return this._region.getLayoutStartPoint();
  }
  getRootMark() {
    return this._rootMark;
  }
  getSeriesMark() {
    return this._seriesMark;
  }
  getRawData() {
    return this._rawData;
  }
  getViewDataFilter() {
    return this._viewDataFilter;
  }
  getViewData() {
    var _a;
    return null === (_a = this._data) || void 0 === _a ? void 0 : _a.getDataView();
  }
  getViewDataProductId() {
    var _a;
    return null === (_a = this._data) || void 0 === _a ? void 0 : _a.getProductId();
  }
  getViewDataStatistics() {
    return this._viewDataStatistics;
  }
  getViewStackData() {
    return this._viewStackData;
  }
  getSeriesField() {
    return this._seriesField;
  }
  setSeriesField(field3) {
    isValid_default(field3) && (this._seriesField = field3, this.getMarks().filter((m4) => m4.getDataView() === this.getViewData()).forEach((m4) => {
      m4.setFacet(this._seriesField);
    }));
  }
  getGroups() {
    return this._groups;
  }
  getStack() {
    var _a;
    return null === (_a = this.getSpecInfo()) || void 0 === _a ? void 0 : _a.stack;
  }
  getStackValue() {
    var _a;
    return null !== (_a = this._spec.stackValue) && void 0 !== _a ? _a : `${PREFIX}_series_${this.type}`;
  }
  getPercent() {
    return this._spec.percent;
  }
  getStackOffsetSilhouette() {
    return this._spec.stackOffsetSilhouette;
  }
  get tooltipHelper() {
    return this._tooltipHelper || this.initTooltip(), this._tooltipHelper;
  }
  getInvalidType() {
    return this._invalidType;
  }
  setInvalidType(t) {
    var _a;
    this._invalidType = t, null === (_a = this.getViewData()) || void 0 === _a || _a.reRunAllTransform();
  }
  getMarkAttributeContext() {
    return this._markAttributeContext;
  }
  constructor(spec, options) {
    var _a;
    super(spec, options), this.specKey = "series", this.type = "series", this.layoutType = "absolute", this.modelType = "series", this.name = void 0, this.transformerConstructor = BaseSeriesSpecTransformer, this.coordinate = "none", this._region = null, this._layoutStartPoint = {
      x: 0,
      y: 0
    }, this._layoutRect = {
      width: null,
      height: null
    }, this.getLayoutRect = () => {
      var _a2, _b;
      return {
        width: null !== (_a2 = this._layoutRect.width) && void 0 !== _a2 ? _a2 : this._region.getLayoutRect().width,
        height: null !== (_b = this._layoutRect.height) && void 0 !== _b ? _b : this._region.getLayoutRect().height
      };
    }, this._rootMark = null, this._seriesMark = null, this._viewDataMap = /* @__PURE__ */ new Map(), this._viewDataFilter = null, this._data = null, this.layoutZIndex = 0, this._invalidType = "break", this._region = options.region, this._dataSet = options.dataSet, (null === (_a = this._spec) || void 0 === _a ? void 0 : _a.name) && (this.name = this._spec.name);
  }
  created() {
    super.created(), this._buildMarkAttributeContext(), this.initData(), this.initGroups(), this.initStatisticalData(), this.event.emit(ChartEvent.afterInitData, {
      model: this
    }), this.initRootMark(), this.initMark();
    const hasAnimation = isAnimationEnabledForSeries(this);
    this._initExtensionMark({
      hasAnimation
    }), this.initMarkStyle(), this.initMarkState(), hasAnimation && this.initAnimation(), this._option.disableTriggerEvent || this.initInteraction(), this.afterInitMark(), this.initEvent(), this.event.emit(ChartEvent.afterInitEvent, {
      model: this
    });
  }
  _buildMarkAttributeContext() {
    this._markAttributeContext = {
      vchart: this._option.globalInstance,
      globalScale: (key, value) => {
        var _a;
        return null === (_a = this._option.globalScale.getScale(key)) || void 0 === _a ? void 0 : _a.scale(value);
      },
      seriesColor: (seriesValue) => {
        var _a;
        return isNil_default(seriesValue) && (seriesValue = this.getSeriesKeys()[0]), null === (_a = this._option.globalScale.getScale("color")) || void 0 === _a ? void 0 : _a.scale(seriesValue);
      },
      getRegion: () => this._region
    };
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this.setSeriesField(this._spec.seriesField), isValid_default(this._spec.invalidType) && (this._invalidType = this._spec.invalidType);
  }
  getInvalidCheckFields() {
    return [this.getStackValueField()];
  }
  initInvalidDataTransform() {
    var _a, _b;
    "zero" === this._invalidType && (null === (_a = this._rawData) || void 0 === _a ? void 0 : _a.dataSet) && (registerDataSetInstanceTransform(this._rawData.dataSet, "invalidTravel", invalidTravel), null === (_b = this._rawData) || void 0 === _b || _b.transform({
      type: "invalidTravel",
      options: {
        config: () => ({
          invalidType: this._invalidType,
          checkField: this.getInvalidCheckFields()
        })
      }
    }, false));
  }
  initData() {
    var _a, _b, _c, _d;
    const d = null !== (_a = this._spec.data) && void 0 !== _a ? _a : this._option.getSeriesData(this._spec.dataId, this._spec.dataIndex);
    if (d && (this._rawData = dataToDataView(d, this._dataSet, this._option.sourceDataList, {
      onError: null === (_b = this._option) || void 0 === _b ? void 0 : _b.onError
    })), null === (_d = null === (_c = this._rawData) || void 0 === _c ? void 0 : _c.target) || void 0 === _d || _d.addListener("change", this.rawDataUpdate.bind(this)), this._addDataIndexAndKey(), this._rawData) {
      this.getStack() && (this._viewDataFilter = dataViewFromDataView(this._rawData, this._dataSet, {
        name: `${this.type}_${this.id}_viewDataFilter`
      }));
      const viewData = dataViewFromDataView(this.getStack() ? this._viewDataFilter : this._rawData, this._dataSet, {
        name: `${this.type}_${this.id}_viewData`
      });
      this._data = new SeriesData(this._option, viewData), this.getStack() && this._viewDataFilter.target.removeListener("change", viewData.reRunAllTransform);
    }
    this.initInvalidDataTransform();
  }
  initGroups() {
    const groupFields = this.getGroupFields();
    groupFields && groupFields.length && (this._groups = {
      fields: groupFields
    });
  }
  initStatisticalData() {
    this._data && this._statisticViewData();
  }
  getRawDataStatisticsByField(field3, isNumeric2) {
    var _a, _b;
    if (this._rawStatisticsCache || (this._rawStatisticsCache = {}), !this._rawStatisticsCache[field3]) {
      if (this._viewDataStatistics && (!this._viewDataFilter || this._viewDataFilter.transformsArr.length <= 1) && this.getViewData().transformsArr.length <= 1 && (null === (_a = this._viewDataStatistics.latestData) || void 0 === _a ? void 0 : _a[field3]))
        this._rawStatisticsCache[field3] = this._viewDataStatistics.latestData[field3];
      else if (this._rawData) {
        const fieldInfo = null === (_b = this._rawData.getFields()) || void 0 === _b ? void 0 : _b[field3];
        fieldInfo && fieldInfo.lockStatisticsByDomain && fieldInfo.domain ? (this._rawStatisticsCache[field3] = {}, isNumeric2 ? (this._rawStatisticsCache[field3].min = minInArray(fieldInfo.domain), this._rawStatisticsCache[field3].max = maxInArray(fieldInfo.domain)) : this._rawStatisticsCache[field3].values = fieldInfo.domain) : this._rawStatisticsCache[field3] = dimensionStatisticsOfSimpleData(this._rawData.latestData, [{
          key: field3,
          operations: isNumeric2 ? ["min", "max"] : ["values"]
        }])[field3];
      }
    }
    return isNumeric2 && (isNil_default(this._rawStatisticsCache[field3].min) || isNil_default(this._rawStatisticsCache[field3].max)) && (this._rawStatisticsCache[field3].min = minInArray(this._rawStatisticsCache[field3].values), this._rawStatisticsCache[field3].max = maxInArray(this._rawStatisticsCache[field3].values)), this._rawStatisticsCache[field3];
  }
  _statisticViewData() {
    registerDataSetInstanceTransform(this._dataSet, "dimensionStatistics", dimensionStatistics);
    const viewDataStatisticsName = `${this.type}_${this.id}_viewDataStatic`;
    this._viewDataStatistics = new DataView(this._dataSet, {
      name: viewDataStatisticsName
    }), this._viewDataStatistics.parse([this._data.getDataView()], {
      type: "dataview"
    }), this._viewDataStatistics.transform({
      type: "dimensionStatistics",
      options: {
        fields: () => {
          const fields2 = this.getStatisticFields();
          return this._seriesField && mergeFields(fields2, [{
            key: this._seriesField,
            operations: ["values"]
          }]), fields2;
        },
        target: "latest"
      }
    }, false), this._data.getDataView().target.removeListener("change", this._viewDataStatistics.reRunAllTransform), this.getStack() && this.createdStackData();
  }
  createStatisticalData(dataName, rawData, staticFields) {
    registerDataSetInstanceTransform(this._dataSet, "dimensionStatistics", dimensionStatistics);
    const data = new DataView(this._dataSet, {
      name: dataName
    });
    return data.parse([rawData], {
      type: "dataview"
    }), data.transform({
      type: "dimensionStatistics",
      options: {
        operations: ["max", "min", "values"],
        fields: () => {
          var _a;
          const fields2 = mergeFields(this.getStatisticFields(), null !== (_a = null == staticFields ? void 0 : staticFields(rawData.name)) && void 0 !== _a ? _a : []);
          return this._seriesField && mergeFields(fields2, [{
            key: this._seriesField,
            operations: ["values"]
          }]), fields2;
        },
        target: "latest"
      }
    }, false), data;
  }
  createdStackData() {
    const dataName = `${this.type}_${this.id}_viewStackData`;
    this._viewStackData = new DataView(this._dataSet, {
      name: dataName
    }), this._viewStackData.parse([this._viewDataFilter], {
      type: "dataview"
    }), this._viewStackData.transform({
      type: "stackSplit",
      options: {
        fields: this.getStackGroupFields()
      }
    }, false);
  }
  _noAnimationDataKey(datum, index) {
    return index;
  }
  generateDefaultDataKey(dataKey) {
    var _a;
    return isNil_default(dataKey) ? (datum, index, context) => {
      if (false === this._spec.animation) {
        const v = this._noAnimationDataKey(datum, index);
        if (void 0 !== v)
          return v;
      }
      const { keyMap: keyMap2 } = context, seriesDataKey = this._getSeriesDataKey(datum);
      return void 0 === keyMap2.get(seriesDataKey) ? (keyMap2.set(seriesDataKey, 0), seriesDataKey) : (keyMap2.set(seriesDataKey, keyMap2.get(seriesDataKey) + 1), `${seriesDataKey}_${keyMap2.get(seriesDataKey)}`);
    } : isString_default(dataKey) ? (datum) => datum[dataKey] : isArray_default(dataKey) && dataKey.every((d) => isString_default(d)) ? (datum) => dataKey.map((k2) => datum[k2]).join("-") : isFunction_default(dataKey) ? (datum, index) => dataKey(datum, index) : (null === (_a = this._option) || void 0 === _a || _a.onError(`invalid dataKey: ${dataKey}`), (datum, index) => {
    });
  }
  _addDataIndexAndKey() {
    var _a;
    (null === (_a = this._rawData) || void 0 === _a ? void 0 : _a.dataSet) && (registerDataSetInstanceTransform(this._rawData.dataSet, "addVChartProperty", addVChartProperty), this._rawData.transform({
      type: "addVChartProperty",
      options: {
        beforeCall: initKeyMap.bind(this),
        call: addDataKey
      }
    }, false));
  }
  updateRawData(d) {
    this._rawData && this._rawData.updateRawData(d);
  }
  rawDataUpdate(d) {
    var _a;
    null === (_a = this._rawDataStatistics) || void 0 === _a || _a.reRunAllTransform(), this._rawStatisticsCache = null, this.event.emit(ChartEvent.rawDataUpdate, {
      model: this
    });
  }
  viewDataFilterOver(d) {
    this.event.emit(ChartEvent.viewDataFilterOver, {
      model: this
    });
  }
  viewDataUpdate(d) {
    var _a;
    this.event.emit(ChartEvent.viewDataUpdate, {
      model: this
    }), null === (_a = this._data) || void 0 === _a || _a.updateData(), this._viewDataStatistics && this._viewDataStatistics.reRunAllTransform();
  }
  viewDataStatisticsUpdate(d) {
    this.event.emit(ChartEvent.viewDataStatisticsUpdate, {
      model: this
    });
  }
  getDatumPositionValue(datum, field3) {
    return !datum || isNil_default(field3) ? null : datum[field3];
  }
  getDatumPositionValues(datum, fields2) {
    return !datum || isNil_default(fields2) ? [] : isString_default(fields2) ? [datum[fields2]] : fields2.map((f) => datum[f]);
  }
  setValueFieldToStack() {
  }
  setValueFieldToPercent() {
  }
  setValueFieldToStackOffsetSilhouette() {
  }
  initRootMark() {
    var _a, _b;
    this._rootMark = this._createMark({
      type: "group",
      name: `seriesGroup_${this.type}_${this.id}`
    }, {
      parent: null === (_b = (_a = this._region).getGroupMark) || void 0 === _b ? void 0 : _b.call(_a),
      dataView: false
    }), this._rootMark.setZIndex(this.layoutZIndex);
  }
  _getExtensionMarkNamePrefix() {
    return `${this.type}_${this.id}_extensionMark`;
  }
  _initExtensionMark(options) {
    var _a;
    if (!this._spec.extensionMark)
      return;
    const mainMarks = this.getMarksWithoutRoot();
    options.depend = mainMarks, null === (_a = this._spec.extensionMark) || void 0 === _a || _a.forEach((m4, i) => {
      this._createExtensionMark(m4, null, this._getExtensionMarkNamePrefix(), i, options);
    });
  }
  _createExtensionMark(spec, parentMark, namePrefix, index, options) {
    var _a;
    const mark = this._createMark({
      type: spec.type,
      name: `${namePrefix}_${index}`
    }, {
      skipBeforeLayouted: true,
      markSpec: spec,
      parent: parentMark,
      dataView: false,
      customShape: null == spec ? void 0 : spec.customShape,
      componentType: spec.componentType,
      depend: options.depend,
      key: spec.dataKey
    });
    if (mark) {
      if (options.hasAnimation) {
        const config2 = animationConfig({}, userAnimationConfig(spec.type, spec, this._markAttributeContext));
        mark.setAnimationConfig(config2);
      }
      if ("group" === spec.type)
        namePrefix = `${namePrefix}_${index}`, null === (_a = spec.children) || void 0 === _a || _a.forEach((s2, i) => {
          this._createExtensionMark(s2, mark, namePrefix, i, options);
        });
      else if (!(parentMark || isNil_default(spec.dataId) && isNil_default(spec.dataIndex))) {
        const dataView = this._option.getSeriesData(spec.dataId, spec.dataIndex);
        dataView === this._rawData ? mark.setDataView(this.getViewData(), this.getViewDataProductId()) : (mark.setDataView(dataView), dataView.target.addListener("change", () => {
          mark.getData().updateData();
        }));
      }
    }
  }
  _updateExtensionMarkSpec() {
    var _a;
    null === (_a = this._spec.extensionMark) || void 0 === _a || _a.forEach((spec, i) => {
      const mark = this._marks.getMarkWithInfo({
        name: `${this._getExtensionMarkNamePrefix()}_${i}`
      });
      mark && (this.initMarkStyleWithSpec(mark, spec), mark.updateStaticEncode(), mark.updateLayoutState());
    });
  }
  getStackData() {
    var _a;
    return null === (_a = this._viewStackData) || void 0 === _a ? void 0 : _a.latestData;
  }
  _parseSelectorOfInteraction(interactionSpec, marks) {
    if (!marks || !marks.length)
      return [];
    const selector = [];
    return interactionSpec.markIds ? marks.filter((mark) => {
      interactionSpec.markIds.includes(mark.getProductId()) && selector.push(`#${mark.getProductId()}`);
    }) : interactionSpec.markNames ? marks.forEach((mark) => {
      interactionSpec.markNames.includes(mark.name) && selector.push(`#${mark.getProductId()}`);
    }) : marks.forEach((mark) => {
      selector.push(`#${mark.getProductId()}`);
    }), selector;
  }
  _parseDefaultInteractionConfig(mainMarks) {
    if (!(null == mainMarks ? void 0 : mainMarks.length))
      return [];
    const defaultConfig = getDefaultInteractionConfigByMode(this._option.mode);
    let finalHoverSpec = Object.assign({}, null == defaultConfig ? void 0 : defaultConfig.hover), finalSelectSpec = Object.assign({}, null == defaultConfig ? void 0 : defaultConfig.select);
    const hoverSpec = this._spec.hover;
    isBoolean_default(hoverSpec) ? finalHoverSpec.enable = hoverSpec : isObject_default(hoverSpec) && (finalHoverSpec.enable = true, finalHoverSpec = mergeSpec(finalHoverSpec, hoverSpec));
    const selectSpec = this._spec.select;
    isBoolean_default(selectSpec) ? finalSelectSpec.enable = selectSpec : isObject_default(selectSpec) && (finalSelectSpec.enable = true, finalSelectSpec = mergeSpec(finalSelectSpec, selectSpec));
    const res = [];
    if (finalHoverSpec.enable) {
      const selector = this._parseSelectorOfInteraction(finalHoverSpec, mainMarks);
      selector.length && res.push({
        seriesId: this.id,
        regionId: this._region.id,
        selector,
        type: "element-highlight",
        trigger: finalHoverSpec.trigger,
        triggerOff: finalHoverSpec.triggerOff,
        blurState: STATE_VALUE_ENUM.STATE_HOVER_REVERSE,
        highlightState: STATE_VALUE_ENUM.STATE_HOVER
      });
    }
    if (finalSelectSpec.enable) {
      const selector = this._parseSelectorOfInteraction(finalSelectSpec, mainMarks), isMultiple = "multiple" === finalSelectSpec.mode, triggerOff = isValid_default(finalSelectSpec.triggerOff) ? finalSelectSpec.triggerOff : isMultiple ? ["empty"] : ["empty", finalSelectSpec.trigger];
      selector.length && res.push({
        type: "element-select",
        seriesId: this.id,
        regionId: this._region.id,
        selector,
        trigger: finalSelectSpec.trigger,
        triggerOff,
        reverseState: STATE_VALUE_ENUM.STATE_SELECTED_REVERSE,
        state: STATE_VALUE_ENUM.STATE_SELECTED,
        isMultiple
      });
    }
    return res;
  }
  _parseInteractionConfig(mainMarks) {
    const compiler = this.getCompiler();
    if (!compiler)
      return;
    const { interactions } = this._spec, res = this._parseDefaultInteractionConfig(mainMarks);
    res && res.length && res.forEach((interaction) => {
      compiler.addInteraction(interaction);
    }), interactions && interactions.length && interactions.forEach((interaction) => {
      const selectors = this._parseSelectorOfInteraction(interaction, this.getMarks());
      selectors.length && compiler.addInteraction(Object.assign(Object.assign({}, interaction), {
        selector: selectors,
        seriesId: this.id,
        regionId: this._region.id
      }));
    });
  }
  initInteraction() {
    const marks = this.getMarksWithoutRoot();
    this._parseInteractionConfig(marks);
  }
  initAnimation() {
  }
  initMarkState() {
    this.initSeriesStyleState();
  }
  initSeriesStyleState() {
    var _a;
    const seriesStyle = this._spec.seriesStyle;
    if (!seriesStyle || !seriesStyle.length)
      return;
    const groupBy2 = null !== (_a = this._seriesField) && void 0 !== _a ? _a : DEFAULT_DATA_SERIES_FIELD2;
    this.getMarksWithoutRoot().forEach((mark) => {
      const filterMap = {}, attrMap = {}, markStyle = {};
      seriesStyle.forEach((item) => {
        var _a2;
        const style2 = null === (_a2 = item[mark.name]) || void 0 === _a2 ? void 0 : _a2.style;
        style2 && (filterMap[item.name] = true, markStyle[item.name] = markStyle[item.name] || {}, Object.keys(style2).forEach((key) => {
          attrMap[key] = true, markStyle[item.name][key] = style2[key];
        }));
      }), mark.state.addStateInfo({
        stateValue: DEFAULT_SERIES_STYLE_NAME2,
        level: -1,
        filter: (datum) => Array.isArray(datum) ? 0 !== datum.length && true === filterMap[datum[0][groupBy2]] : true === filterMap[datum[groupBy2]]
      });
      const style = {};
      Object.keys(attrMap).forEach((key) => {
        style[key] = (datum) => {
          var _a2, _b;
          let style2;
          if (Array.isArray(datum)) {
            if (0 === datum.length)
              return;
            style2 = null === (_a2 = markStyle[datum[0][groupBy2]]) || void 0 === _a2 ? void 0 : _a2[key];
          }
          return style2 = null === (_b = markStyle[datum[groupBy2]]) || void 0 === _b ? void 0 : _b[key], style2 || mark.getAttribute(key, datum);
        };
      }), this.setMarkStyle(mark, style, DEFAULT_SERIES_STYLE_NAME2);
    });
  }
  afterInitMark() {
    this.event.emit(ChartEvent.afterInitMark, {
      model: this
    }), this.setSeriesField(this._spec.seriesField), this.getMarks().forEach((m4) => {
      var _a, _b;
      (null === (_b = null === (_a = m4.stateStyle) || void 0 === _a ? void 0 : _a.normal) || void 0 === _b ? void 0 : _b.lineWidth) && m4.setAttribute("stroke", this.getColorAttribute(), "normal", AttributeLevel2.Base_Series);
    });
  }
  getMarksWithoutRoot() {
    return this.getMarks().filter((m4) => !m4.name.includes("seriesGroup"));
  }
  getMarksInType(type) {
    return this._marks.getMarksInType(type);
  }
  getMarkInName(name) {
    return this._marks.get(name);
  }
  getMarkInId(markId) {
    return this.getMarks().find((m4) => m4.id === markId);
  }
  initEvent() {
    var _a, _b, _c;
    null === (_b = null === (_a = this._data) || void 0 === _a ? void 0 : _a.getDataView()) || void 0 === _b || _b.target.addListener("change", this.viewDataUpdate.bind(this)), null === (_c = this._viewDataStatistics) || void 0 === _c || _c.target.addListener("change", this.viewDataStatisticsUpdate.bind(this));
  }
  _releaseEvent() {
    super._releaseEvent(), this.getCompiler().removeInteraction(this.id);
  }
  initTooltip() {
    this._tooltipHelper = new BaseSeriesTooltipHelper(this);
  }
  _compareSpec(spec, prevSpec, ignoreCheckKeys) {
    var _a, _b;
    const result2 = super._compareSpec(spec, prevSpec), currentKeys = Object.keys(prevSpec || {}).sort(), nextKeys = Object.keys(spec || {}).sort();
    return isEqual(currentKeys, nextKeys) ? ((ignoreCheckKeys = null != ignoreCheckKeys ? ignoreCheckKeys : {
      data: true
    }).invalidType = true, spec.invalidType !== prevSpec.invalidType && (result2.reCompile = true), ignoreCheckKeys.extensionMark = true, (array(spec.extensionMark).length !== array(prevSpec.extensionMark).length || (null === (_a = prevSpec.extensionMark) || void 0 === _a ? void 0 : _a.some((mark, index) => mark.type !== spec.extensionMark[index].type || mark.id !== spec.extensionMark[index].id))) && (result2.reMake = true), result2.reMake ? result2 : ((null === (_b = prevSpec.extensionMark) || void 0 === _b ? void 0 : _b.some((mark, index) => mark.visible !== spec.extensionMark[index].visible)) && (result2.reCompile = true), this._marks.getMarks().some((m4) => {
      var _a2, _b2;
      return ignoreCheckKeys[m4.name] = true, (null === (_a2 = prevSpec[m4.name]) || void 0 === _a2 ? void 0 : _a2.visible) !== (null === (_b2 = spec[m4.name]) || void 0 === _b2 ? void 0 : _b2.visible);
    }) && (result2.reCompile = true), currentKeys.some((k2) => !ignoreCheckKeys[k2] && !isEqual(spec[k2], prevSpec[k2])) ? (result2.reMake = true, result2) : result2)) : (result2.reMake = true, result2);
  }
  _updateSpecData() {
    !this._rawData || !this._spec.data || this._spec.data instanceof DataView || updateDataViewInData(this._rawData, this._spec.data, true);
  }
  reInit(spec) {
    super.reInit(spec);
    const marks = this.getMarksWithoutRoot();
    marks.forEach((mark) => {
      this._spec[mark.name] && this.initMarkStyleWithSpec(mark, this._spec[mark.name]);
    }), this.initMarkStyle(), marks.forEach((mark) => {
      mark.updateStaticEncode(), mark.updateLayoutState(true);
    }), this._updateExtensionMarkSpec(), this._updateSpecData(), this._tooltipHelper && this._tooltipHelper.updateTooltipSpec();
  }
  onEvaluateEnd(ctx) {
    this._data.updateData();
  }
  onRender(ctx) {
  }
  release() {
    var _a, _b, _c;
    super.release(), this._viewDataMap.clear();
    const transformIndex = null === (_b = null === (_a = this._rawData) || void 0 === _a ? void 0 : _a.transformsArr) || void 0 === _b ? void 0 : _b.findIndex((t) => "addVChartProperty" === t.type);
    transformIndex >= 0 && this._rawData.transformsArr.splice(transformIndex, 1), null === (_c = this._data) || void 0 === _c || _c.release(), this._dataSet = this._data = this._rawData = this._rawDataStatistics = this._spec = this._region = this._viewDataStatistics = this._viewStackData = null;
  }
  setLayoutStartPosition(pos) {
    isValidNumber_default(pos.x) && (this._layoutStartPoint.x = pos.x), isValidNumber_default(pos.y) && (this._layoutStartPoint.y = pos.y);
  }
  setLayoutRect({ width, height }, levelMap) {
    isValidNumber_default(width) && (this._layoutRect.width = width), isValidNumber_default(height) && (this._layoutRect.height = height);
  }
  getSeriesKeys() {
    var _a, _b;
    return this._seriesField ? null !== (_b = null === (_a = this.getRawDataStatisticsByField(this._seriesField)) || void 0 === _a ? void 0 : _a.values) && void 0 !== _b ? _b : [] : this.name ? [this.name] : this.userId ? [`${this.userId}`] : [`${this.type}_${this.id}`];
  }
  getSeriesStyle(datum) {
    return (attribute) => {
      var _a, _b;
      return null !== (_b = null === (_a = this._seriesMark) || void 0 === _a ? void 0 : _a.getAttribute(attribute, datum)) && void 0 !== _b ? _b : void 0;
    };
  }
  _getSeriesInfo(field3, keys2) {
    const defaultShapeType = this.getDefaultShapeType();
    return keys2.map((key) => ({
      key,
      originalKey: key,
      style: this.getSeriesStyle({
        [field3]: key
      }),
      shapeType: defaultShapeType
    }));
  }
  getSeriesInfoInField(field3) {
    var _a, _b;
    return this._getSeriesInfo(field3, null !== (_b = null === (_a = this.getRawDataStatisticsByField(field3)) || void 0 === _a ? void 0 : _a.values) && void 0 !== _b ? _b : []);
  }
  getSeriesInfoList() {
    var _a;
    return this._getSeriesInfo(null !== (_a = this._seriesField) && void 0 !== _a ? _a : DEFAULT_DATA_SERIES_FIELD2, this.getSeriesKeys());
  }
  _getDefaultColorScale() {
    var _a, _b;
    const colorDomain = this.getDefaultColorDomain(), colorRange = this._getDataScheme();
    return null === (_b = (_a = new ColorOrdinalScale().domain(colorDomain)).range) || void 0 === _b ? void 0 : _b.call(_a, colorRange);
  }
  _getDataScheme() {
    return getDataScheme(this.getColorScheme(), this.type);
  }
  getDefaultColorDomain() {
    var _a, _b;
    return this._seriesField ? null === (_b = null === (_a = this.getViewDataStatistics()) || void 0 === _a ? void 0 : _a.latestData[this._seriesField]) || void 0 === _b ? void 0 : _b.values : [];
  }
  getColorAttribute() {
    var _a, _b;
    return {
      scale: null !== (_a = this._option.globalScale.getScale("color")) && void 0 !== _a ? _a : this._getDefaultColorScale(),
      field: null !== (_b = this._seriesField) && void 0 !== _b ? _b : DEFAULT_DATA_SERIES_FIELD2
    };
  }
  getDimensionField() {
    return [];
  }
  getMeasureField() {
    return [];
  }
  onMarkPositionUpdate() {
    this.onMarkTreePositionUpdate(this.getMarksWithoutRoot());
  }
  onMarkTreePositionUpdate(marks) {
  }
  _createMark(markInfo, option = {}) {
    var _a, _b, _c, _d;
    const { key, groupKey, skipBeforeLayouted, themeSpec = {}, markSpec, dataView, dataProductId, parent, isSeriesMark, depend, progressive, support3d = this._spec.support3d || !!this._spec.zField, morph = false, clip, customShape, stateSort, noSeparateStyle = false } = option, m4 = super._createMark(markInfo, {
      key: null != key ? key : this._getDataIdKey(),
      support3d,
      seriesId: this.id,
      attributeContext: this._markAttributeContext,
      componentType: option.componentType,
      noSeparateStyle
    });
    if (isValid_default(m4)) {
      this._marks.addMark(m4, {
        name: markInfo.name
      }), isSeriesMark && (this._seriesMark = m4), isNil_default(parent) ? null === (_a = this._rootMark) || void 0 === _a || _a.addMark(m4) : false !== parent && parent.addMark(m4), isNil_default(dataView) ? (m4.setDataView(this.getViewData(), this.getViewDataProductId()), m4.setSkipBeforeLayouted(true)) : false !== dataView && m4.setDataView(dataView, dataProductId), isBoolean_default(skipBeforeLayouted) && m4.setSkipBeforeLayouted(skipBeforeLayouted), isValid_default(depend) && m4.setDepend(...array(depend));
      const spec = this.getSpec() || {};
      m4.setMorph(morph), m4.setMorphKey((null === (_b = spec.morph) || void 0 === _b ? void 0 : _b.morphKey) || `${this.getSpecIndex()}`), m4.setMorphElementKey(null !== (_d = null === (_c = spec.morph) || void 0 === _c ? void 0 : _c.morphElementKey) && void 0 !== _d ? _d : option.defaultMorphElementKey), isNil_default(progressive) || m4.setProgressiveConfig(progressive), isNil_default(groupKey) || m4.setGroupKey(groupKey), customShape && m4.setCustomizedShapeCallback(customShape), stateSort && m4.setStateSortCallback(stateSort), clip && m4.setClip(clip), this.initMarkStyleWithSpec(m4, mergeSpec({}, themeSpec, markSpec || spec[m4.name]));
    }
    return m4;
  }
  _getDataIdKey() {
    var _a;
    return null !== (_a = super._getDataIdKey()) && void 0 !== _a ? _a : DEFAULT_DATA_KEY2;
  }
  _getSeriesDataKey(datum) {
    let key = "";
    if (!datum)
      return key;
    const dimensionFields = this.getDimensionField();
    key = dimensionFields.map((field3) => datum[field3]).join("_");
    const seriesField = this.getSeriesField();
    return seriesField && !dimensionFields.includes(seriesField) && (key += `_${datum[seriesField]}`), key;
  }
  addViewDataFilter(option) {
    var _a, _b;
    null === (_b = null !== (_a = this._viewDataFilter) && void 0 !== _a ? _a : this.getViewData()) || void 0 === _b || _b.transform(option, false);
  }
  reFilterViewData() {
    var _a, _b;
    null === (_b = null !== (_a = this._viewDataFilter) && void 0 !== _a ? _a : this.getViewData()) || void 0 === _b || _b.reRunAllTransform();
  }
  reTransformViewData() {
    var _a, _b;
    null === (_b = null === (_a = this._data) || void 0 === _a ? void 0 : _a.getDataView()) || void 0 === _b || _b.reRunAllTransform();
  }
  fillData() {
    var _a;
    null === (_a = this.getRawData()) || void 0 === _a || _a.reRunAllTransform();
  }
  compile() {
    this.compileData();
  }
  getDefaultShapeType() {
    return "circle";
  }
  getFieldAlias(field3) {
    var _a;
    return field3 !== STACK_FIELD_END2 && field3 !== STACK_FIELD_END_PERCENT2 && field3 !== STACK_FIELD_START2 && field3 !== STACK_FIELD_START_PERCENT2 || (field3 = this.getStackValueField()), null !== (_a = getFieldAlias(this.getRawData(), field3)) && void 0 !== _a ? _a : field3;
  }
  getMarkInfoList() {
    var _a;
    const list = super.getMarkInfoList();
    return list.length ? list : Object.values(null !== (_a = seriesMarkInfoMap[this.type]) && void 0 !== _a ? _a : {});
  }
  _getInvalidConnectType() {
    return "zero" === this._invalidType ? "zero" : "link" === this._invalidType ? "connect" : "none";
  }
  _getInvalidDefined(datum) {
    const checkFields = this.getInvalidCheckFields();
    return !checkFields.length || checkFields.every((field3) => couldBeValidNumber(datum[field3]));
  }
  _getRelatedComponentSpecInfo(specKey) {
    var _a;
    const specIndex = this.getSpecIndex(), relatedComponent = null === (_a = this._option.getSpecInfo().component[specKey]) || void 0 === _a ? void 0 : _a.filter((componentInfo) => componentInfo.seriesIndexes.includes(specIndex));
    return null != relatedComponent ? relatedComponent : [];
  }
  _forEachStackGroup(callback, node) {
    var _a, _b;
    (node = null != node ? node : null === (_a = this._viewStackData) || void 0 === _a ? void 0 : _a.latestData) && ((null === (_b = node.values) || void 0 === _b ? void 0 : _b.length) ? callback(node) : node.nodes && Object.values(node.nodes).forEach((n) => {
      this._forEachStackGroup(callback, n);
    }));
  }
  isDatumInViewData(datum) {
    if (!datum)
      return false;
    const viewDataList = this.getViewData().latestData;
    return !!viewDataList && (!!viewDataList.includes(datum) || viewDataList.some((viewDatum) => Object.keys(datum).every((key) => datum[key] === viewDatum[key])));
  }
  getSeriesFieldValue(datum, seriesField) {
    var _a;
    return datum[null !== (_a = null != seriesField ? seriesField : this.getSeriesField()) && void 0 !== _a ? _a : DEFAULT_DATA_SERIES_FIELD2];
  }
};
BaseSeries.mark = baseSeriesMark, BaseSeries.transformerConstructor = BaseSeriesSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/util/utils
function isPolarAxisSeries(type) {
  return [SeriesTypeEnum.rose, SeriesTypeEnum.radar, SeriesTypeEnum.circularProgress].includes(type);
}
function sortDataInAxisHelper(axisHelper, field3, dataList) {
  const scale4 = axisHelper.getScale(0), isRevert = "isInverse" in axisHelper && axisHelper.isInverse();
  isContinuous(scale4.type) ? dataList.sort((datumA, datumB) => (datumA[field3] - datumB[field3]) * (isRevert ? -1 : 1)) : dataList.sort((datumA, datumB) => (scale4.index(datumA[field3]) - scale4.index(datumB[field3])) * (isRevert ? -1 : 1));
}
function getGroupAnimationParams(series2) {
  return {
    dataIndex: (datum) => {
      var _a, _b;
      const indexField = "horizontal" === series2.direction ? series2.fieldY[0] : series2.fieldX[0], indexValue = null == datum ? void 0 : datum[indexField], scale4 = "horizontal" === series2.direction ? series2.scaleY : series2.scaleX;
      return (null !== (_b = null === (_a = null == scale4 ? void 0 : scale4.domain) || void 0 === _a ? void 0 : _a.call(scale4)) && void 0 !== _b ? _b : []).indexOf(indexValue) || 0;
    },
    dataCount: () => {
      var _a, _b, _c;
      const scale4 = "horizontal" === series2.direction ? series2.scaleY : series2.scaleX;
      return null !== (_c = (null !== (_b = null === (_a = null == scale4 ? void 0 : scale4.domain) || void 0 === _a ? void 0 : _a.call(scale4)) && void 0 !== _b ? _b : []).length) && void 0 !== _c ? _c : 0;
    }
  };
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/cartesian/cartesian
var CartesianSeries = class extends BaseSeries {
  constructor() {
    super(...arguments), this.coordinate = "cartesian", this._bandPosition = 0.5, this._scaleConfig = {
      bandPosition: this._bandPosition
    }, this._direction = "vertical", this._sortDataByAxis = false, this._getPositionXEncoder = () => {
      var _a;
      return null === (_a = this._positionXEncoder) || void 0 === _a ? void 0 : _a.bind(this);
    }, this._setPositionXEncoder = (encoder) => {
      this._positionXEncoder = encoder.bind(this);
    }, this._getPositionYEncoder = () => {
      var _a;
      return null === (_a = this._positionYEncoder) || void 0 === _a ? void 0 : _a.bind(this);
    }, this._setPositionYEncoder = (encoder) => {
      this._positionYEncoder = encoder.bind(this);
    };
  }
  _buildScaleConfig() {
    this._scaleConfig = {
      bandPosition: this._bandPosition
    };
  }
  get fieldX() {
    return this._fieldX;
  }
  setFieldX(f) {
    this._fieldX = array(f);
  }
  get fieldY() {
    return this._fieldY;
  }
  setFieldY(f) {
    this._fieldY = array(f);
  }
  get fieldZ() {
    return this._fieldZ;
  }
  setFieldZ(f) {
    this._fieldZ = f && array(f);
  }
  get fieldX2() {
    return this._fieldX2;
  }
  setFieldX2(f) {
    this._fieldX2 = f;
  }
  get fieldY2() {
    return this._fieldY2;
  }
  setFieldY2(f) {
    this._fieldY2 = f;
  }
  get direction() {
    return this._direction;
  }
  get scaleX() {
    return this._scaleX;
  }
  setScaleX(s2) {
    this._scaleX = s2;
  }
  get scaleY() {
    return this._scaleY;
  }
  setScaleY(s2) {
    this._scaleY = s2;
  }
  get scaleZ() {
    return this._scaleZ;
  }
  setScaleZ(s2) {
    this._scaleZ = s2;
  }
  getXAxisHelper() {
    return this._xAxisHelper;
  }
  setXAxisHelper(h) {
    this._xAxisHelper = h, this.onXAxisHelperUpdate();
  }
  getYAxisHelper() {
    return this._yAxisHelper;
  }
  setYAxisHelper(h) {
    this._yAxisHelper = h, this.onYAxisHelperUpdate();
  }
  getZAxisHelper() {
    return this._zAxisHelper;
  }
  setZAxisHelper(h) {
    this._zAxisHelper = h, this.onYAxisHelperUpdate();
  }
  get sortDataByAxis() {
    return this._sortDataByAxis;
  }
  getStatisticFields() {
    const fields2 = [];
    return [{
      axisHelper: this.getXAxisHelper(),
      fields: this._fieldX2 ? [...this._fieldX, this._fieldX2] : this._fieldX
    }, {
      axisHelper: this.getYAxisHelper(),
      fields: this._fieldY2 ? [...this._fieldY, this._fieldY2] : this._fieldY
    }, {
      axisHelper: this.getZAxisHelper(),
      fields: this._fieldZ
    }].forEach((axisOption) => {
      axisOption.axisHelper && axisOption.axisHelper.getScale && axisOption.fields && axisOption.fields.forEach((f) => {
        const result2 = {
          key: f,
          operations: []
        }, scale4 = axisOption.axisHelper.getScale(0);
        isContinuous(scale4.type) ? (result2.operations = ["max", "min"], "log" === scale4.type && (result2.filter = (fv) => fv > 0)) : result2.operations = ["values"], fields2.push(result2);
      });
    }), this.getStack() && fields2.push({
      key: this.getStackValueField(),
      operations: ["allValid"]
    }), fields2;
  }
  getGroupFields() {
    return "vertical" === this.direction ? this._fieldX : this._fieldY;
  }
  getStackGroupFields() {
    return this.getGroupFields();
  }
  getStackValue() {
    var _a, _b;
    const axisId = null === (_a = "horizontal" === this.direction ? this.getXAxisHelper() : this.getYAxisHelper()) || void 0 === _a ? void 0 : _a.getAxisId();
    return null !== (_b = this._spec.stackValue) && void 0 !== _b ? _b : `${PREFIX}_series_${this.type}_${axisId}`;
  }
  getStackValueField() {
    return "horizontal" === this.direction ? array(this._spec.xField)[0] : array(this._spec.yField)[0];
  }
  setValueFieldToStack() {
    "horizontal" === this.direction ? (this.setFieldX(STACK_FIELD_END), this.setFieldX2(STACK_FIELD_START)) : (this.setFieldY(STACK_FIELD_END), this.setFieldY2(STACK_FIELD_START));
  }
  setValueFieldToPercent() {
    "horizontal" === this.direction ? (this.setFieldX(STACK_FIELD_END_PERCENT), this.setFieldX2(STACK_FIELD_START_PERCENT)) : (this.setFieldY(STACK_FIELD_END_PERCENT), this.setFieldY2(STACK_FIELD_START_PERCENT));
  }
  setValueFieldToStackOffsetSilhouette() {
    "horizontal" === this.direction ? (this.setFieldX(STACK_FIELD_END_OffsetSilhouette), this.setFieldX2(STACK_FIELD_START_OffsetSilhouette)) : (this.setFieldY(STACK_FIELD_END_OffsetSilhouette), this.setFieldY2(STACK_FIELD_START_OffsetSilhouette));
  }
  onXAxisHelperUpdate() {
    this.onMarkPositionUpdate();
  }
  onYAxisHelperUpdate() {
    this.onMarkPositionUpdate();
  }
  onZAxisHelperUpdate() {
    this.onMarkPositionUpdate();
  }
  setAttrFromSpec() {
    var _a, _b;
    super.setAttrFromSpec(), this.setFieldX(this._spec.xField), this.setFieldY(this._spec.yField), this.setFieldZ(this._spec.zField), this._specXField = array(this._spec.xField), this._specYField = array(this._spec.yField), isValid_default(this._spec.direction) && (this._direction = this._spec.direction), this.setFieldX2(null === (_a = this._spec) || void 0 === _a ? void 0 : _a.x2Field), this.setFieldY2(null === (_b = this._spec) || void 0 === _b ? void 0 : _b.y2Field), this.getStack() && this.setValueFieldToStack(), this.getPercent() && this.setValueFieldToPercent(), this.getStackOffsetSilhouette() && this.setValueFieldToStackOffsetSilhouette(), isValid_default(this._spec.sortDataByAxis) && (this._sortDataByAxis = true === this._spec.sortDataByAxis);
  }
  dataToPosition(datum, checkInViewData) {
    return datum ? checkInViewData && !this.isDatumInViewData(datum) ? null : {
      x: this.dataToPositionX(datum),
      y: this.dataToPositionY(datum)
    } : null;
  }
  _buildMarkAttributeContext() {
    super._buildMarkAttributeContext(), this._markAttributeContext.valueToX = this.valueToPositionX.bind(this), this._markAttributeContext.valueToY = this.valueToPositionY.bind(this), this._markAttributeContext.xBandwidth = (depth = 0) => {
      var _a, _b, _c;
      return null !== (_c = null === (_b = (_a = this.getXAxisHelper()).getBandwidth) || void 0 === _b ? void 0 : _b.call(_a, depth)) && void 0 !== _c ? _c : 0;
    }, this._markAttributeContext.yBandwidth = (depth = 0) => {
      var _a, _b, _c;
      return null !== (_c = null === (_b = (_a = this.getYAxisHelper()).getBandwidth) || void 0 === _b ? void 0 : _b.call(_a, depth)) && void 0 !== _c ? _c : 0;
    }, this._markAttributeContext.valueToPosition = this.valueToPosition.bind(this);
  }
  valueToPosition(xValue, yValue) {
    return {
      x: this.valueToPositionX(xValue),
      y: this.valueToPositionY(yValue)
    };
  }
  _axisPosition(helper, value, datum) {
    return this._scaleConfig.datum = datum, helper.isContinuous ? helper.valueToPosition(value, this._scaleConfig) : helper.dataToPosition(array(value), this._scaleConfig);
  }
  valueToPositionX(value, datum) {
    return this._axisPosition(this._xAxisHelper, value, datum);
  }
  valueToPositionY(value, datum) {
    return this._axisPosition(this._yAxisHelper, value, datum);
  }
  _dataToPosition(datum, axisHelper, field3, scaleDepth, getEncoder, setEncoder) {
    const encoder = getEncoder();
    if (encoder)
      return encoder(datum);
    if (!axisHelper)
      return setEncoder((datum2) => Number.NaN), Number.NaN;
    const fields2 = (axisHelper.getFields ? axisHelper.getFields() : field3).slice(0, scaleDepth);
    return fields2 && 0 !== fields2.length ? (axisHelper.isContinuous ? setEncoder((datum2) => (this._scaleConfig.datum = datum2, axisHelper.valueToPosition(this.getDatumPositionValue(datum2, fields2[0]), this._scaleConfig))) : setEncoder((datum2) => (this._scaleConfig.datum = datum2, axisHelper.dataToPosition(array(this.getDatumPositionValues(datum2, fields2)), this._scaleConfig))), getEncoder()(datum)) : (setEncoder((datum2) => null), null);
  }
  dataToPositionX(datum) {
    return this._dataToPosition(datum, this._xAxisHelper, this.fieldX, void 0, this._getPositionXEncoder, this._setPositionXEncoder);
  }
  dataToPositionY(datum) {
    return this._dataToPosition(datum, this._yAxisHelper, this.fieldY, void 0, this._getPositionYEncoder, this._setPositionYEncoder);
  }
  dataToPositionZ(datum) {
    if (!this._zAxisHelper)
      return Number.NaN;
    const { dataToPosition } = this._zAxisHelper;
    return dataToPosition(this.getDatumPositionValues(datum, this._fieldZ), {
      bandPosition: this._bandPosition
    });
  }
  dataToPositionX1(datum) {
    return this._xAxisHelper ? this._fieldX2 && this._fieldX2 in datum ? this.valueToPositionX(this.getDatumPositionValues(datum, this._fieldX2)) : this.valueToPositionX(0) : Number.NaN;
  }
  dataToPositionY1(datum) {
    return this._yAxisHelper ? this._fieldY2 && this._fieldY2 in datum ? this.valueToPositionY(this.getDatumPositionValues(datum, this._fieldY2)) : this.valueToPositionY(0) : Number.NaN;
  }
  positionToData(p) {
    return p ? {
      x: this.positionToDataX(p.x),
      y: this.positionToDataY(p.y)
    } : null;
  }
  positionToDataX(xPos) {
    return this._scaleX ? this._scaleX.invert(xPos) : null;
  }
  positionToDataY(yPos) {
    return this._scaleY ? this._scaleY.invert(yPos) : null;
  }
  getRegionRectLeft() {
    if (!this._xAxisHelper)
      return Number.NaN;
    const { getScale: getScale2 } = this._xAxisHelper;
    return getScale2(0).range()[0];
  }
  getRegionRectRight() {
    if (!this._xAxisHelper)
      return Number.NaN;
    const { getScale: getScale2 } = this._xAxisHelper;
    return getScale2(0).range()[1];
  }
  afterInitMark() {
    super.afterInitMark(), this.setFieldX(this._fieldX), this.setFieldY(this._fieldY), this._buildScaleConfig();
  }
  getDimensionField() {
    return "horizontal" === this._direction ? this._specYField : this._specXField;
  }
  getDimensionContinuousField() {
    return "horizontal" === this._direction ? [this.fieldY[0], this.fieldY2] : [this.fieldX[0], this.fieldX2];
  }
  getMeasureField() {
    return "horizontal" === this._direction ? this._specXField : this._specYField;
  }
  initEvent() {
    super.initEvent(), this.sortDataByAxis && this.event.on(ChartEvent.scaleDomainUpdate, {
      filter: (param) => {
        var _a;
        return param.model.id === (null === (_a = "horizontal" === this._direction ? this._yAxisHelper : this._xAxisHelper) || void 0 === _a ? void 0 : _a.getAxisId());
      }
    }, () => {
      this._sortDataInAxisDomain();
    });
  }
  _sortDataInAxisDomain() {
    var _a, _b, _c;
    (null === (_b = null === (_a = this.getViewData()) || void 0 === _a ? void 0 : _a.latestData) || void 0 === _b ? void 0 : _b.length) && (sortDataInAxisHelper("horizontal" === this._direction ? this._yAxisHelper : this._xAxisHelper, "horizontal" === this._direction ? this._fieldY[0] : this._fieldX[0], this.getViewData().latestData), null === (_c = this._data) || void 0 === _c || _c.updateData(true));
  }
  getInvalidCheckFields() {
    const fields2 = [];
    if (this._xAxisHelper && this._xAxisHelper.isContinuous && this._xAxisHelper.getAxisType() !== ComponentTypeEnum.geoCoordinate) {
      (this._xAxisHelper.getFields ? this._xAxisHelper.getFields() : this._specXField).forEach((f) => {
        fields2.push(f);
      });
    }
    if (this._yAxisHelper && this._yAxisHelper.isContinuous && this._yAxisHelper.getAxisType() !== ComponentTypeEnum.geoCoordinate) {
      (this._yAxisHelper.getFields ? this._yAxisHelper.getFields() : this._specYField).forEach((f) => {
        fields2.push(f);
      });
    }
    return fields2;
  }
  reInit(spec) {
    this._positionXEncoder && (this._positionXEncoder = null), this._positionYEncoder && (this._positionYEncoder = null), super.reInit(spec);
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/mark/base/base-line
var BaseLineMark = class extends BaseMark {
  setStyle(style, state = "normal", level = 0, stateStyle = this.stateStyle) {
    if (isNil_default(style))
      return;
    void 0 === stateStyle[state] && (stateStyle[state] = {});
    const ignoreAttributes = this._getIgnoreAttributes(), segmentAttributes = ["strokeWidth", "lineWidth", "lineDash", "strokeDash", "lineJoin", "stroke", "strokeOpacity", "opacity", "fill", "fillOpacity", "texture", "texturePadding", "textureSize", "textureColor"], isUserLevel = this.isUserLevel(level);
    let enableSegments = false;
    Object.keys(style).forEach((attr) => {
      const attrStyle = style[attr];
      if (isNil_default(attrStyle) || ignoreAttributes.includes(attr))
        return;
      isUserLevel && segmentAttributes.includes(attr) && (isValidScaleType(null == attrStyle ? void 0 : attrStyle.type) || (null == attrStyle ? void 0 : attrStyle.scale) || isFunction_default(attrStyle)) && (enableSegments = true);
      let styleConverter = this._styleConvert(attrStyle);
      isUserLevel && "angle" === attr && (styleConverter = this.convertAngleToRadian(styleConverter)), this.setAttribute(attr, styleConverter, state, level, stateStyle);
    }), enableSegments && this.setEnableSegments(enableSegments);
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/mark/line
var LineMark = class _LineMark extends BaseLineMark {
  constructor() {
    super(...arguments), this.type = _LineMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      lineWidth: 1
    });
  }
  _getIgnoreAttributes() {
    var _a, _b;
    return (null === (_a = this.model) || void 0 === _a ? void 0 : _a.type) === SeriesTypeEnum.radar && "polar" === (null === (_b = this.model) || void 0 === _b ? void 0 : _b.coordinate) ? [] : ["fill", "fillOpacity"];
  }
};
LineMark.type = "line";
var registerLineMark = () => {
  Factory2.registerMark(LineMark.type, LineMark), registerLineGraphic2(), registerVGrammarLineOrAreaAnimation();
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/mark/area
var AreaMark = class _AreaMark extends BaseLineMark {
  constructor() {
    super(...arguments), this.type = _AreaMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      lineWidth: 0
    });
  }
  _getIgnoreAttributes() {
    return [];
  }
};
AreaMark.type = "area";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/mark/symbol
var BaseSymbolMark = class extends BaseMark {
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      size: 1,
      symbolType: "circle",
      fill: void 0,
      lineWidth: 0
    });
  }
};
var SymbolMark = class _SymbolMark extends BaseSymbolMark {
  constructor() {
    super(...arguments), this.type = _SymbolMark.type;
  }
};
SymbolMark.type = "symbol";
var registerSymbolMark = () => {
  Factory2.registerMark(SymbolMark.type, SymbolMark), registerSymbolGraphic2();
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/area/tooltip-helpter
var AreaSeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  constructor() {
    super(...arguments), this._getSeriesStyle = (datum, styleKey, defaultValue) => {
      var _a, _b, _c, _d;
      for (const key of array(styleKey)) {
        let value = null === (_a = this.series.getSeriesStyle(datum)) || void 0 === _a ? void 0 : _a(key);
        if (false !== value || "fill" !== key && "stroke" !== key || (value = "fill" === key ? null === (_c = null === (_b = this.series.getSeriesStyle(datum)) || void 0 === _b ? void 0 : _b("stroke")) || void 0 === _c ? void 0 : _c[0] : null === (_d = this.series.getSeriesStyle(datum)) || void 0 === _d ? void 0 : _d("fill")), isValid_default(value))
          return value;
      }
      return defaultValue;
    };
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/mixin/line-mixin-transformer
var LineLikeSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    var _a, _b, _c;
    false !== (null === (_a = spec.point) || void 0 === _a ? void 0 : _a.visible) && false !== (null === (_c = null === (_b = spec.point) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.visible) ? this._addMarkLabelSpec(spec, "point") : this._addMarkLabelSpec(spec, "line"), this._addMarkLabelSpec(spec, "line", "lineLabel", "initLineLabelMarkStyle", void 0, true);
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/area/area-transformer
var AreaSeriesSpecTransformer = class extends LineLikeSeriesSpecTransformer {
  constructor() {
    super(...arguments), this._supportStack = true;
  }
  _transformLabelSpec(spec) {
    var _a, _b, _c;
    super._transformLabelSpec(spec), this._addMarkLabelSpec(spec, "area", "areaLabel", "initLineLabelMarkStyle", void 0, true);
    false !== (null === (_a = spec.point) || void 0 === _a ? void 0 : _a.visible) && false !== (null === (_c = null === (_b = spec.point) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.visible) || this._addMarkLabelSpec(spec, "area");
  }
  _transformSpecAfterMergingTheme(spec, chartSpec, chartSpecInfo) {
    var _a, _b, _c, _d, _e;
    super._transformSpecAfterMergingTheme(spec, chartSpec, chartSpecInfo);
    const { area: area2 = {}, line: line2 = {}, seriesMark } = spec, isAreaVisible = false !== area2.visible && false !== (null === (_a = area2.style) || void 0 === _a ? void 0 : _a.visible), isLineVisible = false !== line2.visible && false !== (null === (_b = line2.style) || void 0 === _b ? void 0 : _b.visible);
    area2.support3d = !(!area2.support3d && !line2.support3d), area2.zIndex = isValid_default(area2.zIndex) || isValid_default(line2.zIndex) ? Math.max(null !== (_c = area2.zIndex) && void 0 !== _c ? _c : 0, null !== (_d = line2.zIndex) && void 0 !== _d ? _d : 0) : void 0, area2.style && delete area2.style.stroke, area2.state && Object.keys(area2.state).forEach((state) => {
      "style" in area2.state[state] ? delete area2.state[state].style.stroke : delete area2.state[state].stroke;
    });
    let mainSpec = area2, subSpec = line2;
    ("line" === seriesMark || isLineVisible && !isAreaVisible) && (mainSpec = line2, subSpec = area2), area2.style = mergeSpec({}, subSpec.style, mainSpec.style), area2.state = mergeSpec({}, subSpec.state, mainSpec.state), isAreaVisible || (area2.style.fill = false), isLineVisible || (area2.style.stroke = false), false === area2.interactive && (area2.style.fillPickable = false), false === line2.interactive && (line2.style.strokePickable = false), area2.interactive = !(!area2.interactive && null !== (_e = line2.interactive) && void 0 !== _e && !_e), area2.visible = !(!isAreaVisible && !isLineVisible), spec.area = area2, spec.line = line2;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/plugin/components/plugin-service
var ComponentPluginService = class extends BasePluginService {
  constructor(component2) {
    super(), this.component = component2;
  }
  releaseAll() {
    super.releaseAll(), this.component = null;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/base/util
function getComponentThemeFromGlobalTheme(type, chartTheme, componentSpec, chartSpec) {
  switch (type) {
    case ComponentTypeEnum.cartesianBandAxis:
      return getCartesianAxisTheme(getOrient(componentSpec, ["z"]), "band", chartTheme);
    case ComponentTypeEnum.cartesianLinearAxis:
      return getCartesianAxisTheme(getOrient(componentSpec, ["z"]), "linear", chartTheme);
    case ComponentTypeEnum.cartesianLogAxis:
      return getCartesianAxisTheme(getOrient(componentSpec, ["z"]), "log", chartTheme);
    case ComponentTypeEnum.cartesianSymlogAxis:
      return getCartesianAxisTheme(getOrient(componentSpec, ["z"]), "symlog", chartTheme);
    case ComponentTypeEnum.cartesianAxis:
    case ComponentTypeEnum.cartesianTimeAxis:
      return getCartesianAxisTheme(getOrient(componentSpec), void 0, chartTheme);
    case ComponentTypeEnum.polarBandAxis:
      return getPolarAxisTheme(componentSpec.orient, "band", chartTheme);
    case ComponentTypeEnum.polarLinearAxis:
      return getPolarAxisTheme(componentSpec.orient, "linear", chartTheme);
    case ComponentTypeEnum.polarAxis:
      return getPolarAxisTheme(componentSpec.orient, void 0, chartTheme);
    case ComponentTypeEnum.cartesianCrosshair:
      return getCartesianCrosshairTheme(chartTheme, chartSpec);
    case ComponentTypeEnum.polarCrosshair:
      return getPolarCrosshairTheme(chartTheme, chartSpec);
    case ComponentTypeEnum.colorLegend:
    case ComponentTypeEnum.sizeLegend:
    case ComponentTypeEnum.discreteLegend:
    case ComponentTypeEnum.dataZoom:
    case ComponentTypeEnum.scrollBar:
      return getComponentThemeWithDirection(componentSpec, getComponentThemeFromOption(type, chartTheme));
    default:
      return getComponentThemeFromOption(type, chartTheme);
  }
}
var getComponentThemeWithDirection = (componentSpec, originalTheme) => {
  var _a;
  const orient = null !== (_a = componentSpec.orient) && void 0 !== _a ? _a : originalTheme.orient, directionTheme = originalTheme[getDirectionByOrient(orient)], finalTheme = mergeSpec({}, originalTheme, directionTheme);
  return delete finalTheme.horizontal, delete finalTheme.vertical, finalTheme;
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/base/base-component-transformer
var BaseComponentSpecTransformer = class extends BaseModelSpecTransformer {
  getTheme(spec, chartSpec) {
    return getComponentThemeFromGlobalTheme(this.type, this._option.getTheme(), spec, chartSpec);
  }
  _mergeThemeToSpec(spec, chartSpec) {
    const { spec: newSpec, theme: theme2 } = super._mergeThemeToSpec(spec, chartSpec);
    return this._adjustPadding(newSpec), {
      spec: newSpec,
      theme: theme2
    };
  }
  _adjustPadding(spec) {
    const { padding, noOuterPadding = true, orient } = spec;
    noOuterPadding && padding && orient && (spec.padding = Object.assign(Object.assign({}, normalizeLayoutPaddingSpec(padding)), {
      [orient]: 0
    }));
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/base/base-component
var __rest10 = function(s2, e) {
  var t = {};
  for (var p in s2)
    Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++)
      e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var BaseComponent = class extends LayoutModel {
  static createComponent(specInfo, options) {
    const { spec } = specInfo, others = __rest10(specInfo, ["spec"]);
    return new this(spec, Object.assign(Object.assign({}, options), others));
  }
  getRegions() {
    return this._regions;
  }
  created() {
    super.created(), this.initLayout(), this.pluginService = new ComponentPluginService(this);
  }
  constructor(spec, options) {
    super(spec, options), this.name = "component", this.modelType = "component", this.transformerConstructor = BaseComponentSpecTransformer, this._delegateEvent = (component2, event, type, item = null, datum = null) => {
      var _a, _b;
      event instanceof CustomEvent || this.event.emit(type, {
        model: this,
        node: component2,
        event,
        item,
        datum,
        source: Event_Source_Type.chart,
        chart: null === (_b = null === (_a = this._option) || void 0 === _a ? void 0 : _a.globalInstance) || void 0 === _b ? void 0 : _b.getChart()
      }, "model");
    }, this._option.animation && (this.animate = new AnimateManager({
      getCompiler: options.getCompiler
    }));
  }
  initLayout() {
    var _a;
    super.initLayout(), this._regions = null !== (_a = this._regions) && void 0 !== _a ? _a : this._option.getRegionsInIndex(), this._layout && (this._layout.layoutBindRegionID = this._regions.map((x) => null == x ? void 0 : x.id));
  }
  changeRegions(regions) {
    throw new Error("Method not implemented.");
  }
  _getNeedClearVRenderComponents() {
    throw new Error("Method not implemented.");
  }
  onRender(ctx) {
    throw new Error("Method not implemented.");
  }
  getVRenderComponents() {
    return this._getNeedClearVRenderComponents();
  }
  callPlugin(cb) {
    this.pluginService && this.pluginService.getAll().forEach((plugin) => cb(plugin));
  }
  getContainer() {
    var _a;
    return this._container || (this._container = null === (_a = this._option) || void 0 === _a ? void 0 : _a.globalInstance.getStage().find((node) => "root" === node.name, true)), this._container;
  }
  _compareSpec(spec, prevSpec) {
    const result2 = super._compareSpec(spec, prevSpec);
    return result2.reMake || (result2.reMake = ["seriesId", "seriesIndex", "regionId", "regionIndex"].some((k2) => !isEqual(null == prevSpec ? void 0 : prevSpec[k2], spec[k2]))), (null == prevSpec ? void 0 : prevSpec.visible) !== spec.visible && (result2.reCompile = true), result2;
  }
  release() {
    var _a;
    super.release(), this.clear(), null === (_a = this.pluginService) || void 0 === _a || _a.releaseAll(), this.pluginService = null;
  }
  clear() {
    var _a;
    const components = this._getNeedClearVRenderComponents();
    components && components.length && components.forEach((c3) => {
      var _a2;
      c3 && (null === (_a2 = this.getContainer()) || void 0 === _a2 || _a2.removeChild(c3), c3 = null);
    }), this._container = null, null === (_a = this.pluginService) || void 0 === _a || _a.clearAll();
  }
  compile() {
    this.compileMarks(), this.reAppendComponents();
  }
  compileMarks(group) {
    this.getMarks().forEach((m4) => {
      var _a;
      m4.compile({
        group
      }), null === (_a = m4.getProduct()) || void 0 === _a || _a.configure({
        context: {
          model: this
        }
      });
    });
  }
  reAppendComponents() {
    const components = this._getNeedClearVRenderComponents();
    components && components.length && components.forEach((c3) => {
      var _a;
      c3 && !c3.stage && (null === (_a = this.getContainer()) || void 0 === _a || _a.appendChild(c3));
    });
  }
  getBoundsInRect(rect, fullRect) {
    return {
      x1: 0,
      x2: 0,
      y1: 0,
      y2: 0
    };
  }
};
BaseComponent.transformerConstructor = BaseComponentSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/mark/component
var ComponentMark = class extends BaseMark {
  constructor(name, option) {
    super(name, option), this.type = "component", this._componentType = option.componentType, this._mode = option.mode;
  }
  _initProduct(group) {
    const view = this.getVGrammarView(), id2 = this.getProductId();
    this._product = view.mark(GrammarMarkType.component, null != group ? group : view.rootMark, {
      componentType: this._componentType,
      mode: this._mode
    }).id(id2), this._compiledProductId = id2;
  }
};
ComponentMark.type = "component";
var registerComponentMark = () => {
  Factory2.registerMark(ComponentMark.type, ComponentMark);
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/data/parser/scale
var scaleParser = (scale4) => scale4;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/axis/base-axis
var __rest11 = function(s2, e) {
  var t = {};
  for (var p in s2)
    Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++)
      e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var AxisComponent = class extends BaseComponent {
  getOrient() {
    return this._orient;
  }
  getScale() {
    return this._scale;
  }
  getScales() {
    return this._scales;
  }
  getTickData(index = 0) {
    return this._tickData[index];
  }
  get visible() {
    return this._visible;
  }
  getInverse() {
    return this._inverse;
  }
  getCoordinateType() {
    return this._coordinateType;
  }
  constructor(spec, options) {
    var _a;
    super(spec, options), this.specKey = "axes", this._scales = [], this._tickData = [], this._visible = true, this._tick = void 0, this._visible = null === (_a = spec.visible) || void 0 === _a || _a, this._coordinateType = "none";
  }
  _getNeedClearVRenderComponents() {
    return [];
  }
  getVRenderComponents() {
    var _a, _b;
    return array(null === (_b = null === (_a = this._axisMark) || void 0 === _a ? void 0 : _a.getProduct()) || void 0 === _b ? void 0 : _b.getGroupGraphicItem());
  }
  created() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s;
    if (super.created(), this.setSeriesAndRegionsFromSpec(), this.initEvent(), this.initScales(), this.updateSeriesScale(), this._shouldComputeTickData() && this._initData(), this._visible) {
      const axisMark = this._createMark({
        type: "component",
        name: `axis-${this.getOrient()}`
      }, {
        componentType: "angle" === this.getOrient() ? "circleAxis" : "axis",
        mode: this._spec.mode,
        noSeparateStyle: true,
        skipTheme: true
      });
      if (this._axisMark = axisMark, axisMark.setZIndex(this.layoutZIndex), isValid_default(this._spec.id) && axisMark.setUserId(this._spec.id), this._marks.addMark(axisMark), null === (_a = this._spec.grid) || void 0 === _a ? void 0 : _a.visible) {
        const gridMark = this._createMark({
          type: "component",
          name: `axis-${this.getOrient()}-grid`
        }, {
          componentType: "angle" === this.getOrient() ? GridEnum.circleAxisGrid : GridEnum.lineAxisGrid,
          mode: this._spec.mode,
          noSeparateStyle: true,
          skipTheme: true
        });
        gridMark.setZIndex(null !== (_f = null !== (_d = null === (_c = null === (_b = this._spec.grid) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.zIndex) && void 0 !== _d ? _d : null === (_e = this._spec.grid) || void 0 === _e ? void 0 : _e.zIndex) && void 0 !== _f ? _f : LayoutZIndex.Axis_Grid), gridMark.setInteractive(false), this._marks.addMark(gridMark), this._gridMark = gridMark;
      }
      if (isBoolean_default(this._spec.interactive) && this._marks.forEach((m4) => m4.setInteractive(this._spec.interactive)), false !== this._option.animation && false !== get_default(this._option.getChart().getSpec(), "animation") && true === this._spec.animation) {
        const axisAnimateConfig = animationConfig(null === (_g = Factory2.getAnimationInKey("axis")) || void 0 === _g ? void 0 : _g(), {
          appear: null !== (_j = null !== (_h = this._spec.animationAppear) && void 0 !== _h ? _h : get_default(this._option.getChart().getSpec(), "animationAppear.axis")) && void 0 !== _j ? _j : get_default(this._option.getChart().getSpec(), "animationAppear"),
          disappear: null !== (_l = null !== (_k = this._spec.animationDisappear) && void 0 !== _k ? _k : get_default(this._option.getChart().getSpec(), "animationDisappear.axis")) && void 0 !== _l ? _l : get_default(this._option.getChart().getSpec(), "animationDisappear"),
          enter: null !== (_o = null !== (_m = this._spec.animationEnter) && void 0 !== _m ? _m : get_default(this._option.getChart().getSpec(), "animationEnter.axis")) && void 0 !== _o ? _o : get_default(this._option.getChart().getSpec(), "animationEnter"),
          exit: null !== (_q = null !== (_p = this._spec.animationExit) && void 0 !== _p ? _p : get_default(this._option.getChart().getSpec(), "animationExit.axis")) && void 0 !== _q ? _q : get_default(this._option.getChart().getSpec(), "animationExit"),
          update: null !== (_s = null !== (_r = this._spec.animationUpdate) && void 0 !== _r ? _r : get_default(this._option.getChart().getSpec(), "animationUpdate.axis")) && void 0 !== _s ? _s : get_default(this._option.getChart().getSpec(), "animationUpdate")
        });
        axisAnimateConfig.enter && (axisAnimateConfig.update[0].customParameters = {
          enter: axisAnimateConfig.enter[0]
        }), this._marks.forEach((m4) => m4.setAnimationConfig(axisAnimateConfig));
      }
    }
  }
  _shouldComputeTickData() {
    return this.getVisible() || this._spec.forceInitTick;
  }
  _initData() {
    const tickData = this._initTickDataSet(this._tickTransformOption());
    tickData.target.addListener("change", this._forceLayout.bind(this)), this._tickData = [new CompilableData(this._option, tickData)];
  }
  collectData(depth, rawData) {
    const data = [];
    return eachSeries(this._regions, (s2) => {
      var _a;
      let field3 = this.collectSeriesField(depth, s2);
      if (field3 = isArray_default(field3) ? isContinuous(this._scale.type) ? field3 : [field3[0]] : [field3], depth || (this._dataFieldText = s2.getFieldAlias(field3[0])), field3) {
        const viewData = s2.getViewData();
        if (rawData)
          field3.forEach((f) => {
            data.push(s2.getRawDataStatisticsByField(f, false));
          });
        else if (viewData && viewData.latestData && viewData.latestData.length) {
          const seriesData = null === (_a = s2.getViewDataStatistics) || void 0 === _a ? void 0 : _a.call(s2);
          field3.forEach((f) => {
            var _a2;
            (null === (_a2 = null == seriesData ? void 0 : seriesData.latestData) || void 0 === _a2 ? void 0 : _a2[f]) && data.push(seriesData.latestData[f]);
          });
        }
      }
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    }), data;
  }
  isSeriesDataEnable() {
    let enable = true;
    return eachSeries(this._regions, (s2) => {
      var _a;
      isArray_default(null === (_a = s2.getViewDataStatistics()) || void 0 === _a ? void 0 : _a.latestData) && (enable = false);
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    }), enable;
  }
  setSeriesAndRegionsFromSpec() {
    const { seriesId, seriesIndex, regionId, regionIndex } = this._spec;
    isValid_default(seriesId) && (this._seriesUserId = array(seriesId)), isValid_default(regionId) && (this._regionUserId = array(regionId)), isValid_default(seriesIndex) && (this._seriesIndex = array(seriesIndex)), isValid_default(regionIndex) && (this._regionIndex = array(regionIndex)), this._regions = this._option.getRegionsInUserIdOrIndex(this._regionUserId, this._regionIndex), this.layout.layoutBindRegionID = this._regions.map((x) => x.id);
  }
  getBindSeriesFilter() {
    return {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    };
  }
  initEvent() {
    this.event.on(ChartEvent.scaleUpdate, {
      filter: ({ model }) => (null == model ? void 0 : model.id) === this.id
    }, this.effect.scaleUpdate.bind(this));
    const viewStatistics = getSeries(this._regions, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    }).map((s2) => s2.getViewDataStatistics()).filter((v) => !!v);
    viewStatistics.length > 1 ? this._option.dataSet.multipleDataViewAddListener(viewStatistics, "change", () => {
      this.updateScaleDomain();
    }) : 1 === viewStatistics.length && viewStatistics[0].target.addListener("change", () => {
      this.updateScaleDomain();
    }), eachSeries(this._regions, (s2) => {
      s2.event.on(ChartEvent.rawDataUpdate, {
        filter: ({ model }) => (null == model ? void 0 : model.id) === s2.id
      }, () => {
        this._clearRawDomain();
      });
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    });
  }
  updateScaleDomain() {
  }
  _clearRawDomain() {
  }
  onLayoutEnd(ctx) {
    this.updateScaleRange();
    this.event.emit(ChartEvent.scaleUpdate, {
      model: this,
      value: "range"
    }), super.onLayoutEnd(ctx);
  }
  computeData(updateType) {
    !this._tickData || !this._tickData.length || "force" !== updateType && isEqual(this._scale.range(), [0, 1]) || this._tickData.forEach((tickData) => {
      tickData.getDataView().reRunAllTransform(), tickData.updateData();
    });
  }
  initScales() {
    this._scales = [this._scale];
    const groups2 = [];
    if (eachSeries(this._regions, (s2) => {
      const g = s2.getGroups();
      g && groups2.push(g);
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    }), 0 !== groups2.length) {
      const depth = maxInArray(groups2.map((g) => g.fields.length));
      for (let i = 1; i < depth; i++) {
        const scale4 = this._scale.clone();
        this._scales.push(scale4);
      }
    }
  }
  _compareSpec(spec, prevSpec) {
    const result2 = super._compareSpec(spec, prevSpec);
    return result2.reRender = true, (null == prevSpec ? void 0 : prevSpec.type) !== (null == spec ? void 0 : spec.type) ? (result2.reMake = true, result2) : result2;
  }
  _delegateAxisContainerEvent(component2) {
    0 === component2.listenerCount("*") && component2.addEventListener("*", (event, type) => this._delegateEvent(component2, event, type));
  }
  _getAxisAttributes() {
    const spec = this._spec, axisAttrs = {
      orient: this.getOrient(),
      select: true !== this._option.disableTriggerEvent && spec.select,
      hover: true !== this._option.disableTriggerEvent && spec.hover
    };
    if (spec.domainLine && spec.domainLine.visible ? axisAttrs.line = transformAxisLineStyle(spec.domainLine) : axisAttrs.line = {
      visible: false
    }, spec.label && spec.label.visible) {
      const labelSpec = pickWithout(spec.label, ["style", "formatMethod", "state"]);
      axisAttrs.label = labelSpec, spec.label.style && (axisAttrs.label.style = isFunction_default(spec.label.style) ? (datum, index, data, layer) => {
        var _a;
        const style = spec.label.style(datum.rawValue, index, datum, data, layer);
        return transformToGraphic(mergeSpec({}, null === (_a = this._theme.label) || void 0 === _a ? void 0 : _a.style, style));
      } : transformToGraphic(spec.label.style)), (spec.label.formatMethod || spec.label.formatter) && (axisAttrs.label.formatMethod = this._getLabelFormatMethod()), spec.label.state && (axisAttrs.label.state = transformAxisLabelStateStyle(spec.label.state));
    } else
      axisAttrs.label = {
        visible: false
      };
    if (spec.tick && spec.tick.visible ? (axisAttrs.tick = {
      visible: spec.tick.visible,
      length: spec.tick.tickSize,
      inside: spec.tick.inside,
      alignWithLabel: spec.tick.alignWithLabel,
      dataFilter: spec.tick.dataFilter
    }, spec.tick.style && (axisAttrs.tick.style = isFunction_default(spec.tick.style) ? (value, index, datum, data) => {
      var _a;
      const style = spec.tick.style(value, index, datum, data);
      return transformToGraphic(mergeSpec({}, null === (_a = this._theme.tick) || void 0 === _a ? void 0 : _a.style, style));
    } : transformToGraphic(spec.tick.style)), spec.tick.state && (axisAttrs.tick.state = transformStateStyle(spec.tick.state))) : axisAttrs.tick = {
      visible: false
    }, spec.subTick && spec.subTick.visible ? (axisAttrs.subTick = {
      visible: spec.subTick.visible,
      length: spec.subTick.tickSize,
      inside: spec.subTick.inside,
      count: spec.subTick.tickCount
    }, spec.subTick.style && (axisAttrs.subTick.style = isFunction_default(spec.subTick.style) ? (value, index, datum, data) => {
      var _a;
      const style = spec.subTick.style(value, index, datum, data);
      return transformToGraphic(mergeSpec({}, null === (_a = this._theme.subTick) || void 0 === _a ? void 0 : _a.style, style));
    } : transformToGraphic(spec.subTick.style)), spec.subTick.state && (axisAttrs.subTick.state = transformStateStyle(spec.subTick.state))) : axisAttrs.subTick = {
      visible: false
    }, spec.title && spec.title.visible) {
      const _a = spec.title, { autoRotate: autoRotate2, angle: angle2, style: titleStyle = {}, background: titleBackgroundSpec, state: titleState, shape: titleShapeSpec } = _a, restTitleAttrs = __rest11(_a, ["autoRotate", "angle", "style", "background", "state", "shape"]);
      let titleTextStyle, titleAngle = angle2;
      "left" !== spec.orient && "right" !== spec.orient || autoRotate2 && isNil_default(titleAngle) && (titleAngle = "left" === spec.orient ? -90 : 90, titleTextStyle = DEFAULT_TITLE_STYLE[spec.orient]), axisAttrs.title = Object.assign(Object.assign({}, restTitleAttrs), {
        autoRotate: false,
        angle: titleAngle ? degreeToRadian(titleAngle) : null,
        textStyle: mergeSpec({}, titleTextStyle, transformToGraphic(titleStyle)),
        pickable: false !== titleStyle.pickable,
        childrenPickable: false !== titleStyle.pickable,
        state: {}
      }), titleShapeSpec && titleShapeSpec.visible ? (axisAttrs.title.shape = Object.assign(Object.assign({}, titleShapeSpec), {
        style: transformToGraphic(titleShapeSpec.style)
      }), titleShapeSpec.state && (axisAttrs.title.state.shape = transformStateStyle(titleShapeSpec.state))) : axisAttrs.title.shape = {
        visible: false
      }, titleBackgroundSpec && titleBackgroundSpec.visible ? (axisAttrs.title.background = Object.assign(Object.assign({}, titleBackgroundSpec), {
        style: transformToGraphic(titleBackgroundSpec.style)
      }), titleBackgroundSpec.state && (axisAttrs.title.state.background = transformStateStyle(titleBackgroundSpec.state))) : axisAttrs.title.background = {
        visible: false
      }, titleState && (axisAttrs.title.state.text = transformStateStyle(titleState));
    } else
      axisAttrs.title = {
        visible: false
      };
    return spec.background && spec.background.visible ? (axisAttrs.panel = {
      visible: true
    }, spec.background.style && (axisAttrs.panel.style = transformToGraphic(spec.background.style)), spec.background.state && (axisAttrs.panel.state = transformStateStyle(spec.background.state))) : axisAttrs.panel = {
      visible: false
    }, axisAttrs;
  }
  _getGridAttributes() {
    const spec = this._spec;
    return {
      alternateColor: spec.grid.alternateColor,
      alignWithLabel: spec.grid.alignWithLabel,
      style: isFunction_default(spec.grid.style) ? () => (datum, index) => {
        var _a, _b;
        const style = spec.grid.style(null === (_a = datum.datum) || void 0 === _a ? void 0 : _a.rawValue, index, datum.datum);
        return transformToGraphic(mergeSpec({}, null === (_b = this._theme.grid) || void 0 === _b ? void 0 : _b.style, style));
      } : transformToGraphic(spec.grid.style),
      subGrid: false === spec.subGrid.visible ? {
        visible: false
      } : {
        type: "line",
        visible: spec.subGrid.visible,
        alternateColor: spec.subGrid.alternateColor,
        style: transformToGraphic(spec.subGrid.style)
      }
    };
  }
  _getLabelFormatMethod() {
    const { formatMethod, formatter } = this._spec.label, { formatFunc } = getFormatFunction(formatMethod, formatter);
    return formatFunc ? (value, datum, index) => formatFunc(datum.rawValue, datum, formatter) : null;
  }
  _initTickDataSet(options, index = 0) {
    registerDataSetInstanceParser(this._option.dataSet, "scale", scaleParser), registerDataSetInstanceTransform(this._option.dataSet, "ticks", ticks3);
    return new DataView(this._option.dataSet, {
      name: `${this.type}_${this.id}_ticks_${index}`
    }).parse(this._scales[index], {
      type: "scale"
    }).transform({
      type: "ticks",
      options
    }, false);
  }
  _tickTransformOption() {
    const tick = this._tick || {}, label = this._spec.label || {}, { tickCount, forceTickCount, tickStep: tickStep2, tickMode } = tick, { style: labelStyle, formatMethod: labelFormatter, minGap: labelGap } = label;
    return {
      sampling: false !== this._spec.sampling,
      tickCount,
      forceTickCount,
      tickStep: tickStep2,
      tickMode,
      axisOrientType: this._orient,
      coordinateType: this._coordinateType,
      labelStyle,
      labelFormatter,
      labelGap
    };
  }
  addTransformToTickData(options, execute) {
    this._tickData.forEach((tickData) => {
      var _a;
      null === (_a = null == tickData ? void 0 : tickData.getDataView()) || void 0 === _a || _a.transform(options, execute);
    });
  }
  dataToPosition(values) {
    return this._scale.scale(values);
  }
};
AxisComponent.specKey = "axes";
var registerAxis2 = () => {
  registerAxis(), registerGrid(), registerComponentMark(), Factory2.registerAnimation("axis", () => ({
    appear: {
      custom: GroupFadeIn
    },
    update: {
      custom: GroupTransition
    },
    exit: {
      custom: GroupFadeOut
    }
  }));
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/axis/cartesian/axis
var __rest12 = function(s2, e) {
  var t = {};
  for (var p in s2)
    Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++)
      e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var CartesianAxisPlugin = [AxisSyncPlugin];
var CartesianAxis = class extends AxisComponent {
  getOrient() {
    return this._orient;
  }
  set autoIndentOnce(v) {
    this._autoIndentOnce = v;
  }
  getScales() {
    return this._scales;
  }
  constructor(spec, options) {
    super(spec, options), this.type = ComponentTypeEnum.cartesianAxis, this.name = ComponentTypeEnum.cartesianAxis, this._defaultBandPosition = 0.5, this._defaultBandInnerPadding = 0.1, this._defaultBandOuterPadding = 0.3, this.layoutType = "region-relative", this.layoutZIndex = LayoutZIndex.Axis, this.layoutLevel = LayoutLevel2.Axis, this._orient = "left", this._autoIndentOnce = false, this._hasAutoIndent = false, this._scales = [], this._tick = void 0, this._layoutCache = {
      width: 0,
      height: 0,
      _lastComputeOutBounds: {
        x1: 0,
        x2: 0,
        y1: 0,
        y2: 0
      }
    }, this._innerOffset = {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    }, this.effect = {
      scaleUpdate: (params2) => {
        this.computeData(null == params2 ? void 0 : params2.value), eachSeries(this._regions, (s2) => {
          const orient = this.getOrient();
          isXAxis(orient) ? s2.setXAxisHelper(this.axisHelper()) : isYAxis(orient) ? s2.setYAxisHelper(this.axisHelper()) : isZAxis(orient) && s2.setZAxisHelper(this.axisHelper());
        }, {
          userId: this._seriesUserId,
          specIndex: this._seriesIndex
        });
      }
    }, this._transformLayoutPosition = (pos) => {
      let { x, y } = pos;
      return isValidNumber_default(x) && (x += Number("left" === this._orient) * this.getLayoutRect().width), isValidNumber_default(y) && (y += Number("top" === this._orient) * this.getLayoutRect().height), {
        x,
        y
      };
    }, this._transformLayoutRect = (result2) => {
      if (!this._visible)
        return result2;
      const bounds = this._latestBounds.clone().translate(-this.getLayoutStartPoint().x, -this.getLayoutStartPoint().y);
      switch (this._layout.layoutOrient) {
        case "left":
          this._layout.layoutRectLevelMap.width === DEFAULT_LAYOUT_RECT_LEVEL && (result2.width = bounds.x1 < 0 ? -bounds.x1 : 0);
          break;
        case "right":
          this._layout.layoutRectLevelMap.width === DEFAULT_LAYOUT_RECT_LEVEL && (result2.width = bounds.x2 > 0 ? bounds.x2 : 0);
          break;
        case "top":
          this._layout.layoutRectLevelMap.height === DEFAULT_LAYOUT_RECT_LEVEL && (result2.height = bounds.y1 < 0 ? -bounds.y1 : 0);
          break;
        case "bottom":
          this._layout.layoutRectLevelMap.height === DEFAULT_LAYOUT_RECT_LEVEL && (result2.height = bounds.y2 > 0 ? bounds.y2 : 0);
      }
      return result2.width = Math.ceil(result2.width), result2.height = Math.ceil(result2.height), this._layout.setRectInSpec(this._layoutCacheProcessing(result2));
    }, this._updateAxisLayout = () => {
      const startPoint = this.getLayoutStartPoint(), _a = this._getUpdateAttribute(false), { grid: updateGridAttrs } = _a, updateAxisAttrs = __rest12(_a, ["grid"]), axisProduct = this._axisMark.getProduct(), axisAttrs = mergeSpec({
        x: startPoint.x,
        y: startPoint.y
      }, this._axisStyle, updateAxisAttrs);
      if (axisProduct.encode(axisAttrs), this._gridMark) {
        this._gridMark.getProduct().encode(mergeSpec({
          x: startPoint.x,
          y: startPoint.y
        }, this._getGridAttributes(), updateGridAttrs));
      }
    }, this._fixAxisOnZero = () => {
      const { onZero, visible } = this._spec.domainLine;
      if (this.visible && onZero && false !== visible) {
        const { onZeroAxisId, onZeroAxisIndex } = this._spec.domainLine, axesComponents = this._option.getComponentsByKey("axes"), isX = isXAxis(this.getOrient()), isValidAxis = (item) => {
          var _a;
          return (isX ? !isXAxis(item.getOrient()) : isXAxis(item.getOrient())) && isContinuous(item.getScale().type) && (item.getTickData() ? null === (_a = item.getTickData().getLatestData()) || void 0 === _a ? void 0 : _a.find((d) => 0 === d.value) : item.getScale().domain()[0] <= 0 && item.getScale().domain()[1] >= 0);
        }, relativeAxes = axesComponents.filter((item) => isValidAxis(item));
        if (relativeAxes.length) {
          let bindAxis;
          if (isValid_default(onZeroAxisId))
            bindAxis = relativeAxes.find((axis2) => axis2.id === onZeroAxisId);
          else if (isValid_default(onZeroAxisIndex)) {
            const indexAxis = axesComponents[onZeroAxisIndex];
            isValidAxis(indexAxis) && (bindAxis = indexAxis);
          } else
            bindAxis = relativeAxes[0];
          if (bindAxis) {
            const axisMark = this._axisMark.getProduct(), position = bindAxis.valueToPosition(0);
            isX ? axisMark.encode({
              line: Object.assign(Object.assign({}, this._axisStyle.line), {
                dy: "bottom" === this._orient ? -(bindAxis.getScale().range()[0] - position) : position
              })
            }) : axisMark.encode({
              line: Object.assign(Object.assign({}, this._axisStyle.line), {
                dx: "left" === this._orient ? position : -(bindAxis.getScale().range()[1] - position)
              })
            });
          }
        }
      }
    }, this._orient = getOrient(spec, ["z"]), isZAxis(this._orient) && (this.layoutType = "absolute"), this._dataSet = options.dataSet, this._coordinateType = "cartesian";
  }
  static getSpecInfo(chartSpec) {
    const axesSpec = chartSpec[this.specKey];
    if (!axesSpec)
      return null;
    const isHorizontal3 = "horizontal" === chartSpec.direction;
    if (!isArray_default(axesSpec)) {
      if (!isValidCartesianAxis(axesSpec))
        return null;
      const { axisType, componentName } = getCartesianAxisInfo(axesSpec, isHorizontal3);
      return axesSpec.type = axisType, [{
        spec: axesSpec,
        specPath: [this.specKey],
        specInfoPath: ["component", this.specKey, 0],
        type: componentName
      }];
    }
    let valid = true;
    if (axesSpec.filter((s2) => "z" === s2.orient)[0]) {
      const xAxis = axesSpec.filter((s2) => "bottom" === s2.orient)[0], yAxis = axesSpec.filter((s2) => isYAxis(s2.orient))[0];
      valid = 3 === axesSpec.length && xAxis && yAxis;
    }
    let axesSpecList = axesSpec.map((spec, index) => ({
      spec,
      index
    }));
    valid || (axesSpecList = axesSpecList.filter(({ spec }) => "z" !== spec.orient));
    const specInfos = [];
    return axesSpecList.forEach(({ spec, index }) => {
      if (!isValidCartesianAxis(spec))
        return;
      const { axisType, componentName } = getCartesianAxisInfo(spec, isHorizontal3);
      spec.type = axisType, specInfos.push({
        spec,
        specPath: [this.specKey, index],
        specInfoPath: ["component", this.specKey, index],
        type: componentName
      });
    }), specInfos;
  }
  static createComponent(specInfo, options) {
    const { spec } = specInfo, others = __rest12(specInfo, ["spec"]), C = Factory2.getComponentInKey(others.type);
    return C ? new C(spec, Object.assign(Object.assign({}, options), others)) : (options.onError(`Component ${others.type} not found`), null);
  }
  initLayout() {
    super.initLayout(), this._layout.autoIndent = false !== this._spec.autoIndent, this._layout.layoutOrient = this._orient;
  }
  setLayout3dBox(box3d) {
    this.layout3dBox = box3d;
  }
  updateScaleRange() {
    let isScaleChange = false;
    const { width, height } = this.getLayoutRect(), { left: left2, right: right2, top, bottom } = this._innerOffset;
    let newRange = [];
    isXAxis(this.getOrient()) ? isValidNumber_default(width) && (newRange = this._inverse ? [width - right2, left2] : [left2, width - right2]) : isZAxis(this.getOrient()) ? isValidNumber_default(width) && (newRange = this._inverse ? [width - right2, left2] : [left2, width - right2], this._scale.range(newRange)) : isValidNumber_default(height) && (newRange = this._inverse ? [top, height - bottom] : [height - bottom, top]);
    const [start, end] = this._scale.range();
    return newRange[0] === start && newRange[1] === end || (isScaleChange = true, this._scale.range(newRange)), isScaleChange;
  }
  init(option) {
    var _a;
    super.init(option), null === (_a = this.pluginService) || void 0 === _a || _a.load(CartesianAxisPlugin.map((P) => new P())), this.callPlugin((plugin) => {
      this.pluginService && plugin.onInit && plugin.onInit(this.pluginService, this);
    });
  }
  setAttrFromSpec() {
    var _a;
    if (super.setAttrFromSpec(), this.visible) {
      isXAxis(this.getOrient()) ? isUndefined_default(this._spec.maxHeight) && (this._spec.maxHeight = "30%") : isUndefined_default(this._spec.maxWidth) && (this._spec.maxWidth = "30%");
      const axisStyle = this._getAxisAttributes();
      axisStyle.label.formatMethod = this._getLabelFormatMethod(), axisStyle.verticalFactor = "top" === this.getOrient() || "right" === this.getOrient() ? -1 : 1, this._axisStyle = axisStyle;
    }
    this._tick = this._spec.tick;
    const chartSpec = null === (_a = this._option.getChart()) || void 0 === _a ? void 0 : _a.getSpec();
    this._inverse = transformInverse(this._spec, "horizontal" === (null == chartSpec ? void 0 : chartSpec.direction));
  }
  onLayoutStart(layoutRect, viewRect, ctx) {
    if (super.onLayoutStart(layoutRect, viewRect, ctx), !isZAxis(this.getOrient()) && this._spec.innerOffset) {
      const spec = this._spec;
      isYAxis(this.getOrient()) ? ["top", "bottom"].forEach((orient) => {
        this._innerOffset[orient] = calcLayoutNumber(spec.innerOffset[orient], viewRect.height, viewRect);
      }) : ["left", "right"].forEach((orient) => {
        this._innerOffset[orient] = calcLayoutNumber(spec.innerOffset[orient], viewRect.width, viewRect);
      });
    }
  }
  getSeriesStatisticsField(s2) {
    let f;
    return f = isXAxis(this.getOrient()) ? s2.fieldX : isZAxis(this.getOrient()) ? s2.fieldZ : s2.fieldY, isContinuous(this._scale.type) ? f : [f[0]];
  }
  _tickTransformOption() {
    var _a, _b, _c;
    return Object.assign(Object.assign({}, super._tickTransformOption()), {
      noDecimals: null === (_a = this._tick) || void 0 === _a ? void 0 : _a.noDecimals,
      labelLastVisible: null === (_b = this._spec.label) || void 0 === _b ? void 0 : _b.lastVisible,
      labelFlush: null === (_c = this._spec.label) || void 0 === _c ? void 0 : _c.flush
    });
  }
  axisHelper() {
    return {
      isContinuous: isContinuous(this._scale.type),
      dataToPosition: this.dataToPosition.bind(this),
      getScale: (depth = 0) => this._scales[depth],
      getAxisType: () => this.type,
      getAxisId: () => this.id,
      isInverse: () => true === this._inverse,
      getSpec: () => this._spec
    };
  }
  afterCompile() {
    var _a;
    const product = null === (_a = this._axisMark) || void 0 === _a ? void 0 : _a.getProduct();
    product && product.addEventListener(HOOK_EVENT.AFTER_ELEMENT_ENCODE, () => {
      if (false === this._isLayout && (isXAxis(this.getOrient()) ? this.callPlugin((plugin) => {
        this.pluginService && plugin.onDidLayoutHorizontal && plugin.onDidLayoutHorizontal(this.pluginService, this);
      }) : this.callPlugin((plugin) => {
        this.pluginService && plugin.onDidLayoutVertical && plugin.onDidLayoutVertical(this.pluginService, this);
      }), this._delegateAxisContainerEvent(product.getGroupGraphicItem()), this._unitText)) {
        const { x, y } = this.getLayoutStartPoint(), pos = isXAxis(this._orient) ? {
          x: maxInArray(this._scale.range()) + x,
          y
        } : {
          x,
          y: minInArray(this._scale.range()) + y
        };
        this._unitText.setAttributes(pos);
      }
    }), this.callPlugin((plugin) => {
      this.pluginService && plugin.onDidCompile && plugin.onDidCompile(this.pluginService, this);
    });
  }
  onRender(ctx) {
  }
  changeRegions(regions) {
  }
  update(ctx) {
  }
  resize(ctx) {
  }
  collectScale() {
    const scales = [];
    return eachSeries(this._regions, (s2) => {
      scales.push("left" === this.getOrient() || "right" === this.getOrient() ? s2.scaleY : s2.scaleX);
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    }), scales;
  }
  collectSeriesField(depth, series2) {
    var _a, _b;
    let field3;
    return field3 = depth > 0 ? null === (_b = null === (_a = series2.getGroups()) || void 0 === _a ? void 0 : _a.fields) || void 0 === _b ? void 0 : _b[depth] : isXAxis(this.getOrient()) ? series2.getSpec().x2Field ? [...series2.fieldX, series2.fieldX2] : series2.fieldX : isZAxis(this.getOrient()) ? series2.fieldZ : series2.getSpec().y2Field ? [...series2.fieldY, series2.fieldY2] : series2.fieldY, field3;
  }
  updateSeriesScale() {
    const orient = this.getOrient();
    eachSeries(this._regions, (s2) => {
      isXAxis(orient) ? (s2.setScaleX(this._scale), s2.setXAxisHelper(this.axisHelper())) : isYAxis(orient) ? (s2.setScaleY(this._scale), s2.setYAxisHelper(this.axisHelper())) : isZAxis(orient) && (s2.setScaleZ(this._scale), s2.setZAxisHelper(this.axisHelper()));
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    });
  }
  getBoundsInRect(rect) {
    var _a;
    let result2 = {
      x1: 0,
      y1: 0,
      x2: 0,
      y2: 0
    };
    if (!this._visible)
      return result2;
    this._verticalLimitSize = isXAxis(this.getOrient()) ? rect.height : rect.width, this.setLayoutRect(rect);
    !this.updateScaleRange() && isArray_default(null === (_a = this.getTickData()) || void 0 === _a ? void 0 : _a.getLatestData()) || this.computeData("range");
    const context = {
      skipLayout: false
    }, isX = isXAxis(this.getOrient());
    this.pluginService && (isX ? this.callPlugin((plugin) => {
      plugin.onWillLayoutHorizontal && plugin.onWillLayoutHorizontal(this.pluginService, context, this);
    }) : this.callPlugin((plugin) => {
      plugin.onWillLayoutVertical && plugin.onWillLayoutVertical(this.pluginService, context, this);
    }));
    const product = this._axisMark.getProduct();
    let hasBounds2 = false;
    if (!context.skipLayout) {
      const attrs = this._getUpdateAttribute(true), axisComponent = product.getGroupGraphicItem(), spec = mergeSpec(Object.assign({}, this.getLayoutStartPoint()), this._axisStyle, attrs, {
        line: {
          visible: false
        }
      }), updateBounds = axisComponent.getBoundsWithoutRender(spec);
      hasBounds2 = true, this._latestBounds = updateBounds, isFinite(updateBounds.width()) && (result2 = this._appendAxisUnit(updateBounds, isX));
    }
    return hasBounds2 || (this._latestBounds = product.getBounds()), result2;
  }
  _getTitleLimit(isX) {
    var _a, _b, _c, _d, _e;
    if (this._spec.title.visible && isNil_default(null === (_a = this._spec.title.style) || void 0 === _a ? void 0 : _a.maxLineWidth)) {
      const angle2 = null !== (_e = null !== (_c = null === (_b = this._axisStyle.title) || void 0 === _b ? void 0 : _b.angle) && void 0 !== _c ? _c : null === (_d = this._spec.title.style) || void 0 === _d ? void 0 : _d.angle) && void 0 !== _e ? _e : 0;
      if (isX) {
        const width = this.getLayoutRect().width, cosValue = Math.abs(Math.cos(angle2));
        return cosValue < 1e-6 ? 1 / 0 : width / cosValue;
      }
      const height = this.getLayoutRect().height, sinValue = Math.abs(Math.sin(angle2));
      return sinValue < 1e-6 ? 1 / 0 : height / sinValue;
    }
    return null;
  }
  _getUpdateAttribute(ignoreGrid) {
    var _a;
    let regionHeight = 0, regionWidth = 0;
    if (!ignoreGrid) {
      const regions = this.getRegions();
      let { x: minX, y: minY } = regions[0].getLayoutStartPoint(), maxX = minX + regions[0].getLayoutRect().width, maxY = minY + regions[0].getLayoutRect().height;
      for (let index = 1; index < regions.length; index++) {
        const region = regions[index], { x, y } = region.getLayoutStartPoint(), { width: width2, height: height2 } = region.getLayoutRect();
        minX = Math.min(minX, x), maxX = Math.max(maxX, width2 + x), minY = Math.min(minY, y), maxY = Math.max(maxY, height2 + y);
      }
      regionHeight = Math.abs(maxY - minY), regionWidth = Math.abs(maxX - minX);
    }
    const { width, height } = this.getLayoutRect(), isX = isXAxis(this._orient), isY = isYAxis(this._orient), isZ = isZAxis(this._orient);
    let end = {
      x: 0,
      y: 0
    }, gridLength = 0, axisLength = 0;
    const depth = this.layout3dBox ? this.layout3dBox.length : 0;
    if (isX ? (end = {
      x: width,
      y: 0
    }, gridLength = regionHeight, axisLength = width) : isY && (end = {
      x: 0,
      y: height
    }, gridLength = regionWidth, axisLength = height), isZ) {
      const directionStr = null !== (_a = this.directionStr) && void 0 !== _a ? _a : "r2l", depthZ = this.layout3dBox ? this.layout3dBox.width : 0;
      let anchor3d = [0, 0], alpha = -Math.PI / 2, z = 0;
      "l2r" === directionStr && (z = this.layout3dBox.length, anchor3d = [0, 0, 0], alpha = Math.PI / 2);
      const items2 = this.getLabelItems(width), axisAttrs = {
        start: {
          x: 0,
          y: 0
        },
        end: {
          x: depth,
          y: 0
        },
        z,
        alpha,
        anchor3d,
        title: {
          text: this._spec.title.text || this._dataFieldText,
          maxWidth: this._getTitleLimit(isX)
        },
        items: items2
      };
      return ignoreGrid || (axisAttrs.grid = {
        type: "line",
        start: {
          x: 0,
          y: 0
        },
        end: {
          x: depth,
          y: 0
        },
        items: items2[0],
        verticalFactor: this._axisStyle.verticalFactor,
        depth: depthZ,
        length: regionHeight,
        z,
        alpha,
        anchor3d
      }), axisAttrs;
    }
    let verticalMinSize = isX ? this.layout.minHeight : this.layout.minWidth;
    (isX && this._layout.layoutRectLevelMap.height === USER_LAYOUT_RECT_LEVEL || isY && this._layout.layoutRectLevelMap.width === USER_LAYOUT_RECT_LEVEL) && (verticalMinSize = this._verticalLimitSize);
    const items = this.getLabelItems(axisLength), attrs = {
      start: {
        x: 0,
        y: 0
      },
      end,
      title: {
        text: this._spec.title.text || this._dataFieldText,
        maxWidth: this._getTitleLimit(isX)
      },
      items,
      verticalLimitSize: this._verticalLimitSize,
      verticalMinSize
    };
    return ignoreGrid || (attrs.grid = {
      type: "line",
      start: {
        x: 0,
        y: 0
      },
      end,
      items: items[0],
      verticalFactor: this._axisStyle.verticalFactor,
      depth,
      length: gridLength
    }), attrs;
  }
  getLabelItems(length2) {
    var _a;
    const tickLatestData = null === (_a = this.getTickData()) || void 0 === _a ? void 0 : _a.getLatestData();
    return tickLatestData && tickLatestData.length ? [tickLatestData.map((obj) => {
      const normalizedValue = this._getNormalizedValue([obj.value], length2);
      return getAxisItem(obj.value, normalizedValue);
    }).filter((entry) => entry.value >= 0 && entry.value <= 1)] : [];
  }
  initEvent() {
    super.initEvent(), this.visible && (this.event.on(ChartEvent.layoutEnd, this._updateAxisLayout), this.event.on(ChartEvent.layoutEnd, this._fixAxisOnZero), this.event.on(ChartEvent.layoutRectUpdate, () => {
      this._clearLayoutCache();
    }));
  }
  _getNormalizedValue(values, length2) {
    return 0 === length2 ? 0 : this.dataToPosition(values) / length2;
  }
  _layoutCacheProcessing(rect) {
    return ["width", "height"].forEach((key) => {
      rect[key] < this._layoutCache[key] ? rect[key] = this._layoutCache[key] : this._layoutCache[key] = rect[key];
    }), this._autoIndentOnce && this._hasAutoIndent ? ["x1", "x2", "y1", "y2"].forEach((key) => {
      this.layout.getLastComputeOutBounds()[key] = this._layoutCache._lastComputeOutBounds[key];
    }) : (this._hasAutoIndent = true, ["x1", "x2", "y1", "y2"].forEach((key) => {
      this.layout.getLastComputeOutBounds()[key] < this._layoutCache._lastComputeOutBounds[key] ? this.layout.getLastComputeOutBounds()[key] = this._layoutCache._lastComputeOutBounds[key] : this._layoutCache._lastComputeOutBounds[key] = this.layout.getLastComputeOutBounds()[key];
    })), rect;
  }
  _clearLayoutCache() {
    this._hasAutoIndent = false, this._layoutCache.width = 0, this._layoutCache.height = 0, this._layoutCache._lastComputeOutBounds = {
      x1: 0,
      x2: 0,
      y1: 0,
      y2: 0
    };
  }
  onDataUpdate() {
    this._clearLayoutCache();
  }
  _appendAxisUnit(bounds, isX) {
    var _a;
    if (this._spec.unit && this._spec.unit.visible) {
      const { text: text2, style } = this._spec.unit;
      let pos, unitTextStyle;
      const { x, y } = this.getLayoutStartPoint();
      isX ? (pos = {
        x: maxInArray(this._scale.range()) + x,
        y
      }, unitTextStyle = {
        textAlign: "left",
        textBaseline: "middle"
      }) : (pos = {
        x,
        y: minInArray(this._scale.range()) + y
      }, unitTextStyle = {
        textAlign: "left" === this._orient ? "left" : "right",
        textBaseline: "bottom"
      }), unitTextStyle = Object.assign(Object.assign(Object.assign({}, unitTextStyle), style), {
        x: pos.x,
        y: pos.y,
        text: text2
      }), this._unitText ? this._unitText.setAttributes(unitTextStyle) : (this._unitText = createText(unitTextStyle), this._unitText.name = "axis-unit", null === (_a = this.getContainer()) || void 0 === _a || _a.add(this._unitText));
      const textBounds = this._unitText.AABBBounds;
      isX ? (bounds.x2 += textBounds.x2 > bounds.x2 ? textBounds.x2 - bounds.x2 : 0, bounds.y2 += textBounds.y2 > bounds.y2 ? textBounds.y2 - bounds.y2 : 0) : (bounds.x1 += textBounds.x1 < bounds.x1 ? textBounds.x1 - bounds.x1 : 0, bounds.y1 += textBounds.y1 < bounds.y1 ? textBounds.y1 - bounds.y1 : 0);
    }
    return bounds;
  }
  _getNeedClearVRenderComponents() {
    return this._unitText ? [this._unitText] : [];
  }
};
CartesianAxis.type = ComponentTypeEnum.cartesianAxis, CartesianAxis.specKey = "axes";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/axis/mixin/linear-axis-mixin
var e103 = Math.sqrt(50);
var e53 = Math.sqrt(10);
var e23 = Math.sqrt(2);
var LinearAxisMixin = class {
  constructor() {
    this._extend = {}, this.niceLabelFormatter = null;
  }
  setExtraAttrFromSpec() {
    isValid_default(this._spec.nice) && (this._nice = this._spec.nice), isValid_default(this._spec.zero) && (this._zero = this._spec.zero), this._expand = this._spec.expand, this._domain = getLinearAxisSpecDomain(this._spec);
  }
  transformScaleDomain() {
    this.setScaleNice();
  }
  setLinearScaleNice() {
    var _a;
    if (!this._nice)
      return false;
    let tickCount = 5;
    const tick = this._spec.tick || {};
    if (isValidNumber_default(tick.forceTickCount))
      tickCount = tick.forceTickCount;
    else if (isFunction_default(tick.tickCount)) {
      const range2 = this._scale.range();
      let rangeSize = Math.abs(range2[range2.length - 1] - range2[0]);
      if (1 === rangeSize && this._option) {
        rangeSize = isXAxis(this._orient) ? this._option.getChartViewRect().width : this._option.getChartViewRect().height;
      }
      tickCount = tick.tickCount({
        rangeSize,
        labelStyle: this._spec.label && this._spec.label.style
      });
    } else
      tickCount = isValidNumber_default(tick.tickCount) ? tick.tickCount : 5;
    "accurateFirst" === this._spec.niceType && (tickCount = Math.max(5, tickCount));
    const { min: min3, max: max3 } = null !== (_a = this._domain) && void 0 !== _a ? _a : {};
    return isNil_default(min3) && isNil_default(max3) && isNil_default(this._softMaxValue) && isNil_default(this._softMinValue) ? this._scale.nice(tickCount) : (isValid_default(min3) || isValid_default(this._softMinValue)) && isNil_default(max3) && isNil_default(this._softMaxValue) ? this._scale.niceMax(tickCount) : !(!isNil_default(min3) || !isNil_default(this._softMinValue) || !isValid_default(max3) && !isValid_default(this._softMaxValue)) && this._scale.niceMin(tickCount);
  }
  setLogScaleNice() {
    var _a;
    if (!this._nice)
      return false;
    const { min: min3, max: max3 } = null !== (_a = this._domain) && void 0 !== _a ? _a : {};
    return isNil_default(min3) && isNil_default(max3) && isNil_default(this._softMaxValue) && isNil_default(this._softMinValue) ? this._scale.nice() : (isValid_default(min3) || isValid_default(this._softMinValue)) && isNil_default(max3) && isNil_default(this._softMaxValue) ? this._scale.niceMax() : !(!isNil_default(min3) || !isNil_default(this._softMinValue) || !isValid_default(max3) && !isValid_default(this._softMaxValue)) && this._scale.niceMin();
  }
  setScaleNice() {
    return "log" === this._spec.type ? this.setLogScaleNice() : this.setLinearScaleNice();
  }
  dataToPosition(values, cfg) {
    return this.valueToPosition(values[0]);
  }
  valueToPosition(value) {
    return this._scale.scale(value);
  }
  computeLinearDomain(data) {
    const domain = [];
    return data.length ? data.forEach((d) => {
      const { min: min3, max: max3 } = d;
      domain[0] = void 0 === domain[0] ? min3 : Math.min(domain[0], min3), domain[1] = void 0 === domain[1] ? max3 : Math.max(domain[1], max3);
    }) : (domain[0] = 0, domain[1] = 0), this.setSoftDomainMinMax(domain), this.expandDomain(domain), this.includeZero(domain), this.setDomainMinMax(domain), domain;
  }
  expandDomain(domain) {
    if (!this._expand)
      return;
    let domainMin = domain[0], domainMax = domain[domain.length - 1];
    domainMin === domainMax && (0 === domainMax ? domainMax = 1 : domainMax > 0 ? domainMin = 0 : domainMax < 0 && (domainMax = 0)), isValid_default(this._expand.min) && (domain[0] = domainMin - (domainMax - domainMin) * this._expand.min), isValid_default(this._expand.max) && (domain[domain.length - 1] = domainMax + (domainMax - domainMin) * this._expand.max);
  }
  niceDomain(domain) {
    const { min: userMin, max: userMax } = getLinearAxisSpecDomain(this._spec);
    if (isValid_default(userMin) || isValid_default(userMax) || "linear" !== this._spec.type)
      return domain;
    if (Math.abs(minInArray(domain) - maxInArray(domain)) <= 1e-12) {
      let num = domain[0];
      const flag = num >= 0 ? 1 : -1;
      if (num = Math.abs(num), num < 1)
        domain[0] = 0, domain[1] = 1;
      else {
        let step = num / 5;
        const power = Math.floor(Math.log(step) / Math.LN10), err = step / Math.pow(10, power);
        step = (err >= e103 ? 10 : err >= e53 ? 5 : err >= e23 ? 2 : 1) * Math.pow(10, power), domain[0] = 0, domain[1] = 10 * step;
      }
      flag < 0 && (domain.reverse(), domain[0] *= -1, domain[1] *= -1);
    }
    return domain;
  }
  includeZero(domain) {
    this._zero && (domain[0] = Math.min(domain[0], 0), domain[domain.length - 1] = Math.max(domain[domain.length - 1], 0));
  }
  setExtendDomain(key, value) {
    if (void 0 === value)
      return void delete this._extend[key];
    this._extend[key] = value;
    const domain = this._scale.domain();
    if (this.extendDomain(domain), this.includeZero(domain), this.setDomainMinMax(domain), this.niceDomain(domain), this._scale.domain(domain, this._nice), this._nice) {
      !this.setScaleNice() && this._scale.rescale();
    }
    this.event.emit(ChartEvent.scaleUpdate, {
      model: this,
      value: "domain"
    });
  }
  extendDomain(domain) {
    let temp3;
    const domainLast = domain.length - 1, reverse = domain[0] - domain[domainLast] > 0, min3 = reverse ? domainLast : 0, max3 = reverse ? 0 : domainLast;
    for (const key in this._extend)
      temp3 = this._extend[key], temp3 > domain[max3] && (domain[max3] = temp3), temp3 < domain[min3] && (domain[min3] = temp3);
  }
  getDomainSpec() {
    return this._domain;
  }
  setDomainMinMax(domain) {
    if (!this._domain)
      return;
    const { min: min3, max: max3 } = this._domain;
    isValid_default(min3) && (domain[0] = min3), isValid_default(max3) && (domain[1] = max3);
  }
  setSoftDomainMinMax(domain) {
    const { softMin, softMax } = this._spec;
    if (isValid_default(softMin)) {
      let softMinValue = isFunction_default(softMin) ? softMin(domain) : softMin;
      isNil_default(softMinValue) && (softMinValue = domain[0]), softMinValue <= domain[0] && (domain[0] = softMinValue, this._softMinValue = softMinValue);
    }
    if (isValid_default(softMax)) {
      let softMaxValue = isFunction_default(softMax) ? softMax(domain) : softMax;
      isNil_default(softMaxValue) && (softMaxValue = domain[1]), softMaxValue >= domain[1] && (domain[1] = softMaxValue), this._softMaxValue = softMaxValue;
    }
  }
  setZero(zero3) {
    this._zero !== zero3 && (this._zero = zero3, this.updateScaleDomain());
  }
  updateScaleDomain() {
    if (!this.isSeriesDataEnable())
      return;
    const data = this.collectData(), domain = this.computeLinearDomain(data);
    this.updateScaleDomainByModel(domain);
  }
  updateScaleDomainByModel(domain) {
    if (domain = null != domain ? domain : this._scale.domain(), this.extendDomain(domain), this.includeZero(domain), this.setDomainMinMax(domain), this.niceDomain(domain), this._scale.domain(domain, this._nice), this._nice) {
      !this.setScaleNice() && this._scale.rescale();
    }
    this._updateNiceLabelFormatter(domain), this._domainAfterSpec = this._scale.domain(), this.event.emit(ChartEvent.scaleDomainUpdate, {
      model: this
    }), this.event.emit(ChartEvent.scaleUpdate, {
      model: this,
      value: "domain"
    });
  }
  getDomainAfterSpec() {
    return this._domainAfterSpec;
  }
  _updateNiceLabelFormatter(domain) {
    const domainSpan = Math.abs(domain[1] - domain[0]), n = Math.max(-Math.floor(Math.log10(domainSpan)), 0) + 2, unit = Math.pow(10, n);
    this.niceLabelFormatter = (value) => isValidNumber_default(+value) ? Math.round(+value * unit) / unit : value;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/axis/cartesian/linear-axis
var CartesianLinearAxis = class extends CartesianAxis {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.cartesianLinearAxis, this._zero = true, this._nice = true, this._extend = {}, this._scale = new LinearScale();
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this.setExtraAttrFromSpec();
  }
  initScales() {
    var _a, _b;
    super.initScales();
    const range2 = [0, 1];
    isValid_default(null === (_a = this._domain) || void 0 === _a ? void 0 : _a.min) && (range2[0] = this._domain.min), isValid_default(null === (_b = this._domain) || void 0 === _b ? void 0 : _b.max) && (range2[1] = this._domain.max), this._scale.domain(range2);
  }
  computeDomain(data) {
    return this.computeLinearDomain(data);
  }
  axisHelper() {
    const helper = super.axisHelper();
    return helper.setExtendDomain = this.setExtendDomain.bind(this), helper.valueToPosition = this.valueToPosition.bind(this), helper;
  }
};
CartesianLinearAxis.type = ComponentTypeEnum.cartesianLinearAxis, CartesianLinearAxis.specKey = "axes", mixin(CartesianLinearAxis, LinearAxisMixin);
var registerCartesianLinearAxis = () => {
  registerAxis2(), Factory2.registerComponent(CartesianLinearAxis.type, CartesianLinearAxis);
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/axis/mixin/band-axis-mixin
var BandAxisMixin = class {
  constructor() {
    this._rawDomainIndex = [];
  }
  _initData() {
    var _a;
    if (this._spec.showAllGroupLayers && this._scales.length > 1)
      for (let layer = 0; layer < this._scales.length; layer++) {
        const layerConfig = (null !== (_a = this._spec.layers) && void 0 !== _a ? _a : [])[this._scales.length - 1 - layer] || {};
        if (false !== layerConfig.visible && 0 !== layerConfig.tickCount && 0 !== layerConfig.forceTickCount) {
          const tickData = this._initTickDataSet(Object.assign(Object.assign({}, this._tickTransformOption()), layerConfig), layer);
          tickData.target.addListener("change", this._forceLayout.bind(this));
          const compilableData = new CompilableData(this._option, tickData);
          this._tickData.push(compilableData), this._tickDataMap || (this._tickDataMap = {}), this._tickDataMap[layer] = compilableData;
        }
      }
    else {
      const tickData = this._initTickDataSet(this._tickTransformOption());
      tickData.target.addListener("change", this._forceLayout.bind(this));
      const compilableData = new CompilableData(this._option, tickData);
      this._tickData = [compilableData], this._tickDataMap = {
        0: compilableData
      };
    }
  }
  dataToPosition(values, cfg = {}) {
    var _a, _b;
    if (0 === values.length || 0 === this._scales.length)
      return 0;
    const { position, bandScale } = this.getPosition(values);
    return position + bandScale.bandwidth() * (null !== (_b = null !== (_a = cfg.bandPosition) && void 0 !== _a ? _a : this._spec.bandPosition) && void 0 !== _b ? _b : this._defaultBandPosition);
  }
  valueToPosition(value) {
    return this._scale.scale(value);
  }
  updateGroupScaleRange() {
    let parentScale = this._scale;
    this._scales.forEach((scale4, i) => {
      i > 0 && (scale4.range([0, parentScale.bandwidth()]), parentScale = scale4);
    });
  }
  getPosition(values) {
    let position = 0, bandScale = this._scale;
    if (1 === this._scales.length || 1 === values.length)
      position = this.valueToPosition(values[0]);
    else {
      const max3 = Math.min(values.length, this._scales.length);
      for (let i = 0; i < max3; i++)
        position += this._scales[i].scale(values[i]);
      bandScale = this._scales[max3 - 1];
    }
    return {
      position,
      bandScale
    };
  }
  calcScales(DEFAULT_BAND_INNER_PADDING, DEFAULT_BAND_OUTER_PADDING) {
    var _a, _b;
    const { bandPadding, paddingInner, paddingOuter } = this._spec, isBandPaddingArray = isArray_default(bandPadding), isPaddingInnerArray = isArray_default(paddingInner), isPaddingOuterArray = isArray_default(paddingOuter);
    for (let i = 0; i < this._scales.length; i++) {
      const _padding = isBandPaddingArray ? bandPadding[i] : bandPadding, _paddingInner = isPaddingInnerArray ? paddingInner[i] : paddingInner, _paddingOuter = isPaddingOuterArray ? paddingOuter[i] : paddingOuter;
      this._scales[i].paddingInner(null !== (_a = null != _paddingInner ? _paddingInner : _padding) && void 0 !== _a ? _a : DEFAULT_BAND_INNER_PADDING, true).paddingOuter(null !== (_b = null != _paddingOuter ? _paddingOuter : _padding) && void 0 !== _b ? _b : DEFAULT_BAND_OUTER_PADDING, true);
    }
  }
  computeBandDomain(data) {
    if (!data.length)
      return [];
    if (1 === data.length)
      return data[0].values;
    const tempSet = /* @__PURE__ */ new Set();
    for (let i = 0; i < data.length; i++)
      for (let j = 0; j < data[i].values.length; j++)
        tempSet.add(data[i].values[j]);
    return Array.from(tempSet);
  }
  updateScaleDomain() {
    var _a;
    if (!this.isSeriesDataEnable())
      return;
    !(null === (_a = this._rawDomainIndex) || void 0 === _a ? void 0 : _a.length) && this._scales.length && this._updateRawDomain();
    const userDomain = this._spec.domain;
    for (let i = 0; i < this._scales.length; i++)
      if (userDomain && userDomain.length && 0 === i)
        this._scales[i].domain(userDomain);
      else {
        const data = this.collectData(i), domain = this.computeBandDomain(data);
        this._scales[i].domain(domain.sort((a3, b) => this._rawDomainIndex[i][a3] - this._rawDomainIndex[i][b]));
      }
    this.transformScaleDomain(), this.event.emit(ChartEvent.scaleDomainUpdate, {
      model: this
    }), this.event.emit(ChartEvent.scaleUpdate, {
      model: this,
      value: "domain"
    });
  }
  getLabelItems(length2) {
    const labelItems = [];
    let preData = [];
    return this._scales.forEach((scale4, index) => {
      var _a;
      const tickData = this._tickDataMap[index], isTickDataHaveData = null === (_a = null == tickData ? void 0 : tickData.getLatestData()) || void 0 === _a ? void 0 : _a.length, ticks4 = isTickDataHaveData ? tickData.getLatestData().map((obj) => obj.value) : scale4.domain();
      if (ticks4 && ticks4.length)
        if (preData && preData.length) {
          const currentLabelItems = [], curData = [];
          preData.forEach((value) => {
            ticks4.forEach((tick) => {
              const values = array(value).concat(tick);
              if (curData.push(values), isTickDataHaveData) {
                const axisItem = getAxisItem(tick, this._getNormalizedValue(values, length2));
                currentLabelItems.push(axisItem);
              }
            });
          }), isTickDataHaveData && labelItems.push(currentLabelItems.filter((entry) => entry.value >= 0 && entry.value <= 1)), preData = curData;
        } else
          ticks4.forEach((tick) => {
            preData.push(tick);
          }), isTickDataHaveData && labelItems.push(tickData.getLatestData().map((obj) => getAxisItem(obj.value, this._getNormalizedValue([obj.value], length2))).filter((entry) => entry.value >= 0 && entry.value <= 1));
    }), labelItems.reverse();
  }
  _updateRawDomain() {
    this._rawDomainIndex = [];
    const userDomain = this._spec.domain;
    for (let i = 0; i < this._scales.length; i++)
      if (userDomain && userDomain.length && 0 === i)
        this._scales[i].domain(userDomain);
      else {
        const data = this.collectData(i, true), domain = this.computeBandDomain(data);
        this._rawDomainIndex[i] = {}, domain.forEach((d, _i) => this._rawDomainIndex[i][d] = _i);
      }
  }
  _clearRawDomain() {
    this._rawDomainIndex = [];
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/axis/cartesian/band-axis
var CartesianBandAxis = class extends CartesianAxis {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.cartesianBandAxis, this._scale = new BandScale();
  }
  computeDomain(data) {
    return this.computeBandDomain(data);
  }
  updateScaleRange() {
    const isChanged = super.updateScaleRange();
    return this.updateGroupScaleRange(), isChanged;
  }
  initScales() {
    super.initScales(), this.calcScales(this._defaultBandInnerPadding, this._defaultBandOuterPadding);
  }
  axisHelper() {
    const getScale2 = (depth) => this._scales[depth];
    return {
      isContinuous: false,
      dataToPosition: this.dataToPosition.bind(this),
      getScale: getScale2,
      getBandwidth: (depth) => getScale2(depth).bandwidth(),
      getAxisType: () => this.type,
      getAxisId: () => this.id,
      isInverse: () => this._inverse,
      getSpec: () => this._spec
    };
  }
  transformScaleDomain() {
    this.updateFixedWholeLength();
  }
  updateFixedWholeLength() {
    if (this._scale) {
      const { bandSize, maxBandSize, minBandSize } = this._getOuterBandSizeFromSpec();
      if (bandSize && this._scale.bandwidth(bandSize), maxBandSize && this._scale.maxBandwidth(maxBandSize), minBandSize && this._scale.minBandwidth(minBandSize), this._scale.isBandwidthFixed() && this._spec.autoRegionSize && (bandSize || maxBandSize)) {
        const rangeSize = scaleWholeRangeSize(this._scale.domain().length, null != bandSize ? bandSize : maxBandSize, this._scale.paddingInner(), this._scale.paddingOuter());
        ["bottom", "top"].includes(this._orient) ? this._regions.forEach((region) => region.setMaxWidth(rangeSize)) : ["left", "right"].includes(this._orient) && this._regions.forEach((region) => region.setMaxHeight(rangeSize));
      }
    }
  }
  _getOuterBandSizeFromSpec() {
    var _a;
    let { bandSize, maxBandSize, minBandSize, bandSizeLevel = 0 } = this._spec;
    const { gap, extend = 0 } = null !== (_a = this._spec.bandSizeExtend) && void 0 !== _a ? _a : {};
    bandSizeLevel = Math.min(bandSizeLevel, this._scales.length - 1);
    for (let i = bandSizeLevel; i > 0; i--) {
      const scale4 = this._scales[i], domain = scale4.domain(), paddingInner = scale4.paddingInner(), paddingOuter = scale4.paddingOuter(), getOuterBandSize = (b) => {
        const extendValue = i === bandSizeLevel ? extend : 0;
        if (isNil_default(gap) || i < bandSizeLevel)
          return scaleWholeRangeSize(domain.length, b, paddingInner, paddingOuter) + extendValue;
        return (b + (isString_default(gap) ? b * (Number(gap.substring(0, gap.length - 1)) / 100) : gap)) * domain.length / (this._scales[i - 1].paddingInner() + 1) + extendValue;
      };
      isValid_default(bandSize) && (bandSize = getOuterBandSize(bandSize)), isValid_default(maxBandSize) && (maxBandSize = getOuterBandSize(maxBandSize)), isValid_default(minBandSize) && (minBandSize = getOuterBandSize(minBandSize));
    }
    return {
      bandSize,
      maxBandSize,
      minBandSize
    };
  }
};
CartesianBandAxis.type = ComponentTypeEnum.cartesianBandAxis, CartesianBandAxis.specKey = "axes", mixin(CartesianBandAxis, BandAxisMixin);
var registerCartesianBandAxis = () => {
  registerAxis2(), Factory2.registerComponent(CartesianBandAxis.type, CartesianBandAxis);
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/axis/cartesian/time-axis
var CartesianTimeAxis = class extends CartesianLinearAxis {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.cartesianTimeAxis, this._zero = false, this.effect = {
      scaleUpdate: (params2) => {
        this.computeData(null == params2 ? void 0 : params2.value), eachSeries(this._regions, (s2) => {
          isXAxis(this.getOrient()) ? s2.setXAxisHelper(this.axisHelper()) : s2.setYAxisHelper(this.axisHelper());
        }, {
          userId: this._seriesUserId,
          specIndex: this._seriesIndex
        });
      }
    };
  }
  setAttrFromSpec() {
    var _a;
    super.setAttrFromSpec(), this._tick = mergeSpec({}, this._spec.tick, null === (_a = this._spec.layers) || void 0 === _a ? void 0 : _a[0]);
  }
  _initData() {
    var _a;
    if (super._initData(), null === (_a = this._spec.layers) || void 0 === _a ? void 0 : _a[1]) {
      const layerTickData = new DataView(this._option.dataSet, {
        name: `${this.type}_${this.id}_layer_1_ticks`
      }).parse(this._scale, {
        type: "scale"
      }).transform({
        type: "ticks",
        options: Object.assign(Object.assign({}, this._tickTransformOption()), {
          tickCount: this._spec.layers[1].tickCount,
          forceTickCount: this._spec.layers[1].forceTickCount,
          tickStep: this._spec.layers[1].tickStep
        })
      }, false);
      this._layerTickData = new CompilableData(this._option, layerTickData);
    }
  }
  computeData(updateType) {
    super.computeData(updateType), this._layerTickData && (this._layerTickData.getDataView().reRunAllTransform(), this._layerTickData.updateData());
  }
  _getLabelFormatMethod() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const timeUtil = TimeUtil.getInstance(), timeFormat1 = (null === (_b = null === (_a = this._spec.layers) || void 0 === _a ? void 0 : _a[1]) || void 0 === _b ? void 0 : _b.timeFormat) || "%Y%m%d", timeFormatter1 = "local" === ((null === (_d = null === (_c = this._spec.layers) || void 0 === _c ? void 0 : _c[1]) || void 0 === _d ? void 0 : _d.timeFormatMode) || "local") ? timeUtil.timeFormat : timeUtil.timeUTCFormat, timeFormat0 = (null === (_f = null === (_e = this._spec.layers) || void 0 === _e ? void 0 : _e[0]) || void 0 === _f ? void 0 : _f.timeFormat) || "%Y%m%d", timeFormatter0 = "local" === ((null === (_h = null === (_g = this._spec.layers) || void 0 === _g ? void 0 : _g[0]) || void 0 === _h ? void 0 : _h.timeFormatMode) || "local") ? timeUtil.timeFormat : timeUtil.timeUTCFormat;
    return (value, datum, index, data, layer) => {
      var _a2;
      let timeValue;
      return timeValue = 0 === layer ? timeFormatter0(timeFormat0, value) : timeFormatter1(timeFormat1, value), (null === (_a2 = this._spec.label) || void 0 === _a2 ? void 0 : _a2.formatMethod) ? this._spec.label.formatMethod(timeValue, datum) : timeValue;
    };
  }
  getLabelItems(length2) {
    var _a, _b;
    const items = [], tickLatestData = null === (_a = this.getTickData()) || void 0 === _a ? void 0 : _a.getLatestData();
    tickLatestData && tickLatestData.length && items.push(tickLatestData.map((obj) => getAxisItem(obj.value, this._getNormalizedValue([obj.value], length2))));
    const layerLatestData = null === (_b = this._layerTickData) || void 0 === _b ? void 0 : _b.getLatestData();
    return layerLatestData && layerLatestData.length && items.push(layerLatestData.map((obj) => getAxisItem(obj.value, this._getNormalizedValue([obj.value], length2)))), items;
  }
  transformScaleDomain() {
  }
};
CartesianTimeAxis.type = ComponentTypeEnum.cartesianTimeAxis, CartesianTimeAxis.specKey = "axes";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/axis/cartesian/log-axis
var CartesianLogAxis = class extends CartesianLinearAxis {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.cartesianLogAxis, this._zero = false, this._scale = new LogScale();
  }
  initScales() {
    var _a;
    super.initScales(), this._scale.base(null !== (_a = this._spec.base) && void 0 !== _a ? _a : 10), this._scale.clamp(true, null, false);
  }
  transformScaleDomain() {
  }
};
CartesianLogAxis.type = ComponentTypeEnum.cartesianLogAxis, CartesianLogAxis.specKey = "axes", mixin(CartesianLogAxis, LinearAxisMixin);

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/axis/cartesian/symlog-axis
var CartesianSymlogAxis = class extends CartesianLinearAxis {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.cartesianSymlogAxis, this._zero = false, this._scale = new SymlogScale();
  }
  initScales() {
    var _a;
    super.initScales(), this._scale.constant(null !== (_a = this._spec.constant) && void 0 !== _a ? _a : 10);
  }
  transformScaleDomain() {
  }
};
CartesianSymlogAxis.type = ComponentTypeEnum.cartesianSymlogAxis, CartesianSymlogAxis.specKey = "axes", mixin(CartesianSymlogAxis, LinearAxisMixin);

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/area/area
var AreaSeries = class _AreaSeries extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.area, this.transformerConstructor = AreaSeriesSpecTransformer, this._sortDataByAxis = false;
  }
  initMark() {
    var _a, _b;
    const progressive = {
      progressiveStep: this._spec.progressiveStep,
      progressiveThreshold: this._spec.progressiveThreshold,
      large: this._spec.large,
      largeThreshold: this._spec.largeThreshold
    }, areaSpec = this._spec.area || {}, isAreaVisible = false !== areaSpec.visible && false !== (null === (_a = areaSpec.style) || void 0 === _a ? void 0 : _a.visible), seriesMark = null !== (_b = this._spec.seriesMark) && void 0 !== _b ? _b : "area";
    this._areaMark = this._createMark(_AreaSeries.mark.area, {
      groupKey: this._seriesField,
      defaultMorphElementKey: this.getDimensionField()[0],
      progressive,
      isSeriesMark: isAreaVisible && "point" !== seriesMark,
      customShape: areaSpec.customShape,
      stateSort: areaSpec.stateSort
    }), this.initSymbolMark(progressive, "point" === seriesMark);
  }
  initMarkStyle() {
    this.initAreaMarkStyle(), this.initSymbolMarkStyle();
  }
  initAreaMarkStyle() {
    var _a, _b, _c, _d, _e;
    const userCurveType = null !== (_c = null === (_b = null === (_a = this.getSpec().area) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.curveType) && void 0 !== _c ? _c : null === (_e = null === (_d = this.getSpec().line) || void 0 === _d ? void 0 : _d.style) || void 0 === _e ? void 0 : _e.curveType, curveType = userCurveType === DEFAULT_SMOOTH_INTERPOLATE ? "horizontal" === this._direction ? "monotoneY" : "monotoneX" : userCurveType, areaMark = this._areaMark;
    areaMark && ("horizontal" === this._direction ? this.setMarkStyle(this._areaMark, {
      x: this.dataToPositionX.bind(this),
      x1: (datum) => {
        var _a2, _b2;
        return valueInScaleRange(this.dataToPositionX1(datum), null === (_b2 = null === (_a2 = this._xAxisHelper) || void 0 === _a2 ? void 0 : _a2.getScale) || void 0 === _b2 ? void 0 : _b2.call(_a2, 0));
      },
      y: this.dataToPositionY.bind(this),
      z: this._fieldZ ? this.dataToPositionZ.bind(this) : null,
      orient: this._direction
    }, "normal", AttributeLevel.Series) : this.setMarkStyle(this._areaMark, {
      x: this.dataToPositionX.bind(this),
      y1: (datum) => {
        var _a2, _b2;
        return valueInScaleRange(this.dataToPositionY1(datum), null === (_b2 = null === (_a2 = this._yAxisHelper) || void 0 === _a2 ? void 0 : _a2.getScale) || void 0 === _b2 ? void 0 : _b2.call(_a2, 0));
      },
      y: this.dataToPositionY.bind(this),
      z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
    }, "normal", AttributeLevel.Series), this.setMarkStyle(areaMark, {
      fill: this.getColorAttribute(),
      stroke: this.getColorAttribute()
    }, "normal", AttributeLevel.Series), "zero" !== this._invalidType && this.setMarkStyle(areaMark, {
      defined: this._getInvalidDefined.bind(this),
      connectedType: this._getInvalidConnectType()
    }, "normal", AttributeLevel.Series), this.setMarkStyle(areaMark, {
      curveType
    }, "normal", AttributeLevel.Built_In), Object.keys(areaMark.stateStyle).forEach((state) => {
      areaMark.stateStyle[state].stroke && areaMark.setPostProcess("stroke", (result2) => [result2, false, false, false], state);
    }));
  }
  initAnimation() {
    var _a, _b, _c, _d;
    const areaAnimationParams = {
      direction: this.direction
    }, appearPreset = null === (_a = this._spec.animationAppear) || void 0 === _a ? void 0 : _a.preset;
    if (this._lineMark && this._lineMark.setAnimationConfig(animationConfig(null === (_b = Factory2.getAnimationInKey("line")) || void 0 === _b ? void 0 : _b(areaAnimationParams, appearPreset), userAnimationConfig("line", this._spec, this._markAttributeContext))), this._areaMark && this._areaMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("area")) || void 0 === _c ? void 0 : _c(areaAnimationParams, appearPreset), userAnimationConfig("area", this._spec, this._markAttributeContext))), this._symbolMark) {
      const animationParams = getGroupAnimationParams(this);
      this._symbolMark.setAnimationConfig(animationConfig(null === (_d = Factory2.getAnimationInKey("scaleInOut")) || void 0 === _d ? void 0 : _d(), userAnimationConfig("point", this._spec, this._markAttributeContext), animationParams));
    }
  }
  initTooltip() {
    this._tooltipHelper = new AreaSeriesTooltipHelper(this);
    const { dimension, group, mark } = this._tooltipHelper.activeTriggerSet;
    this._areaMark && (dimension.add(this._areaMark), group.add(this._areaMark)), this._lineMark && (dimension.add(this._lineMark), group.add(this._lineMark)), this._symbolMark && (mark.add(this._symbolMark), group.add(this._symbolMark));
  }
  viewDataStatisticsUpdate(d) {
    super.viewDataStatisticsUpdate(d), this.encodeDefined(this._areaMark, "defined");
  }
  compile() {
    super.compile(), this.addSamplingCompile(), this.addOverlapCompile();
  }
  getDefaultShapeType() {
    return "square";
  }
  getActiveMarks() {
    return [this._areaMark, this._symbolMark, this._lineMark];
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx), this.reCompileSampling();
  }
  getSeriesStyle(datum) {
    return (attribute) => {
      var _a, _b, _c, _d, _e;
      const seriesMarkType = null !== (_a = this._spec.seriesMark) && void 0 !== _a ? _a : "area";
      let result2 = null !== (_c = null === (_b = this._seriesMark) || void 0 === _b ? void 0 : _b.getAttribute(attribute, datum)) && void 0 !== _c ? _c : void 0;
      return "fill" !== attribute || result2 && "line" !== seriesMarkType || (attribute = "stroke", result2 = null !== (_e = null === (_d = this._seriesMark) || void 0 === _d ? void 0 : _d.getAttribute(attribute, datum)) && void 0 !== _e ? _e : void 0), "stroke" === attribute && isArray_default(result2) ? result2[0] : result2;
    };
  }
};
AreaSeries.type = SeriesTypeEnum.area, AreaSeries.mark = areaSeriesMark, AreaSeries.transformerConstructor = AreaSeriesSpecTransformer, mixin(AreaSeries, LineLikeSeriesMixin);

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/chart-meta/data
var ChartData = class {
  get dataList() {
    return this._dataArr;
  }
  constructor(dataSet, onError) {
    this._dataArr = [], this._onError = onError, this._dataSet = dataSet;
  }
  parseData(dataSpec) {
    this._dataArr = [];
    const list = array(dataSpec);
    for (let i = 0; i < list.length; i++)
      this._dataArr.push(dataToDataView(list[i], this._dataSet, this._dataArr, {
        onError: this._onError
      }));
  }
  updateData(dataSpec, fullUp = false, forceMerge = true) {
    const list = array(dataSpec);
    return (!fullUp || list.length === this._dataArr.length) && (this._dataValueForEach(list, (_data, dv) => {
      dv.markRunning();
    }), this._dataValueForEach(list, (data, dv) => {
      updateDataViewInData(dv, data, forceMerge);
    }), true);
  }
  _dataValueForEach(list, callBack) {
    list.forEach((data, i) => {
      if (data instanceof DataView)
        return;
      const dv = this.getSeriesData(data.id, i);
      dv && callBack(data, dv, i);
    });
  }
  getSeriesData(id2, index) {
    var _a, _b;
    if (!this._dataArr.length)
      return null;
    if ("string" == typeof id2) {
      const metchData = this._dataArr.filter((data) => data.name === id2);
      return metchData[0] ? metchData[0] : (null === (_a = this._onError) || void 0 === _a || _a.call(this, `no data matches dataId ${id2}!`), null);
    }
    return "number" == typeof index ? this._dataArr[index] ? this._dataArr[index] : (null === (_b = this._onError) || void 0 === _b || _b.call(this, `no data matches dataIndex ${index}!`), null) : this._dataArr[0];
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/scale/global-scale
var GlobalScale = class {
  constructor(spec, chart) {
    this._scaleSpecMap = /* @__PURE__ */ new Map(), this._scaleMap = /* @__PURE__ */ new Map(), this._modelScaleSpecMap = /* @__PURE__ */ new Map(), this._markAttributeScaleMap = /* @__PURE__ */ new Map(), this._spec = null, this._chart = null, this.getStatisticalFields = (dataId) => {
      const result2 = [];
      return this._scaleSpecMap.forEach((v, k2) => {
        isDataDomainSpec(v.domain) && v.domain.forEach((spec2) => {
          spec2.dataId === dataId && spec2.fields.forEach((key) => {
            mergeFields(result2, [{
              key,
              operations: isContinuous(v.type) ? ["max", "min"] : ["values"]
            }]);
          });
        });
      }), this._markAttributeScaleMap.forEach((specList, scaleName) => {
        const scale4 = this.getScale(scaleName);
        specList.forEach((spec2) => {
          this._getSeriesBySeriesId(spec2.seriesId).getRawData().name === dataId && spec2.field && mergeFields(result2, [{
            key: spec2.field,
            operations: isContinuous(scale4.type) ? ["max", "min"] : ["values"]
          }]);
        });
      }), result2;
    }, this._spec = spec, this._chart = chart, this._setAttrFromSpec();
  }
  _createFromSpec(s2) {
    if (!s2.id)
      return null;
    let scale4 = this._scaleMap.get(s2.id);
    return scale4 || (scale4 = "ordinal" === s2.type && "color" === s2.id ? createScale("colorOrdinal") : createScale(s2.type)), scale4 ? (isArray_default(s2.range) && scale4.range(s2.range), isArray_default(s2.domain) && (isDataDomainSpec(s2.domain) || scale4.domain(s2.domain)), s2.specified && scale4.specified && scale4.specified(s2.specified), scale4) : null;
  }
  _setAttrFromSpec() {
    var _a;
    if (!(null === (_a = this._spec) || void 0 === _a ? void 0 : _a.length))
      return;
    const newScaleMap = /* @__PURE__ */ new Map(), newScaleSpecMap = /* @__PURE__ */ new Map();
    this._spec.forEach((s2) => {
      const scale4 = this._createFromSpec(s2);
      scale4 && (newScaleMap.set(s2.id, scale4), newScaleSpecMap.set(s2.id, s2));
    }), this._modelScaleSpecMap.forEach((s2) => {
      const scale4 = this._createFromSpec(s2);
      scale4 && (newScaleMap.set(s2.id, scale4), newScaleSpecMap.set(s2.id, s2));
    }), this._scaleSpecMap = newScaleSpecMap, this._scaleMap = newScaleMap;
  }
  updateSpec(spec) {
    const result2 = {
      change: false,
      reMake: false,
      reRender: false,
      reSize: false,
      reCompile: false
    };
    if (isEqual(spec, this._spec))
      return result2;
    result2.change = true;
    for (let i = 0; i < spec.length; i++) {
      const s2 = spec[i], scale4 = this._scaleMap.get(s2.id);
      if (!scale4)
        return result2.reMake = true, result2;
      const lastSpec = this._spec.find((_s) => _s.id === s2.id);
      if (!lastSpec.id)
        return result2.reMake = true, result2;
      if (lastSpec.type !== s2.type)
        return result2.reMake = true, result2;
      s2.range && !isEqual(s2.range, scale4.range()) && (scale4.range(s2.range), result2.reRender = true), isDataDomainSpec(s2.domain) ? result2.reRender = true : isEqual(s2.domain, scale4.domain()) || (scale4.domain(s2.domain), result2.reRender = true), this._scaleSpecMap.set(s2.id, s2);
    }
    return this._spec = spec, result2;
  }
  registerModelScale(spec) {
    const scale4 = this._createFromSpec(spec);
    scale4 && (this._modelScaleSpecMap.set(spec.id, spec), this._scaleSpecMap.set(spec.id, spec), this._scaleMap.set(spec.id, scale4));
  }
  removeModelScale(filter2) {
    this._modelScaleSpecMap.forEach((spec) => {
      filter2(spec) && (this._modelScaleSpecMap.delete(spec.id), this._scaleSpecMap.delete(spec.id), this._scaleMap.delete(spec.id));
    });
  }
  getScale(user_id) {
    return this._scaleMap.get(user_id);
  }
  getScaleSpec(user_id) {
    return this._scaleSpecMap.get(user_id);
  }
  _getSeriesByRawDataId(id2) {
    const series2 = this._chart.getAllSeries();
    for (let i = 0; i < series2.length; i++) {
      const s2 = series2[i];
      if (s2.getRawData().name === id2)
        return s2;
    }
    return null;
  }
  _getSeriesBySeriesId(id2) {
    const series2 = this._chart.getAllSeries();
    for (let i = 0; i < series2.length; i++) {
      const s2 = series2[i];
      if (s2.id === id2)
        return s2;
    }
    return null;
  }
  updateScaleDomain(defaultDomain) {
    this._scaleSpecMap.forEach((scaleSpec, id2) => {
      const scale4 = this._scaleMap.get(id2);
      if (!scale4)
        return;
      if (!isDataDomainSpec(scaleSpec.domain))
        return scaleSpec.domain && 0 !== scaleSpec.domain.length || scale4.domain(defaultDomain), void this._updateMarkScale(id2, scale4, scale4.domain().slice());
      let domain;
      domain = isContinuous(scaleSpec.type) ? [null, null] : /* @__PURE__ */ new Set(), scaleSpec.domain.forEach((spec) => {
        const series2 = this._getSeriesByRawDataId(spec.dataId);
        if (!series2)
          return;
        const isContinuousField = isContinuous(scaleSpec.type);
        spec.fields.forEach((key) => {
          const statistics = series2.getRawDataStatisticsByField(key, isContinuousField);
          statistics && (isContinuousField ? (isNil_default(domain[0]) ? domain[0] = statistics.min : domain[0] = Math.min(statistics.min, domain[0]), isNil_default(domain[1]) ? domain[1] = statistics.max : domain[1] = Math.max(statistics.max, domain[1])) : statistics.values.forEach((value) => {
            domain.add(value);
          }));
        });
      });
      const scaleDomain = domain;
      isContinuous(scaleSpec.type) || (domain = Array.from(domain)), scale4.domain(domain), this._updateMarkScale(id2, scale4, scaleDomain);
    });
  }
  _updateMarkScale(id2, scale4, domain) {
    const list = this._markAttributeScaleMap.get(id2);
    list && 0 !== list.length && list.forEach((info) => {
      if (!info.field || !info.markScale || info.markScale === scale4)
        return;
      if (isNil_default(info.changeDomain) || "none" === info.changeDomain || isNil_default(info.seriesId))
        return void (isContinuous(scale4.type) ? info.markScale.domain(domain) : scale4.domain(Array.from(domain)));
      const series2 = this._getSeriesBySeriesId(info.seriesId), isContinuousScale = isContinuous(scale4.type), statistics = series2.getRawDataStatisticsByField(info.field, isContinuousScale);
      if (!isEmpty_default(statistics))
        return "expand" === info.changeDomain ? (isContinuousScale ? (domain[0] = Math.min(domain[0], statistics.min), domain[1] = Math.max(domain[1], statistics.max)) : (statistics.values.forEach((value) => {
          domain.add(value);
        }), domain = Array.from(domain)), void info.markScale.domain(domain)) : void ("replace" !== info.changeDomain || (isContinuousScale ? info.markScale.domain([statistics.min, statistics.max]) : info.markScale.domain(statistics.values)));
      isContinuous(scale4.type) ? info.markScale.domain(domain) : scale4.domain(Array.from(domain));
    });
  }
  registerMarkAttributeScale(spec, seriesId) {
    const scale4 = this._scaleMap.get(spec.scale);
    let list = this._markAttributeScaleMap.get(spec.scale);
    list || (list = [], this._markAttributeScaleMap.set(spec.scale, list));
    let markScale = scale4;
    return (isNil_default(spec.field) || !isNil_default(spec.changeDomain) && "none" !== spec.changeDomain && !isNil_default(seriesId)) && (markScale = scale4.clone()), list.push(Object.assign(Object.assign({}, spec), {
      seriesId,
      markScale
    })), markScale;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/stack
var Stack = class {
  constructor(chart) {
    this.stackRegion = ({ model }) => {
      const series2 = model.getSeries();
      if (!series2.some((s2) => s2.getStack()))
        return;
      const hasTotalLabel = series2.some((s2) => {
        var _a, _b;
        return null === (_b = null === (_a = s2.getSpec()) || void 0 === _a ? void 0 : _a.totalLabel) || void 0 === _b ? void 0 : _b.visible;
      }), hasPercent = hasTotalLabel || series2.some((s2) => s2.getPercent()), hasOffsetSilhouette = series2.some((s2) => s2.getStackOffsetSilhouette()), stackValueGroup = getRegionStackGroup(model, true);
      for (const stackValue in stackValueGroup)
        for (const key in stackValueGroup[stackValue].nodes)
          stack(stackValueGroup[stackValue].nodes[key], model.getStackInverse(), hasPercent);
      if (hasOffsetSilhouette)
        for (const stackValue in stackValueGroup)
          for (const key in stackValueGroup[stackValue].nodes)
            stackOffsetSilhouette(stackValueGroup[stackValue].nodes[key]);
      hasTotalLabel && model.getSeries().forEach((s2) => {
        const stackData = s2.getStackData(), stackValue = s2.getStackValue(), stackValueField = s2.getStackValueField();
        stackData && stackValueField && stackTotal(stackValueGroup[stackValue], stackValueField);
      });
    }, this._chart = chart;
  }
  init() {
    this._chart.getAllRegions().forEach((r) => {
      r.event.on(ChartEvent.regionSeriesDataFilterOver, {
        filter: ({ model }) => (null == model ? void 0 : model.id) === r.id
      }, this.stackRegion);
    });
  }
  stackAll() {
    this._chart.getAllRegions().forEach((r) => {
      this.stackRegion({
        model: r
      });
    });
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/base/base-chart
var __rest13 = function(s2, e) {
  var t = {};
  for (var p in s2)
    Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++)
      e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var BaseChart = class extends CompilableBase {
  getSpec() {
    return this._spec;
  }
  setSpec(s2) {
    this._spec = s2;
  }
  getOption() {
    return this._option;
  }
  getLayoutRect() {
    return this._layoutRect;
  }
  getViewRect() {
    return this._viewRect;
  }
  getLayoutTag() {
    return this._layoutTag;
  }
  setLayoutTag(tag, morphConfig, renderNextTick = true) {
    var _a;
    return this._layoutTag = tag, (null === (_a = this.getCompiler()) || void 0 === _a ? void 0 : _a.getVGrammarView()) && (this.getCompiler().getVGrammarView().updateLayoutTag(), tag && renderNextTick && this.getCompiler().renderNextTick(morphConfig)), this._layoutTag;
  }
  getGlobalScale() {
    return this._globalScale;
  }
  getEvent() {
    return this._event;
  }
  get chartData() {
    return this._chartData;
  }
  constructor(spec, option) {
    var _a, _b, _c, _d;
    super(option), this.type = "chart", this.id = createID(), this._regions = [], this._series = [], this._components = [], this._layoutRect = {
      x: 0,
      y: 0,
      width: DEFAULT_CHART_WIDTH,
      height: DEFAULT_CHART_HEIGHT
    }, this._viewRect = {
      width: DEFAULT_CHART_WIDTH,
      height: DEFAULT_CHART_HEIGHT
    }, this._viewBox = {
      x1: 0,
      y1: 0,
      x2: DEFAULT_CHART_WIDTH,
      y2: DEFAULT_CHART_HEIGHT
    }, this._layoutTag = true, this._idMap = /* @__PURE__ */ new Map(), this.state = {
      layoutUpdateRank: 1
    }, this.padding = {
      top: 0,
      left: 0,
      right: 0,
      bottom: 0
    }, this.getAllSeries = () => {
      var _a2;
      return null !== (_a2 = this._series) && void 0 !== _a2 ? _a2 : [];
    }, this.getRegionsInIndex = (index) => index && 0 !== index.length ? this._regions.filter((_r, i) => index.includes(i)) : [this._regions[0]], this.getAllRegions = () => this._regions, this.getRegionsInIds = (ids) => ids ? this._regions.filter((r) => ids.includes(r.id)) : [], this.getRegionsInQuerier = (region) => region ? this._regions.filter((r, index) => array(region).some((regionFilter) => isValid_default(regionFilter.regionId) && regionFilter.regionId === r.userId || regionFilter.regionIndex === index)) : this._regions, this.getRegionsInUserId = (userId) => {
      if (userId)
        return this._regions.find((r) => r.userId === userId);
    }, this.getRegionsInUserIdOrIndex = (user_ids, index) => this.getAllRegions().filter((r) => (null == user_ids ? void 0 : user_ids.length) ? r.userId && user_ids.includes(r.userId) : !(null == index ? void 0 : index.length) || index.includes(r.getSpecIndex())), this.getComponents = () => this._components, this.getSeriesInIndex = (index) => index && 0 !== index.length ? this._series.filter((_r, i) => index.includes(i)) : [this._series[0]], this.getSeriesInIds = (ids) => ids ? this._series.filter((r) => ids.includes(r.id)) : [], this.getSeriesInUserId = (userId) => {
      if (userId)
        return this._series.find((r) => r.userId === userId);
    }, this.getSeriesInUserIdOrIndex = (user_ids, index) => this.getAllSeries().filter((s2) => (null == user_ids ? void 0 : user_ids.length) ? s2.userId && user_ids.includes(s2.userId) : !(null == index ? void 0 : index.length) || index.includes(s2.getSpecIndex())), this.getComponentByIndex = (key, index) => {
      const components = this._components.filter((c3) => (c3.specKey || c3.type) === key);
      if (components && 0 !== components.length)
        return components[index];
    }, this.getComponentsByKey = (key) => this._components.filter((c3) => (c3.specKey || c3.type) === key), this.getComponentByUserId = (userId) => {
      const component2 = this._components.find((s2) => s2.userId === userId);
      if (component2)
        return component2;
    }, this.getComponentsByType = (type) => this._components.filter((c3) => c3.type === type), this._paddingSpec = normalizeLayoutPaddingSpec(null !== (_a = spec.padding) && void 0 !== _a ? _a : option.getTheme().padding), this._event = new Event2(option.eventDispatcher, option.mode), this._dataSet = option.dataSet, this._chartData = new ChartData(this._dataSet, null === (_b = this._option) || void 0 === _b ? void 0 : _b.onError), this._modelOption = Object.assign(Object.assign({}, option), {
      mode: this._option.mode,
      map: this._idMap,
      getChartLayoutRect: () => this._layoutRect,
      getChartViewRect: () => this._viewRect,
      getChart: () => this,
      globalScale: this._globalScale,
      onError: null === (_c = this._option) || void 0 === _c ? void 0 : _c.onError,
      disableTriggerEvent: true === (null === (_d = this._option) || void 0 === _d ? void 0 : _d.disableTriggerEvent),
      getSeriesData: this._chartData.getSeriesData.bind(this._chartData)
    }), this._spec = spec;
  }
  created() {
    this._transformer = new this.transformerConstructor(Object.assign(Object.assign({}, this._option), {
      type: this.type,
      seriesType: this.seriesType
    })), this._chartData.parseData(this._spec.data), this._createGlobalScale(), this._spec.background && "object" == typeof this._spec.background && this._createBackground(), this._createLayout(), this._transformer.forEachRegionInSpec(this._spec, this._createRegion.bind(this)), this._transformer.forEachSeriesInSpec(this._spec, this._createSeries.bind(this)), this._transformer.forEachComponentInSpec(this._spec, this._createComponent.bind(this), this._option.getSpecInfo());
  }
  init() {
    this._regions.forEach((r) => r.init({})), this._series.forEach((s2) => s2.init({})), this._components.forEach((c3) => c3.init({
      dataSet: this._dataSet
    })), this._initEvent(), this._canStack && (this._stack = new Stack(this), this._stack.init()), this.reDataFlow();
  }
  reDataFlow() {
    this._series.forEach((s2) => {
      var _a;
      return null === (_a = s2.getRawData()) || void 0 === _a ? void 0 : _a.markRunning();
    }), this._series.forEach((s2) => s2.fillData()), this.updateGlobalScaleDomain();
  }
  onResize(width, height, reRender = true) {
    const canvasRect = {
      width,
      height
    };
    this._canvasRect = canvasRect, this._updateLayoutRect(this._option.viewBox), this.setLayoutTag(true, null, reRender);
  }
  updateViewBox(viewBox, reLayout) {
    this._option.viewBox = viewBox, this._updateLayoutRect(viewBox), this.setLayoutTag(true, null, reLayout);
  }
  _createBackground() {
    const backgroundStyle = convertBackgroundSpec(this._spec.background);
    backgroundStyle && (this._backgroundMark = Factory2.createMark("group", "chart-background", {
      model: this,
      map: this._option.map,
      getCompiler: this.getCompiler,
      globalScale: this._globalScale
    }), this._backgroundMark.created(), this._backgroundMark.setStyle(Object.assign(Object.assign({}, backgroundStyle), {
      x: () => this._viewBox.x1,
      y: () => this._viewBox.y1,
      width: () => this._viewBox.x2 - this._viewBox.x1,
      height: () => this._viewBox.y2 - this._viewBox.y1
    })));
  }
  _createRegion(constructor, specInfo) {
    if (!constructor)
      return;
    const { spec } = specInfo, others = __rest13(specInfo, ["spec"]), region = new constructor(spec, Object.assign(Object.assign({}, this._modelOption), others));
    region && (region.created(), this._regions.push(region));
  }
  _createSeries(constructor, specInfo) {
    if (!constructor)
      return;
    const { spec } = specInfo, others = __rest13(specInfo, ["spec"]);
    let region;
    if (isValid_default(spec.regionId) ? region = this.getRegionsInUserId(spec.regionId) : isValid_default(spec.regionIndex) && (region = this.getRegionsInIndex([spec.regionIndex])[0]), !region && !(region = this._regions[0]))
      return;
    const series2 = new constructor(spec, Object.assign(Object.assign(Object.assign({}, this._modelOption), others), {
      type: spec.type,
      region,
      globalScale: this._globalScale,
      sourceDataList: this._chartData.dataList
    }));
    series2 && (series2.created(), this._series.push(series2), region.addSeries(series2));
  }
  getSeriesById(id2) {
    return this._series.find((x) => x.id === id2);
  }
  _createComponent(constructor, specInfo) {
    const component2 = constructor.createComponent(specInfo, Object.assign(Object.assign({}, this._modelOption), {
      type: constructor.type,
      getAllRegions: this.getAllRegions,
      getRegionsInIndex: this.getRegionsInIndex,
      getRegionsInIds: this.getRegionsInIds,
      getRegionsInUserIdOrIndex: this.getRegionsInUserIdOrIndex,
      getAllSeries: this.getAllSeries,
      getSeriesInIndex: this.getSeriesInIndex,
      getSeriesInIds: this.getSeriesInIds,
      getSeriesInUserIdOrIndex: this.getSeriesInUserIdOrIndex,
      getAllComponents: this.getComponents,
      getComponentByIndex: this.getComponentByIndex,
      getComponentByUserId: this.getComponentByUserId,
      getComponentsByKey: this.getComponentsByKey,
      getComponentsByType: this.getComponentsByType
    }));
    component2 && (component2.created(), this._components.push(component2));
  }
  getAllComponents() {
    return this._components;
  }
  getAllModels() {
    return [].concat(this.getAllSeries(), this.getAllComponents(), this.getAllRegions());
  }
  getModelInFilter(filter2) {
    if (isString_default(filter2))
      return this.getAllModels().find((m4) => m4.userId === filter2);
    if (isFunction_default(filter2))
      return this.getAllModels().find((m4) => filter2(m4));
    let index = 0;
    return this.getAllModels().find((m4) => {
      var _a;
      if ((null !== (_a = m4.specKey) && void 0 !== _a ? _a : m4.type) === filter2.type) {
        if (index === filter2.index)
          return true;
        index++;
      }
      return false;
    });
  }
  _createLayout() {
    this._updateLayoutRect(this._option.viewBox), this._initLayoutFunc();
  }
  setLayout(layout) {
    this._option.layout = layout, this._initLayoutFunc();
  }
  _initLayoutFunc() {
    var _a, _b, _c;
    if (this._layoutFunc = this._option.layout, !this._layoutFunc) {
      let use3dLayout = false;
      (this._spec.zField || this._spec.series && this._spec.series.some((s2) => s2.zField)) && (use3dLayout = true);
      const constructor = Factory2.getLayoutInKey(null !== (_b = null === (_a = this._spec.layout) || void 0 === _a ? void 0 : _a.type) && void 0 !== _b ? _b : use3dLayout ? "layout3d" : "base");
      if (constructor) {
        const layout = new constructor(this._spec.layout, {
          onError: null === (_c = this._option) || void 0 === _c ? void 0 : _c.onError
        });
        this._layoutFunc = layout.layoutItems.bind(layout);
      }
    }
  }
  layout(params2) {
    var _a, _b, _c, _d;
    if (null === (_b = null === (_a = this._option.performanceHook) || void 0 === _a ? void 0 : _a.beforeLayoutWithSceneGraph) || void 0 === _b || _b.call(_a), this.getLayoutTag()) {
      this._event.emit(ChartEvent.layoutStart, {
        chart: this,
        vchart: this._option.globalInstance
      }), this.onLayoutStart(params2);
      const elements = this.getLayoutElements();
      this._layoutFunc(this, elements, this._layoutRect, this._viewBox), this._event.emit(ChartEvent.afterLayout, {
        elements,
        chart: this
      }), this.setLayoutTag(false), this.onLayoutEnd(params2), this._event.emit(ChartEvent.layoutEnd, {
        chart: this,
        vchart: this._option.globalInstance
      });
    }
    null === (_d = null === (_c = this._option.performanceHook) || void 0 === _c ? void 0 : _c.afterLayoutWithSceneGraph) || void 0 === _d || _d.call(_c);
  }
  onLayoutStart(option) {
    this.getAllModels().forEach((element) => element.onLayoutStart(this._layoutRect, this._viewRect, option));
  }
  onLayoutEnd(option) {
    this.getAllModels().forEach((element) => {
      "series" !== element.modelType && element.onLayoutEnd(option);
    });
  }
  onEvaluateEnd(option) {
    [...this._components, ...this._regions, ...this._series].forEach((element) => element.onEvaluateEnd(option));
  }
  getLayoutElements() {
    return this.getAllModels().map((i) => i.layout).filter((i) => !!i);
  }
  getModelById(id2) {
    const model = this._idMap.get(id2);
    if (model && model instanceof BaseModel)
      return model;
  }
  getModelByUserId(userId) {
    const series2 = this.getSeriesInUserId(userId);
    if (series2)
      return series2;
    const region = this.getRegionsInUserId(userId);
    if (region)
      return region;
    const component2 = this.getComponentByUserId(userId);
    return component2 || void 0;
  }
  getAllMarks() {
    return Array.from(this._idMap.values()).filter((item) => item && item instanceof BaseMark);
  }
  getMarkById(id2) {
    const mark = this._idMap.get(id2);
    if (mark && mark instanceof BaseMark)
      return mark;
  }
  updateData(id2, data, updateGlobalScale = true, options) {
    const dv = this._dataSet.getDataView(id2);
    dv && (dv.markRunning(), dv.parseNewData(data, options)), updateGlobalScale && this.updateGlobalScaleDomain(), this.getAllModels().forEach((model) => model.onDataUpdate());
  }
  updateFullData(data, updateGlobalScale = true) {
    array(data).forEach((d) => {
      const dv = this._dataSet.getDataView(d.id);
      dv && dv.markRunning();
    }), array(data).forEach((d) => {
      const dv = this._dataSet.getDataView(d.id);
      dv && updateDataViewInData(dv, d, true);
    }), updateGlobalScale && this.updateGlobalScaleDomain(), this.getAllModels().forEach((model) => model.onDataUpdate());
  }
  onRender(option) {
  }
  setCanvasRect(width, height) {
    this._canvasRect = {
      width,
      height
    };
  }
  getCanvasRect() {
    return this._canvasRect || (this._canvasRect = calculateChartSize(this._spec, this._option, {
      width: DEFAULT_CHART_WIDTH,
      height: DEFAULT_CHART_HEIGHT
    })), this._canvasRect;
  }
  getSeriesData(id2, index) {
    return this._chartData.getSeriesData(id2, index);
  }
  _transformSpecScale() {
    var _a, _b;
    const scales = null !== (_a = this._spec.scales) && void 0 !== _a ? _a : [];
    let colorScaleSpec = scales.find((s2) => "color" === s2.id);
    const colorScheme3 = this.getColorScheme();
    if (!colorScaleSpec && (colorScaleSpec = {
      type: "ordinal",
      id: "color",
      domain: null,
      range: null
    }, scales.push(colorScaleSpec), this._spec.color)) {
      const colorSpec = this._spec.color;
      if (isArray_default(colorSpec))
        colorScaleSpec.range = colorSpec;
      else {
        const tempSpec = colorSpec;
        Object.prototype.hasOwnProperty.call(tempSpec, "type") && (colorScaleSpec.type = tempSpec.type), Object.prototype.hasOwnProperty.call(tempSpec, "domain") && (colorScaleSpec.domain = tempSpec.domain), Object.prototype.hasOwnProperty.call(tempSpec, "range") && (colorScaleSpec.range = tempSpec.range), Object.prototype.hasOwnProperty.call(tempSpec, "specified") && (colorScaleSpec.specified = tempSpec.specified);
      }
    }
    return (null === (_b = colorScaleSpec.range) || void 0 === _b ? void 0 : _b.length) || (colorScaleSpec.range = getDataScheme(colorScheme3), colorScaleSpec.rangeTheme = true), scales;
  }
  _createGlobalScale() {
    this._globalScale = new GlobalScale(this._transformSpecScale(), this), this._modelOption.globalScale = this._globalScale;
  }
  updateGlobalScaleDomain() {
    const domainSet = /* @__PURE__ */ new Set();
    this._series.forEach((s2) => {
      const keys2 = s2.getSeriesKeys();
      keys2 && keys2.forEach((k2) => domainSet.add(k2));
    });
    const domain = Array.from(domainSet);
    this._globalScale.updateScaleDomain(domain);
  }
  updateGlobalScale(result2) {
    mergeUpdateResult(result2, this._globalScale.updateSpec(this._transformSpecScale()));
  }
  updateGlobalScaleTheme() {
    const colorSpec = this._globalScale.getScaleSpec("color"), colorScheme3 = this.getColorScheme();
    colorSpec.rangeTheme && (colorSpec.range = getDataScheme(colorScheme3), this._globalScale.getScale("color").range(colorSpec.range));
  }
  updateSpec(spec) {
    const result2 = {
      change: false,
      reMake: false,
      reRender: false,
      reSize: false,
      reCompile: false
    };
    if (this.setLayoutTag(true, null, false), spec.type !== this.type)
      return result2.reMake = true, result2;
    const currentKeys = Object.keys(this._spec).sort(), nextKeys = Object.keys(spec).sort();
    if (JSON.stringify(currentKeys) !== JSON.stringify(nextKeys))
      return result2.reMake = true, result2;
    for (let i = 0; i < currentKeys.length; i++) {
      const key = currentKeys[i];
      if (isArray_default(this._spec[key]) && this._spec[key].length !== spec[key].length)
        return result2.reMake = true, result2;
    }
    const oldSpec = this._spec;
    return this._spec = spec, this.updateChartConfig(result2, oldSpec), result2.reMake ? result2 : (this.updateGlobalScale(result2), result2.reMake ? result2 : (this.updateRegionSpec(result2), result2.reMake ? result2 : (this.updateComponentSpec(result2), result2.reMake ? result2 : (this.updateSeriesSpec(result2), result2.reMake || (this.reInit(), this.updateDataSpec(), this.updateGlobalScaleDomain()), result2))));
  }
  updateChartConfig(result2, oldSpec) {
    var _a, _b;
    this._paddingSpec = normalizeLayoutPaddingSpec(null !== (_a = this._spec.padding) && void 0 !== _a ? _a : null === (_b = this._option) || void 0 === _b ? void 0 : _b.getTheme().padding), this._updateLayoutRect(this._viewBox), isEqual(this._spec.background, oldSpec.background) || (result2.reMake = true);
  }
  updateDataSpec() {
    this._spec.data && this._chartData.updateData(this._spec.data, false, true);
  }
  updateRegionSpec(result2) {
    var _a;
    (null === (_a = this._spec) || void 0 === _a ? void 0 : _a.region) && (this._spec.region.length === this._regions.length ? this._regions.forEach((r) => {
      mergeUpdateResult(result2, r.updateSpec(this._spec.region[r.getSpecIndex()]));
    }) : result2.reMake = true);
  }
  updateComponentSpec(result2) {
    const componentCache = {};
    this._components.forEach((c3) => {
      var _a, _b;
      const compSpecKey = c3.specKey || c3.type, cmpSpec = null !== (_a = this._spec[compSpecKey]) && void 0 !== _a ? _a : {};
      isArray_default(cmpSpec) ? (componentCache[compSpecKey] = componentCache[compSpecKey] || {
        specCount: cmpSpec.length,
        componentCount: 0
      }, componentCache[compSpecKey].componentCount++, mergeUpdateResult(result2, c3.updateSpec(null !== (_b = cmpSpec[c3.getSpecIndex()]) && void 0 !== _b ? _b : {}, cmpSpec))) : mergeUpdateResult(result2, c3.updateSpec(cmpSpec));
    });
    for (const key in componentCache)
      if (Object.prototype.hasOwnProperty.call(componentCache, key)) {
        const element = componentCache[key];
        element.componentCount !== element.specCount && (result2.reMake = true);
      }
  }
  updateSeriesSpec(result2) {
    this._spec.series.length === this._series.length ? this._series.forEach((s2) => {
      const spec = this._spec.series[s2.getSpecIndex()];
      mergeUpdateResult(result2, s2.updateSpec(spec));
    }) : result2.reMake = true;
  }
  getCanvas() {
    var _a, _b;
    return null !== (_b = null === (_a = this.getCompiler()) || void 0 === _a ? void 0 : _a.getCanvas()) && void 0 !== _b ? _b : null;
  }
  _updateLayoutRect(viewBox) {
    let viewRect = this.getCanvasRect();
    if (viewBox) {
      this._viewBox = viewBox;
      const { x1: x14 = 0, y1: y14 = 0, x2: x23, y2: y23 } = viewBox;
      viewRect = {
        width: x23 - x14,
        height: y23 - y14
      };
    } else
      this._viewBox = {
        x1: 0,
        y1: 0,
        x2: viewRect.width,
        y2: viewRect.height
      };
    this._viewRect = viewRect, this.padding = calcPadding(this._paddingSpec, viewRect, viewRect), this._layoutRect.width = viewRect.width - this.padding.left - this.padding.right, this._layoutRect.height = viewRect.height - this.padding.top - this.padding.bottom, this._layoutRect.x = this.padding.left, this._layoutRect.y = this.padding.top, this._event.emit(ChartEvent.layoutRectUpdate, {
      chart: this
    });
  }
  setCurrentTheme() {
    this.updateChartConfig({
      change: true,
      reMake: false
    }, this._spec), this.setLayoutTag(true, null, false), this.updateGlobalScaleTheme(), this.reInit();
  }
  reInit() {
    [...this._regions, ...this._series, ...this._components].forEach((model) => {
      const specInfo = model.getSpecInfo();
      specInfo && specInfo.spec && model.reInit(specInfo.spec);
    });
  }
  clear() {
    this.getAllModels().forEach((i) => {
      var _a;
      return null === (_a = i.clear) || void 0 === _a ? void 0 : _a.call(i);
    });
  }
  compile() {
    this.compileBackground(), this.compileLayout(), this.compileRegions(), this.compileSeries(), this.compileComponents();
  }
  afterCompile() {
    this.getAllRegions().forEach((r) => {
      var _a;
      null === (_a = r.afterCompile) || void 0 === _a || _a.call(r);
    }), this.getAllSeries().forEach((s2) => {
      var _a;
      null === (_a = s2.afterCompile) || void 0 === _a || _a.call(s2);
    }), this.getAllComponents().forEach((c3) => {
      var _a;
      null === (_a = c3.afterCompile) || void 0 === _a || _a.call(c3);
    });
  }
  compileLayout() {
    const { width, height } = this.getCanvasRect();
    this.getCompiler().setSize(width, height);
  }
  compileBackground() {
    var _a;
    this._backgroundMark && (this._backgroundMark.compile(), null === (_a = this._backgroundMark.getProduct()) || void 0 === _a || _a.configure({
      context: {
        model: this
      }
    }).layout(() => {
    }));
  }
  compileRegions() {
    var _a, _b, _c, _d;
    null === (_b = null === (_a = this._option.performanceHook) || void 0 === _a ? void 0 : _a.beforeRegionCompile) || void 0 === _b || _b.call(_a), this.getAllRegions().forEach((r) => {
      r.compile();
    }), null === (_d = null === (_c = this._option.performanceHook) || void 0 === _c ? void 0 : _c.afterRegionCompile) || void 0 === _d || _d.call(_c);
  }
  compileSeries() {
    var _a, _b, _c, _d;
    null === (_b = null === (_a = this._option.performanceHook) || void 0 === _a ? void 0 : _a.beforeSeriesCompile) || void 0 === _b || _b.call(_a), this.getAllSeries().forEach((s2) => {
      s2.compile();
    }), null === (_d = null === (_c = this._option.performanceHook) || void 0 === _c ? void 0 : _c.afterSeriesCompile) || void 0 === _d || _d.call(_c);
  }
  compileComponents() {
    var _a, _b, _c, _d;
    null === (_b = null === (_a = this._option.performanceHook) || void 0 === _a ? void 0 : _a.beforeComponentCompile) || void 0 === _b || _b.call(_a), this.getAllComponents().forEach((c3) => {
      c3.compile();
    }), null === (_d = null === (_c = this._option.performanceHook) || void 0 === _c ? void 0 : _c.afterComponentCompile) || void 0 === _d || _d.call(_c);
  }
  release() {
    [...this._components, ...this._regions, ...this._series].forEach((m4) => {
      m4.beforeRelease();
    }), super.release(), this.clear(), [...this._components, ...this._regions, ...this._series].forEach((m4) => {
      m4.release();
    }), this._components = this._regions = this._series = [], this._spec = {}, this._dataSet = this._globalScale = this._layoutFunc = null, this._layoutTag = false, this._idMap.clear();
  }
  onLayout(srView) {
    const root = srView.rootMark;
    this.layout({
      group: root,
      srView
    });
  }
  updateState(state, filter2) {
    const seriesArr = this.getAllSeries();
    for (const key in state) {
      if (isEmpty_default(state[key]))
        continue;
      const stateSpec = state[key];
      let stateInfo = {
        stateValue: key
      };
      stateInfo = isFunction_default(stateSpec.filter) ? Object.assign({
        filter: stateSpec.filter
      }, stateInfo) : Object.assign(Object.assign({}, stateSpec.filter), stateInfo), stateSpec.level && (stateInfo.level = stateSpec.level), seriesArr.forEach((series2) => {
        series2.getMarks().forEach((m4) => {
          m4.stateStyle[key] && (filter2 && !filter2(series2, m4, key) || (m4.state.changeStateInfo(stateInfo), m4.updateMarkState(key)));
        });
      });
    }
  }
  setSelected(datum, filter2, region) {
    this._setStateInDatum(STATE_VALUE_ENUM.STATE_SELECTED, true, datum, filter2, region);
  }
  setHovered(datum, filter2, region) {
    this._setStateInDatum(STATE_VALUE_ENUM.STATE_HOVER, true, datum, filter2, region);
  }
  clearState(state) {
    this.getAllRegions().forEach((r) => {
      r.interaction.clearEventElement(state, true), r.interaction.resetInteraction(state, null);
    });
  }
  clearSelected() {
    this.clearState(STATE_VALUE_ENUM.STATE_SELECTED);
  }
  clearHovered() {
    this.clearState(STATE_VALUE_ENUM.STATE_HOVER);
  }
  _initEvent() {
    [ChartEvent.dataZoomChange, ChartEvent.scrollBarChange].forEach((event) => {
      this._event.on(event, ({ value }) => {
        this._disableMarkAnimation(["exit", "update"]);
        const enableMarkAnimate = () => {
          this._enableMarkAnimation(["exit", "update"]), this._event.off(HOOK_EVENT.AFTER_MARK_RENDER_END, enableMarkAnimate);
        };
        this._event.on(HOOK_EVENT.AFTER_MARK_RENDER_END, enableMarkAnimate);
      });
    });
  }
  _enableMarkAnimation(states) {
    this.getAllMarks().forEach((mark) => {
      const product = mark.getProduct();
      product && product.animate && product.animate.enableAnimationState(states);
    });
  }
  _disableMarkAnimation(states) {
    this.getAllMarks().forEach((mark) => {
      const product = mark.getProduct();
      product && product.animate && product.animate.disableAnimationState(states);
    });
  }
  _setStateInDatum(stateKey, checkReverse, datum, filter2, region) {
    const keys2 = (datum = datum ? array(datum) : null) ? Object.keys(datum[0]) : null;
    this.getRegionsInQuerier(region).forEach((r) => {
      datum ? (r.getSeries().forEach((s2) => {
        s2.getMarks().forEach((m4) => {
          if (m4.getProduct() && (!filter2 || isFunction_default(filter2) && filter2(s2, m4))) {
            const isCollect = m4.getProduct().isCollectionMark(), elements = m4.getProduct().elements;
            let pickElements = elements;
            if (isCollect)
              pickElements = elements.filter((e) => {
                const elDatum = e.getDatum();
                datum.every((d, index) => keys2.every((k2) => d[k2] == elDatum[index][k2]));
              });
            else if (datum.length > 1) {
              const datumTemp = datum.slice();
              pickElements = elements.filter((e) => {
                if (0 === datumTemp.length)
                  return false;
                const elDatum = e.getDatum(), index = datumTemp.findIndex((d) => keys2.every((k2) => d[k2] == elDatum[k2]));
                return index >= 0 && (datumTemp.splice(index, 1), true);
              });
            } else {
              const el = elements.find((e) => keys2.every((k2) => datum[0][k2] == e.getDatum()[k2]));
              el && (pickElements = [el]);
            }
            pickElements.forEach((element) => {
              r.interaction.startInteraction(stateKey, element);
            });
          }
        });
      }), checkReverse && r.interaction.reverseEventElement(stateKey)) : r.interaction.clearEventElement(stateKey, true);
    });
  }
  setDimensionIndex(value, opt) {
    var _a, _b, _c, _d;
    let dimensionInfo = null;
    Array.from(this._event.getComposedEventMap().values()).forEach((e) => {
      const { eventType, event } = e;
      if (eventType === DimensionEventEnum.dimensionHover || eventType === DimensionEventEnum.dimensionClick) {
        const info = event.dispatch(value, opt);
        (null == info ? void 0 : info.length) && (dimensionInfo = info);
      }
    });
    const isUnableValue = isNil_default(value) || !dimensionInfo || dimensionInfo.every((d) => isDiscrete(d.axis.getScale().type) && isNil_default(d.index));
    if (false !== opt.tooltip) {
      const tooltip3 = this.getComponentsByType(ComponentTypeEnum.tooltip)[0];
      if (null == tooltip3 ? void 0 : tooltip3.getVisible())
        if (isUnableValue)
          null === (_b = (_a = tooltip3).hideTooltip) || void 0 === _b || _b.call(_a);
        else {
          const dataFilter = {};
          dimensionInfo.forEach((d) => {
            const { axis: axis2, value: value2, data } = d, isY = "left" === axis2.getOrient() || "right" === axis2.getOrient();
            data.forEach((d2) => {
              isY ? dataFilter[d2.series.fieldY[0]] = value2 : dataFilter[d2.series.fieldX[0]] = value2;
            });
          }), tooltip3.showTooltip(dataFilter, opt.showTooltipOption);
        }
    }
    if (false !== opt.crosshair) {
      const crosshair2 = this.getComponentsByType(ComponentTypeEnum.cartesianCrosshair)[0];
      crosshair2 && crosshair2.clearAxisValue && crosshair2.setAxisValue && (isUnableValue ? (null === (_c = crosshair2.clearAxisValue) || void 0 === _c || _c.call(crosshair2), null === (_d = crosshair2.hide) || void 0 === _d || _d.call(crosshair2)) : dimensionInfo.forEach((d) => {
        const { axis: axis2, value: value2 } = d;
        crosshair2.clearAxisValue(), crosshair2.setAxisValue(value2, axis2), crosshair2.layoutByValue();
      }));
    }
  }
  getColorScheme() {
    var _a, _b;
    return null === (_b = (_a = this._option).getTheme) || void 0 === _b ? void 0 : _b.call(_a).colorScheme;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/base/util
var getRelatedRegionInfo = (modelInfo, currentChartSpecInfo) => {
  var _a;
  const spec = modelInfo.spec, { regionId, regionIndex } = spec;
  if (isValid_default(regionId)) {
    const regionIdList = array(regionId);
    return null === (_a = currentChartSpecInfo.region) || void 0 === _a ? void 0 : _a.filter(({ spec: spec2 }) => regionIdList.includes(spec2.id));
  }
  if (isValid_default(regionIndex))
    return array(regionIndex).map((index) => {
      var _a2;
      return null === (_a2 = currentChartSpecInfo.region) || void 0 === _a2 ? void 0 : _a2[index];
    }).filter(isValid_default);
};
var getRelatedSeriesInfo = (modelInfo, currentChartSpecInfo) => {
  var _a;
  const spec = modelInfo.spec, { seriesId, seriesIndex } = spec;
  if (isValid_default(seriesId)) {
    const seriesIdList = array(seriesId);
    return null === (_a = currentChartSpecInfo.series) || void 0 === _a ? void 0 : _a.filter(({ spec: spec2 }) => seriesIdList.includes(spec2.id));
  }
  if (isValid_default(seriesIndex))
    return array(seriesIndex).map((index) => {
      var _a2;
      return null === (_a2 = currentChartSpecInfo.series) || void 0 === _a2 ? void 0 : _a2[index];
    }).filter(isValid_default);
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/base/base-chart-transformer
var BaseChartSpecTransformer = class {
  constructor(option) {
    this._option = option, this.type = option.type, this.seriesType = option.seriesType;
  }
  initChartSpec(chartSpec) {
    return this.transformSpec(chartSpec), this.transformModelSpec(chartSpec);
  }
  transformSpec(chartSpec) {
    chartSpec.region && 0 !== chartSpec.region.length || (chartSpec.region = [{}]), void 0 === chartSpec.tooltip && (chartSpec.tooltip = {}), isValid_default(chartSpec.stackInverse) && chartSpec.region.forEach((r) => {
      !isValid_default(r.stackInverse) && (r.stackInverse = chartSpec.stackInverse);
    }), isValid_default(chartSpec.stackSort) && chartSpec.region.forEach((r) => {
      !isValid_default(r.stackSort) && (r.stackSort = chartSpec.stackSort);
    });
  }
  transformModelSpec(chartSpec) {
    return this.createSpecInfo(chartSpec, (constructor, specInfo, chartSpecInfo) => {
      const { spec, specPath, specInfoPath, type } = specInfo, transformResult = new constructor.transformerConstructor(Object.assign(Object.assign({}, this._option), {
        type
      })).transformSpec(spec, chartSpec, chartSpecInfo);
      setProperty(chartSpec, specPath, transformResult.spec), setProperty(chartSpecInfo, null != specInfoPath ? specInfoPath : specPath, Object.assign(Object.assign({}, specInfo), transformResult));
    });
  }
  createSpecInfo(chartSpec, transform5) {
    var _a, _b;
    transform5 || (transform5 = (constructor, specInfo, chartSpecInfo) => {
      const { spec, specPath, specInfoPath, type } = specInfo, transformer2 = new constructor.transformerConstructor(Object.assign(Object.assign({}, this._option), {
        type
      }));
      setProperty(chartSpecInfo, null != specInfoPath ? specInfoPath : specPath, Object.assign(Object.assign({}, specInfo), {
        theme: transformer2.getTheme(spec, chartSpec)
      }));
    });
    const currentChartSpecInfo = {};
    return this.forEachRegionInSpec(chartSpec, transform5, currentChartSpecInfo), this.forEachSeriesInSpec(chartSpec, transform5, currentChartSpecInfo), null === (_a = currentChartSpecInfo.series) || void 0 === _a || _a.forEach((seriesSpecInfo, i) => {
      var _a2, _b2;
      const region = (null !== (_b2 = null !== (_a2 = getRelatedRegionInfo(seriesSpecInfo, currentChartSpecInfo)) && void 0 !== _a2 ? _a2 : currentChartSpecInfo.region) && void 0 !== _b2 ? _b2 : [])[0];
      region && (region.seriesIndexes || (region.seriesIndexes = []), region.seriesIndexes.push(i), seriesSpecInfo.regionIndexes = region.regionIndexes.slice());
    }), this.forEachComponentInSpec(chartSpec, transform5, currentChartSpecInfo), Object.values(null !== (_b = currentChartSpecInfo.component) && void 0 !== _b ? _b : {}).forEach((specInfoList) => specInfoList.forEach((componentSpecInfo, i) => {
      var _a2, _b2, _c;
      if (componentSpecInfo) {
        if (!componentSpecInfo.regionIndexes) {
          const relatedRegion = null !== (_b2 = null !== (_a2 = getRelatedRegionInfo(componentSpecInfo, currentChartSpecInfo)) && void 0 !== _a2 ? _a2 : currentChartSpecInfo.region) && void 0 !== _b2 ? _b2 : [];
          componentSpecInfo.regionIndexes = relatedRegion.map((region) => region.regionIndexes[0]);
        }
        if (!componentSpecInfo.seriesIndexes) {
          const seriesInfo = getRelatedSeriesInfo(componentSpecInfo, currentChartSpecInfo);
          if (seriesInfo)
            componentSpecInfo.seriesIndexes = seriesInfo.map(({ seriesIndexes }) => seriesIndexes[0]);
          else {
            const seriesIndexSet = /* @__PURE__ */ new Set();
            (null !== (_c = componentSpecInfo.regionIndexes) && void 0 !== _c ? _c : []).forEach((regionIndex) => {
              var _a3, _b3;
              const region = null === (_a3 = currentChartSpecInfo.region) || void 0 === _a3 ? void 0 : _a3[regionIndex];
              null === (_b3 = null == region ? void 0 : region.seriesIndexes) || void 0 === _b3 || _b3.forEach((seriesIndex) => seriesIndexSet.add(seriesIndex));
            }), componentSpecInfo.seriesIndexes = Array.from(seriesIndexSet);
          }
        }
      }
    })), currentChartSpecInfo;
  }
  _isValidSeries(seriesType) {
    return true;
  }
  _getDefaultSeriesSpec(chartSpec) {
    var _a, _b, _c, _d;
    return {
      dataKey: chartSpec.dataKey,
      hover: chartSpec.hover,
      select: chartSpec.select,
      label: chartSpec.label,
      seriesStyle: chartSpec.seriesStyle,
      animation: null !== (_a = chartSpec.animation) && void 0 !== _a ? _a : this._option.animation,
      animationThreshold: null !== (_b = chartSpec.animationThreshold) && void 0 !== _b ? _b : null === (_d = (_c = this._option).getTheme) || void 0 === _d ? void 0 : _d.call(_c).animationThreshold,
      animationAppear: chartSpec.animationAppear,
      animationDisappear: chartSpec.animationDisappear,
      animationEnter: chartSpec.animationEnter,
      animationUpdate: chartSpec.animationUpdate,
      animationExit: chartSpec.animationExit,
      animationNormal: chartSpec.animationNormal,
      extensionMark: chartSpec.extensionMark,
      large: chartSpec.large,
      largeThreshold: chartSpec.largeThreshold,
      progressiveStep: chartSpec.progressiveStep,
      progressiveThreshold: chartSpec.progressiveThreshold,
      background: chartSpec.seriesBackground,
      invalidType: chartSpec.invalidType,
      seriesField: chartSpec.seriesField,
      morph: chartSpec.morph,
      interactions: chartSpec.interactions
    };
  }
  forEachRegionInSpec(chartSpec, callbackfn, chartSpecInfo) {
    var _a;
    return (null !== (_a = chartSpec.region) && void 0 !== _a ? _a : []).map((spec, index) => callbackfn(Factory2.getRegionInType("region"), {
      spec,
      specPath: ["region", index],
      type: "region",
      regionIndexes: [index]
    }, chartSpecInfo));
  }
  forEachSeriesInSpec(chartSpec, callbackfn, chartSpecInfo) {
    var _a;
    return (null !== (_a = chartSpec.series) && void 0 !== _a ? _a : []).map((spec, index) => callbackfn(Factory2.getSeriesInType(spec.type), {
      spec,
      specPath: ["series", index],
      type: spec.type,
      seriesIndexes: [index]
    }, chartSpecInfo));
  }
  forEachComponentInSpec(chartSpec, callbackfn, chartSpecInfo) {
    var _a, _b, _c;
    const results = [], components = Factory2.getComponents();
    let cartesianAxis, polarAxis, geoCoordinate, tooltip3;
    const otherComponents = [];
    for (let index = 0; index < components.length; index++) {
      const { cmp, alwaysCheck } = components[index];
      cmp.type.startsWith(ComponentTypeEnum.cartesianAxis) ? cartesianAxis = cmp : cmp.type.startsWith(ComponentTypeEnum.polarAxis) ? polarAxis = cmp : cmp.type === ComponentTypeEnum.geoCoordinate ? geoCoordinate = cmp : (alwaysCheck || chartSpec[null !== (_a = cmp.specKey) && void 0 !== _a ? _a : cmp.type]) && (cmp.type === ComponentTypeEnum.tooltip ? tooltip3 = cmp : otherComponents.push(cmp));
    }
    let hasInitAxis = false;
    if (cartesianAxis) {
      const infoList = cartesianAxis.getSpecInfo(chartSpec, chartSpecInfo);
      (null == infoList ? void 0 : infoList.length) > 0 && (hasInitAxis = true, infoList.forEach((info) => {
        const cmp = Factory2.getComponentInKey(info.type);
        results.push(callbackfn(cmp, info, chartSpecInfo));
      }));
    }
    if (polarAxis && !hasInitAxis) {
      const infoList = polarAxis.getSpecInfo(chartSpec, chartSpecInfo);
      (null == infoList ? void 0 : infoList.length) > 0 && (hasInitAxis = true, infoList.forEach((info) => {
        const cmp = Factory2.getComponentInKey(info.type);
        results.push(callbackfn(cmp, info, chartSpecInfo));
      }));
    }
    return geoCoordinate && !hasInitAxis && (null === (_b = geoCoordinate.getSpecInfo(chartSpec, chartSpecInfo)) || void 0 === _b || _b.forEach((info) => {
      results.push(callbackfn(geoCoordinate, info, chartSpecInfo));
    })), otherComponents.forEach((C) => {
      var _a2;
      null === (_a2 = C.getSpecInfo(chartSpec, chartSpecInfo)) || void 0 === _a2 || _a2.forEach((info) => {
        results.push(callbackfn(C, info, chartSpecInfo));
      });
    }), null === (_c = null == tooltip3 ? void 0 : tooltip3.getSpecInfo(chartSpec, chartSpecInfo)) || void 0 === _c || _c.forEach((info) => {
      results.push(callbackfn(tooltip3, info, chartSpecInfo));
    }), results;
  }
  transformSeriesSpec(spec) {
    const defaultSeriesSpec = this._getDefaultSeriesSpec(spec);
    spec.series && 0 !== spec.series.length ? spec.series.forEach((s2) => {
      this._isValidSeries(s2.type) && Object.keys(defaultSeriesSpec).forEach((k2) => {
        k2 in s2 || (s2[k2] = defaultSeriesSpec[k2]);
      });
    }) : spec.series = [defaultSeriesSpec];
  }
  _findBandAxisBySeries(seriesSpec, seriesIndex, axesSpec) {
    const matchOrient = "horizontal" === (null == seriesSpec ? void 0 : seriesSpec.direction) ? ["left", "right"] : ["top", "bottom"];
    return axesSpec.find((axis2) => {
      if (!matchOrient.includes(axis2.orient))
        return false;
      if (isValid_default(axis2.seriesId)) {
        if (array(axis2.seriesId).includes(null == seriesSpec ? void 0 : seriesSpec.id))
          return true;
      } else if (isValid_default(axis2.seriesIndex)) {
        if (array(axis2.seriesIndex).includes(seriesIndex))
          return true;
      } else if ("band" === axis2.type)
        return true;
      return true;
    });
  }
  _applyAxisBandSize(axis2, extend, barWidthSpec) {
    const { barMaxWidth, barMinWidth, barWidth, barGapInGroup } = barWidthSpec;
    let hasBarWidth = false;
    isNumber_default(barMinWidth) ? (axis2.minBandSize = barMinWidth, hasBarWidth = true) : isNumber_default(barWidth) ? (axis2.minBandSize = barWidth, hasBarWidth = true) : isNumber_default(barMaxWidth) && (axis2.minBandSize = barMaxWidth, hasBarWidth = true), hasBarWidth && (axis2.bandSizeLevel = Number.MAX_VALUE, axis2.bandSizeExtend = {
      extend,
      gap: isArray_default(barGapInGroup) ? barGapInGroup[barGapInGroup.length - 1] : barGapInGroup
    });
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/cartesian/cartesian-transformer
var CartesianChartSpecTransformer = class extends BaseChartSpecTransformer {
  needAxes() {
    return true;
  }
  _isValidSeries(type) {
    return !this.seriesType || type === this.seriesType;
  }
  _getDefaultSeriesSpec(spec) {
    const series2 = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      xField: spec.xField,
      yField: spec.yField,
      zField: spec.zField,
      seriesField: spec.seriesField,
      seriesStyle: spec.seriesStyle,
      direction: spec.direction,
      stack: spec.stack,
      percent: spec.percent,
      stackOffsetSilhouette: spec.stackOffsetSilhouette,
      totalLabel: spec.totalLabel,
      sortDataByAxis: spec.sortDataByAxis
    }), seriesType = this.seriesType;
    return seriesType && (series2.type = seriesType, series2[seriesType] = spec[seriesType]), series2;
  }
  transformSpec(spec) {
    super.transformSpec(spec);
    const defaultSeriesSpec = this._getDefaultSeriesSpec(spec);
    spec.series && 0 !== spec.series.length ? spec.series.forEach((s2) => {
      this._isValidSeries(s2.type) && Object.keys(defaultSeriesSpec).forEach((k2) => {
        k2 in s2 || (s2[k2] = defaultSeriesSpec[k2]);
      });
    }) : spec.series = [defaultSeriesSpec], this._transformAxisSpec(spec);
  }
  _transformAxisSpec(spec) {
    if (this.needAxes()) {
      spec.axes || (spec.axes = []);
      const haxAxes = {
        x: false,
        y: false,
        z: false
      };
      spec.axes.forEach((axis2) => {
        const { orient } = axis2;
        "top" !== orient && "bottom" !== orient || (haxAxes.x = true), "left" !== orient && "right" !== orient || (haxAxes.y = true), "z" === orient && (haxAxes.z = true), get_default(axis2, "trimPadding") && mergeSpec(axis2, getTrimPaddingConfig(this.type, spec));
      }), haxAxes.x || spec.axes.push({
        orient: "bottom"
      }), haxAxes.y || spec.axes.push({
        orient: "left"
      }), spec.zField && !haxAxes.z && spec.axes.push({
        orient: "z"
      });
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/area/area-transformer
var AreaChartSpecTransformer = class extends CartesianChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      point: spec.point,
      line: spec.line,
      area: spec.area,
      seriesMark: spec.seriesMark,
      activePoint: spec.activePoint,
      sampling: spec.sampling,
      samplingFactor: spec.samplingFactor,
      pointDis: spec.pointDis,
      pointDisMul: spec.pointDisMul,
      markOverlap: spec.markOverlap,
      areaLabel: spec.areaLabel
    });
  }
  transformSpec(spec) {
    super.transformSpec(spec), setDefaultCrosshairForCartesianChart(spec);
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/area/area
var AreaChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = AreaChartSpecTransformer, this.type = "area", this.seriesType = SeriesTypeEnum.area, this._canStack = true;
  }
};
AreaChart.type = "area", AreaChart.seriesType = SeriesTypeEnum.area, AreaChart.transformerConstructor = AreaChartSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/bar/animation
function barGrowOption(barParams, isOverall = true) {
  return (datum, element, params2) => {
    const field3 = "vertical" === barParams.direction ? barParams.yField : barParams.xField, data = null == datum ? void 0 : datum[field3];
    return "vertical" === barParams.direction ? {
      overall: isOverall ? barParams.growFrom() : isOverall,
      orient: data > 0 ? "negative" : "positive"
    } : {
      overall: !!isOverall && barParams.growFrom(),
      orient: data > 0 ? "positive" : "negative"
    };
  };
}
var barGrowIn = (params2, isOverall = true) => ({
  type: "horizontal" === params2.direction ? "growWidthIn" : "growHeightIn",
  options: barGrowOption(params2, isOverall)
});
var barGrowOut = (params2, isOverall = true) => ({
  type: "horizontal" === params2.direction ? "growWidthOut" : "growHeightOut",
  options: barGrowOption(params2, isOverall)
});
var Appear_FadeIn2 = {
  type: "fadeIn"
};
var Appear_ScaleIn = {
  type: "growCenterIn"
};
function barPresetAnimation(params2, preset) {
  if (false === preset)
    return {};
  switch (preset) {
    case "fadeIn":
      return Appear_FadeIn2;
    case "scaleIn":
      return Appear_ScaleIn;
    default:
      return barGrowIn(params2);
  }
}
var registerBarAnimation = () => {
  Factory2.registerAnimation("bar", (params2, preset) => ({
    appear: barPresetAnimation(params2, preset),
    enter: barGrowIn(params2, false),
    exit: barGrowOut(params2, false),
    disappear: barGrowOut(params2)
  }));
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/mark/rect
var RectMark = class _RectMark extends BaseMark {
  constructor() {
    super(...arguments), this.type = _RectMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      width: void 0,
      height: void 0,
      lineWidth: 0
    });
  }
};
RectMark.type = "rect";
var registerRectMark = () => {
  Factory2.registerMark(RectMark.type, RectMark), registerRectGraphic2(), registerVGrammarRectAnimation();
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/util/stack
function stackWithMinHeight(stackCache, stackInverse, context) {
  var _a, _b;
  if (stackCache.values.length > 0) {
    let lastY;
    if (stackCache.sortDatums.length) {
      let sortDatums = stackCache.sortDatums;
      stackInverse && (sortDatums = stackCache.sortDatums.slice().reverse());
      for (let index = 0; index < sortDatums.length; index++)
        lastY = computeOneDatumY(sortDatums[index].datum, lastY, sortDatums[index].series, context, null === (_b = (_a = sortDatums[index].series[context.axisHelper]).getScale) || void 0 === _b ? void 0 : _b.call(_a, 0), 0 === index);
    } else {
      let seriesInfo = stackCache.series;
      stackInverse && (seriesInfo = seriesInfo.slice().reverse()), seriesInfo.forEach(({ s: s2, values }, sIndex) => {
        var _a2, _b2;
        const seriesScale = null === (_b2 = (_a2 = s2[context.axisHelper]).getScale) || void 0 === _b2 ? void 0 : _b2.call(_a2, 0);
        for (let index = 0; index < values.length; index++) {
          const obj = values[stackInverse ? values.length - 1 - index : index];
          lastY = computeOneDatumY(obj, lastY, s2, context, seriesScale, 0 === index && 0 === sIndex);
        }
      });
    }
  }
  for (const key in stackCache.nodes)
    stackWithMinHeight(stackCache.nodes[key], stackInverse, context);
}
function computeOneDatumY(obj, lastY, s2, context, seriesScale, isFirst) {
  const barMinHeight = s2.getSpec().barMinHeight, inverse = s2[context.axisHelper].isInverse(), y14 = valueInScaleRange(s2[context.startMethod](obj), seriesScale);
  let y = valueInScaleRange(s2[context.endMethod](obj), seriesScale);
  isFirst && (lastY = y14);
  let height = Math.abs(y14 - y);
  height < barMinHeight && (height = barMinHeight);
  let flag = 1;
  return y < y14 ? flag = -1 : y === y14 && (flag = context.isVertical ? inverse ? 1 : -1 : inverse ? -1 : 1), y = lastY + flag * height, obj[context.start] = lastY, obj[context.end] = y, y;
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/bar/bar-transformer
var BarSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  constructor() {
    super(...arguments), this._supportStack = true;
  }
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "bar");
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/bar/bar
var BarSeries = class _BarSeries extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.bar, this._barMarkName = "bar", this._barMarkType = "rect", this.transformerConstructor = BarSeriesSpecTransformer, this._bandPosition = 0, this._getBarXStart = (datum, scale4) => this._shouldDoPreCalculate() ? (this._calculateStackRectPosition(false), datum[RECT_X]) : this._spec.barMinHeight ? this._calculateRectPosition(datum, false) : valueInScaleRange(this._dataToPosX(datum), scale4), this._getBarXEnd = (datum, scale4) => this._shouldDoPreCalculate() ? (this._calculateStackRectPosition(false), datum[RECT_X1]) : valueInScaleRange(this._dataToPosX1(datum), scale4), this._getBarYStart = (datum, scale4) => this._shouldDoPreCalculate() ? (this._calculateStackRectPosition(true), datum[RECT_Y]) : this._spec.barMinHeight ? this._calculateRectPosition(datum, true) : valueInScaleRange(this._dataToPosY(datum), scale4), this._getBarYEnd = (datum, scale4) => this._shouldDoPreCalculate() ? (this._calculateStackRectPosition(true), datum[RECT_Y1]) : valueInScaleRange(this._dataToPosY1(datum), scale4), this._getBarBackgroundXStart = (scale4) => {
      const range2 = scale4.range();
      return Math.min(range2[0], range2[range2.length - 1]);
    }, this._getBarBackgroundXEnd = (scale4) => {
      const range2 = scale4.range();
      return Math.max(range2[0], range2[range2.length - 1]);
    }, this._getBarBackgroundYStart = (scale4) => {
      const range2 = scale4.range();
      return Math.min(range2[0], range2[range2.length - 1]);
    }, this._getBarBackgroundYEnd = (scale4) => {
      const range2 = scale4.range();
      return Math.max(range2[0], range2[range2.length - 1]);
    }, this._getBarBackgroundPositionXEncoder = () => {
      var _a;
      return null === (_a = this._barBackgroundPositionXEncoder) || void 0 === _a ? void 0 : _a.bind(this);
    }, this._setBarBackgroundPositionXEncoder = (encoder) => {
      this._barBackgroundPositionXEncoder = encoder.bind(this);
    }, this._getBarBackgroundPositionYEncoder = () => {
      var _a;
      return null === (_a = this._barBackgroundPositionYEncoder) || void 0 === _a ? void 0 : _a.bind(this);
    }, this._setBarBackgroundPositionYEncoder = (encoder) => {
      this._barBackgroundPositionYEncoder = encoder.bind(this);
    };
  }
  initMark() {
    var _a, _b;
    const progressive = {
      progressiveStep: this._spec.progressiveStep,
      progressiveThreshold: this._spec.progressiveThreshold,
      large: this._spec.large,
      largeThreshold: this._spec.largeThreshold
    };
    this._initBarBackgroundMark(progressive), this._barMark = this._createMark(Object.assign(Object.assign({}, _BarSeries.mark.bar), {
      name: this._barMarkName,
      type: this._barMarkType
    }), {
      morph: shouldMarkDoMorph(this._spec, this._barMarkName),
      defaultMorphElementKey: this.getDimensionField()[0],
      groupKey: this._seriesField,
      isSeriesMark: true,
      progressive,
      customShape: null === (_a = this._spec.bar) || void 0 === _a ? void 0 : _a.customShape,
      stateSort: null === (_b = this._spec.bar) || void 0 === _b ? void 0 : _b.stateSort
    });
  }
  _initBarBackgroundMark(progressive) {
    this._spec.barBackground && this._spec.barBackground.visible && (this._barBackgroundMark = this._createMark(_BarSeries.mark.barBackground, {
      dataView: this._barBackgroundViewData.getDataView(),
      dataProductId: this._barBackgroundViewData.getProductId(),
      progressive,
      customShape: this._spec.barBackground.customShape,
      stateSort: this._spec.barBackground.stateSort
    }));
  }
  initMarkStyle() {
    this._barMark && this.setMarkStyle(this._barMark, {
      fill: this.getColorAttribute()
    }, "normal", AttributeLevel.Series);
  }
  initLabelMarkStyle(textMark) {
    textMark && this.setMarkStyle(textMark, {
      fill: this.getColorAttribute(),
      text: (datum) => datum[this.getStackValueField()],
      z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
    });
  }
  initTooltip() {
    super.initTooltip();
    const { mark, group } = this._tooltipHelper.activeTriggerSet;
    this._barMark && (mark.add(this._barMark), group.add(this._barMark));
  }
  _statisticViewData() {
    var _a, _b;
    super._statisticViewData();
    const spec = null !== (_a = this._spec.barBackground) && void 0 !== _a ? _a : {};
    if (!spec.visible)
      return;
    const hasBandAxis = this._getRelatedComponentSpecInfo("axes").some((axisInfo) => axisInfo.type === ComponentTypeEnum.cartesianBandAxis);
    let barBackgroundData;
    if (registerDataSetInstanceTransform(this._option.dataSet, "addVChartProperty", addVChartProperty), hasBandAxis) {
      const dimensionItems = ([data], { scaleDepth }) => {
        var _a2;
        let dataCollect = [{}];
        const fields2 = this.getDimensionField(), depth = isNil_default(scaleDepth) ? fields2.length : Math.min(fields2.length, scaleDepth);
        for (let i = 0; i < depth; i++) {
          const field3 = fields2[i], values = null === (_a2 = data.latestData[field3]) || void 0 === _a2 ? void 0 : _a2.values;
          if (!(null == values ? void 0 : values.length))
            continue;
          const newDataCollect = [];
          for (let j = 0; j < values.length; j++)
            for (let k2 = 0; k2 < dataCollect.length; k2++)
              newDataCollect.push(Object.assign(Object.assign({}, dataCollect[k2]), {
                [field3]: values[j]
              }));
          dataCollect = newDataCollect;
        }
        return dataCollect;
      };
      registerDataSetInstanceTransform(this._option.dataSet, "dimensionItems", dimensionItems), barBackgroundData = new DataView(this._option.dataSet).parse([this._viewDataStatistics], {
        type: "dataview"
      }).transform({
        type: "dimensionItems",
        options: {
          scaleDepth: isNil_default(spec.fieldLevel) ? void 0 : spec.fieldLevel + 1
        }
      }, false).transform({
        type: "addVChartProperty",
        options: {
          beforeCall: initKeyMap.bind(this),
          call: addDataKey
        }
      }, false), null === (_b = this._viewDataStatistics) || void 0 === _b || _b.target.addListener("change", barBackgroundData.reRunAllTransform);
    } else {
      const dimensionItems = ([data]) => {
        const dataCollect = [], [field0, field1] = this.getDimensionContinuousField(), map4 = {};
        return viewData.latestData.forEach((datum) => {
          const key = `${datum[field0]}-${datum[field1]}`;
          map4[key] || (map4[key] = {
            [field0]: datum[field0],
            [field1]: datum[field1]
          }, dataCollect.push(map4[key]));
        }), dataCollect;
      };
      registerDataSetInstanceTransform(this._option.dataSet, "dimensionItems", dimensionItems);
      const viewData = this.getViewData();
      barBackgroundData = new DataView(this._option.dataSet).parse([viewData], {
        type: "dataview"
      }).transform({
        type: "dimensionItems"
      }, false).transform({
        type: "addVChartProperty",
        options: {
          beforeCall: initKeyMap.bind(this),
          call: addDataKey
        }
      }, false), null == viewData || viewData.target.addListener("change", barBackgroundData.reRunAllTransform);
    }
    this._barBackgroundViewData = new SeriesData(this._option, barBackgroundData);
  }
  init(option) {
    var _a, _b;
    super.init(option), "vertical" === this.direction ? "band" === (null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.getScale(0).type) ? this.initBandRectMarkStyle() : this.initLinearRectMarkStyle() : "band" === (null === (_b = this._yAxisHelper) || void 0 === _b ? void 0 : _b.getScale(0).type) ? this.initBandRectMarkStyle() : this.initLinearRectMarkStyle();
  }
  _shouldDoPreCalculate() {
    const region = this.getRegion();
    return this.getStack() && region.getSeries().filter((s2) => s2.type === this.type && s2.getSpec().barMinHeight).length;
  }
  _calculateStackRectPosition(isVertical3) {
    const region = this.getRegion();
    if (region._bar_series_position_calculated)
      return;
    let start, end, startMethod, endMethod, axisHelper;
    region._bar_series_position_calculated = true, isVertical3 ? (start = RECT_Y1, end = RECT_Y, startMethod = "_dataToPosY1", endMethod = "_dataToPosY", axisHelper = "_yAxisHelper") : (start = RECT_X1, end = RECT_X, startMethod = "_dataToPosX1", endMethod = "_dataToPosX", axisHelper = "_xAxisHelper");
    const stackValueGroup = getRegionStackGroup(region, false, (s2) => s2.type === this.type);
    for (const stackValue in stackValueGroup)
      for (const key in stackValueGroup[stackValue].nodes)
        stackWithMinHeight(stackValueGroup[stackValue].nodes[key], region.getStackInverse(), {
          isVertical: isVertical3,
          start,
          end,
          startMethod,
          endMethod,
          axisHelper
        });
  }
  _calculateRectPosition(datum, isVertical3) {
    var _a, _b;
    let startMethod, endMethod, axisHelper;
    isVertical3 ? (startMethod = "_dataToPosY1", endMethod = "_dataToPosY", axisHelper = "_yAxisHelper") : (startMethod = "_dataToPosX1", endMethod = "_dataToPosX", axisHelper = "_xAxisHelper");
    const seriesScale = null === (_b = (_a = this[axisHelper]).getScale) || void 0 === _b ? void 0 : _b.call(_a, 0), inverse = this[axisHelper].isInverse(), barMinHeight = this._spec.barMinHeight, y14 = valueInScaleRange(this[startMethod](datum), seriesScale), y = valueInScaleRange(this[endMethod](datum), seriesScale);
    let height = Math.abs(y14 - y);
    height < barMinHeight && (height = barMinHeight);
    let flag = 1;
    return y < y14 ? flag = -1 : y === y14 && (flag = isVertical3 ? inverse ? 1 : -1 : inverse ? -1 : 1), y14 + flag * height;
  }
  _dataToPosX(datum) {
    return this.dataToPositionX(datum);
  }
  _dataToPosX1(datum) {
    return this.dataToPositionX1(datum);
  }
  _dataToPosY(datum) {
    return this.dataToPositionY(datum);
  }
  _dataToPosY1(datum) {
    return this.dataToPositionY1(datum);
  }
  initBandRectMarkStyle() {
    var _a, _b, _c, _d;
    const xScale = null === (_b = null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0), yScale = null === (_d = null === (_c = this._yAxisHelper) || void 0 === _c ? void 0 : _c.getScale) || void 0 === _d ? void 0 : _d.call(_c, 0);
    "horizontal" === this.direction ? this.setMarkStyle(this._barMark, {
      x: (datum) => this._getBarXStart(datum, xScale),
      x1: (datum) => this._getBarXEnd(datum, xScale),
      y: (datum) => this._getPosition(this.direction, datum),
      height: () => this._getBarWidth(this._yAxisHelper),
      width: () => {
      },
      y1: () => {
      }
    }, "normal", AttributeLevel.Series) : this.setMarkStyle(this._barMark, {
      y: (datum) => this._getBarYStart(datum, yScale),
      y1: (datum) => this._getBarYEnd(datum, yScale),
      x: (datum) => this._getPosition(this.direction, datum),
      width: () => this._getBarWidth(this._xAxisHelper),
      x1: () => {
      },
      height: () => {
      }
    }, "normal", AttributeLevel.Series), this._initStackBarMarkStyle(), this._initBandBarBackgroundMarkStyle();
  }
  _initStackBarMarkStyle() {
    var _a, _b, _c, _d;
    if (!this._spec.stackCornerRadius)
      return;
    const xScale = null === (_b = null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0), yScale = null === (_d = null === (_c = this._yAxisHelper) || void 0 === _c ? void 0 : _c.getScale) || void 0 === _d ? void 0 : _d.call(_c, 0);
    this._barMark.setClip(() => {
      const rectPaths = [];
      return this._forEachStackGroup((node) => {
        let min3 = 1 / 0, max3 = -1 / 0, hasPercent = false, minPercent = 1 / 0, maxPercent = -1 / 0;
        node.values.forEach((datum) => {
          const start = datum[STACK_FIELD_START], end = datum[STACK_FIELD_END], startPercent = datum[STACK_FIELD_START_PERCENT], endPercent = datum[STACK_FIELD_END_PERCENT];
          min3 = Math.min(min3, start, end), max3 = Math.max(max3, start, end), isValid_default(startPercent) && isValid_default(endPercent) && (hasPercent = true, minPercent = Math.min(minPercent, startPercent, endPercent), maxPercent = Math.max(maxPercent, startPercent, endPercent));
        });
        const mockDatum = Object.assign(Object.assign(Object.assign({}, node.values[0]), {
          [STACK_FIELD_START]: min3,
          [STACK_FIELD_END]: max3
        }), hasPercent ? {
          [STACK_FIELD_START_PERCENT]: minPercent,
          [STACK_FIELD_END_PERCENT]: maxPercent
        } : void 0);
        rectPaths.push(createRect(Object.assign(Object.assign({}, "horizontal" === this.direction ? {
          x: this._getBarXStart(mockDatum, xScale),
          x1: this._getBarXEnd(mockDatum, xScale),
          y: this._getPosition(this.direction, mockDatum),
          height: this._getBarWidth(this._yAxisHelper)
        } : {
          y: this._getBarYStart(mockDatum, yScale),
          y1: this._getBarYEnd(mockDatum, yScale),
          x: this._getPosition(this.direction, mockDatum),
          width: this._getBarWidth(this._xAxisHelper)
        }), {
          cornerRadius: this._spec.stackCornerRadius,
          fill: true
        })));
      }), rectPaths;
    });
  }
  initLinearRectMarkStyle() {
    var _a, _b, _c, _d;
    const xScale = null === (_b = null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0), yScale = null === (_d = null === (_c = this._yAxisHelper) || void 0 === _c ? void 0 : _c.getScale) || void 0 === _d ? void 0 : _d.call(_c, 0);
    if ("horizontal" === this.direction) {
      const yChannels = isValid_default(this._fieldY2) ? {
        y: (datum) => valueInScaleRange(this._dataToPosY(datum), yScale),
        y1: (datum) => valueInScaleRange(this._dataToPosY1(datum), yScale)
      } : {
        y: (datum) => valueInScaleRange(this._dataToPosY(datum) - this._getBarWidth(this._yAxisHelper) / 2, yScale),
        height: (datum) => this._getBarWidth(this._yAxisHelper)
      };
      this.setMarkStyle(this._barMark, Object.assign({
        x: (datum) => this._getBarXStart(datum, xScale),
        x1: (datum) => this._getBarXEnd(datum, xScale)
      }, yChannels), "normal", AttributeLevel.Series), this.setMarkStyle(this._barBackgroundMark, Object.assign({
        x: () => this._getBarBackgroundXStart(xScale),
        x1: () => this._getBarBackgroundXEnd(xScale)
      }, yChannels), "normal", AttributeLevel.Series);
    } else {
      const xChannels = isValid_default(this._fieldX2) ? {
        x: (datum) => valueInScaleRange(this._dataToPosX(datum), xScale),
        x1: (datum) => valueInScaleRange(this._dataToPosX1(datum), xScale)
      } : {
        x: (datum) => valueInScaleRange(this._dataToPosX(datum) - this._getBarWidth(this._xAxisHelper) / 2, xScale),
        width: (datum) => this._getBarWidth(this._xAxisHelper)
      };
      this.setMarkStyle(this._barMark, Object.assign(Object.assign({}, xChannels), {
        y: (datum) => this._getBarYStart(datum, yScale),
        y1: (datum) => this._getBarYEnd(datum, yScale)
      }), "normal", AttributeLevel.Series), this.setMarkStyle(this._barBackgroundMark, Object.assign(Object.assign({}, xChannels), {
        y: () => this._getBarBackgroundYStart(yScale),
        y1: () => this._getBarBackgroundYEnd(yScale)
      }), "normal", AttributeLevel.Series);
    }
  }
  _initBandBarBackgroundMarkStyle() {
    var _a, _b, _c, _d, _e;
    if (!this._barBackgroundMark)
      return;
    const xScale = null === (_b = null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0), yScale = null === (_d = null === (_c = this._yAxisHelper) || void 0 === _c ? void 0 : _c.getScale) || void 0 === _d ? void 0 : _d.call(_c, 0), spec = null !== (_e = this._spec.barBackground) && void 0 !== _e ? _e : {}, scaleDepth = isNil_default(spec.fieldLevel) ? void 0 : spec.fieldLevel + 1;
    "horizontal" === this.direction ? this.setMarkStyle(this._barBackgroundMark, {
      x: () => this._getBarBackgroundXStart(xScale),
      x1: () => this._getBarBackgroundXEnd(xScale),
      y: (datum) => this._getPosition(this.direction, datum, scaleDepth, "barBackground"),
      height: () => this._getBarWidth(this._yAxisHelper, scaleDepth),
      width: () => {
      },
      y1: () => {
      }
    }, "normal", AttributeLevel.Series) : this.setMarkStyle(this._barBackgroundMark, {
      x: (datum) => this._getPosition(this.direction, datum, scaleDepth, "barBackground"),
      y: () => this._getBarBackgroundYStart(yScale),
      y1: () => this._getBarBackgroundYEnd(yScale),
      width: () => this._getBarWidth(this._xAxisHelper, scaleDepth),
      x1: () => {
      },
      height: () => {
      }
    }, "normal", AttributeLevel.Series);
  }
  initAnimation() {
    var _a, _b;
    const barAnimationParams = {
      yField: this._fieldY[0],
      xField: this._fieldX[0],
      direction: this.direction,
      growFrom: () => {
        var _a2, _b2;
        return "horizontal" === this.direction ? null === (_a2 = this._xAxisHelper) || void 0 === _a2 ? void 0 : _a2.getScale(0).scale(0) : null === (_b2 = this._yAxisHelper) || void 0 === _b2 ? void 0 : _b2.getScale(0).scale(0);
      }
    }, appearPreset = null === (_a = this._spec.animationAppear) || void 0 === _a ? void 0 : _a.preset, animationParams = getGroupAnimationParams(this);
    this._barMark.setAnimationConfig(animationConfig(null === (_b = Factory2.getAnimationInKey("bar")) || void 0 === _b ? void 0 : _b(barAnimationParams, appearPreset), userAnimationConfig(this._barMarkName, this._spec, this._markAttributeContext), animationParams));
  }
  _getBarWidth(axisHelper, scaleDepth) {
    var _a, _b;
    const depthFromSpec = this._groups ? this._groups.fields.length : 1, depth = isNil_default(scaleDepth) ? depthFromSpec : Math.min(depthFromSpec, scaleDepth), bandWidth = null !== (_b = null === (_a = axisHelper.getBandwidth) || void 0 === _a ? void 0 : _a.call(axisHelper, depth - 1)) && void 0 !== _b ? _b : 6;
    if (void 0 !== this._spec.barWidth && depth === depthFromSpec)
      return getActualNumValue(this._spec.barWidth, bandWidth);
    const hasBarMinWidth = void 0 !== this._spec.barMinWidth, hasBarMaxWidth = void 0 !== this._spec.barMaxWidth;
    let width = bandWidth;
    return hasBarMinWidth && (width = Math.max(width, getActualNumValue(this._spec.barMinWidth, bandWidth))), hasBarMaxWidth && (width = Math.min(width, getActualNumValue(this._spec.barMaxWidth, bandWidth))), width;
  }
  _getPosition(direction2, datum, scaleDepth, mark) {
    var _a, _b, _c, _d, _e;
    let axisHelper, sizeAttribute, dataToPosition;
    "horizontal" === direction2 ? (axisHelper = this.getYAxisHelper(), sizeAttribute = "height", dataToPosition = "barBackground" === mark ? this.dataToBarBackgroundPositionY.bind(this) : this.dataToPositionY.bind(this)) : (axisHelper = this.getXAxisHelper(), sizeAttribute = "width", dataToPosition = "barBackground" === mark ? this.dataToBarBackgroundPositionX.bind(this) : this.dataToPositionX.bind(this));
    const scale4 = axisHelper.getScale(0), depthFromSpec = this._groups ? this._groups.fields.length : 1, depth = isNil_default(scaleDepth) ? depthFromSpec : Math.min(depthFromSpec, scaleDepth), bandWidth = null !== (_b = null === (_a = axisHelper.getBandwidth) || void 0 === _a ? void 0 : _a.call(axisHelper, depth - 1)) && void 0 !== _b ? _b : 6, size = depth === depthFromSpec ? this._barMark.getAttribute(sizeAttribute, datum) : bandWidth;
    if (depth > 1 && isValid_default(this._spec.barGapInGroup)) {
      const groupFields = this._groups.fields, barInGroup = array(this._spec.barGapInGroup);
      let totalWidth = 0, offSet = 0;
      for (let index = groupFields.length - 1; index >= 1; index--) {
        const groupField = groupFields[index], groupValues = null !== (_d = null === (_c = axisHelper.getScale(index)) || void 0 === _c ? void 0 : _c.domain()) && void 0 !== _d ? _d : [], groupCount = groupValues.length, gap = getActualNumValue(null !== (_e = barInGroup[index - 1]) && void 0 !== _e ? _e : last(barInGroup), bandWidth), i = groupValues.indexOf(datum[groupField]);
        index === groupFields.length - 1 ? (totalWidth += groupCount * size + (groupCount - 1) * gap, offSet += i * (size + gap)) : (offSet += i * (totalWidth + gap), totalWidth += totalWidth + (groupCount - 1) * gap);
      }
      return scale4.scale(datum[groupFields[0]]) + axisHelper.getBandwidth(0) / 2 - totalWidth / 2 + offSet;
    }
    const continuous = isContinuous(scale4.type || "band");
    return dataToPosition(datum, depth) + 0.5 * (bandWidth - size) + (continuous ? -bandWidth / 2 : 0);
  }
  dataToBarBackgroundPositionX(datum, scaleDepth) {
    return this._dataToPosition(datum, this._xAxisHelper, this.fieldX, scaleDepth, this._getBarBackgroundPositionXEncoder, this._setBarBackgroundPositionXEncoder);
  }
  dataToBarBackgroundPositionY(datum, scaleDepth) {
    return this._dataToPosition(datum, this._yAxisHelper, this.fieldY, scaleDepth, this._getBarBackgroundPositionYEncoder, this._setBarBackgroundPositionYEncoder);
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx);
    this.getRegion()._bar_series_position_calculated = false, this._spec.sampling && this.compile();
  }
  compile() {
    if (super.compile(), this._spec.sampling) {
      const { width, height } = this._region.getLayoutRect(), samplingTrans = [], fieldsY = this._fieldY, fieldsX = this._fieldX;
      samplingTrans.push({
        type: "sampling",
        size: "horizontal" === this._direction ? height : width,
        factor: this._spec.samplingFactor,
        yfield: "horizontal" === this._direction ? fieldsX[0] : fieldsY[0],
        groupBy: this._seriesField,
        mode: this._spec.sampling
      }), this._data.getProduct().transform(samplingTrans);
    }
  }
  getDefaultShapeType() {
    return "square";
  }
  getActiveMarks() {
    return [this._barMark];
  }
  compileData() {
    var _a;
    super.compileData(), null === (_a = this._barBackgroundViewData) || void 0 === _a || _a.compile();
  }
  fillData() {
    var _a, _b;
    super.fillData(), null === (_b = null === (_a = this._barBackgroundViewData) || void 0 === _a ? void 0 : _a.getDataView()) || void 0 === _b || _b.reRunAllTransform();
  }
  viewDataUpdate(d) {
    var _a, _b, _c;
    super.viewDataUpdate(d), null === (_b = null === (_a = this._barBackgroundViewData) || void 0 === _a ? void 0 : _a.getDataView()) || void 0 === _b || _b.reRunAllTransform(), null === (_c = this._barBackgroundViewData) || void 0 === _c || _c.updateData();
  }
  release() {
    var _a;
    super.release(), null === (_a = this._barBackgroundViewData) || void 0 === _a || _a.release(), this._barBackgroundViewData = null;
  }
};
BarSeries.type = SeriesTypeEnum.bar, BarSeries.mark = barSeriesMark, BarSeries.transformerConstructor = BarSeriesSpecTransformer;
var registerBarSeries = () => {
  registerSampleTransform(), registerRectMark(), registerBarAnimation(), registerCartesianBandAxis(), registerCartesianLinearAxis(), Factory2.registerSeries(BarSeries.type, BarSeries);
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/bar/bar-transformer
var BarChartSpecTransformer = class extends CartesianChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      barWidth: spec.barWidth,
      barMaxWidth: spec.barMaxWidth,
      barMinWidth: spec.barMinWidth,
      barGapInGroup: spec.barGapInGroup,
      barMinHeight: spec.barMinHeight,
      sampling: spec.sampling,
      samplingFactor: spec.samplingFactor,
      barBackground: spec.barBackground,
      stackCornerRadius: spec.stackCornerRadius
    });
  }
  transformSpec(spec) {
    super.transformSpec(spec), setDefaultCrosshairForCartesianChart(spec);
  }
  _transformAxisSpec(spec) {
    var _a, _b;
    if (super._transformAxisSpec(spec), !spec.axes)
      return;
    const isHorizontal3 = spec.series.some((series2) => "horizontal" === series2.direction), bandAxis = null !== (_a = spec.axes.find((axis2) => "band" === axis2.type)) && void 0 !== _a ? _a : spec.axes.find((axis2) => (isHorizontal3 ? ["left", "right"] : ["top", "bottom"]).includes(axis2.orient));
    if (bandAxis && !bandAxis.bandSize && !bandAxis.maxBandSize && !bandAxis.minBandSize && spec.autoBandSize) {
      const extend = isObject_default(spec.autoBandSize) && null !== (_b = spec.autoBandSize.extend) && void 0 !== _b ? _b : 0, { barMaxWidth, barMinWidth, barWidth, barGapInGroup } = spec.series.find((series2) => "bar" === series2.type);
      this._applyAxisBandSize(bandAxis, extend, {
        barMaxWidth,
        barMinWidth,
        barWidth,
        barGapInGroup
      });
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/bar/bar
var BarChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = BarChartSpecTransformer, this.type = "bar", this.seriesType = SeriesTypeEnum.bar, this._canStack = true;
  }
};
BarChart.type = "bar", BarChart.seriesType = SeriesTypeEnum.bar, BarChart.transformerConstructor = BarChartSpecTransformer;
var registerBarChart = () => {
  registerBarSeries(), Factory2.registerChart(BarChart.type, BarChart);
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/mark/rect-3d
var Rect3dMark = class _Rect3dMark extends BaseMark {
  constructor() {
    super(...arguments), this.type = _Rect3dMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      width: void 0,
      height: void 0,
      length: 3
    });
  }
};
Rect3dMark.type = "rect3d";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/bar/bar-3d
var Bar3dSeries = class extends BarSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.bar3d, this._barMarkName = "bar3d", this._barMarkType = "rect3d";
  }
};
Bar3dSeries.type = SeriesTypeEnum.bar3d, Bar3dSeries.mark = bar3dSeriesMark;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/bar/3d/bar-3d-transformer
var Bar3dChartSpecTransformer = class extends BarChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      barWidth: spec.barWidth,
      barMaxWidth: spec.barMaxWidth,
      barMinWidth: spec.barMinWidth,
      barGapInGroup: spec.barGapInGroup
    });
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/bar/3d/bar-3d
var Bar3dChart = class extends BarChart {
  constructor() {
    super(...arguments), this.transformerConstructor = Bar3dChartSpecTransformer, this.type = "bar3d", this.seriesType = SeriesTypeEnum.bar3d;
  }
};
Bar3dChart.type = "bar3d", Bar3dChart.seriesType = SeriesTypeEnum.bar3d, Bar3dChart.transformerConstructor = Bar3dChartSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/constant/box-plot
var BOX_PLOT_OUTLIER_VALUE_FIELD = `${PREFIX}_BOX_PLOT_OUTLIER_VALUE`;
var BOX_PLOT_TOOLTIP_KEYS;
!function(BOX_PLOT_TOOLTIP_KEYS2) {
  BOX_PLOT_TOOLTIP_KEYS2.OUTLIER = "outlier", BOX_PLOT_TOOLTIP_KEYS2.MAX = "max", BOX_PLOT_TOOLTIP_KEYS2.MIN = "min", BOX_PLOT_TOOLTIP_KEYS2.MEDIAN = "median", BOX_PLOT_TOOLTIP_KEYS2.Q1 = "q1", BOX_PLOT_TOOLTIP_KEYS2.Q3 = "q3", BOX_PLOT_TOOLTIP_KEYS2.SERIES_FIELD = "seriesField";
}(BOX_PLOT_TOOLTIP_KEYS || (BOX_PLOT_TOOLTIP_KEYS = {}));

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/data/transforms/box-plot
var foldOutlierData = (data, op) => {
  const result2 = [], { outliersField, dimensionField } = op;
  return (data[0].latestData || []).forEach((d) => {
    let outlierValues = d[outliersField];
    isArray_default(outlierValues) || (outlierValues = [outlierValues]), result2.push(...outlierValues.map((v) => {
      const resData = {
        [BOX_PLOT_OUTLIER_VALUE_FIELD]: v
      };
      return dimensionField.forEach((field3) => {
        resData[field3] = d[field3];
      }), resData;
    }));
  }), result2;
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/box-plot/tooltip-helper
var BoxPlotSeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  constructor() {
    super(...arguments), this.getContentKey = (contentType) => (datum) => {
      if (this.isOutlierMark(datum)) {
        if (contentType === BOX_PLOT_TOOLTIP_KEYS.OUTLIER)
          return this.series.getOutliersField();
        if (contentType === BOX_PLOT_TOOLTIP_KEYS.SERIES_FIELD) {
          return this.series.getSeriesField();
        }
        return null;
      }
      switch (contentType) {
        case BOX_PLOT_TOOLTIP_KEYS.MIN:
          return this.series.getMinField();
        case BOX_PLOT_TOOLTIP_KEYS.MAX:
          return this.series.getMaxField();
        case BOX_PLOT_TOOLTIP_KEYS.MEDIAN:
          return this.series.getMedianField();
        case BOX_PLOT_TOOLTIP_KEYS.Q1:
          return this.series.getQ1Field();
        case BOX_PLOT_TOOLTIP_KEYS.Q3:
          return this.series.getQ3Field();
        case BOX_PLOT_TOOLTIP_KEYS.SERIES_FIELD:
          return this.series.getSeriesField();
      }
      return null;
    }, this.getContentValue = (contentType) => (datum) => {
      if (this.isOutlierMark(datum)) {
        if (contentType === BOX_PLOT_TOOLTIP_KEYS.OUTLIER)
          return datum[BOX_PLOT_OUTLIER_VALUE_FIELD];
        if (contentType === BOX_PLOT_TOOLTIP_KEYS.SERIES_FIELD) {
          return datum[this.series.getSeriesField()];
        }
        return null;
      }
      switch (contentType) {
        case BOX_PLOT_TOOLTIP_KEYS.MIN:
          return datum[this.series.getMinField()];
        case BOX_PLOT_TOOLTIP_KEYS.MAX:
          return datum[this.series.getMaxField()];
        case BOX_PLOT_TOOLTIP_KEYS.MEDIAN:
          return datum[this.series.getMedianField()];
        case BOX_PLOT_TOOLTIP_KEYS.Q1:
          return datum[this.series.getQ1Field()];
        case BOX_PLOT_TOOLTIP_KEYS.Q3:
          return datum[this.series.getQ3Field()];
        case BOX_PLOT_TOOLTIP_KEYS.SERIES_FIELD:
          return datum[this.series.getSeriesField()];
      }
      return null;
    }, this.shapeColorCallback = (datum) => "line" === this.series.getShaftShape() ? this.series.getMarkInName("boxPlot").getAttribute("stroke", datum) : this.series.getMarkInName("boxPlot").getAttribute("fill", datum), this.getOutlierFillColor = (datum) => {
      var _a;
      const outliersStyle = this.series.getOutliersStyle();
      return null !== (_a = null == outliersStyle ? void 0 : outliersStyle.fill) && void 0 !== _a ? _a : this.series.getMarkInName("outlier").getAttribute("fill", datum);
    }, this.isOutlierMark = (datum) => isValid_default(datum[BOX_PLOT_OUTLIER_VALUE_FIELD]);
  }
  getDefaultTooltipPattern(activeType) {
    return {
      visible: true,
      activeType,
      title: {
        key: void 0,
        value: this.dimensionTooltipTitleCallback,
        hasShape: false
      },
      content: [{
        key: this.getContentKey(BOX_PLOT_TOOLTIP_KEYS.OUTLIER),
        value: this.getContentValue(BOX_PLOT_TOOLTIP_KEYS.OUTLIER),
        hasShape: true,
        shapeType: this.shapeTypeCallback,
        shapeColor: this.getOutlierFillColor,
        shapeStroke: this.getOutlierFillColor,
        shapeHollow: false
      }, {
        key: this.getContentKey(BOX_PLOT_TOOLTIP_KEYS.MAX),
        value: this.getContentValue(BOX_PLOT_TOOLTIP_KEYS.MAX),
        hasShape: true,
        shapeType: this.shapeTypeCallback,
        shapeColor: this.shapeColorCallback,
        shapeStroke: this.shapeStrokeCallback,
        shapeHollow: false
      }, {
        key: this.getContentKey(BOX_PLOT_TOOLTIP_KEYS.Q3),
        value: this.getContentValue(BOX_PLOT_TOOLTIP_KEYS.Q3),
        hasShape: true,
        shapeType: this.shapeTypeCallback,
        shapeColor: this.shapeColorCallback,
        shapeStroke: this.shapeStrokeCallback,
        shapeHollow: false
      }, {
        key: this.getContentKey(BOX_PLOT_TOOLTIP_KEYS.MEDIAN),
        value: this.getContentValue(BOX_PLOT_TOOLTIP_KEYS.MEDIAN),
        hasShape: true,
        shapeType: this.shapeTypeCallback,
        shapeColor: this.shapeColorCallback,
        shapeStroke: this.shapeStrokeCallback,
        shapeHollow: false
      }, {
        key: this.getContentKey(BOX_PLOT_TOOLTIP_KEYS.Q1),
        value: this.getContentValue(BOX_PLOT_TOOLTIP_KEYS.Q1),
        hasShape: true,
        shapeType: this.shapeTypeCallback,
        shapeColor: this.shapeColorCallback,
        shapeStroke: this.shapeStrokeCallback,
        shapeHollow: false
      }, {
        key: this.getContentKey(BOX_PLOT_TOOLTIP_KEYS.MIN),
        value: this.getContentValue(BOX_PLOT_TOOLTIP_KEYS.MIN),
        hasShape: true,
        shapeType: this.shapeTypeCallback,
        shapeColor: this.shapeColorCallback,
        shapeStroke: this.shapeStrokeCallback,
        shapeHollow: false
      }, {
        key: this.getContentKey(BOX_PLOT_TOOLTIP_KEYS.SERIES_FIELD),
        value: this.getContentValue(BOX_PLOT_TOOLTIP_KEYS.SERIES_FIELD),
        hasShape: true,
        shapeType: this.shapeTypeCallback,
        shapeColor: this.shapeColorCallback,
        shapeStroke: this.shapeStrokeCallback,
        shapeHollow: false
      }]
    };
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/mark/box-plot
var BoxPlotMark = class _BoxPlotMark extends BaseMark {
  constructor() {
    super(...arguments), this.type = _BoxPlotMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      lineWidth: 2,
      boxWidth: 30,
      shaftWidth: 20,
      shaftShape: "line"
    });
  }
  _initProduct(group) {
    const shaftShape = this.getStyle("shaftShape"), view = this.getVGrammarView(), id2 = this.getProductId(), glyphType = "bar" === shaftShape ? "barBoxplot" : "boxplot", direction2 = this.getStyle("direction");
    this._product = view.glyph(glyphType, null != group ? group : view.rootMark).id(id2).configureGlyph({
      direction: direction2
    }), this._compiledProductId = id2;
  }
};
BoxPlotMark.type = "boxPlot";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/box-plot/box-plot
var BoxPlotSeries = class _BoxPlotSeries extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.boxPlot;
  }
  getMinField() {
    return this._minField;
  }
  getMaxField() {
    return this._maxField;
  }
  getQ1Field() {
    return this._q1Field;
  }
  getMedianField() {
    return this._medianField;
  }
  getQ3Field() {
    return this._q3Field;
  }
  getOutliersField() {
    return this._outliersField;
  }
  getShaftShape() {
    return this._shaftShape;
  }
  getBoxFillColor() {
    return this._boxFillColor;
  }
  getStrokeColor() {
    return this._strokeColor;
  }
  getOutliersStyle() {
    return this._outliersStyle;
  }
  setAttrFromSpec() {
    var _a, _b, _c, _d, _e;
    super.setAttrFromSpec();
    const boxPlotStyle = null !== (_b = null === (_a = this._spec.boxPlot) || void 0 === _a ? void 0 : _a.style) && void 0 !== _b ? _b : {};
    this._minField = this._spec.minField, this._maxField = this._spec.maxField, this._q1Field = this._spec.q1Field, this._medianField = this._spec.medianField, this._q3Field = this._spec.q3Field, this._outliersField = this._spec.outliersField, this._lineWidth = null !== (_c = boxPlotStyle.lineWidth) && void 0 !== _c ? _c : 2, this._boxWidth = boxPlotStyle.boxWidth, this._shaftShape = null !== (_d = boxPlotStyle.shaftShape) && void 0 !== _d ? _d : "line", this._shaftWidth = boxPlotStyle.shaftWidth, this._boxFillColor = boxPlotStyle.boxFill, this._strokeColor = boxPlotStyle.stroke, this._shaftFillOpacity = "bar" === this._shaftShape ? null !== (_e = boxPlotStyle.shaftFillOpacity) && void 0 !== _e ? _e : 0.5 : void 0, this._outliersStyle = this._spec.outliersStyle;
  }
  initMark() {
    const progressive = {
      progressiveStep: this._spec.progressiveStep,
      progressiveThreshold: this._spec.progressiveThreshold,
      large: this._spec.large,
      largeThreshold: this._spec.largeThreshold
    };
    this._boxPlotMark = this._createMark(_BoxPlotSeries.mark.boxPlot, {
      isSeriesMark: true,
      progressive
    }), this._outlierMark = this._createMark(_BoxPlotSeries.mark.outlier, {
      progressive,
      key: DEFAULT_DATA_INDEX,
      dataView: this._outlierDataView.getDataView(),
      dataProductId: this._outlierDataView.getProductId()
    });
  }
  initMarkStyle() {
    var _a, _b, _c, _d, _e;
    const boxPlotMark = this._boxPlotMark;
    if (boxPlotMark) {
      const commonBoxplotStyles = {
        direction: this._direction,
        lineWidth: this._lineWidth,
        shaftShape: this._shaftShape,
        fill: null !== (_a = this._boxFillColor) && void 0 !== _a ? _a : "line" === this._shaftShape ? "#FFF" : this.getColorAttribute(),
        minMaxFillOpacity: this._shaftFillOpacity,
        stroke: null !== (_b = this._strokeColor) && void 0 !== _b ? _b : "line" === this._shaftShape ? this.getColorAttribute() : "#000"
      }, boxPlotMarkStyles = "horizontal" === this._direction ? Object.assign(Object.assign({
        y: this.dataToPositionY.bind(this)
      }, commonBoxplotStyles), {
        boxHeight: () => {
          var _a2;
          return null !== (_a2 = this._boxWidth) && void 0 !== _a2 ? _a2 : this._getMarkWidth();
        },
        ruleHeight: () => {
          var _a2;
          return null !== (_a2 = this._shaftWidth) && void 0 !== _a2 ? _a2 : this._getMarkWidth();
        },
        q1q3Height: () => {
          var _a2;
          return null !== (_a2 = this._boxWidth) && void 0 !== _a2 ? _a2 : this._getMarkWidth();
        },
        minMaxHeight: () => {
          var _a2;
          return null !== (_a2 = this._shaftWidth) && void 0 !== _a2 ? _a2 : this._getMarkWidth();
        }
      }) : Object.assign(Object.assign({
        x: this.dataToPositionX.bind(this)
      }, commonBoxplotStyles), {
        boxWidth: () => {
          var _a2;
          return null !== (_a2 = this._boxWidth) && void 0 !== _a2 ? _a2 : this._getMarkWidth();
        },
        ruleWidth: () => {
          var _a2;
          return null !== (_a2 = this._shaftWidth) && void 0 !== _a2 ? _a2 : this._getMarkWidth();
        },
        q1q3Width: () => {
          var _a2;
          return null !== (_a2 = this._boxWidth) && void 0 !== _a2 ? _a2 : this._getMarkWidth();
        },
        minMaxWidth: () => {
          var _a2;
          return null !== (_a2 = this._shaftWidth) && void 0 !== _a2 ? _a2 : this._getMarkWidth();
        }
      });
      this.setMarkStyle(boxPlotMark, boxPlotMarkStyles, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
    }
    const outlierMark = this._outlierMark;
    outlierMark && this.setMarkStyle(outlierMark, {
      fill: null !== (_d = null === (_c = this._outliersStyle) || void 0 === _c ? void 0 : _c.fill) && void 0 !== _d ? _d : this.getColorAttribute(),
      size: isNumber_default(null === (_e = this._outliersStyle) || void 0 === _e ? void 0 : _e.size) ? this._outliersStyle.size : 10,
      symbolType: "circle"
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  initBoxPlotMarkStyle() {
    var _a, _b;
    const boxPlotMark = this._boxPlotMark, axisHelper = "horizontal" === this._direction ? this._xAxisHelper : this._yAxisHelper;
    if (boxPlotMark && axisHelper) {
      const { dataToPosition } = axisHelper, scale4 = null === (_a = null == axisHelper ? void 0 : axisHelper.getScale) || void 0 === _a ? void 0 : _a.call(axisHelper, 0);
      this.setMarkStyle(boxPlotMark, {
        min: (datum) => valueInScaleRange(dataToPosition(this.getDatumPositionValues(datum, this._minField), {
          bandPosition: this._bandPosition
        }), scale4),
        q1: (datum) => valueInScaleRange(dataToPosition(this.getDatumPositionValues(datum, this._q1Field), {
          bandPosition: this._bandPosition
        }), scale4),
        median: (datum) => valueInScaleRange(dataToPosition(this.getDatumPositionValues(datum, this._medianField), {
          bandPosition: this._bandPosition
        }), scale4),
        q3: (datum) => valueInScaleRange(dataToPosition(this.getDatumPositionValues(datum, this._q3Field), {
          bandPosition: this._bandPosition
        }), scale4),
        max: (datum) => valueInScaleRange(dataToPosition(this.getDatumPositionValues(datum, this._maxField), {
          bandPosition: this._bandPosition
        }), scale4)
      }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
    }
    const outlierMark = this._outlierMark;
    if (outlierMark && axisHelper) {
      const { dataToPosition } = axisHelper, scale4 = null === (_b = null == axisHelper ? void 0 : axisHelper.getScale) || void 0 === _b ? void 0 : _b.call(axisHelper, 0), outlierMarkPositionChannel = "horizontal" === this._direction ? {
        y: this.dataToPositionY.bind(this),
        x: (datum) => valueInScaleRange(dataToPosition(this.getDatumPositionValues(datum, BOX_PLOT_OUTLIER_VALUE_FIELD), {
          bandPosition: this._bandPosition
        }), scale4)
      } : {
        x: this.dataToPositionX.bind(this),
        y: (datum) => valueInScaleRange(dataToPosition(this.getDatumPositionValues(datum, BOX_PLOT_OUTLIER_VALUE_FIELD), {
          bandPosition: this._bandPosition
        }), scale4)
      };
      this.setMarkStyle(outlierMark, outlierMarkPositionChannel, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
    }
  }
  initData() {
    if (super.initData(), !this._data)
      return;
    registerDataSetInstanceTransform(this._dataSet, "foldOutlierData", foldOutlierData), registerDataSetInstanceTransform(this._dataSet, "addVChartProperty", addVChartProperty);
    const outlierDataView = new DataView(this._dataSet, {
      name: `${this.type}_outlier_${this.id}_data`
    });
    outlierDataView.parse([this.getViewData()], {
      type: "dataview"
    }), outlierDataView.name = `${PREFIX}_series_${this.id}_outlierData`, outlierDataView.transform({
      type: "foldOutlierData",
      options: {
        dimensionField: "horizontal" === this._direction ? this._fieldY : this._fieldX,
        outliersField: this._outliersField
      }
    }), outlierDataView.transform({
      type: "addVChartProperty",
      options: {
        beforeCall: initKeyMap.bind(this),
        call: addDataKey
      }
    }, false), this._outlierDataView = new SeriesData(this._option, outlierDataView);
  }
  init(option) {
    super.init(option), this.initBoxPlotMarkStyle();
  }
  _getMarkWidth() {
    if (this._autoBoxWidth)
      return this._autoBoxWidth;
    const bandAxisHelper = "horizontal" === this._direction ? this._yAxisHelper : this._xAxisHelper, xField = "horizontal" === this._direction ? this._fieldY : this._fieldX, autoBoxWidth = bandAxisHelper.getBandwidth(xField.length - 1) / xField.length;
    return this._autoBoxWidth = autoBoxWidth, this._autoBoxWidth;
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx), this._autoBoxWidth = null;
  }
  _initAnimationSpec(config2 = {}) {
    const newConfig = merge({}, config2);
    return ["appear", "enter", "update", "exit", "disappear"].forEach((state) => {
      newConfig[state] && "scaleIn" === newConfig[state].type ? newConfig[state].type = "line" === this._shaftShape ? "boxplotScaleIn" : "barBoxplotScaleIn" : newConfig[state] && "scaleOut" === newConfig[state].type && (newConfig[state].type = "line" === this._shaftShape ? "boxplotScaleOut" : "barBoxplotScaleOut");
    }), newConfig;
  }
  initAnimation() {
    var _a, _b, _c, _d, _e, _f, _g;
    const animationParams = getGroupAnimationParams(this);
    if (this._boxPlotMark) {
      const newDefaultConfig = this._initAnimationSpec(null === (_a = Factory2.getAnimationInKey("scaleInOut")) || void 0 === _a ? void 0 : _a()), newConfig = this._initAnimationSpec(userAnimationConfig("boxPlot", this._spec, this._markAttributeContext));
      this._boxPlotMark.setAnimationConfig(animationConfig(newDefaultConfig, newConfig, animationParams));
    }
    if (this._outlierMark) {
      const outlierMarkUserAnimation = {
        appear: null === (_b = this._spec.animationAppear) || void 0 === _b ? void 0 : _b.symbol,
        disappear: null === (_c = this._spec.animationDisappear) || void 0 === _c ? void 0 : _c.symbol,
        enter: null === (_d = this._spec.animationEnter) || void 0 === _d ? void 0 : _d.symbol,
        exit: null === (_e = this._spec.animationExit) || void 0 === _e ? void 0 : _e.symbol,
        update: null === (_f = this._spec.animationUpdate) || void 0 === _f ? void 0 : _f.symbol
      };
      this._outlierMark.setAnimationConfig(animationConfig(null === (_g = Factory2.getAnimationInKey("scaleInOut")) || void 0 === _g ? void 0 : _g(), outlierMarkUserAnimation, animationParams));
    }
  }
  initTooltip() {
    this._tooltipHelper = new BoxPlotSeriesTooltipHelper(this), this._boxPlotMark && this._tooltipHelper.activeTriggerSet.mark.add(this._boxPlotMark), this._outlierMark && this._tooltipHelper.activeTriggerSet.mark.add(this._outlierMark);
  }
  getStatisticFields() {
    const fields2 = super.getStatisticFields(), outliersField = fields2.find((f) => f.key === this._outliersField);
    return outliersField && (outliersField.operations = ["array-min", "array-max"]), fields2;
  }
  onEvaluateEnd(ctx) {
    super.onEvaluateEnd(ctx), this._outlierDataView.updateData();
  }
  getDefaultShapeType() {
    return "square";
  }
  getActiveMarks() {
    return [this._boxPlotMark];
  }
};
BoxPlotSeries.type = SeriesTypeEnum.boxPlot, BoxPlotSeries.mark = boxPlotSeriesMark;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/box-plot/box-plot-transformer
var BoxPlotChartSpecTransformer = class extends CartesianChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    var _a;
    const dataFields = [spec.maxField, spec.medianField, spec.q1Field, spec.q3Field, spec.minField, spec.outliersField], seriesSpec = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      boxPlot: spec.boxPlot,
      direction: null !== (_a = spec.direction) && void 0 !== _a ? _a : "vertical",
      minField: spec.minField,
      maxField: spec.maxField,
      q1Field: spec.q1Field,
      medianField: spec.medianField,
      q3Field: spec.q3Field,
      outliersField: spec.outliersField,
      outliersStyle: spec.outliersStyle
    });
    return seriesSpec["horizontal" === seriesSpec.direction ? "xField" : "yField"] = dataFields, seriesSpec;
  }
  transformSpec(spec) {
    super.transformSpec(spec), spec.axes || (spec.axes = [{
      orient: "bottom"
    }, {
      orient: "left"
    }]), setDefaultCrosshairForCartesianChart(spec);
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/box-plot/box-plot
var BoxPlotChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = BoxPlotChartSpecTransformer, this.type = "boxPlot", this.seriesType = SeriesTypeEnum.boxPlot;
  }
};
BoxPlotChart.type = "boxPlot", BoxPlotChart.seriesType = SeriesTypeEnum.boxPlot, BoxPlotChart.transformerConstructor = BoxPlotChartSpecTransformer;

// http-url:https://unpkg.com/@visactor/vgrammar-hierarchy@0.13.8/es/format
var flattenNodes = (nodes, output = [], options) => {
  const hasMaxDepth = (null == options ? void 0 : options.maxDepth) >= 0;
  return nodes.forEach((node) => {
    (!hasMaxDepth || node.depth <= options.maxDepth) && (output.push((null == options ? void 0 : options.callback) ? options.callback(node) : node), node.children && (hasMaxDepth && node.depth === options.maxDepth ? (node.children = null, node.isLeaf = true) : flattenNodes(node.children, output, options)));
  }), output;
};

// http-url:https://unpkg.com/@visactor/vgrammar-hierarchy@0.13.8/es/treemap/dice
function dice_default(parent, x05, y05, x14, y14, keyMap2 = {
  x0: "x0",
  x1: "x1",
  y0: "y0",
  y1: "y1"
}) {
  const nodes = parent.children;
  let node, i = -1;
  const n = nodes.length, k2 = parent.value && (x14 - x05) / parent.value;
  for (; ++i < n; )
    node = nodes[i], node[keyMap2.y0] = y05, node[keyMap2.y1] = y14, node[keyMap2.x0] = x05, node[keyMap2.x1] = x05 += node.value * k2;
}

// http-url:https://unpkg.com/@visactor/vgrammar-hierarchy@0.13.8/es/utils
var calculateNodeValue = (subTree, output, depth = 0, flattenIndex = -1, parent, getNodeKey) => {
  let sum4 = 0, prevFlattenIndex = null != flattenIndex ? flattenIndex : -1, maxDepth2 = depth;
  return subTree.forEach((datum, index) => {
    var _a, _b;
    const node = {
      flattenIndex: ++prevFlattenIndex,
      key: getNodeKey ? getNodeKey(datum) : `${null !== (_a = null == parent ? void 0 : parent.key) && void 0 !== _a ? _a : ""}-${index}`,
      maxDepth: -1,
      depth,
      index,
      value: datum.value,
      isLeaf: true,
      datum: parent ? parent.datum.concat(datum) : [datum],
      parentKey: null == parent ? void 0 : parent.key
    };
    if (null === (_b = datum.children) || void 0 === _b ? void 0 : _b.length) {
      node.children = [], node.isLeaf = false;
      const res = calculateNodeValue(datum.children, node.children, depth + 1, prevFlattenIndex, node, getNodeKey);
      node.value = isNil_default(datum.value) ? res.sum : Math.max(res.sum, toValidNumber(datum.value)), prevFlattenIndex = res.flattenIndex, maxDepth2 = Math.max(res.maxDepth, maxDepth2);
    } else
      node.isLeaf = true, node.value = toValidNumber(datum.value);
    sum4 += Math.abs(node.value), output.push(node);
  }), {
    sum: sum4,
    maxDepth: maxDepth2,
    flattenIndex: prevFlattenIndex
  };
};
var eachBefore = (subTree, callback, parent, ctx) => {
  let ctxRes = ctx;
  return subTree.forEach((node, index) => {
    var _a;
    ctxRes = callback(node, index, parent, ctxRes), (null === (_a = node.children) || void 0 === _a ? void 0 : _a.length) && (ctxRes = eachBefore(node.children, callback, node, ctxRes));
  }), ctx;
};
var eachAfter = (subTree, callback, parent, ctx) => {
  let ctxRes = ctx;
  return subTree.forEach((node, index) => {
    var _a;
    (null === (_a = node.children) || void 0 === _a ? void 0 : _a.length) && (ctxRes = eachAfter(node.children, callback, node, ctxRes)), ctxRes = callback(node, index, parent, ctxRes);
  }), ctxRes;
};

// http-url:https://unpkg.com/@visactor/vgrammar-hierarchy@0.13.8/es/sunburst/layout
var keyMap = {
  x0: "startAngle",
  x1: "endAngle",
  y0: "innerRadius",
  y1: "outerRadius"
};
var SunburstLayout = class _SunburstLayout {
  constructor(options) {
    this._layoutNode = (parent) => {
      if (parent.maxDepth = this._maxDepth, parent.children) {
        const ir = this._parsedInnerRadius[parent.depth + 1], or = this._parsedOutterRadius[parent.depth + 1];
        dice_default(parent, parent.startAngle, Math.min(ir, or), parent.endAngle, Math.max(ir, or), keyMap);
        const labelOption = isArray_default(this.options.label) ? this.options.label[parent.depth + 1] : this.options.label;
        parent.children.forEach((child) => {
          if (child.x = this._parsedCenter[0], child.y = this._parsedCenter[1], labelOption)
            return this._layoutLabel(child, isBoolean_default(labelOption) ? {
              align: "center",
              rotate: "radial"
            } : labelOption);
        });
      }
    }, this.options = options ? Object.assign({}, _SunburstLayout.defaultOpionts, options) : Object.assign({}, _SunburstLayout.defaultOpionts);
    const keyOption = this.options.nodeKey, keyFunc = isFunction_default(keyOption) ? keyOption : keyOption ? field(keyOption) : null;
    this._getNodeKey = keyFunc, this._maxDepth = -1;
  }
  _parseRadius(viewBox, maxDepth2) {
    const cx = viewBox.x0 + toPercent(this.options.center[0], viewBox.width), cy = viewBox.y0 + toPercent(this.options.center[1], viewBox.height), maxRadius = Math.min(viewBox.width / 2, viewBox.height / 2), innerRadius = this.options.innerRadius, outerRadius = this.options.outerRadius, isInnerArray = isArray_default(innerRadius), parsedInnerRadius = isInnerArray ? innerRadius.map((entry) => toPercent(entry, maxRadius)) : toPercent(innerRadius, maxRadius), isOuterArray = isArray_default(outerRadius), gapRadius = this.options.gapRadius, parsedOuterRadius = isOuterArray ? outerRadius.map((entry) => toPercent(entry, maxRadius)) : toPercent(outerRadius, maxRadius), rangeArr = range(0, maxDepth2 + 1);
    if (isInnerArray)
      this._parsedInnerRadius = rangeArr.map((entry, index) => {
        const ir = parsedInnerRadius[index];
        return isNil_default(ir) ? maxRadius : ir;
      }), this._parsedOutterRadius = rangeArr.map((entry, index) => {
        var _a, _b;
        return isOuterArray ? null !== (_a = parsedOuterRadius[index]) && void 0 !== _a ? _a : maxRadius : index < maxDepth2 ? this._parsedInnerRadius[index + 1] - (isArray_default(gapRadius) ? null !== (_b = gapRadius[index]) && void 0 !== _b ? _b : 0 : gapRadius) : parsedOuterRadius;
      });
    else if (isOuterArray)
      this._parsedOutterRadius = rangeArr.map((entry, index) => isNil_default(parsedOuterRadius[index]) ? maxRadius : parsedOuterRadius[index]), this._parsedInnerRadius = rangeArr.map((entry, index) => {
        var _a;
        return 0 === index ? parsedInnerRadius : this._parsedOutterRadius[index - 1] - (isArray_default(gapRadius) ? null !== (_a = gapRadius[index]) && void 0 !== _a ? _a : 0 : gapRadius);
      });
    else {
      const ir = toPercent(innerRadius, maxRadius), step = (parsedOuterRadius - ir) / (maxDepth2 + 1);
      this._parsedInnerRadius = rangeArr.map((entry, index) => ir + index * step), this._parsedOutterRadius = rangeArr.map((entry, index) => {
        var _a;
        return this._parsedInnerRadius[index] + step - (isArray_default(gapRadius) ? null !== (_a = gapRadius[index]) && void 0 !== _a ? _a : 0 : gapRadius);
      });
    }
    this._parsedCenter = [cx, cy], this._maxRadius = maxRadius;
  }
  layout(data, config2) {
    const viewBox = "width" in config2 ? {
      x0: 0,
      x1: config2.width,
      y0: 0,
      y1: config2.height,
      width: config2.width,
      height: config2.height
    } : {
      x0: Math.min(config2.x0, config2.x1),
      x1: Math.max(config2.x0, config2.x1),
      y0: Math.min(config2.y0, config2.y1),
      y1: Math.max(config2.y0, config2.y1),
      width: Math.abs(config2.x1 - config2.x0),
      height: Math.abs(config2.y1 - config2.y0)
    };
    if (!data || !data.length)
      return [];
    const nodes = [], res = calculateNodeValue(data, nodes, 0, -1, null, this._getNodeKey);
    return this._parseRadius(viewBox, res.maxDepth), this._maxDepth = res.maxDepth, this._layout(nodes, {
      flattenIndex: -1,
      maxDepth: -1,
      key: "-1",
      depth: -1,
      index: -1,
      value: res.sum,
      datum: null,
      children: nodes,
      startAngle: this.options.startAngle,
      endAngle: this.options.endAngle
    }), nodes;
  }
  _layout(nodes, parent) {
    this._layoutNode(parent), nodes.forEach((node) => {
      var _a;
      (null === (_a = null == node ? void 0 : node.children) || void 0 === _a ? void 0 : _a.length) ? this._layout(node.children, node) : this._layoutNode(node);
    });
  }
  _layoutLabel(child, labelOption) {
    var _a;
    const angle2 = (child.startAngle + child.endAngle) / 2, r = ("start" === labelOption.align ? child.innerRadius : "end" === labelOption.align ? child.outerRadius : (child.innerRadius + child.outerRadius) / 2) + (null !== (_a = labelOption.offset) && void 0 !== _a ? _a : 0), pos = polarToCartesian({
      x: this._parsedCenter[0],
      y: this._parsedCenter[1]
    }, r, angle2);
    if (child.label = {
      x: pos.x,
      y: pos.y,
      textBaseline: "middle"
    }, "tangential" === labelOption.rotate)
      child.label.angle = angle2 - Math.PI / 2, child.label.textAlign = "center", child.label.maxLineWidth = Math.abs(child.endAngle - child.startAngle) * r;
    else {
      const uniformAngle = angle2 % (2 * Math.PI), formatAngle = uniformAngle < 0 ? uniformAngle + 2 * Math.PI : uniformAngle;
      formatAngle > Math.PI / 2 && formatAngle < 1.5 * Math.PI ? (child.label.angle = formatAngle + Math.PI, child.label.textAlign = "start" === labelOption.align ? "end" : "end" === labelOption.align ? "start" : "center") : (child.label.angle = formatAngle, child.label.textAlign = labelOption.align), child.label.maxLineWidth = child.isLeaf ? void 0 : Math.abs(child.outerRadius - child.innerRadius);
    }
  }
};
SunburstLayout.defaultOpionts = {
  startAngle: Math.PI / 2,
  endAngle: -3 * Math.PI / 2,
  center: ["50%", "50%"],
  gapRadius: 0,
  innerRadius: 0,
  outerRadius: "70%"
};

// http-url:https://unpkg.com/@visactor/vgrammar-hierarchy@0.13.8/es/lcg
var a2 = 1664525;
var c2 = 1013904223;
var m3 = 4294967296;
function randomLCG(initS = 1) {
  let s2 = initS;
  return () => (s2 = (a2 * s2 + c2) % m3) / m3;
}

// http-url:https://unpkg.com/@visactor/vgrammar-hierarchy@0.13.8/es/circle-packing/enclose
function packEncloseRandom(circles, random) {
  let i = 0;
  const sCircles = shuffleArray(Array.from(circles), random), n = sCircles.length;
  let p, e, B = [];
  for (; i < n; )
    p = sCircles[i], e && enclosesWeak(e, p) ? ++i : (B = extendBasis(B, p), e = encloseBasis(B), i = 0);
  return e;
}
function extendBasis(B, p) {
  let i, j;
  if (enclosesWeakAll(p, B))
    return [p];
  for (i = 0; i < B.length; ++i)
    if (enclosesNot(p, B[i]) && enclosesWeakAll(encloseBasis2(B[i], p), B))
      return [B[i], p];
  for (i = 0; i < B.length - 1; ++i)
    for (j = i + 1; j < B.length; ++j)
      if (enclosesNot(encloseBasis2(B[i], B[j]), p) && enclosesNot(encloseBasis2(B[i], p), B[j]) && enclosesNot(encloseBasis2(B[j], p), B[i]) && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B))
        return [B[i], B[j], p];
  Logger.getInstance().error("error when packEncloseRandom");
}
function enclosesNot(a3, b) {
  const dr = a3.radius - b.radius, dx = b.x - a3.x, dy = b.y - a3.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}
function enclosesWeak(a3, b) {
  const dr = a3.radius - b.radius + 1e-9 * Math.max(a3.radius, b.radius, 1), dx = b.x - a3.x, dy = b.y - a3.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function enclosesWeakAll(a3, B) {
  for (let i = 0; i < B.length; ++i)
    if (!enclosesWeak(a3, B[i]))
      return false;
  return true;
}
function encloseBasis(B) {
  switch (B.length) {
    case 1:
      return encloseBasis1(B[0]);
    case 2:
      return encloseBasis2(B[0], B[1]);
    case 3:
      return encloseBasis3(B[0], B[1], B[2]);
  }
}
function encloseBasis1(a3) {
  return {
    x: a3.x,
    y: a3.y,
    radius: a3.radius
  };
}
function encloseBasis2(a3, b) {
  const x14 = a3.x, y14 = a3.y, r1 = a3.radius, x23 = b.x, y23 = b.y, r2 = b.radius, x212 = x23 - x14, y212 = y23 - y14, r21 = r2 - r1, l = Math.sqrt(x212 * x212 + y212 * y212);
  return {
    x: (x14 + x23 + x212 / l * r21) / 2,
    y: (y14 + y23 + y212 / l * r21) / 2,
    radius: (l + r1 + r2) / 2
  };
}
function encloseBasis3(a3, b, c3) {
  const x14 = a3.x, y14 = a3.y, r1 = a3.radius, x23 = b.x, y23 = b.y, r2 = b.radius, x3 = c3.x, y3 = c3.y, r3 = c3.radius, a22 = x14 - x23, a32 = x14 - x3, b2 = y14 - y23, b3 = y14 - y3, c22 = r2 - r1, c32 = r3 - r1, d1 = x14 * x14 + y14 * y14 - r1 * r1, d2 = d1 - x23 * x23 - y23 * y23 + r2 * r2, d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3, ab = a32 * b2 - a22 * b3, xa = (b2 * d3 - b3 * d2) / (2 * ab) - x14, xb = (b3 * c22 - b2 * c32) / ab, ya = (a32 * d2 - a22 * d3) / (2 * ab) - y14, yb = (a22 * c32 - a32 * c22) / ab, A = xb * xb + yb * yb - 1, B = 2 * (r1 + xa * xb + ya * yb), C = xa * xa + ya * ya - r1 * r1, r = -(Math.abs(A) > 1e-6 ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
  return {
    x: x14 + xa + xb * r,
    y: y14 + ya + yb * r,
    radius: r
  };
}

// http-url:https://unpkg.com/@visactor/vgrammar-hierarchy@0.13.8/es/circle-packing/siblings
function place(b, a3, c3) {
  const dx = b.x - a3.x;
  let x, a22;
  const dy = b.y - a3.y;
  let y, b2;
  const d2 = dx * dx + dy * dy;
  d2 ? (a22 = a3.radius + c3.radius, a22 *= a22, b2 = b.radius + c3.radius, b2 *= b2, a22 > b2 ? (x = (d2 + b2 - a22) / (2 * d2), y = Math.sqrt(Math.max(0, b2 / d2 - x * x)), c3.x = b.x - x * dx - y * dy, c3.y = b.y - x * dy + y * dx) : (x = (d2 + a22 - b2) / (2 * d2), y = Math.sqrt(Math.max(0, a22 / d2 - x * x)), c3.x = a3.x + x * dx - y * dy, c3.y = a3.y + x * dy + y * dx)) : (c3.x = a3.x + c3.radius, c3.y = a3.y);
}
function intersects(a3, b) {
  const dr = a3.radius + b.radius - 1e-6, dx = b.x - a3.x, dy = b.y - a3.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function score(node) {
  const a3 = node._, b = node.next._, ab = a3.radius + b.radius, dx = (a3.x * b.radius + b.x * a3.radius) / ab, dy = (a3.y * b.radius + b.y * a3.radius) / ab;
  return dx * dx + dy * dy;
}
function getCicleNode(circle3) {
  return {
    _: circle3,
    next: null,
    prev: null
  };
}
function packSiblingsRandom(circles, random) {
  const n = (circles = array(circles)).length;
  if (!n)
    return 0;
  let a3 = circles[0];
  if (a3.x = 0, a3.y = 0, 1 === n)
    return a3.radius;
  const b = circles[1];
  if (a3.x = -b.radius, b.x = a3.radius, b.y = 0, 2 === n)
    return a3.radius + b.radius;
  let c3 = circles[2];
  place(b, a3, c3);
  let j, k2, sj, sk, aa, ca, isContinue, aNode = getCicleNode(a3), bNode = getCicleNode(b), cNode = getCicleNode(c3);
  aNode.next = bNode, cNode.prev = bNode, bNode.next = cNode, aNode.prev = cNode, cNode.next = aNode, bNode.prev = aNode;
  for (let i = 3; i < n; ++i) {
    isContinue = false, c3 = circles[i], place(aNode._, bNode._, c3), cNode = getCicleNode(c3), j = bNode.next, k2 = aNode.prev, sj = bNode._.radius, sk = aNode._.radius;
    do {
      if (sj <= sk) {
        if (intersects(j._, cNode._)) {
          bNode = j, aNode.next = bNode, bNode.prev = aNode, --i, isContinue = true;
          break;
        }
        sj += j._.radius, j = j.next;
      } else {
        if (intersects(k2._, cNode._)) {
          aNode = k2, aNode.next = bNode, bNode.prev = aNode, --i, isContinue = true;
          break;
        }
        sk += k2._.radius, k2 = k2.prev;
      }
    } while (j !== k2.next);
    if (!isContinue) {
      for (cNode.prev = aNode, cNode.next = bNode, aNode.next = bNode.prev = bNode = cNode, aa = score(aNode), cNode = cNode.next; cNode !== bNode; )
        ca = score(cNode), ca < aa && (aNode = cNode, aa = ca), cNode = cNode.next;
      bNode = aNode.next;
    }
  }
  const aCircles = [bNode._];
  for (cNode = bNode.next; cNode !== bNode; )
    aCircles.push(cNode._), cNode = cNode.next;
  c3 = packEncloseRandom(aCircles, random);
  for (let i = 0; i < n; ++i)
    a3 = circles[i], a3.x -= c3.x, a3.y -= c3.y;
  return c3.radius;
}

// http-url:https://unpkg.com/@visactor/vgrammar-hierarchy@0.13.8/es/circle-packing/layout
function radiusLeaf(radius) {
  return function(node) {
    node.children || (node.radius = Math.max(0, +radius(node) || 0));
  };
}
function packChildrenRandom(padding, k2, random) {
  return function(node) {
    const children = null == node ? void 0 : node.children;
    if (children) {
      let i;
      const n = children.length, r = padding(node) * k2 || 0;
      if (r)
        for (i = 0; i < n; ++i)
          children[i].radius += r;
      const e = packSiblingsRandom(children, random);
      if (r)
        for (i = 0; i < n; ++i)
          children[i].radius -= r;
      node.radius = e + r;
    }
  };
}
function translateChild(k2, maxDepth2) {
  return function(node, index, parent) {
    node.radius *= k2, node.maxDepth = maxDepth2, parent && (node.x = parent.x + k2 * node.x, node.y = parent.y + k2 * node.y);
  };
}
var CirclePackingLayout = class _CirclePackingLayout {
  constructor(options) {
    this.options = options;
    const keyOption = null == options ? void 0 : options.nodeKey, keyFunc = isFunction_default(keyOption) ? keyOption : keyOption ? field(keyOption) : null;
    this._getNodeKey = keyFunc, this._getPadding = isNumber_default(null == options ? void 0 : options.padding) ? (node) => options.padding : isArray_default(null == options ? void 0 : options.padding) ? (node) => {
      var _a;
      return null !== (_a = options.padding[node.depth + 1]) && void 0 !== _a ? _a : 0;
    } : () => 0, this._maxDepth = -1;
  }
  layout(data, config2) {
    var _a;
    const viewBox = "width" in config2 ? {
      x0: 0,
      x1: config2.width,
      y0: 0,
      y1: config2.height,
      width: config2.width,
      height: config2.height
    } : {
      x0: Math.min(config2.x0, config2.x1),
      x1: Math.max(config2.x0, config2.x1),
      y0: Math.min(config2.y0, config2.y1),
      y1: Math.max(config2.y0, config2.y1),
      width: Math.abs(config2.x1 - config2.x0),
      height: Math.abs(config2.y1 - config2.y0)
    };
    if (!data || !data.length)
      return [];
    const nodes = [], res = calculateNodeValue(data, nodes, 0, -1, null, this._getNodeKey);
    this._maxDepth = res.maxDepth;
    const random = randomLCG(), root = {
      flattenIndex: -1,
      maxDepth: -1,
      key: "root",
      depth: -1,
      index: -1,
      value: res.sum,
      datum: null,
      children: nodes,
      x: viewBox.x0 + viewBox.width / 2,
      y: viewBox.y0 + viewBox.height / 2
    }, { nodeSort, setRadius, padding, includeRoot } = null !== (_a = this.options) && void 0 !== _a ? _a : {};
    if (false !== nodeSort) {
      const sort = isFunction_default(nodeSort) ? this.options.nodeKey : _CirclePackingLayout.defaultOpionts.nodeSort;
      eachBefore([root], (node) => {
        node.children && node.children.length && node.children.sort(sort);
      });
    }
    if (setRadius)
      eachBefore([root], radiusLeaf(setRadius)), eachAfter([root], packChildrenRandom(this._getPadding, 0.5, random)), eachBefore([root], translateChild(1, this._maxDepth));
    else {
      const size = Math.min(viewBox.width, viewBox.height);
      eachBefore([root], radiusLeaf(_CirclePackingLayout.defaultOpionts.setRadius)), eachAfter([root], packChildrenRandom(zero2, 1, random)), padding && eachAfter([root], packChildrenRandom(this._getPadding, root.radius / size, random)), eachBefore([root], translateChild(size / (2 * root.radius), this._maxDepth));
    }
    return includeRoot ? [root] : nodes;
  }
};
CirclePackingLayout.defaultOpionts = {
  setRadius: (node) => Math.sqrt(node.value),
  padding: 0,
  nodeSort: (a3, b) => b.value - a3.value
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/data/transforms/circle-packing
var circlePackingLayout = (data, op) => {
  if (!data)
    return data;
  const options = op(), { width, height } = options;
  if (0 === width || 0 === height)
    return data;
  return new CirclePackingLayout(options).layout(data, {
    width,
    height
  });
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/data/transforms/flatten
var flatten = (data, op = {}) => {
  if (!data)
    return [];
  const result2 = [];
  return flattenNodes(data, result2, op), result2;
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/circle-packing/tooltip-helper
var CirclePackingTooltipHelper = class extends BaseSeriesTooltipHelper {
  constructor() {
    super(...arguments), this.markTooltipKeyCallback = (datum) => null == datum ? void 0 : datum[this.series.getDimensionField()[0]];
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/data/transforms/drill
var DrillEnum;
!function(DrillEnum2) {
  DrillEnum2.DrillDown = "drillDown", DrillEnum2.DrillUp = "drillUp";
}(DrillEnum || (DrillEnum = {}));
var drillFilter = (data, op) => {
  const info = op.info(), keyField = op.keyField(), dataKey = null == info ? void 0 : info.key;
  if (isNil_default(dataKey))
    return data;
  if (info.type === DrillEnum.DrillDown) {
    const targetNode = findHierarchyNode(data, dataKey, keyField, "children");
    return array(targetNode);
  }
  if (info.type === DrillEnum.DrillUp) {
    const targetNode = findHierarchyNodeParent(data, dataKey, keyField, "children");
    if (targetNode)
      return array(targetNode);
  }
  return data;
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/common/trigger/desktop
var DeskTopTrigger = class {
  parserScrollEvent(e) {
    return e ? !(e.ctrlKey || 0 === e.deltaY && 0 === e.deltaX) && (e.scrollX = e.deltaX, e.scrollY = e.deltaY, e) : e;
  }
  parserZoomEvent(e) {
    if (!e)
      return e;
    const zoom = Math.pow(1.0005, -e.deltaY * Math.pow(16, e.deltaMode));
    return e.zoomDelta = zoom, e.zoomX = e.canvasX, e.zoomY = e.canvasY, e;
  }
  clearZoom() {
  }
  clearScroll() {
  }
  clearDrag() {
  }
  parserDragEvent() {
    return true;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/common/trigger/mobile
var MobileTrigger = class {
  constructor() {
    this._lastScale = 0;
  }
  clearZoom() {
    this._lastScale = 0, this.pointerId = null;
  }
  parserDragEvent(event) {
    return true;
  }
  parserZoomEvent(event) {
    const scale4 = event.scale;
    if (0 === this._lastScale)
      return this._lastScale = scale4, event;
    event.zoomDelta = scale4 / this._lastScale;
    const center2 = event.center;
    return event.zoomX = center2.x, event.zoomY = center2.y, this._lastScale = scale4, event;
  }
  parserScrollEvent(event) {
    return event;
  }
  clearScroll() {
  }
  clearDrag() {
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/common/trigger/config
function getDefaultTriggerEventByMode(mode) {
  return mode === RenderModeEnum["desktop-browser"] || mode === RenderModeEnum["desktop-miniApp"] ? {
    start: "pointerdown",
    move: "pointermove",
    end: "pointerup",
    zoom: "wheel",
    zoomEnd: "pointerup",
    scroll: "wheel",
    trigger: DeskTopTrigger
  } : isMobileLikeMode(mode) || isMiniAppLikeMode(mode) ? {
    start: "pointerdown",
    move: "pointermove",
    end: "pointerup",
    zoom: "pinch",
    zoomEnd: "pinchend",
    scroll: "pan",
    scrollEnd: "panend",
    trigger: MobileTrigger
  } : null;
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/interaction/drill/drillable
var Drillable = class {
  _getDrillTriggerEvent(type) {
    var _a;
    const { mode } = this._drillParams;
    return null === (_a = getDefaultTriggerEventByMode(mode)) || void 0 === _a ? void 0 : _a[type];
  }
  _hideTooltip() {
    const tooltip3 = this.getChart().getComponentsByType(ComponentTypeEnum.tooltip)[0];
    tooltip3 && tooltip3.hideTooltip();
  }
  initDrillable(params2) {
    this._drillParams = params2;
  }
  initDrillableData(dataSet) {
    const { getRawData } = this._drillParams;
    registerDataSetInstanceTransform(dataSet, "drillFilter", drillFilter), getRawData().transform({
      type: "drillFilter",
      options: {
        info: () => this._drillInfo,
        keyField: () => this._drillParams.drillField()
      }
    });
  }
  bindDrillEvent() {
    const { event, getRawData, drillField } = this._drillParams, keyField = drillField();
    this._getDrillTriggerEvent("start") && event.on(this._getDrillTriggerEvent("start"), (e) => {
      var _a, _b, _c;
      if (isNil_default(e.datum) || isNil_default(null === (_a = e.datum) || void 0 === _a ? void 0 : _a[keyField]))
        return void this.drillUp();
      this._hideTooltip();
      const dataKey = e.datum[keyField], selectPath = null !== (_c = null === (_b = this._drillInfo) || void 0 === _b ? void 0 : _b.path) && void 0 !== _c ? _c : [], clickedPath = findHierarchyPath(getRawData().rawData, dataKey, keyField, "children");
      selectPath[selectPath.length - 1] === clickedPath[clickedPath.length - 1] ? this.drillUp() : this.drillDown(clickedPath);
    });
  }
  drillDown(drillPath = []) {
    const { getRawData, event } = this._drillParams;
    if (!isArray_default(drillPath) || isEmpty_default(drillPath))
      return drillPath;
    const dataKey = drillPath[drillPath.length - 1];
    return this._drillInfo = {
      key: dataKey,
      path: drillPath,
      type: DrillEnum.DrillDown
    }, getRawData().reRunAllTransform(), event.emit(ChartEvent.drill, {
      value: {
        path: drillPath,
        type: DrillEnum.DrillDown
      },
      model: this
    }), drillPath;
  }
  drillUp() {
    var _a, _b;
    const { getRawData, event } = this._drillParams, path = null !== (_b = null === (_a = this._drillInfo) || void 0 === _a ? void 0 : _a.path) && void 0 !== _b ? _b : [];
    if (!isArray_default(path) || isEmpty_default(path))
      return path;
    const dataKey = path.pop();
    return this._drillInfo = {
      key: dataKey,
      path,
      type: DrillEnum.DrillUp
    }, getRawData().reRunAllTransform(), event.emit(ChartEvent.drill, {
      value: {
        path,
        type: DrillEnum.DrillUp
      },
      model: this
    }), path;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/mark/arc
var BaseArcMark = class extends BaseMark {
  constructor(name, option) {
    super(name, option), this.type = ArcMark.type, this._unCompileChannel = {
      centerOffset: true,
      radiusOffset: true
    }, this.computeOuterRadius = (key, datum, states = "normal", opt, superValue) => {
      var _a;
      return superValue + (null !== (_a = this.getAttribute("radiusOffset", datum, states, opt)) && void 0 !== _a ? _a : 0);
    }, this.computeCenter = (key, datum, states = "normal", opt, center2) => polarToCartesian({
      x: 0,
      y: 0
    }, this.getAttribute("centerOffset", datum, states, opt), datum[ARC_MIDDLE_ANGLE])[key] + center2, this._computeExChannel.x = this.computeCenter, this._computeExChannel.y = this.computeCenter, this._computeExChannel.outerRadius = this.computeOuterRadius, this._extensionChannel.centerOffset = ["x", "y"], this._extensionChannel.radiusOffset = ["outerRadius"];
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      startAngle: 0,
      endAngle: 0,
      outerRadius: 0,
      innerRadius: 0,
      cornerRadius: 0,
      lineWidth: 0,
      innerPadding: 0,
      outerPadding: 0
    });
  }
};
var ArcMark = class _ArcMark extends BaseArcMark {
  constructor() {
    super(...arguments), this.type = _ArcMark.type;
  }
};
ArcMark.type = "arc";
var registerArcMark = () => {
  registerArcGraphic2(), registerVGrammarArcAnimation(), Factory2.registerMark(ArcMark.type, ArcMark);
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/mark/text
var TextMark = class _TextMark extends BaseMark {
  getTextType() {
    return this._textType;
  }
  constructor(name, option) {
    super(name, option), this.type = _TextMark.type, this._textType = "text";
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      angle: 0,
      textAlign: "center",
      lineWidth: 0,
      textConfig: []
    });
  }
  initStyleWithSpec(spec, key) {
    super.initStyleWithSpec(spec, key), spec.textType && (this._textType = spec.textType);
  }
  compileEncode() {
    super.compileEncode(), "rich" === this._textType && this._product.encodeState("group", {
      textType: this._textType
    });
  }
};
TextMark.type = "text";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/circle-packing/circle-packing
var CirclePackingSeries = class _CirclePackingSeries extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.circlePacking;
  }
  setCategoryField(f) {
    return this._categoryField = f, this._categoryField;
  }
  getCategoryField() {
    return this._categoryField;
  }
  setValueField(f) {
    return this._valueField = f, this._valueField;
  }
  getValueField() {
    return this._valueField;
  }
  getDimensionField() {
    return [this._categoryField];
  }
  getMeasureField() {
    return [this._valueField];
  }
  setAttrFromSpec() {
    var _a;
    super.setAttrFromSpec(), this.setCategoryField(this._spec.categoryField), this.setValueField(this._spec.valueField), this.setSeriesField(null !== (_a = this._spec.seriesField) && void 0 !== _a ? _a : DEFAULT_HIERARCHY_ROOT), this._spec.drill && this.initDrillable({
      event: this.event,
      mode: this._option.mode,
      drillField: () => {
        var _a2;
        return null !== (_a2 = this._spec.drillField) && void 0 !== _a2 ? _a2 : DEFAULT_DATA_KEY;
      },
      getRawData: () => this.getRawData()
    }), this._circlePacking = this._spec.circlePacking, this._label = this._spec.label, this._layoutPadding = this._spec.layoutPadding;
  }
  initData() {
    super.initData();
    const rawData = this.getRawData();
    isNil_default(rawData) || (this._spec.drill && this.initDrillableData(this._dataSet), registerDataSetInstanceTransform(this._dataSet, "circlePackingLayout", circlePackingLayout), registerDataSetInstanceTransform(this._dataSet, "flatten", flatten), rawData.transform({
      type: "circlePackingLayout",
      options: () => ({
        nodeKey: this._categoryField,
        padding: this._layoutPadding,
        includeRoot: false,
        width: this.getLayoutRect().width || 1,
        height: this.getLayoutRect().height || 1
      })
    }), rawData.transform({
      type: "flatten",
      options: {
        callback: (node) => {
          if (node.datum) {
            const nodeData = node.datum[node.depth];
            return Object.assign(Object.assign({}, node), nodeData);
          }
          return node;
        }
      }
    }));
  }
  _addDataIndexAndKey() {
    const rawData = this.getRawData();
    isNil_default(null == rawData ? void 0 : rawData.dataSet) || (registerDataSetInstanceTransform(rawData.dataSet, "addVChartProperty", addVChartProperty), rawData.transform({
      type: "addVChartProperty",
      options: {
        beforeCall: initHierarchyKeyMap.bind(this),
        call: addHierarchyDataKey
      }
    }));
  }
  initMark() {
    this._initCirclePackingMark(), this._initLabelMark();
  }
  initMarkStyle() {
    this._initCirclePackingMarkStyle(), this._initLabelMarkStyle();
  }
  _initCirclePackingMark() {
    var _a, _b;
    if (false === (null === (_a = this._circlePacking) || void 0 === _a ? void 0 : _a.visible))
      return;
    const circlePacking2 = this._createMark(_CirclePackingSeries.mark.circlePacking, {
      isSeriesMark: true,
      customShape: null === (_b = this._spec.circlePacking) || void 0 === _b ? void 0 : _b.customShape
    });
    this._circlePackingMark = circlePacking2;
  }
  _initCirclePackingMarkStyle() {
    isNil_default(this._circlePackingMark) || this.setMarkStyle(this._circlePackingMark, {
      x: (d) => d.x,
      y: (d) => d.y,
      outerRadius: (d) => d.radius,
      innerRadius: 0,
      startAngle: 0,
      endAngle: 2 * Math.PI,
      fill: this.getColorAttribute(),
      zIndex: (d) => d.depth
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  _initLabelMark() {
    var _a;
    if (false === (null === (_a = this._label) || void 0 === _a ? void 0 : _a.visible))
      return;
    const labelMark = this._createMark(_CirclePackingSeries.mark.label, {
      isSeriesMark: false
    });
    this._labelMark = labelMark;
  }
  _initLabelMarkStyle() {
    isNil_default(this._labelMark) || this.setMarkStyle(this._labelMark, {
      x: (d) => d.x,
      y: (d) => d.y,
      text: (d) => d.key,
      cursor: "pointer"
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  getStatisticFields() {
    return super.getStatisticFields().concat([{
      key: this._categoryField,
      operations: ["values"]
    }, {
      key: this._valueField,
      operations: ["max", "min"]
    }, {
      key: DEFAULT_HIERARCHY_DEPTH,
      operations: ["max", "min", "values"]
    }, {
      key: DEFAULT_HIERARCHY_ROOT,
      operations: ["values"]
    }]);
  }
  initTooltip() {
    this._tooltipHelper = new CirclePackingTooltipHelper(this), this._tooltipHelper.updateTooltipSpec(), this._circlePackingMark && this._tooltipHelper.activeTriggerSet.mark.add(this._circlePackingMark), this._labelMark && this._tooltipHelper.activeTriggerSet.mark.add(this._labelMark);
  }
  initAnimation() {
    var _a;
    const appearPreset = null === (_a = this._spec.animationAppear) || void 0 === _a ? void 0 : _a.preset;
    this.getMarksInType("arc").forEach((mark) => {
      var _a2;
      mark.setAnimationConfig(animationConfig(null === (_a2 = Factory2.getAnimationInKey("circlePacking")) || void 0 === _a2 ? void 0 : _a2(void 0, appearPreset), userAnimationConfig(mark.name, this._spec, this._markAttributeContext)));
    }), this.getMarksInType("text").forEach((mark) => {
      var _a2;
      mark.setAnimationConfig(animationConfig(null === (_a2 = Factory2.getAnimationInKey("scaleInOut")) || void 0 === _a2 ? void 0 : _a2(), userAnimationConfig(mark.name, this._spec, this._markAttributeContext)));
    });
  }
  initEvent() {
    super.initEvent(), this._spec.drill && this.bindDrillEvent();
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx), this._rawData.reRunAllTransform();
  }
  _noAnimationDataKey(datum, index) {
  }
  getActiveMarks() {
    return [this._circlePackingMark];
  }
};
CirclePackingSeries.type = SeriesTypeEnum.circlePacking, CirclePackingSeries.mark = circlePackingSeriesMark, mixin(CirclePackingSeries, Drillable);

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/circle-packing/circle-packing-transformer
var CirclePackingChartSpecTransformer = class extends BaseChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    const series2 = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      categoryField: spec.categoryField,
      valueField: spec.valueField,
      seriesField: spec.seriesField,
      layoutPadding: spec.layoutPadding,
      label: spec.label,
      circlePacking: spec.circlePacking,
      drill: spec.drill,
      drillField: spec.drillField
    }), seriesType = SeriesTypeEnum.circlePacking;
    return series2.type = seriesType, series2[seriesType] = spec[seriesType], series2;
  }
  transformSpec(spec) {
    super.transformSpec(spec), this.transformSeriesSpec(spec);
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/circle-packing/circle-packing
var CirclePackingChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = CirclePackingChartSpecTransformer, this.type = "circlePacking", this.seriesType = SeriesTypeEnum.circlePacking;
  }
};
CirclePackingChart.type = "circlePacking", CirclePackingChart.seriesType = SeriesTypeEnum.circlePacking, CirclePackingChart.transformerConstructor = CirclePackingChartSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/common/common-transformer
var CommonChartSpecTransformer = class extends BaseChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    const defaultSpec = super._getDefaultSeriesSpec(spec);
    return delete defaultSpec.data, defaultSpec;
  }
  _transformAxisSpec(spec) {
    spec.axes && spec.autoBandSize && spec.series.forEach((series2, seriesIndex) => {
      var _a;
      if ("bar" === series2.type) {
        const relatedAxis = this._findBandAxisBySeries(series2, seriesIndex, spec.axes);
        if (relatedAxis && !relatedAxis.bandSize && !relatedAxis.maxBandSize && !relatedAxis.minBandSize) {
          const extend = isObject_default(series2.autoBandSize) && null !== (_a = series2.autoBandSize.extend) && void 0 !== _a ? _a : 0, { barMaxWidth, barMinWidth, barWidth, barGapInGroup } = series2;
          this._applyAxisBandSize(relatedAxis, extend, {
            barMaxWidth,
            barMinWidth,
            barWidth,
            barGapInGroup
          });
        }
      }
    });
  }
  transformSpec(spec) {
    if (super.transformSpec(spec), spec.series && spec.series.length) {
      const defaultSeriesSpec = this._getDefaultSeriesSpec(spec);
      spec.series.forEach((s2) => {
        this._isValidSeries(s2.type) && Object.keys(defaultSeriesSpec).forEach((k2) => {
          k2 in s2 || (s2[k2] = defaultSeriesSpec[k2]);
        });
      });
    }
    spec.axes && spec.axes.length && spec.axes.forEach((axis2) => {
      get_default(axis2, "trimPadding") && mergeSpec(axis2, getTrimPaddingConfig(this.type, spec));
    }), this._transformAxisSpec(spec);
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/common/common
var CommonChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = CommonChartSpecTransformer, this.type = "common", this._canStack = true;
  }
};
CommonChart.type = "common", CommonChart.transformerConstructor = CommonChartSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/data/transforms/funnel
var funnel2 = (originData, op) => {
  var _a, _b;
  const data = originData.map((datum) => Object.assign({}, datum));
  if (!data || 0 === data.length)
    return data;
  const { valueField, asTransformRatio, asReachRatio, asHeightRatio, asValueRatio, asNextValueRatio, asLastValueRatio, asLastValue, asCurrentValue, asNextValue, heightVisual = false, isCone = true, range: range2 } = op, max3 = data.reduce((m4, d) => Math.max(m4, Number.parseFloat(d[valueField]) || -1 / 0), -1 / 0), min3 = data.reduce((m4, d) => Math.min(m4, Number.parseFloat(d[valueField]) || 1 / 0), 1 / 0), rangeArr = [null !== (_a = null == range2 ? void 0 : range2.min) && void 0 !== _a ? _a : min3, null !== (_b = null == range2 ? void 0 : range2.max) && void 0 !== _b ? _b : max3];
  return data.forEach((d, i) => {
    var _a2, _b2;
    const currentValue = Number.parseFloat(d[valueField]), lastValue = Number.parseFloat(null === (_a2 = data[i - 1]) || void 0 === _a2 ? void 0 : _a2[valueField]), nextValue = Number.parseFloat(null === (_b2 = data[i + 1]) || void 0 === _b2 ? void 0 : _b2[valueField]), transformRatio = isValidNumber_default(nextValue * currentValue) && 0 !== currentValue ? nextValue / currentValue : 0, reachRatio = isValidNumber_default(currentValue * lastValue) && 0 !== lastValue ? currentValue / lastValue : 0;
    asLastValue && (d[asLastValue] = lastValue), asNextValue && (d[asNextValue] = nextValue), asTransformRatio && (d[asTransformRatio] = transformRatio), asReachRatio && (d[asReachRatio] = 0 === i ? 1 : reachRatio), asHeightRatio && (d[asHeightRatio] = true === heightVisual ? transformRatio : 1 / data.length), asValueRatio && (d[asValueRatio] = currentValue / rangeArr[1]), asNextValueRatio && (d[asNextValueRatio] = i === data.length - 1 ? isCone ? 0 : d[asValueRatio] : nextValue / rangeArr[1]), asLastValueRatio && (d[asLastValueRatio] = 0 === i ? 1 : lastValue / rangeArr[1]), asCurrentValue && (d[asCurrentValue] = currentValue);
  }), data;
};
var funnelTransform = (originData, op) => {
  var _a, _b;
  const data = null === (_b = null === (_a = originData[0]) || void 0 === _a ? void 0 : _a.latestData) || void 0 === _b ? void 0 : _b.map((datum) => Object.assign({}, datum));
  return data && 0 !== data.length ? (data.shift(), data.forEach((d) => {
    d[op.asIsTransformLevel] = true;
  }), data) : data;
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/constant/funnel
var FUNNEL_TRANSFORM_RATIO = `${PREFIX}_FUNNEL_TRANSFORM_RATIO`;
var FUNNEL_REACH_RATIO = `${PREFIX}_FUNNEL_REACH_RATIO`;
var FUNNEL_HEIGHT_RATIO = `${PREFIX}_FUNNEL_HEIGHT_RATIO`;
var FUNNEL_VALUE_RATIO = `${PREFIX}_FUNNEL_VALUE_RATIO`;
var FUNNEL_LAST_VALUE_RATIO = `${PREFIX}_FUNNEL_LAST_VALUE_RATIO`;
var FUNNEL_NEXT_VALUE_RATIO = `${PREFIX}_FUNNEL_NEXT_VALUE_RATIO`;
var FUNNEL_LAST_VALUE = `${PREFIX}_FUNNEL_LAST_VALUE`;
var FUNNEL_CURRENT_VALUE = `${PREFIX}_FUNNEL_CURRENT_VALUE`;
var FUNNEL_NEXT_VALUE = `${PREFIX}_FUNNEL_NEXT_VALUE`;
var FUNNEL_TRANSFORM_LEVEL = `${PREFIX}_FUNNEL_TRANSFORM_LEVEL`;
var FUNNEL_LABEL_LINE_LENGTH = 20;
var FUNNEL_LABEL_SPACE_WIDTH = 5;
var FUNNEL_MAX_SIZE = "80%";
var FUNNEL_MIN_SIZE = 0;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/funnel/tooltip-helper
var FunnelSeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  constructor() {
    super(...arguments), this.dimensionTooltipTitleCallback = (datum, params2) => {
      var _a, _b, _c;
      const series2 = this.series;
      return "transform" === (null === (_a = null == params2 ? void 0 : params2.mark) || void 0 === _a ? void 0 : _a.name) ? "\u8F6C\u5316\u7387" : null !== (_b = this._getDimensionData(datum)) && void 0 !== _b ? _b : null === (_c = datum.properties) || void 0 === _c ? void 0 : _c[`${series2.getCategoryField()}`];
    }, this.markTooltipValueCallback = (datum, params2) => {
      var _a;
      if ("transform" === (null === (_a = null == params2 ? void 0 : params2.mark) || void 0 === _a ? void 0 : _a.name)) {
        return `${(100 * (null == datum ? void 0 : datum[FUNNEL_REACH_RATIO])).toFixed(1)}%`;
      }
      return this._getMeasureData(datum);
    }, this.markTooltipKeyCallback = (datum, params2) => {
      var _a;
      if ("transform" === (null === (_a = null == params2 ? void 0 : params2.mark) || void 0 === _a ? void 0 : _a.name))
        return "\u8F6C\u5316\u7387";
      const { dimensionFields, seriesFields } = this._seriesCacheInfo, subDimensionField = dimensionFields[dimensionFields.length - 1];
      return isValid_default(seriesFields[0]) ? null == datum ? void 0 : datum[seriesFields[0]] : null == datum ? void 0 : datum[subDimensionField];
    };
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/mark/polygon/base-polygon
var BasePolygonMark = class extends BaseMark {
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      points: []
    });
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/mark/polygon/polygon
var PolygonMark = class _PolygonMark extends BasePolygonMark {
  constructor() {
    super(...arguments), this.type = _PolygonMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      lineWidth: 0
    });
  }
};
PolygonMark.type = "polygon";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/mark/rule
var RuleMark = class _RuleMark extends BaseMark {
  constructor() {
    super(...arguments), this.type = _RuleMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      x1: 0,
      y1: 0
    });
  }
};
RuleMark.type = "rule";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/funnel/funnel-transformer
var FunnelSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "funnel"), spec.isTransform && this._addMarkLabelSpec(spec, "transform", "transformLabel");
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/funnel/funnel
var FunnelSeries = class _FunnelSeries extends BaseSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.funnel, this._funnelMarkName = "funnel", this._funnelMarkType = "polygon", this._transformMarkName = "transform", this._transformMarkType = "polygon", this.transformerConstructor = FunnelSeriesSpecTransformer, this._funnelMark = null, this._funnelTransformMark = null, this._labelMark = null, this._transformLabelMark = null, this._funnelOuterLabelMark = {};
  }
  getCategoryField() {
    return this._categoryField;
  }
  setCategoryField(f) {
    return this._categoryField = f, this._categoryField;
  }
  getValueField() {
    return this._valueField;
  }
  setValueField(f) {
    return this._valueField = f, this._valueField;
  }
  setAttrFromSpec() {
    var _a, _b;
    super.setAttrFromSpec(), this.setCategoryField(this._spec.categoryField), this.setValueField(this._spec.valueField), this._funnelOrient = null !== (_a = this._spec.funnelOrient) && void 0 !== _a ? _a : "top", this._shape = null !== (_b = this._spec.shape) && void 0 !== _b ? _b : "trapezoid", this._isHorizontal() ? this._funnelAlign = ["top", "bottom"].includes(this._spec.funnelAlign) ? this._spec.funnelAlign : "center" : this._funnelAlign = ["left", "right"].includes(this._spec.funnelAlign) ? this._spec.funnelAlign : "center", this._spec.categoryField && this.setSeriesField(this._spec.categoryField);
  }
  initData() {
    if (super.initData(), !this._data)
      return;
    registerDataSetInstanceTransform(this._dataSet, "funnel", funnel2), registerDataSetInstanceTransform(this._dataSet, "funnelTransform", funnelTransform);
    const viewDataTransform = new DataView(this._dataSet, {
      name: `${PREFIX}_series_${this.id}_viewDataTransform`
    });
    viewDataTransform.parse([this.getViewData()], {
      type: "dataview"
    }), this._viewDataTransform = new SeriesData(this._option, viewDataTransform);
  }
  getStatisticFields() {
    const fields2 = [];
    return fields2.push({
      key: this._categoryField,
      operations: ["values"]
    }), fields2.push({
      key: this._valueField,
      operations: ["max", "min"]
    }), fields2;
  }
  _statisticViewData() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    super._statisticViewData(), this._data.getDataView().transform({
      type: "funnel",
      options: {
        valueField: this.getValueField(),
        isCone: this._spec.isCone,
        asCurrentValue: FUNNEL_CURRENT_VALUE,
        asTransformRatio: FUNNEL_TRANSFORM_RATIO,
        asReachRatio: FUNNEL_REACH_RATIO,
        asHeightRatio: FUNNEL_HEIGHT_RATIO,
        asValueRatio: FUNNEL_VALUE_RATIO,
        asNextValueRatio: FUNNEL_NEXT_VALUE_RATIO,
        asLastValueRatio: FUNNEL_LAST_VALUE_RATIO,
        asLastValue: FUNNEL_LAST_VALUE,
        asNextValue: FUNNEL_NEXT_VALUE,
        range: {
          min: null !== (_b = null === (_a = this._spec.range) || void 0 === _a ? void 0 : _a.min) && void 0 !== _b ? _b : null === (_d = null === (_c = this.getViewDataStatistics().latestData) || void 0 === _c ? void 0 : _c[this.getValueField()]) || void 0 === _d ? void 0 : _d.min,
          max: null !== (_f = null === (_e = this._spec.range) || void 0 === _e ? void 0 : _e.max) && void 0 !== _f ? _f : null === (_h = null === (_g = this.getViewDataStatistics().latestData) || void 0 === _g ? void 0 : _g[this.getValueField()]) || void 0 === _h ? void 0 : _h.max
        }
      }
    }), null === (_j = this._viewDataTransform.getDataView()) || void 0 === _j || _j.transform({
      type: "funnelTransform",
      options: {
        asIsTransformLevel: FUNNEL_TRANSFORM_LEVEL
      }
    });
  }
  initMark() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    if (this._funnelMark = this._createMark(Object.assign(Object.assign({}, _FunnelSeries.mark.funnel), {
      name: this._funnelMarkName,
      type: this._funnelMarkType
    }), {
      themeSpec: null === (_a = this._theme) || void 0 === _a ? void 0 : _a.funnel,
      morph: shouldMarkDoMorph(this._spec, this._funnelMarkName),
      defaultMorphElementKey: this._seriesField,
      groupKey: this._seriesField,
      isSeriesMark: true,
      customShape: null === (_b = this._spec.funnel) || void 0 === _b ? void 0 : _b.customShape,
      stateSort: null === (_c = this._spec.funnel) || void 0 === _c ? void 0 : _c.stateSort,
      noSeparateStyle: true
    }), this._spec.isTransform && (this._funnelTransformMark = this._createMark(Object.assign(Object.assign({}, _FunnelSeries.mark.transform), {
      name: this._transformMarkName,
      type: this._transformMarkType
    }), {
      themeSpec: null === (_d = this._theme) || void 0 === _d ? void 0 : _d.transform,
      skipBeforeLayouted: false,
      dataView: this._viewDataTransform.getDataView(),
      dataProductId: this._viewDataTransform.getProductId(),
      customShape: null === (_e = this._spec.transform) || void 0 === _e ? void 0 : _e.customShape,
      stateSort: null === (_f = this._spec.transform) || void 0 === _f ? void 0 : _f.stateSort,
      noSeparateStyle: true
    })), null === (_h = null === (_g = this._spec) || void 0 === _g ? void 0 : _g.outerLabel) || void 0 === _h ? void 0 : _h.visible) {
      const { line: line2 } = null !== (_j = this._spec.outerLabel) && void 0 !== _j ? _j : {}, { line: lineTheme } = null !== (_l = null === (_k = this._theme) || void 0 === _k ? void 0 : _k.outerLabel) && void 0 !== _l ? _l : {};
      this._funnelOuterLabelMark.label = this._createMark(_FunnelSeries.mark.outerLabel, {
        themeSpec: null === (_m = this._theme) || void 0 === _m ? void 0 : _m.outerLabel,
        markSpec: this._spec.outerLabel,
        skipBeforeLayouted: true,
        noSeparateStyle: true
      }), this._funnelOuterLabelMark.line = this._createMark(_FunnelSeries.mark.outerLabelLine, {
        themeSpec: lineTheme,
        markSpec: line2,
        depend: [this._funnelOuterLabelMark.label],
        noSeparateStyle: true
      });
    }
  }
  initTooltip() {
    this._tooltipHelper = new FunnelSeriesTooltipHelper(this), this._funnelMark && this._tooltipHelper.activeTriggerSet.mark.add(this._funnelMark), this._funnelTransformMark && this._tooltipHelper.activeTriggerSet.mark.add(this._funnelTransformMark);
  }
  getDimensionField() {
    return this._seriesField ? [this._seriesField] : [];
  }
  getMeasureField() {
    return [this._valueField];
  }
  getGroupFields() {
    return null;
  }
  initMarkStyle() {
    const funnelMark = this._funnelMark;
    funnelMark && this.setMarkStyle(funnelMark, {
      points: (datum) => this.getPoints(datum),
      visible: (datum) => isValid_default(datum[this._valueField]),
      fill: this.getColorAttribute()
    }, "normal", AttributeLevel.Series);
    const funnelTransformMark = this._funnelTransformMark;
    funnelTransformMark && this.setMarkStyle(funnelTransformMark, {
      points: (datum) => this.getPoints(datum)
    }, "normal", AttributeLevel.Series);
    const outerLabelMark = this._funnelOuterLabelMark.label;
    outerLabelMark && this.setMarkStyle(outerLabelMark, {
      text: (datum) => {
        const text2 = `${datum[this.getCategoryField()]}`;
        return isFunction_default(this._spec.outerLabel.formatMethod) ? this._spec.outerLabel.formatMethod(text2, datum) : text2;
      },
      x: (datum) => this._computeOuterLabelPosition(datum).x,
      y: (datum) => this._computeOuterLabelPosition(datum).y,
      textAlign: (datum) => this._computeOuterLabelPosition(datum).align,
      textBaseline: (datum) => this._computeOuterLabelPosition(datum).textBaseline,
      maxLineWidth: (datum) => this._computeOuterLabelLimit(datum)
    }, "normal", AttributeLevel.Series);
    const outerLabelLineMark = this._funnelOuterLabelMark.line;
    outerLabelLineMark && outerLabelMark && this.setMarkStyle(outerLabelLineMark, {
      x: (datum) => this._computeOuterLabelLinePosition(datum).x1,
      y: (datum) => this._computeOuterLabelLinePosition(datum).y1,
      x1: (datum) => this._computeOuterLabelLinePosition(datum).x2,
      y1: (datum) => this._computeOuterLabelLinePosition(datum).y2
    }, "normal", AttributeLevel.Series);
  }
  initLabelMarkStyle(labelMark) {
    var _a, _b;
    if (!labelMark)
      return;
    const target = labelMark.getTarget(), component2 = labelMark.getComponent();
    target === this._funnelMark ? (this._labelMark = labelMark, this.setMarkStyle(labelMark, {
      text: (datum) => `${datum[this.getCategoryField()]} ${datum[this.getValueField()]}`,
      x: (datum) => this._computeLabelPosition(datum).x,
      y: (datum) => this._computeLabelPosition(datum).y,
      maxLineWidth: (datum) => this._computeLabelLimit(datum, this._spec.label),
      stroke: this.getColorAttribute()
    }, "normal", AttributeLevel.Series), (null === (_a = this._funnelOuterLabelMark) || void 0 === _a ? void 0 : _a.label) && this._funnelOuterLabelMark.label.setDepend(component2), (null === (_b = this._funnelOuterLabelMark) || void 0 === _b ? void 0 : _b.line) && this._funnelOuterLabelMark.line.setDepend(...this._funnelOuterLabelMark.line.getDepend())) : this._funnelTransformMark && target === this._funnelTransformMark && (this._transformLabelMark = labelMark, this.setMarkStyle(labelMark, {
      text: (datum) => `${(100 * field2(FUNNEL_REACH_RATIO).bind(this)(datum)).toFixed(1)}%`,
      x: (datum) => this._computeLabelPosition(datum).x,
      y: (datum) => this._computeLabelPosition(datum).y,
      maxLineWidth: (datum) => this._computeLabelLimit(datum, this._spec.transformLabel)
    }, "normal", AttributeLevel.Series));
  }
  initAnimation() {
    var _a, _b, _c, _d, _e, _f, _g;
    const appearPreset = null !== (_c = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset) && void 0 !== _c ? _c : "clipIn";
    "clipIn" === appearPreset && this._rootMark && this._rootMark.setAnimationConfig(animationConfig(null === (_d = Factory2.getAnimationInKey("cartesianGroupClip")) || void 0 === _d ? void 0 : _d({
      direction: () => this._isHorizontal() ? "x" : "y",
      width: () => {
        const rootMark = this.getRootMark().getProduct();
        if (rootMark) {
          const { x1: x14, x2: x23 } = rootMark.getBounds();
          return Math.max(x14, x23);
        }
        return this.getLayoutRect().width;
      },
      height: () => {
        const rootMark = this.getRootMark().getProduct();
        if (rootMark) {
          const { y1: y14, y2: y23 } = rootMark.getBounds();
          return Math.max(y14, y23);
        }
        return this.getLayoutRect().height;
      },
      orient: () => this._isReverse() ? "negative" : "positive"
    }, appearPreset), userAnimationConfig("group", this._spec, this._markAttributeContext))), [null === (_e = this._funnelOuterLabelMark) || void 0 === _e ? void 0 : _e.label].forEach((m4) => {
      m4 && m4.setAnimationConfig(animationConfig(Factory2.getAnimationInKey("fadeInOut")(), userAnimationConfig(m4.name, this._spec, this._markAttributeContext)));
    }), [this._funnelMark, this._funnelTransformMark].forEach((m4) => {
      m4 && m4.setAnimationConfig(animationConfig(Factory2.getAnimationInKey("funnel")({}, appearPreset), userAnimationConfig(m4.name, this._spec, this._markAttributeContext)));
    }), (null === (_f = this._funnelOuterLabelMark) || void 0 === _f ? void 0 : _f.line) && this._funnelOuterLabelMark.line.setAnimationConfig(animationConfig(null === (_g = Factory2.getAnimationInKey("fadeInOut")) || void 0 === _g ? void 0 : _g(), userAnimationConfig("outerLabelLine", this._spec, this._markAttributeContext)));
  }
  initGroups() {
  }
  getStackGroupFields() {
    return [];
  }
  getStackValueField() {
    return null;
  }
  initEvent() {
    var _a;
    super.initEvent(), null === (_a = this._viewDataTransform.getDataView()) || void 0 === _a || _a.target.addListener("change", (d) => {
      this._viewDataTransform.updateData();
    });
  }
  getPoints(datum) {
    const isTransformLevel = this.isTransformLevel(datum), heightHalf = this._getMainAxisLength(isTransformLevel) / 2;
    let upperLeft, lowerLeft;
    isTransformLevel ? (upperLeft = "rect" === this._shape ? this._getSecondaryAxisLength(datum[FUNNEL_LAST_VALUE_RATIO]) / 2 : this._getSecondaryAxisLength(datum[FUNNEL_VALUE_RATIO]) / 2, lowerLeft = this._getSecondaryAxisLength(datum[FUNNEL_VALUE_RATIO]) / 2) : (upperLeft = this._getSecondaryAxisLength(datum[FUNNEL_VALUE_RATIO]) / 2, lowerLeft = "rect" === this._shape ? upperLeft : this._getSecondaryAxisLength(datum[FUNNEL_NEXT_VALUE_RATIO]) / 2);
    const { x, y } = this._getPositionByData(datum), points = this._getPolygonPoints([x, y], upperLeft, lowerLeft, upperLeft, lowerLeft, heightHalf);
    return "center" !== this._funnelAlign && this._adjustPoints(points), points;
  }
  isTransformLevel(datum) {
    return !!(null == datum ? void 0 : datum[FUNNEL_TRANSFORM_LEVEL]);
  }
  _buildMarkAttributeContext() {
    super._buildMarkAttributeContext(), this._markAttributeContext.valueToPosition = this.valueToPosition.bind(this), this._markAttributeContext.getPoints = this.getPoints.bind(this), this._markAttributeContext.isTransformLevel = this.isTransformLevel.bind(this);
  }
  valueToPosition(category) {
    var _a, _b, _c;
    const innerDatum = null === (_c = null === (_b = null === (_a = this.getViewData()) || void 0 === _a ? void 0 : _a.latestData) || void 0 === _b ? void 0 : _b.find) || void 0 === _c ? void 0 : _c.call(_b, (d) => d[this._categoryField] === category);
    return isValid_default(innerDatum) ? this._getPolygonCenter(this.getPoints(innerDatum)) : null;
  }
  dataToPosition(datum, checkInViewData) {
    return checkInViewData && !this.isDatumInViewData(datum) ? null : this.valueToPosition(datum[this._categoryField]);
  }
  dataToPositionX(datum) {
    var _a;
    return null === (_a = this.dataToPosition(datum)) || void 0 === _a ? void 0 : _a.x;
  }
  dataToPositionY(datum) {
    var _a;
    return null === (_a = this.dataToPosition(datum)) || void 0 === _a ? void 0 : _a.y;
  }
  dataToPositionZ(datum) {
    return 0;
  }
  _getMainAxisLength(isTransform = false) {
    var _a;
    const funnelCount = this.getViewData().latestData.length, viewHeight = this._isHorizontal() ? this.getLayoutRect().width : this.getLayoutRect().height, hasTransform = !!this._spec.isTransform, gap = hasTransform ? 0 : null !== (_a = this._spec.gap) && void 0 !== _a ? _a : 0, transformCount = hasTransform ? Math.max(0, funnelCount - 1) : 0, heightRatio = this._spec.heightRatio || 0.5, funnelHeight = (viewHeight - gap * Math.max(0, funnelCount - 1)) / (funnelCount + heightRatio * transformCount);
    return isTransform ? hasTransform ? funnelHeight * heightRatio : 0 : funnelHeight;
  }
  _getSecondaryAxisLength(ratio) {
    const validRatio = Number.isNaN(ratio) || !Number.isFinite(ratio) ? 0 : ratio, maxSize = this._computeMaxSize(), minSize = this._computeMinSize();
    return minSize + (maxSize - minSize) * validRatio;
  }
  _getPositionByData(datum) {
    var _a;
    const index = null === (_a = this.getViewData().latestData) || void 0 === _a ? void 0 : _a.findIndex((d) => d[this._categoryField] === datum[this._categoryField] && d[DEFAULT_DATA_KEY] === datum[DEFAULT_DATA_KEY]);
    if (!isValid_default(index) || index < 0)
      return {};
    const isTransform = this.isTransformLevel(datum), isHorizontal3 = this._isHorizontal(), viewWidth = isHorizontal3 ? this.getLayoutRect().height : this.getLayoutRect().width, viewHeight = isHorizontal3 ? this.getLayoutRect().width : this.getLayoutRect().height, centerX = viewWidth / 2;
    let centerY = 0;
    const funnelHeight = this._getMainAxisLength(), transformHeight = this._getMainAxisLength(true);
    return centerY += index * (funnelHeight + transformHeight), centerY += isTransform ? -transformHeight / 2 : funnelHeight / 2, !this._spec.isTransform && this._spec.gap && (centerY += this._spec.gap * index), this._isReverse() && (centerY = viewHeight - centerY), this._isHorizontal() ? {
      x: centerY,
      y: centerX
    } : {
      x: centerX,
      y: centerY
    };
  }
  _getPolygonPoints(center2, upperLeft, lowerLeft, upperRight, lowerRight, heightHalf) {
    const x = center2[0], y = center2[1];
    switch (this._funnelOrient) {
      case "left":
        return [{
          x: x - heightHalf,
          y: y + upperLeft
        }, {
          x: x - heightHalf,
          y: y - upperRight
        }, {
          x: x + heightHalf,
          y: y - lowerRight
        }, {
          x: x + heightHalf,
          y: y + lowerLeft
        }];
      case "right":
        return [{
          x: x + heightHalf,
          y: y - upperRight
        }, {
          x: x + heightHalf,
          y: y + upperRight
        }, {
          x: x - heightHalf,
          y: y + lowerLeft
        }, {
          x: x - heightHalf,
          y: y - lowerLeft
        }];
      case "bottom":
        return [{
          x: x + upperLeft,
          y: y + heightHalf
        }, {
          x: x - upperRight,
          y: y + heightHalf
        }, {
          x: x - lowerRight,
          y: y - heightHalf
        }, {
          x: x + lowerLeft,
          y: y - heightHalf
        }];
      default:
        return [{
          x: x - upperLeft,
          y: y - heightHalf
        }, {
          x: x + upperRight,
          y: y - heightHalf
        }, {
          x: x + lowerRight,
          y: y + heightHalf
        }, {
          x: x - lowerLeft,
          y: y + heightHalf
        }];
    }
  }
  _getPolygonCenter(points) {
    if (this._isHorizontal()) {
      const p0_x2 = (points[0].x + points[3].x) / 2, p0_y2 = (points[0].y + points[3].y) / 2;
      return {
        x: (p0_x2 + (points[1].x + points[2].x) / 2) / 2,
        y: (p0_y2 + (points[1].y + points[2].y) / 2) / 2
      };
    }
    const p0_x = (points[0].x + points[3].x) / 2, p0_y = (points[0].y + points[3].y) / 2;
    return {
      x: (p0_x + (points[1].x + points[2].x) / 2) / 2,
      y: (p0_y + (points[1].y + points[2].y) / 2) / 2
    };
  }
  _adjustPoints(points) {
    let upperOffset, lowerOffset, dirKey;
    return this._isHorizontal() ? (dirKey = "y", "left" === this._funnelOrient ? (upperOffset = "bottom" === this._funnelAlign ? -points[1].y : points[1].y, lowerOffset = "bottom" === this._funnelAlign ? -points[2].y : points[2].y) : (upperOffset = "bottom" === this._funnelAlign ? -points[0].y : points[0].y, lowerOffset = "bottom" === this._funnelAlign ? -points[3].y : points[3].y)) : (dirKey = "x", "top" === this._funnelOrient ? (upperOffset = "left" === this._funnelAlign ? points[0].x : -points[0].x, lowerOffset = "left" === this._funnelAlign ? points[3].x : -points[3].x) : (upperOffset = "left" === this._funnelAlign ? points[1].x : -points[1].x, lowerOffset = "left" === this._funnelAlign ? points[2].x : -points[2].x)), points[0][dirKey] -= upperOffset, points[1][dirKey] -= upperOffset, points[2][dirKey] -= lowerOffset, points[3][dirKey] -= lowerOffset, points;
  }
  _computeLabelPosition(datum) {
    const points = this.getPoints(datum);
    return this._getPolygonCenter(points);
  }
  _computeLabelLimit(datum, labelSpec) {
    const limit = null == labelSpec ? void 0 : labelSpec.limit;
    if (isNumber_default(limit))
      return limit;
    const points = this.getPoints(datum);
    return "shapeSize" === limit ? this._isHorizontal() ? Math.abs(points[3].x - points[0].x) : (Math.abs(points[0].x - points[1].x) + Math.abs(points[2].x - points[3].x)) / 2 : this._isHorizontal() ? Math.abs(points[3].x - points[0].x) : void 0;
  }
  _computeOuterLabelPosition(datum) {
    var _a, _b;
    let x, y, position = null === (_a = this._spec.outerLabel) || void 0 === _a ? void 0 : _a.position, textAlign = "center", textBaseline = "middle";
    if (position = this._isHorizontal() ? ["top", "bottom"].includes(position) ? position : "bottom" === this._funnelAlign ? "top" : "bottom" : ["left", "right"].includes(position) ? position : "left" === this._funnelAlign ? "right" : "left", false !== (null === (_b = this._spec.outerLabel) || void 0 === _b ? void 0 : _b.alignLabel))
      ({ x, y } = this._getPositionByData(datum)), "left" === position ? (x = 0, textAlign = "left") : "right" === position ? (x = this.getLayoutRect().width, textAlign = "right") : "top" === position ? (y = 0, textBaseline = "top") : "bottom" === position && (y = this.getLayoutRect().height, textBaseline = "bottom");
    else {
      const { x2: x23, y2: y23 } = this._computeOuterLabelLinePosition(datum);
      x = x23, y = y23, "left" === position ? (x -= FUNNEL_LABEL_SPACE_WIDTH, textAlign = "right") : "right" === position ? (x += FUNNEL_LABEL_SPACE_WIDTH, textAlign = "left") : "top" === position ? (y -= FUNNEL_LABEL_SPACE_WIDTH, textBaseline = "bottom") : "bottom" === position && (y += FUNNEL_LABEL_SPACE_WIDTH, textBaseline = "top");
    }
    return {
      x,
      y,
      align: textAlign,
      textBaseline
    };
  }
  _computeOuterLabelLimit(datum) {
    var _a, _b, _c, _d, _e;
    if (this._isHorizontal())
      return this._getMainAxisLength(this.isTransformLevel(datum));
    const points = this.getPoints(datum), shapeMiddleWidth = (Math.abs(points[0].x - points[1].x) + Math.abs(points[2].x - points[3].x)) / 2, categoryField = this.getCategoryField(), funnelLabelBounds = null === (_c = null === (_b = null === (_a = this._labelMark) || void 0 === _a ? void 0 : _a.getComponent()) || void 0 === _b ? void 0 : _b.getProduct().getGroupGraphicItem().find(({ attribute, type }) => {
      var _a2;
      return "text" === type && (null === (_a2 = attribute.data) || void 0 === _a2 ? void 0 : _a2[categoryField]) === datum[categoryField];
    }, true)) || void 0 === _c ? void 0 : _c.AABBBounds, funnelLabelWidth = funnelLabelBounds ? funnelLabelBounds.x2 - funnelLabelBounds.x1 : 0, outerLineSpace = this._funnelOuterLabelMark.line ? FUNNEL_LABEL_LINE_LENGTH : 0;
    let space = this.getLayoutRect().width - Math.max(shapeMiddleWidth, funnelLabelWidth);
    return "center" === this._funnelAlign && (space /= 2), space - outerLineSpace - (null !== (_e = null === (_d = this._spec.outerLabel) || void 0 === _d ? void 0 : _d.spaceWidth) && void 0 !== _e ? _e : FUNNEL_LABEL_SPACE_WIDTH);
  }
  _computeOuterLabelLinePosition(datum) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const categoryField = this.getCategoryField(), outerLabelMarkBounds = null === (_e = null === (_d = null === (_c = null === (_b = null === (_a = this._funnelOuterLabelMark) || void 0 === _a ? void 0 : _a.label) || void 0 === _b ? void 0 : _b.getProduct()) || void 0 === _c ? void 0 : _c.elements) || void 0 === _d ? void 0 : _d.find((el) => {
      var _a2;
      return (null === (_a2 = el.data[0]) || void 0 === _a2 ? void 0 : _a2[categoryField]) === datum[categoryField];
    })) || void 0 === _e ? void 0 : _e.getBounds(), labelMarkBounds = null === (_h = null === (_g = null === (_f = this._labelMark) || void 0 === _f ? void 0 : _f.getComponent()) || void 0 === _g ? void 0 : _g.getProduct().getGroupGraphicItem().find(({ attribute, type }) => {
      var _a2;
      return "text" === type && (null === (_a2 = attribute.data) || void 0 === _a2 ? void 0 : _a2[categoryField]) === datum[categoryField];
    }, true)) || void 0 === _h ? void 0 : _h.AABBBounds, outerLabelSpec = null !== (_j = this._spec.outerLabel) && void 0 !== _j ? _j : {};
    let x14, x23, y14, y23;
    if (this._isHorizontal()) {
      const spaceWidth2 = null !== (_k = outerLabelSpec.spaceWidth) && void 0 !== _k ? _k : FUNNEL_LABEL_SPACE_WIDTH, points2 = this.getPoints(datum), shapeMiddleHeight = (Math.abs(points2[0].y - points2[1].y) + Math.abs(points2[2].y - points2[3].y)) / 2;
      return "top" === this._spec.outerLabel.position || "bottom" === this._funnelAlign ? (y14 = this._getPolygonCenter(points2).y - shapeMiddleHeight / 2 - spaceWidth2, y23 = false !== outerLabelSpec.alignLabel ? (null == outerLabelMarkBounds ? void 0 : outerLabelMarkBounds.y2) + spaceWidth2 : y14 - spaceWidth2, x14 = this._getPolygonCenter(points2).x, y14 - y23 < FUNNEL_LABEL_LINE_LENGTH && (y23 = y14 - FUNNEL_LABEL_LINE_LENGTH), x23 = x14) : (y14 = this._getPolygonCenter(points2).y + shapeMiddleHeight / 2 + spaceWidth2, y23 = false !== outerLabelSpec.alignLabel ? (null == outerLabelMarkBounds ? void 0 : outerLabelMarkBounds.y1) - spaceWidth2 : y14 + spaceWidth2, x14 = this._getPolygonCenter(points2).x, y23 - y14 < FUNNEL_LABEL_LINE_LENGTH && (y23 = y14 + FUNNEL_LABEL_LINE_LENGTH), x23 = x14), {
        x1: x14,
        x2: x23,
        y1: y14,
        y2: y23
      };
    }
    const points = this.getPoints(datum), shapeMiddleWidth = (Math.abs(points[0].x - points[1].x) + Math.abs(points[2].x - points[3].x)) / 2, labelWidth = (null == labelMarkBounds ? void 0 : labelMarkBounds.x2) - (null == labelMarkBounds ? void 0 : labelMarkBounds.x1) || 0, spaceWidth = null !== (_l = outerLabelSpec.spaceWidth) && void 0 !== _l ? _l : FUNNEL_LABEL_SPACE_WIDTH;
    return "right" === this._spec.outerLabel.position || "left" === this._funnelAlign ? (x14 = this._getPolygonCenter(points).x + Math.max(labelWidth / 2, shapeMiddleWidth / 2) + spaceWidth, x23 = false !== outerLabelSpec.alignLabel ? (null == outerLabelMarkBounds ? void 0 : outerLabelMarkBounds.x1) - spaceWidth : x14 + spaceWidth, y14 = this._getPolygonCenter(points).y, x23 - x14 < FUNNEL_LABEL_LINE_LENGTH && (x23 = x14 + FUNNEL_LABEL_LINE_LENGTH), y23 = y14) : (x14 = this._getPolygonCenter(points).x - Math.max(labelWidth / 2, shapeMiddleWidth / 2) - spaceWidth, x23 = false !== outerLabelSpec.alignLabel ? (null == outerLabelMarkBounds ? void 0 : outerLabelMarkBounds.x2) + spaceWidth : x14 - spaceWidth, y14 = this._getPolygonCenter(points).y, x14 - x23 < FUNNEL_LABEL_LINE_LENGTH && (x23 = x14 - FUNNEL_LABEL_LINE_LENGTH), y23 = y14), {
      x1: x14,
      x2: x23,
      y1: y14,
      y2: y23
    };
  }
  _computeMaxSize() {
    var _a;
    const size = this._isHorizontal() ? this.getLayoutRect().height : this.getLayoutRect().width, maxSize = null !== (_a = this._spec.maxSize) && void 0 !== _a ? _a : FUNNEL_MAX_SIZE;
    return calcLayoutNumber(maxSize, size);
  }
  _computeMinSize() {
    var _a;
    const size = this._isHorizontal() ? this.getLayoutRect().height : this.getLayoutRect().width, minSize = null !== (_a = this._spec.minSize) && void 0 !== _a ? _a : FUNNEL_MIN_SIZE;
    return calcLayoutNumber(minSize, size);
  }
  _isHorizontal() {
    return "left" === this._funnelOrient || "right" === this._funnelOrient;
  }
  _isReverse() {
    return "bottom" === this._funnelOrient || "right" === this._funnelOrient;
  }
  getDefaultShapeType() {
    return "square";
  }
  getActiveMarks() {
    return [this._funnelMark];
  }
};
FunnelSeries.type = SeriesTypeEnum.funnel, FunnelSeries.mark = funnelSeriesMark, FunnelSeries.transformerConstructor = FunnelSeriesSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/funnel/funnel-transformer
var FunnelChartSpecTransformer = class extends BaseChartSpecTransformer {
  needAxes() {
    return false;
  }
  _getDefaultSeriesSpec(spec) {
    const series2 = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      categoryField: spec.categoryField,
      valueField: spec.valueField,
      seriesField: spec.seriesField,
      funnelAlign: spec.funnelAlign,
      funnelOrient: spec.funnelOrient,
      heightRatio: spec.heightRatio,
      shape: spec.shape,
      funnel: spec.funnel,
      transform: spec.transform,
      outerLabel: spec.outerLabel,
      transformLabel: spec.transformLabel,
      isTransform: spec.isTransform,
      maxSize: spec.maxSize,
      minSize: spec.minSize,
      gap: spec.gap,
      isCone: spec.isCone,
      range: spec.range
    }), seriesType = this.seriesType;
    return seriesType && (series2.type = seriesType, series2[seriesType] = spec[seriesType]), series2;
  }
  transformSpec(spec) {
    super.transformSpec(spec);
    const defaultSeriesSpec = this._getDefaultSeriesSpec(spec);
    spec.series && 0 !== spec.series.length ? spec.series.forEach((s2) => {
      this._isValidSeries(s2.type) && Object.keys(defaultSeriesSpec).forEach((k2) => {
        k2 in s2 || (s2[k2] = defaultSeriesSpec[k2]);
      });
    }) : spec.series = [defaultSeriesSpec];
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/funnel/funnel
var FunnelChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = FunnelChartSpecTransformer, this.type = "funnel", this.seriesType = SeriesTypeEnum.funnel;
  }
};
FunnelChart.type = "funnel", FunnelChart.seriesType = SeriesTypeEnum.funnel, FunnelChart.transformerConstructor = FunnelChartSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/mark/polygon/pyramid-3d
var Pyramid3dMark = class _Pyramid3dMark extends BasePolygonMark {
  constructor() {
    super(...arguments), this.type = _Pyramid3dMark.type;
  }
};
Pyramid3dMark.type = "pyramid3d";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/funnel/3d/funnel-3d-transformer
var Funnel3dSeriesSpecTransformer = class extends FunnelSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "funnel3d"), spec.isTransform && this._addMarkLabelSpec(spec, "transform3d", "transformLabel");
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/funnel/3d/funnel-3d
var Funnel3dSeries = class _Funnel3dSeries extends FunnelSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.funnel3d, this._funnelMarkName = "funnel3d", this._funnelMarkType = "pyramid3d", this._transformMarkName = "transform3d", this._transformMarkType = "pyramid3d", this.transformerConstructor = Funnel3dSeriesSpecTransformer;
  }
  initMark() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (this._funnelMark = this._createMark(Object.assign(Object.assign({}, _Funnel3dSeries.mark.funnel3d), {
      name: this._funnelMarkName,
      type: this._funnelMarkType
    }), {
      themeSpec: null === (_a = this._theme) || void 0 === _a ? void 0 : _a.funnel3d,
      key: this._seriesField,
      isSeriesMark: true,
      support3d: true
    }), this._spec.isTransform && (this._funnelTransformMark = this._createMark(Object.assign(Object.assign({}, _Funnel3dSeries.mark.transform3d), {
      name: this._transformMarkName,
      type: this._transformMarkType
    }), {
      themeSpec: null === (_b = this._theme) || void 0 === _b ? void 0 : _b.transform3d,
      key: this._seriesField,
      skipBeforeLayouted: false,
      dataView: this._viewDataTransform.getDataView(),
      dataProductId: this._viewDataTransform.getProductId()
    })), null === (_d = null === (_c = this._spec) || void 0 === _c ? void 0 : _c.outerLabel) || void 0 === _d ? void 0 : _d.visible) {
      const { line: line2 } = null !== (_e = this._spec.outerLabel) && void 0 !== _e ? _e : {}, { line: lineTheme } = null !== (_g = null === (_f = this._theme) || void 0 === _f ? void 0 : _f.outerLabel) && void 0 !== _g ? _g : {};
      this._funnelOuterLabelMark.label = this._createMark(_Funnel3dSeries.mark.outerLabel, {
        themeSpec: null === (_h = this._theme) || void 0 === _h ? void 0 : _h.outerLabel,
        key: this._seriesField,
        markSpec: this._spec.outerLabel
      }), this._funnelOuterLabelMark.line = this._createMark(_Funnel3dSeries.mark.outerLabelLine, {
        themeSpec: lineTheme,
        key: this._seriesField,
        markSpec: line2,
        depend: [this._funnelOuterLabelMark.label]
      });
    }
  }
  initMarkStyle() {
    super.initMarkStyle();
    const funnelMark = this._funnelMark;
    funnelMark && this.setMarkStyle(funnelMark, {
      z: (_) => {
        if (this._isHorizontal())
          return 0;
        const points = this.getPoints(_), width = Math.max(Math.abs(points[0].x - points[1].x), Math.abs(points[2].x - points[3].x));
        return (this._computeMaxSize() - width) / 2;
      }
    }, "normal", AttributeLevel.Series);
  }
  initLabelMarkStyle(labelMark) {
    var _a, _b;
    super.initLabelMarkStyle(labelMark), this.setMarkStyle(labelMark, {
      z: (_) => {
        if (this._isHorizontal())
          return 0;
        const points = this.getPoints(_), width = Math.max(Math.abs(points[0].x - points[1].x), Math.abs(points[2].x - points[3].x));
        return (this._computeMaxSize() - width) / 2;
      }
    }, "normal", AttributeLevel.Series), this._labelMark = labelMark, (null === (_a = this._funnelOuterLabelMark) || void 0 === _a ? void 0 : _a.label) && this._funnelOuterLabelMark.label.setDepend(labelMark.getComponent()), (null === (_b = this._funnelOuterLabelMark) || void 0 === _b ? void 0 : _b.line) && this._funnelOuterLabelMark.line.setDepend(...this._funnelOuterLabelMark.line.getDepend());
  }
};
Funnel3dSeries.type = SeriesTypeEnum.funnel3d, Funnel3dSeries.mark = funnel3dSeriesMark, Funnel3dSeries.transformerConstructor = Funnel3dSeriesSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/funnel/3d/funnel-3d
var Funnel3dChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = FunnelChartSpecTransformer, this.type = "funnel3d", this.seriesType = SeriesTypeEnum.funnel3d;
  }
};
Funnel3dChart.type = "funnel3d", Funnel3dChart.seriesType = SeriesTypeEnum.funnel3d, Funnel3dChart.transformerConstructor = FunnelChartSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/polar/polar
var PolarSeries = class extends BaseSeries {
  constructor() {
    super(...arguments), this.coordinate = "polar", this._outerRadius = POLAR_DEFAULT_RADIUS, this._innerRadius = 0, this._angleField = [], this._radiusField = [], this._sortDataByAxis = false;
  }
  get outerRadius() {
    return this._outerRadius;
  }
  get innerRadius() {
    return this._innerRadius;
  }
  getAngleField() {
    return this._angleField;
  }
  setAngleField(f) {
    return this._angleField = isValid_default(f) ? array(f) : [], this._angleField;
  }
  getRadiusField() {
    return this._radiusField;
  }
  setRadiusField(f) {
    return this._radiusField = isValid_default(f) ? array(f) : [], this._radiusField;
  }
  get innerRadiusField() {
    return this._innerRadiusField;
  }
  setInnerRadiusField(f) {
    return this._innerRadiusField = array(f), this._innerRadiusField;
  }
  get radiusScale() {
    return this._radiusScale;
  }
  setRadiusScale(s2) {
    return this._radiusScale = s2, s2;
  }
  get angleScale() {
    return this._angleScale;
  }
  setAngleScale(s2) {
    return this._angleScale = s2, s2;
  }
  get angleAxisHelper() {
    return this._angleAxisHelper;
  }
  set angleAxisHelper(h) {
    this._angleAxisHelper = h, this.onAngleAxisHelperUpdate();
  }
  get radiusAxisHelper() {
    return this._radiusAxisHelper;
  }
  set radiusAxisHelper(h) {
    this._radiusAxisHelper = h, this.onRadiusAxisHelperUpdate();
  }
  get sortDataByAxis() {
    return this._sortDataByAxis;
  }
  _buildMarkAttributeContext() {
    super._buildMarkAttributeContext(), this._markAttributeContext.valueToPosition = this.valueToPosition.bind(this), this._markAttributeContext.getCenter = () => this.angleAxisHelper.center(), this._markAttributeContext.getLayoutRadius = () => this._computeLayoutRadius();
  }
  valueToPosition(angleValue, radiusValue) {
    if (isNil_default(angleValue) || isNil_default(radiusValue) || !this.angleAxisHelper || !this.radiusAxisHelper)
      return {
        x: Number.NaN,
        y: Number.NaN
      };
    const angle2 = this.angleAxisHelper.dataToPosition(array(angleValue)), radius = this.radiusAxisHelper.dataToPosition(array(radiusValue));
    return this.angleAxisHelper.coordToPoint({
      angle: angle2,
      radius
    });
  }
  dataToPosition(datum, checkInViewData) {
    return datum && this.angleAxisHelper && this.radiusAxisHelper ? checkInViewData && !this.isDatumInViewData(datum) ? null : this.valueToPosition(this.getDatumPositionValues(datum, this._angleField), this.getDatumPositionValues(datum, this._radiusField)) : null;
  }
  dataToPositionX(datum) {
    var _a;
    return null === (_a = this.dataToPosition(datum)) || void 0 === _a ? void 0 : _a.x;
  }
  dataToPositionY(datum) {
    var _a;
    return null === (_a = this.dataToPosition(datum)) || void 0 === _a ? void 0 : _a.y;
  }
  dataToPositionZ(datum) {
    return 0;
  }
  positionToData(p) {
  }
  radiusToData(r) {
  }
  angleToData(a3) {
  }
  getStatisticFields() {
    var _a, _b;
    const fields2 = [];
    return (null === (_a = this.radiusAxisHelper) || void 0 === _a ? void 0 : _a.getScale) && this._radiusField.forEach((f) => {
      const result2 = {
        key: f,
        operations: []
      };
      isContinuous(this.radiusAxisHelper.getScale(0).type) ? result2.operations = ["max", "min"] : result2.operations = ["values"], fields2.push(result2);
    }), (null === (_b = this.angleAxisHelper) || void 0 === _b ? void 0 : _b.getScale) && this._angleField.forEach((f) => {
      const result2 = {
        key: f,
        operations: []
      };
      isContinuous(this.angleAxisHelper.getScale(0).type) ? result2.operations = ["max", "min"] : result2.operations = ["values"], fields2.push(result2);
    }), fields2;
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), isValid_default(this._spec.outerRadius) && (this._outerRadius = this._spec.outerRadius), isValid_default(this._spec.radius) && (this._outerRadius = this._spec.radius), isValid_default(this._spec.innerRadius) && (this._innerRadius = this._spec.innerRadius), isValid_default(this._spec.sortDataByAxis) && (this._sortDataByAxis = true === this._spec.sortDataByAxis);
  }
  onRadiusAxisHelperUpdate() {
    this.onMarkPositionUpdate();
  }
  onAngleAxisHelperUpdate() {
    this.onMarkPositionUpdate();
  }
  afterInitMark() {
    super.afterInitMark();
  }
  _computeLayoutRadius() {
    const axisHelper = this._angleAxisHelper || this._radiusAxisHelper;
    if (axisHelper)
      return axisHelper.layoutRadius();
    const { width, height } = this._region.getLayoutRect();
    return Math.min(width / 2, height / 2);
  }
  initEvent() {
    super.initEvent(), this.sortDataByAxis && this.event.on(ChartEvent.scaleDomainUpdate, {
      filter: (param) => {
        var _a;
        return param.model.id === (null === (_a = this._angleAxisHelper) || void 0 === _a ? void 0 : _a.getAxisId());
      }
    }, () => {
      this._sortDataInAxisDomain();
    });
  }
  _sortDataInAxisDomain() {
    var _a, _b;
    (null === (_b = null === (_a = this.getViewData()) || void 0 === _a ? void 0 : _a.latestData) || void 0 === _b ? void 0 : _b.length) && sortDataInAxisHelper(this.angleAxisHelper, this._angleField[0], this.getViewData().latestData);
  }
  getInvalidCheckFields() {
    const fields2 = [];
    return this.angleAxisHelper.isContinuous && this._angleField.forEach((f) => {
      fields2.push(f);
    }), this.radiusAxisHelper.isContinuous && this._radiusField.forEach((f) => {
      fields2.push(f);
    }), fields2;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/polar/progress-like/progress-like
var ProgressLikeSeries = class _ProgressLikeSeries extends PolarSeries {
  constructor() {
    super(...arguments), this._arcGroupMark = null, this._getAngleValueStart = (datum) => {
      const axis2 = this._getAngleAxis(), { tickMask } = this._spec;
      if ((null == tickMask ? void 0 : tickMask.forceAlign) && this._isTickMaskVisible(axis2)) {
        const originValue = datum[this.getStack() ? STACK_FIELD_START : SEGMENT_FIELD_START], subTickData = this._getAngleAxisSubTickData(axis2), step = subTickData[1].value - subTickData[0].value, offsetAngle = degreeToRadian(tickMask.offsetAngle);
        let pos;
        if (isValid_default(originValue)) {
          const index = binaryFuzzySearch(subTickData, (tick) => tick.value - originValue), targetIndex = originValue > subTickData[index].value - step / 2 ? Math.min(index, subTickData.length - 1) : index > 0 ? index - 1 : void 0;
          void 0 !== targetIndex && (pos = this.angleAxisHelper.dataToPosition([subTickData[targetIndex].value - step / 2]));
        }
        return isNil_default(pos) && (pos = this.angleAxisHelper.dataToPosition([subTickData[0].value - step / 2])), pos + offsetAngle;
      }
      return this._getAngleValueStartWithoutMask(datum);
    }, this._getAngleValueEnd = (datum) => {
      const axis2 = this._getAngleAxis(), { tickMask } = this._spec;
      if ((null == tickMask ? void 0 : tickMask.forceAlign) && this._isTickMaskVisible(axis2)) {
        const originValue = datum[this.getStack() ? STACK_FIELD_END : this._angleField[0]], subTickData = this._getAngleAxisSubTickData(axis2), step = subTickData[1].value - subTickData[0].value, offsetAngle = degreeToRadian(tickMask.offsetAngle), index = binaryFuzzySearch(subTickData, (tick) => tick.value - originValue), targetIndex = originValue > subTickData[index].value - step / 2 ? Math.min(index, subTickData.length - 1) : index > 0 ? index - 1 : void 0;
        let pos;
        return pos = void 0 !== targetIndex ? this.angleAxisHelper.dataToPosition([subTickData[targetIndex].value + step / 2]) : this.angleAxisHelper.dataToPosition([subTickData[0].value - step / 2]), pos + offsetAngle;
      }
      return this._getAngleValueEndWithoutMask(datum);
    };
  }
  setAttrFromSpec() {
    var _a, _b, _c;
    super.setAttrFromSpec();
    const chartSpec = null === (_a = this._option.globalInstance.getChart()) || void 0 === _a ? void 0 : _a.getSpec(), startAngle = null !== (_b = this._spec.startAngle) && void 0 !== _b ? _b : null == chartSpec ? void 0 : chartSpec.startAngle;
    this._startAngle = isValid_default(startAngle) ? degreeToRadian(startAngle) : POLAR_START_RADIAN;
    const endAngle = null !== (_c = this._spec.endAngle) && void 0 !== _c ? _c : null == chartSpec ? void 0 : chartSpec.endAngle;
    this._endAngle = isValid_default(endAngle) ? degreeToRadian(endAngle) : POLAR_END_RADIAN, this.setAngleField(this._spec.valueField || this._spec.angleField), this.setRadiusField(this._spec.categoryField || this._spec.radiusField), this._specAngleField = this._angleField.slice(), this._specRadiusField = this._radiusField.slice();
  }
  getStackGroupFields() {
    return this._radiusField;
  }
  getStackValueField() {
    var _a;
    return null === (_a = this._angleField) || void 0 === _a ? void 0 : _a[0];
  }
  getGroupFields() {
    return this._angleField;
  }
  _convertMarkStyle(style) {
    const newStyle = super._convertMarkStyle(style);
    if (newStyle.fill) {
      const value = style.fill;
      "conical" !== (null == value ? void 0 : value.gradient) || isValid_default(null == value ? void 0 : value.startAngle) || isValid_default(null == value ? void 0 : value.endAngle) || (newStyle.fill = Object.assign(Object.assign({}, value), {
        startAngle: this._startAngle,
        endAngle: this._endAngle
      }));
    }
    return newStyle;
  }
  _getAngleValueStartWithoutMask(datum) {
    if (this.getStack()) {
      const value = valueInScaleRange(this.angleAxisHelper.dataToPosition([datum[STACK_FIELD_START]]), this.angleAxisHelper.getScale(0));
      if (isValidNumber_default(value))
        return value;
    }
    return this._startAngle;
  }
  _getAngleValueEndWithoutMask(datum) {
    if (this.getStack()) {
      const value = valueInScaleRange(this.angleAxisHelper.dataToPosition([datum[STACK_FIELD_END]]), this.angleAxisHelper.getScale(0));
      if (isValidNumber_default(value))
        return value;
    }
    return this.angleAxisHelper.dataToPosition([datum[this._angleField[0]]]);
  }
  getDimensionField() {
    return this._specRadiusField;
  }
  getMeasureField() {
    return this._specAngleField;
  }
  initMark() {
    this._initArcGroupMark();
  }
  initMarkStyle() {
    this._initArcGroupMarkStyle();
  }
  _initArcGroupMark() {
    return this._arcGroupMark = this._createMark(_ProgressLikeSeries.mark.group, {
      skipBeforeLayouted: false
    }), this._arcGroupMark;
  }
  _initArcGroupMarkStyle() {
    const groupMark = this._arcGroupMark;
    groupMark.setZIndex(this.layoutZIndex), groupMark.created(), this.setMarkStyle(groupMark, {
      x: 0,
      y: 0
    }, "normal", AttributeLevel.Series), groupMark.setClip(() => {
      const axis2 = this._getAngleAxis();
      if (this._isTickMaskVisible(axis2)) {
        const { tickMask } = this._spec, { angle: angle2, offsetAngle, style = {} } = tickMask, subTickData = this._getAngleAxisSubTickData(axis2), { x, y } = this.angleAxisHelper.center(), radius = this._computeLayoutRadius(), markStyle = style;
        return subTickData.map(({ value }) => {
          const pos = this.angleAxisHelper.dataToPosition([value]) + degreeToRadian(offsetAngle), angleUnit = degreeToRadian(angle2) / 2;
          return createArc(Object.assign(Object.assign({}, markStyle), {
            x,
            y,
            startAngle: pos - angleUnit,
            endAngle: pos + angleUnit,
            innerRadius: radius * this._innerRadius,
            outerRadius: radius * this._outerRadius,
            fill: true
          }));
        });
      }
      const { width, height } = this.getLayoutRect();
      return [createRect({
        width,
        height,
        fill: true
      })];
    }), this._arcGroupMark.setInteractive(false);
  }
  _getAngleAxis() {
    if (!this.angleAxisHelper)
      return;
    const angleAxisId = this.angleAxisHelper.getAxisId();
    return this._option.getChart().getAllComponents().find((component2) => component2.id === angleAxisId);
  }
  _getAngleAxisTickData(angleAxis) {
    var _a;
    return null === (_a = null == angleAxis ? void 0 : angleAxis.getTickData()) || void 0 === _a ? void 0 : _a.getLatestData();
  }
  _isTickMaskVisible(angleAxis) {
    const tickData = this._getAngleAxisTickData(angleAxis), { tickMask } = this._spec;
    return tickMask && false !== tickMask.visible && (null == tickData ? void 0 : tickData.length) > 1;
  }
  _getAngleAxisSubTickData(angleAxis) {
    var _a;
    const tickData = this._getAngleAxisTickData(angleAxis), subTickData = [], { subTick = {}, tick = {} } = null !== (_a = null == angleAxis ? void 0 : angleAxis.getSpec()) && void 0 !== _a ? _a : {}, { tickCount: subTickCount = 4 } = subTick, { alignWithLabel } = tick;
    if ((null == tickData ? void 0 : tickData.length) >= 2) {
      const tickSegment = tickData[1].value - tickData[0].value;
      for (let i = 0; i < tickData.length - 1; i++) {
        const pre = tickData[i], next = tickData[i + 1];
        subTickData.push(pre);
        for (let j = 0; j < subTickCount; j++) {
          const percent = (j + 1) / (subTickCount + 1), value = (1 - percent) * pre.value + percent * (next ? next.value : alignWithLabel ? 1 : pre.value + tickSegment);
          subTickData.push({
            value
          });
        }
      }
      return subTickData.push(tickData[tickData.length - 1]), subTickData;
    }
    return tickData;
  }
};
ProgressLikeSeries.mark = progressLikeSeriesMark;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/mark/path
var PathMark = class _PathMark extends BaseMark {
  constructor() {
    super(...arguments), this.type = _PathMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      lineWidth: 0,
      path: ""
    });
  }
};
PathMark.type = "path";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/gauge/gauge-pointer-transformer
var GaugePointerSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  constructor() {
    super(...arguments), this._supportStack = false;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/axis/polar/util/common
var getPolarAxisInfo = (spec, chartSpec) => {
  var _a, _b, _c, _d, _e, _f;
  const axisType = null !== (_a = spec.type) && void 0 !== _a ? _a : "angle" === spec.orient ? "band" : "linear", componentName = `${ComponentTypeEnum.polarAxis}-${axisType}`, startAngleFromSpec = null !== (_b = spec.startAngle) && void 0 !== _b ? _b : chartSpec.startAngle, endAngleFromSpec = null !== (_c = spec.endAngle) && void 0 !== _c ? _c : chartSpec.endAngle;
  return {
    axisType,
    componentName,
    startAngle: null != startAngleFromSpec ? startAngleFromSpec : POLAR_START_ANGLE2,
    endAngle: null != endAngleFromSpec ? endAngleFromSpec : isValid_default(startAngleFromSpec) ? startAngleFromSpec + 360 : POLAR_END_ANGLE2,
    center: isValid_default(chartSpec.center) ? chartSpec.center : isValid_default(null == chartSpec ? void 0 : chartSpec.centerX) || isValid_default(null == chartSpec ? void 0 : chartSpec.centerY) ? {
      x: null == chartSpec ? void 0 : chartSpec.centerX,
      y: null == chartSpec ? void 0 : chartSpec.centerY
    } : void 0,
    outerRadius: null !== (_f = null !== (_e = null !== (_d = spec.radius) && void 0 !== _d ? _d : chartSpec.outerRadius) && void 0 !== _e ? _e : chartSpec.radius) && void 0 !== _f ? _f : POLAR_DEFAULT_RADIUS,
    layoutRadius: chartSpec.layoutRadius
  };
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/axis/polar/axis
var __rest14 = function(s2, e) {
  var t = {};
  for (var p in s2)
    Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++)
      e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var PolarAxis = class extends AxisComponent {
  get center() {
    return this._center;
  }
  get startAngle() {
    return this._startAngle;
  }
  get endAngle() {
    return this._endAngle;
  }
  getOrient() {
    return this._orient;
  }
  getGroupScales() {
    return this._groupScales;
  }
  static getSpecInfo(chartSpec) {
    const axesSpec = chartSpec[this.specKey];
    if (!axesSpec)
      return null;
    if (!isArray_default(axesSpec)) {
      if (!isValidPolarAxis(axesSpec))
        return null;
      const { axisType, componentName, startAngle, endAngle, center: center2, outerRadius, layoutRadius } = getPolarAxisInfo(axesSpec, chartSpec);
      return axesSpec.center = center2, axesSpec.startAngle = startAngle, axesSpec.endAngle = endAngle, axesSpec.outerRadius = outerRadius, axesSpec.type = axisType, axesSpec.layoutRadius = layoutRadius, [{
        spec: axesSpec,
        specPath: [this.specKey],
        specInfoPath: ["component", this.specKey, 0],
        type: componentName
      }];
    }
    const specInfos = [];
    let angleAxisIndex;
    const radiusAxisSpecInfos = [];
    return axesSpec.forEach((s2, i) => {
      if (!isValidPolarAxis(s2))
        return;
      const { axisType, componentName, startAngle, endAngle, center: center2, outerRadius, layoutRadius } = getPolarAxisInfo(s2, chartSpec);
      s2.center = center2, s2.startAngle = startAngle, s2.endAngle = endAngle, s2.outerRadius = outerRadius, s2.type = axisType, s2.layoutRadius = layoutRadius;
      const info = {
        spec: s2,
        specPath: [this.specKey, i],
        specInfoPath: ["component", this.specKey, i],
        type: componentName
      };
      specInfos.push(info), "radius" === s2.orient ? radiusAxisSpecInfos.push(info) : angleAxisIndex = i;
    }), radiusAxisSpecInfos.forEach((info) => {
      info.angleAxisIndex = angleAxisIndex;
    }), specInfos;
  }
  static createComponent(specInfo, options) {
    const { spec } = specInfo, others = __rest14(specInfo, ["spec"]), C = Factory2.getComponentInKey(others.type);
    return C ? new C(spec, Object.assign(Object.assign({}, options), others)) : (options.onError(`Component ${others.type} not found`), null);
  }
  constructor(spec, options) {
    super(spec, options), this.type = ComponentTypeEnum.polarAxis, this.name = ComponentTypeEnum.polarAxis, this._defaultBandPosition = 0, this._defaultBandInnerPadding = 0, this._defaultBandOuterPadding = 0, this.layoutType = "absolute", this.layoutZIndex = LayoutZIndex.Axis, this._tick = void 0, this._center = null, this._startAngle = POLAR_START_RADIAN, this._endAngle = POLAR_END_RADIAN, this._orient = "radius", this._groupScales = [], this.effect = {
      scaleUpdate: (param) => {
        this.computeData(null == param ? void 0 : param.value), eachSeries(this._regions, (s2) => {
          "radius" === this.getOrient() ? s2.radiusAxisHelper = this.axisHelper() : s2.angleAxisHelper = this.axisHelper();
        }, {
          userId: this._seriesUserId,
          specIndex: this._seriesIndex
        });
      }
    }, this._transformLayoutPosition = (pos) => {
      var _a;
      const region = null === (_a = this.getRegions()) || void 0 === _a ? void 0 : _a[0];
      return region ? region.getLayoutStartPoint() : pos;
    }, this._coordinateType = "polar";
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this.visible && (this._axisStyle = this._getAxisAttributes(), this._gridStyle = this._getGridAttributes()), this._tick = this._spec.tick, this._orient = "angle" === this._spec.orient ? "angle" : "radius", this._center = this._spec.center, this._startAngle = degreeToRadian(this._spec.startAngle), this._endAngle = degreeToRadian(this._spec.endAngle), this._inverse = this._spec.inverse;
  }
  onRender(ctx) {
  }
  changeRegions() {
  }
  _tickTransformOption() {
    var _a;
    return Object.assign(Object.assign({}, super._tickTransformOption()), {
      noDecimal: null === (_a = this._tick) || void 0 === _a ? void 0 : _a.noDecimals,
      startAngle: this.startAngle,
      labelOffset: getAxisLabelOffset(this._spec),
      getRadius: () => this.getOuterRadius(),
      inside: this._spec.inside
    });
  }
  afterCompile() {
    var _a;
    const product = null === (_a = this._axisMark) || void 0 === _a ? void 0 : _a.getProduct();
    product && product.addEventListener(HOOK_EVENT.AFTER_ELEMENT_ENCODE, () => {
      false === this._isLayout && this._delegateAxisContainerEvent(product.getGroupGraphicItem());
    });
  }
  updateScaleRange() {
    const prevRange = this._scale.range();
    let newRange;
    return newRange = "radius" === this.getOrient() ? this._inverse ? [this.computeLayoutOuterRadius(), this.computeLayoutInnerRadius()] : [this.computeLayoutInnerRadius(), this.computeLayoutOuterRadius()] : this._inverse ? [this._endAngle, this._startAngle] : [this._startAngle, this._endAngle], (!prevRange || !newRange || prevRange[0] !== newRange[0] || prevRange[1] !== newRange[1]) && (this._scale.range(newRange), true);
  }
  collectSeriesField(depth, series2) {
    var _a, _b;
    let field3;
    return field3 = depth > 0 ? null === (_b = null === (_a = series2.getGroups()) || void 0 === _a ? void 0 : _a.fields) || void 0 === _b ? void 0 : _b[depth] : "radius" === this.getOrient() ? series2.getRadiusField() : series2.getAngleField(), field3;
  }
  updateSeriesScale() {
    eachSeries(this._regions, (s2) => {
      "radius" === this.getOrient() ? (s2.setRadiusScale(this._scale), s2.radiusAxisHelper = this.axisHelper()) : (s2.setAngleScale(this._scale), s2.angleAxisHelper = this.axisHelper());
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    });
  }
  getSeriesStatisticsField(s2) {
    const f = "radius" === this.getOrient() ? s2.getRadiusField() : s2.getAngleField();
    return isContinuous(this._scale.type) ? f : [f[0]];
  }
  initGroupScales() {
  }
  axisHelper() {
    return {
      isContinuous: isContinuous(this._scale.type),
      dataToPosition: this.dataToPosition.bind(this),
      coordToPoint: this.coordToPoint.bind(this),
      pointToCoord: this.pointToCoord.bind(this),
      center: this.getCenter.bind(this),
      layoutRadius: this.computeLayoutRadius.bind(this),
      getScale: (depth) => this._scales[depth],
      getAxisId: () => this.id,
      getSpec: () => this._spec
    };
  }
  positionToData(position) {
    const coord = this.pointToCoord(position);
    return "radius" === this.getOrient() ? this.invert(coord.radius) : this.invert(coord.angle);
  }
  coordToPoint(point5) {
    const center2 = this.getCenter();
    return polarToCartesian(center2, point5.radius, point5.angle);
  }
  pointToCoord(point5) {
    const { x: centerX, y: centerY } = this.getCenter();
    let dx = point5.x - centerX, dy = point5.y - centerY;
    const startAngle = this._startAngle, endAngle = this._endAngle, radius = Math.sqrt(dx * dx + dy * dy);
    dx /= radius, dy /= radius;
    let radian = Math.atan2(dy, dx);
    if (radian < startAngle)
      for (; radian <= startAngle; )
        radian += 2 * Math.PI;
    if (radian > endAngle)
      for (; radian >= endAngle; )
        radian -= 2 * Math.PI;
    return {
      radius,
      angle: radian
    };
  }
  getCenter() {
    var _a, _b;
    const layoutRect = this.getRefLayoutRect(), { width, height } = layoutRect;
    return {
      x: calcLayoutNumber(null === (_a = this._center) || void 0 === _a ? void 0 : _a.x, width, layoutRect, width / 2),
      y: calcLayoutNumber(null === (_b = this._center) || void 0 === _b ? void 0 : _b.y, height, layoutRect, height / 2)
    };
  }
  getOuterRadius() {
    return this.computeLayoutOuterRadius();
  }
  getInnerRadius() {
    return this.computeLayoutInnerRadius();
  }
  updateLayoutAttribute() {
    this._visible && ("radius" === this.getOrient() ? this._layoutRadiusAxis() : this._layoutAngleAxis()), super.updateLayoutAttribute();
  }
  _getNormalizedValue(values, length2) {
    return 0 === length2 ? 0 : (this.dataToPosition(values) - this._getStartValue()) / length2;
  }
  getLabelItems(length2) {
    var _a;
    const tickLatestData = null === (_a = this.getTickData()) || void 0 === _a ? void 0 : _a.getLatestData();
    return tickLatestData && tickLatestData.length ? [tickLatestData.map((obj) => getAxisItem(obj.value, this._getNormalizedValue([obj.value], length2)))] : [];
  }
  _getStartValue() {
    return "radius" === this.getOrient() ? this.computeLayoutInnerRadius() : this._startAngle;
  }
  _layoutAngleAxis() {
    const center2 = this.getCenter(), radius = this.computeLayoutOuterRadius(), innerRadius = this.computeLayoutInnerRadius(), angleRange = this._endAngle - this._startAngle, items = this.getLabelItems(angleRange), commonAttrs = Object.assign(Object.assign({}, this.getLayoutStartPoint()), {
      inside: this._spec.inside,
      center: center2,
      radius,
      innerRadius,
      startAngle: this._startAngle,
      endAngle: this._endAngle
    }), attrs = Object.assign(Object.assign({}, commonAttrs), {
      title: {
        text: this._spec.title.text || this._dataFieldText
      },
      items,
      orient: "angle"
    });
    this._spec.grid.visible && (attrs.grid = Object.assign({
      type: "line",
      smoothLink: true,
      items: items[0]
    }, commonAttrs)), this._update(attrs);
  }
  _layoutRadiusAxis() {
    var _a, _b, _c;
    const center2 = this.getCenter(), radius = this.computeLayoutOuterRadius(), innerRadius = this.computeLayoutInnerRadius(), endPoint = this.coordToPoint({
      angle: this._startAngle,
      radius
    }), startPoint = this.coordToPoint({
      angle: this._startAngle,
      radius: innerRadius
    }), distance2 = PointService.distancePP(startPoint, endPoint), items = this.getLabelItems(distance2), commonAttrs = Object.assign(Object.assign({}, this.getLayoutStartPoint()), {
      start: startPoint,
      end: endPoint,
      verticalFactor: -1
    }), attrs = Object.assign(Object.assign({}, commonAttrs), {
      title: {
        text: this._spec.title.text || this._dataFieldText
      },
      items,
      orient: "radius"
    });
    (null === (_a = this._spec.grid) || void 0 === _a ? void 0 : _a.visible) && (attrs.grid = Object.assign({
      items: items[0],
      type: (null === (_b = this._spec.grid) || void 0 === _b ? void 0 : _b.smooth) ? "circle" : "polygon",
      center: center2,
      closed: true,
      sides: null === (_c = this._getRelatedAngleAxis()) || void 0 === _c ? void 0 : _c.getScale().domain().length,
      startAngle: this._startAngle,
      endAngle: this._endAngle
    }, commonAttrs)), this._update(attrs);
  }
  _getRelatedAngleAxis() {
    const index = this._option.angleAxisIndex;
    if (isValid_default(index))
      return this._option.getComponentByIndex(this.specKey, index);
  }
  computeLayoutRadius() {
    const layoutRect = this.getRefLayoutRect();
    if (isNumber_default(this._spec.layoutRadius))
      return this._spec.layoutRadius;
    if (isFunction_default(this._spec.layoutRadius))
      return this._spec.layoutRadius(layoutRect, this.getCenter());
    const { width, height } = layoutRect;
    return "auto" === this._spec.layoutRadius && width > 0 && height > 0 ? calculateMaxRadius(layoutRect, this.getCenter(), this._startAngle, this._endAngle) : Math.min(width / 2, height / 2);
  }
  computeLayoutOuterRadius() {
    var _a;
    const radius = null !== (_a = this._spec.outerRadius) && void 0 !== _a ? _a : this._spec.radius, outerRadius = null != radius ? radius : this.getRefSeriesRadius().outerRadius;
    return this.computeLayoutRadius() * outerRadius;
  }
  computeLayoutInnerRadius() {
    var _a;
    const innerRadius = null !== (_a = this._spec.innerRadius) && void 0 !== _a ? _a : this.getRefSeriesRadius().innerRadius;
    return this.computeLayoutRadius() * innerRadius;
  }
  getRefLayoutRect() {
    return this.getRegions()[0].getLayoutRect();
  }
  getRefSeriesRadius() {
    let outerRadius = POLAR_DEFAULT_RADIUS, innerRadius = 0;
    const chartSpec = this.getChart().getSpec();
    return eachSeries(this.getRegions(), (s2) => {
      const series2 = s2;
      if (isPolarAxisSeries(series2.type)) {
        const { outerRadius: seriesRadius = chartSpec.outerRadius, innerRadius: seriesInnerRadius = chartSpec.innerRadius } = series2;
        isValidNumber_default(seriesRadius) && (outerRadius = seriesRadius), isValidNumber_default(seriesInnerRadius) && (innerRadius = seriesInnerRadius);
      }
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    }), {
      outerRadius,
      innerRadius
    };
  }
  _update(attrs) {
    const { grid: gridAttrs } = attrs, axisAttrs = __rest14(attrs, ["grid"]);
    if (this._axisMark.getProduct().encode(mergeSpec({}, this._axisStyle, axisAttrs)), this._gridMark) {
      this._gridMark.getProduct().encode(mergeSpec({}, this._gridStyle, gridAttrs));
    }
  }
  invert(value) {
    var _a;
    if ("angle" === this.getOrient() && "band" === this._scale.type) {
      const range2 = this._scale.range(), rangeValue = range2[range2.length - 1] - range2[0], offset = 0.5 === (null !== (_a = this.getSpec().bandPosition) && void 0 !== _a ? _a : this._defaultBandPosition) ? 0 : this._scale.bandwidth() / 2;
      if (range2[0] < 0) {
        const transformedAngle = (value + offset + Math.abs(range2[0])) % rangeValue - Math.abs(range2[0]);
        return this._scale.invert(transformedAngle);
      }
      return this._scale.invert((value + offset) % rangeValue);
    }
    return this._scale.invert(value);
  }
};
PolarAxis.type = ComponentTypeEnum.polarAxis, PolarAxis.specKey = "axes";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/axis/polar/linear-axis
var PolarLinearAxis = class extends PolarAxis {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.polarLinearAxis, this._zero = true, this._nice = true, this._extend = {}, this._scale = new LinearScale();
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this.setExtraAttrFromSpec();
  }
  initScales() {
    super.initScales(), this.setScaleNice();
  }
  computeDomain(data) {
    return this.computeLinearDomain(data);
  }
  axisHelper() {
    const helper = super.axisHelper();
    return helper.setExtendDomain = this.setExtendDomain.bind(this), helper;
  }
};
PolarLinearAxis.type = ComponentTypeEnum.polarLinearAxis, PolarLinearAxis.specKey = "axes", mixin(PolarLinearAxis, LinearAxisMixin);

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/axis/polar/band-axis
var PolarBandAxis = class extends PolarAxis {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.polarBandAxis, this._scale = new BandScale();
  }
  computeDomain(data) {
    return this.computeBandDomain(data);
  }
  updateScaleRange() {
    const isChanged = super.updateScaleRange();
    return this.updateGroupScaleRange(), isChanged;
  }
  axisHelper() {
    const helper = super.axisHelper();
    return Object.assign(Object.assign({}, helper), {
      getBandwidth: (depth) => helper.getScale(depth).bandwidth()
    });
  }
  initScales() {
    super.initScales(), this.calcScales(this._defaultBandInnerPadding, this._defaultBandOuterPadding);
  }
  transformScaleDomain() {
  }
};
PolarBandAxis.type = ComponentTypeEnum.polarBandAxis, PolarBandAxis.specKey = "axes", mixin(PolarBandAxis, BandAxisMixin);

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/gauge/gauge-pointer
var GaugePointerSeries = class _GaugePointerSeries extends ProgressLikeSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.gaugePointer, this.transformerConstructor = GaugePointerSeriesSpecTransformer, this._pinMark = null, this._pointerMark = null, this._pinBackgroundMark = null;
  }
  setAttrFromSpec() {
    var _a;
    super.setAttrFromSpec(), this.setRadiusField(this._spec.radiusField), this._pointerType = "rect" === (null === (_a = this._spec.pointer) || void 0 === _a ? void 0 : _a.type) ? "rect" : "path";
  }
  initMark() {
    this._pinBackgroundMark = this._createMark(_GaugePointerSeries.mark.pinBackground), this._pointerMark = this._createMark(Object.assign(Object.assign({}, _GaugePointerSeries.mark.pointer), {
      type: this._pointerType
    }), {
      isSeriesMark: true
    }), this._pinMark = this._createMark(_GaugePointerSeries.mark.pin);
  }
  initMarkStyle() {
    this.initPinBackgroundMarkStyle(), this.initPointerMarkStyle(), this.initPinMarkStyle();
  }
  initGroups() {
  }
  initPointerMarkStyle() {
    const pointerMark = this._pointerMark, pointerSpec = this._spec.pointer;
    pointerMark && (this.setMarkStyle(pointerMark, {
      x: (datum) => {
        var _a, _b;
        const { x } = this._getPointerAnchor(datum, pointerSpec);
        return x - this._getPointerWidth() * (null !== (_b = null === (_a = null == pointerSpec ? void 0 : pointerSpec.center) || void 0 === _a ? void 0 : _a[0]) && void 0 !== _b ? _b : 0);
      },
      y: (datum) => {
        var _a, _b;
        const { y } = this._getPointerAnchor(datum, pointerSpec);
        return y - this._getPointerHeight(datum) * (null !== (_b = null === (_a = null == pointerSpec ? void 0 : pointerSpec.center) || void 0 === _a ? void 0 : _a[1]) && void 0 !== _b ? _b : 0);
      },
      anchor: (datum) => {
        const { x, y } = this._getPointerAnchor(datum, pointerSpec);
        return [x, y];
      },
      fill: this.getColorAttribute(),
      zIndex: 200
    }), "path" === this._pointerType ? this.setMarkStyle(pointerMark, {
      scaleX: this._getPointerWidth.bind(this),
      scaleY: this._getPointerHeight.bind(this),
      angle: (datum) => this._getPointerAngle(datum) + Math.PI / 2
    }) : this.setMarkStyle(pointerMark, {
      width: this._getPointerWidth.bind(this),
      height: this._getPointerHeight.bind(this),
      angle: (datum) => this._getPointerAngle(datum) - Math.PI / 2
    }));
  }
  initTooltip() {
    super.initTooltip(), this._pointerMark && this._tooltipHelper.activeTriggerSet.mark.add(this._pointerMark);
  }
  _getPointerAnchor(datum, markSpec) {
    var _a;
    return null === (_a = markSpec.isOnCenter) || void 0 === _a || _a ? this.angleAxisHelper.center() : this.radiusAxisHelper.coordToPoint({
      radius: this._innerRadius * this._computeLayoutRadius(),
      angle: this.angleAxisHelper.dataToPosition([datum[this._angleField[0]]])
    });
  }
  _getPointerWidth() {
    return this._spec.pointer.width * this._computeLayoutRadius();
  }
  _getPointerHeight(datum) {
    var _a, _b;
    const pointerSpec = this._spec.pointer, radiusField = this._radiusField[0];
    return isValid_default(this.radiusAxisHelper) && isValid_default(radiusField) ? this.radiusAxisHelper.dataToPosition([datum[radiusField]]) - (null !== (_a = null == pointerSpec ? void 0 : pointerSpec.innerPadding) && void 0 !== _a ? _a : 0) - (null !== (_b = null == pointerSpec ? void 0 : pointerSpec.outerPadding) && void 0 !== _b ? _b : 10) : pointerSpec.height * this._computeLayoutRadius();
  }
  _getPointerAngle(datum) {
    return this.angleAxisHelper.dataToPosition([datum[this._angleField[0]]]);
  }
  _getRotatedPointerCenterOffset(datum) {
    var _a, _b, _c, _d;
    const pointerSpec = this._spec.pointer, x = this._getPointerWidth() * (null !== (_b = null === (_a = null == pointerSpec ? void 0 : pointerSpec.center) || void 0 === _a ? void 0 : _a[0]) && void 0 !== _b ? _b : 0), y = -this._getPointerHeight(datum) * (null !== (_d = null === (_c = null == pointerSpec ? void 0 : pointerSpec.center) || void 0 === _c ? void 0 : _c[1]) && void 0 !== _d ? _d : 0), angle2 = this._getPointerAngle(datum) - Math.PI / 2, cos3 = Math.cos(angle2), sin3 = Math.sin(angle2);
    return {
      x: x * cos3 + y * sin3,
      y: -(y * cos3 - x * sin3)
    };
  }
  initPinBackgroundMarkStyle() {
    const pinBackgroundMark = this._pinBackgroundMark, pinBackgroundSpec = this._spec.pinBackground;
    pinBackgroundMark && this.setMarkStyle(pinBackgroundMark, {
      x: (datum) => this._getPointerAnchor(datum, pinBackgroundSpec).x,
      y: (datum) => this._getPointerAnchor(datum, pinBackgroundSpec).y,
      scaleX: () => pinBackgroundSpec.width * this._computeLayoutRadius(),
      scaleY: () => pinBackgroundSpec.height * this._computeLayoutRadius(),
      fill: this.getColorAttribute(),
      zIndex: 100
    });
  }
  initPinMarkStyle() {
    const pinMark = this._pinMark, pinSpec = this._spec.pin;
    pinMark && this.setMarkStyle(pinMark, {
      x: (datum) => this._getPointerAnchor(datum, pinSpec).x,
      y: (datum) => this._getPointerAnchor(datum, pinSpec).y,
      scaleX: () => pinSpec.width * this._computeLayoutRadius(),
      scaleY: () => pinSpec.height * this._computeLayoutRadius(),
      fill: this.getColorAttribute(),
      zIndex: 300
    });
  }
  initInteraction() {
    this._parseInteractionConfig(this._pointerMark ? [this._pointerMark] : []);
  }
  initAnimation() {
    var _a, _b, _c;
    const appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
    this._pointerMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("gaugePointer")) || void 0 === _c ? void 0 : _c({
      startAngle: this._startAngle
    }, appearPreset), userAnimationConfig("pointer", this._spec, this._markAttributeContext)));
  }
  getDefaultShapeType() {
    return "circle";
  }
  getActiveMarks() {
    return [];
  }
};
GaugePointerSeries.type = SeriesTypeEnum.gaugePointer, GaugePointerSeries.mark = gaugePointerSeriesMark, GaugePointerSeries.transformerConstructor = GaugePointerSeriesSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/gauge/gauge-transformer
var GaugeSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  constructor() {
    super(...arguments), this._supportStack = false;
  }
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "segment");
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/gauge/gauge
var GaugeSeries = class _GaugeSeries extends ProgressLikeSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.gauge, this.transformerConstructor = GaugeSeriesSpecTransformer, this._segmentMark = null, this._trackMark = null, this._padAngle = 0;
  }
  setAttrFromSpec() {
    var _a;
    super.setAttrFromSpec(), this._padAngle = degreeToRadian(null !== (_a = this._spec.padAngle) && void 0 !== _a ? _a : 0);
  }
  initData() {
    var _a;
    super.initData();
    registerDataSetInstanceTransform(this._option.dataSet, "spiltSegment", (data, op) => {
      const dataCollect = data.slice();
      return dataCollect.sort((a3, b) => a3[this._angleField[0]] - b[this._angleField[0]]), dataCollect.forEach((datum, i) => {
        datum[SEGMENT_FIELD_END] = datum[this._angleField[0]], datum[SEGMENT_FIELD_START] = i > 0 ? dataCollect[i - 1][SEGMENT_FIELD_END] : void 0;
      }), dataCollect;
    }), null === (_a = this.getViewData()) || void 0 === _a || _a.transform({
      type: "spiltSegment"
    }, false);
  }
  initMark() {
    super.initMark(), this._trackMark = this._createMark(_GaugeSeries.mark.track, {
      parent: this._arcGroupMark,
      dataView: false
    }), this._segmentMark = this._createMark(_GaugeSeries.mark.segment, {
      parent: this._arcGroupMark,
      isSeriesMark: true
    });
  }
  initMarkStyle() {
    super.initMarkStyle(), this.initTrackMarkStyle(), this.initSegmentMarkStyle();
  }
  initSegmentMarkStyle() {
    var _a;
    const segmentMark = this._segmentMark;
    segmentMark && this.setMarkStyle(segmentMark, {
      x: () => this.angleAxisHelper.center().x,
      y: () => this.angleAxisHelper.center().y,
      startAngle: this._getAngleValueStart.bind(this),
      endAngle: this._getAngleValueEnd.bind(this),
      innerRadius: () => {
        var _a2;
        return this._computeLayoutRadius() * (null !== (_a2 = this._spec.innerRadius) && void 0 !== _a2 ? _a2 : 0);
      },
      outerRadius: () => {
        var _a2, _b;
        return this._computeLayoutRadius() * (null !== (_b = null !== (_a2 = this._spec.radius) && void 0 !== _a2 ? _a2 : this._spec.outerRadius) && void 0 !== _b ? _b : 1);
      },
      cap: null !== (_a = this._spec.roundCap) && void 0 !== _a && _a,
      boundsMode: "imprecise",
      cornerRadius: this._spec.cornerRadius,
      fill: this.getColorAttribute(),
      zIndex: 200,
      forceShowCap: true
    });
  }
  initTooltip() {
    super.initTooltip(), this._segmentMark && this._tooltipHelper.activeTriggerSet.mark.add(this._segmentMark);
  }
  initTrackMarkStyle() {
    var _a;
    const trackMark = this._trackMark;
    trackMark && this.setMarkStyle(trackMark, {
      x: () => this.angleAxisHelper.center().x,
      y: () => this.angleAxisHelper.center().y,
      startAngle: this._startAngle,
      endAngle: this._endAngle,
      innerRadius: () => {
        var _a2;
        return this._computeLayoutRadius() * (null !== (_a2 = this._spec.innerRadius) && void 0 !== _a2 ? _a2 : 0);
      },
      outerRadius: () => {
        var _a2, _b;
        return this._computeLayoutRadius() * (null !== (_b = null !== (_a2 = this._spec.radius) && void 0 !== _a2 ? _a2 : this._spec.outerRadius) && void 0 !== _b ? _b : 1);
      },
      cap: null !== (_a = this._spec.roundCap) && void 0 !== _a && _a,
      boundsMode: "imprecise",
      cornerRadius: this._spec.cornerRadius,
      zIndex: 100
    });
  }
  _getAngleValueStartWithoutMask(datum) {
    const startAngle = this._getAngleValueStartWithoutPadAngle(datum), endAngle = this._getAngleValueEndWithoutPadAngle(datum);
    return Math.min(startAngle + this._padAngle / 2, (startAngle + endAngle) / 2);
  }
  _getAngleValueEndWithoutMask(datum) {
    const startAngle = this._getAngleValueStartWithoutPadAngle(datum), endAngle = this._getAngleValueEndWithoutPadAngle(datum);
    return Math.max(endAngle - this._padAngle / 2, (startAngle + endAngle) / 2);
  }
  _getAngleValueStartWithoutPadAngle(datum) {
    return isValid_default(datum[SEGMENT_FIELD_START]) ? this.angleAxisHelper.dataToPosition([datum[SEGMENT_FIELD_START]]) : this._startAngle;
  }
  _getAngleValueEndWithoutPadAngle(datum) {
    return this.angleAxisHelper.dataToPosition([datum[SEGMENT_FIELD_END]]);
  }
  initAnimation() {
    var _a, _b, _c;
    const appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
    this._segmentMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("circularProgress")) || void 0 === _c ? void 0 : _c({
      startAngle: this._startAngle
    }, appearPreset), userAnimationConfig("segment", this._spec, this._markAttributeContext)));
  }
  getDefaultShapeType() {
    return "circle";
  }
  getActiveMarks() {
    return [];
  }
};
GaugeSeries.type = SeriesTypeEnum.gauge, GaugeSeries.mark = gaugeSeriesMark, GaugeSeries.transformerConstructor = GaugeSeriesSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/polar/polar-transformer
var PolarChartSpecTransformer = class extends BaseChartSpecTransformer {
  _isValidSeries(type) {
    return !this.seriesType || type === this.seriesType;
  }
  getIndicatorSpec(spec) {
    var _a, _b, _c;
    const indicatorSpec = array(spec.indicator), limitRatio = null !== (_a = spec.innerRadius) && void 0 !== _a ? _a : null === (_c = null === (_b = spec.series) || void 0 === _b ? void 0 : _b[0]) || void 0 === _c ? void 0 : _c.innerRadius;
    return isValid_default(limitRatio) && indicatorSpec.forEach((indicator2) => {
      isNil_default(indicator2.limitRatio) && (indicator2.limitRatio = limitRatio);
    }), indicatorSpec;
  }
  _getDefaultSeriesSpec(spec) {
    const series2 = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      radius: spec.radius,
      outerRadius: spec.outerRadius,
      innerRadius: spec.innerRadius,
      startAngle: spec.startAngle,
      endAngle: spec.endAngle,
      sortDataByAxis: spec.sortDataByAxis
    }), seriesType = this.seriesType;
    return seriesType && (series2.type = seriesType, series2[seriesType] = spec[seriesType]), series2;
  }
  transformSpec(spec) {
    super.transformSpec(spec), isArray_default(spec.dataZoom) && spec.dataZoom.length > 0 && spec.dataZoom.forEach((zoom) => {
      "axis" === zoom.filterMode && (zoom.filterMode = "filter");
    }), this.transformSeriesSpec(spec), isValid_default(spec.indicator) && (spec.indicator = this.getIndicatorSpec(spec));
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/polar/progress-like/progress-like-transformer
var ProgressLikeChartSpecTransformer = class extends PolarChartSpecTransformer {
  needAxes() {
    return false;
  }
  _getDefaultSeriesSpec(spec) {
    return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      seriesField: spec.seriesField,
      categoryField: spec.categoryField || spec.radiusField,
      valueField: spec.valueField || spec.angleField,
      startAngle: spec.startAngle,
      endAngle: spec.endAngle,
      radius: spec.radius,
      innerRadius: spec.innerRadius,
      centerX: spec.centerX,
      centerY: spec.centerY
    });
  }
  _transformProgressAxisSpec(spec, angleAxisDefaultSpec, radiusAxisDefaultSpec, angleAxisAppendSpec, radiusAxisAppendSpec) {
    var _a, _b;
    spec.axes || (spec.axes = []);
    let radiusAxis = (null !== (_a = spec.axes) && void 0 !== _a ? _a : []).find((axis2) => "radius" === axis2.orient), angleAxis = (null !== (_b = spec.axes) && void 0 !== _b ? _b : []).find((axis2) => "angle" === axis2.orient);
    angleAxis || (angleAxis = angleAxisDefaultSpec, spec.axes.push(angleAxis)), radiusAxis || (radiusAxis = radiusAxisDefaultSpec, spec.axes.push(radiusAxis)), isNil_default(angleAxis.type) && (angleAxis.type = "linear"), isNil_default(radiusAxis.type) && (radiusAxis.type = "band");
    const domain = getLinearAxisSpecDomain(angleAxis, {
      min: 0,
      max: 1
    });
    isNil_default(angleAxis.min) && (angleAxis.min = domain.min), isNil_default(angleAxis.max) && (angleAxis.max = domain.max), angleAxisAppendSpec && Object.assign(angleAxis, mergeSpec({}, angleAxisAppendSpec, angleAxis)), radiusAxisAppendSpec && Object.assign(radiusAxis, mergeSpec({}, radiusAxisAppendSpec, radiusAxis));
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/polar/rose-like/rose-like-transformer
var RoseLikeChartSpecTransformer = class extends PolarChartSpecTransformer {
  needAxes() {
    return true;
  }
  _getDefaultSeriesSpec(spec) {
    return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      categoryField: spec.categoryField || spec.angleField,
      valueField: spec.valueField || spec.radiusField
    });
  }
  transformSpec(spec) {
    var _a;
    if (super.transformSpec(spec), this.needAxes()) {
      spec.axes || (spec.axes = []);
      const haxAxes = {
        radius: false,
        angle: false
      };
      (null !== (_a = spec.axes) && void 0 !== _a ? _a : []).forEach((axis2) => {
        const { orient } = axis2;
        "radius" === orient && (haxAxes.radius = true), "angle" === orient && (haxAxes.angle = true);
      }), haxAxes.angle || spec.axes.push({
        orient: "angle"
      }), haxAxes.radius || spec.axes.push({
        orient: "radius"
      });
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/gauge/gauge-transformer
var GaugeChartSpecTransformer = class extends ProgressLikeChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    const series2 = super._getDefaultSeriesSpec(spec);
    return Object.assign(Object.assign({}, series2), {
      radiusField: spec.radiusField,
      pin: spec.pin,
      pinBackground: spec.pinBackground,
      pointer: spec.pointer
    });
  }
  _getDefaultCircularProgressSeriesSpec(spec) {
    return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      type: SeriesTypeEnum.circularProgress
    });
  }
  transformSpec(spec) {
    var _a, _b, _c, _d, _e;
    super.transformSpec(spec);
    let backgroundSeries = null === (_a = spec.series) || void 0 === _a ? void 0 : _a.find((series2) => series2.type === SeriesTypeEnum.gauge || series2.type === SeriesTypeEnum.circularProgress);
    isNil_default(backgroundSeries) && (backgroundSeries = null !== (_b = spec.gauge) && void 0 !== _b ? _b : this._getDefaultCircularProgressSeriesSpec(spec), "circularProgress" === backgroundSeries.type && (isNil_default(backgroundSeries.radiusField) && isNil_default(backgroundSeries.categoryField) && (backgroundSeries.radiusField = null !== (_d = null !== (_c = spec.radiusField) && void 0 !== _c ? _c : spec.categoryField) && void 0 !== _d ? _d : spec.seriesField), isNil_default(backgroundSeries.valueField) && isNil_default(backgroundSeries.angleField) && (backgroundSeries.valueField = null !== (_e = spec.valueField) && void 0 !== _e ? _e : spec.angleField)), 1 === spec.series.length ? spec.series.push(backgroundSeries) : spec.series.forEach((s2) => {
      s2.type === backgroundSeries.type && Object.keys(backgroundSeries).forEach((k2) => {
        k2 in s2 || (s2[k2] = backgroundSeries[k2]);
      });
    })), backgroundSeries.type === SeriesTypeEnum.circularProgress ? this._transformProgressAxisSpec(spec, {
      orient: "angle",
      visible: true,
      domainLine: {
        visible: false
      },
      grid: {
        visible: false
      }
    }, {
      orient: "radius",
      visible: false
    }, {
      zIndex: LayoutZIndex.Region + 50
    }) : this._transformGaugeAxisSpec(spec);
  }
  _transformGaugeAxisSpec(spec) {
    var _a;
    spec.axes || (spec.axes = []);
    const axesPtr = {
      radius: null,
      angle: null
    };
    (null !== (_a = spec.axes) && void 0 !== _a ? _a : []).forEach((axis2) => {
      const { orient } = axis2;
      "radius" === orient && (axesPtr.radius = axis2), "angle" === orient && (axesPtr.angle = axis2);
    }), axesPtr.angle || (axesPtr.angle = {
      orient: "angle",
      visible: true
    }, spec.axes.push(axesPtr.angle)), axesPtr.radius || (axesPtr.radius = {
      orient: "radius",
      visible: false
    }, spec.axes.push(axesPtr.radius)), isNil_default(axesPtr.angle.type) && (axesPtr.angle.type = "linear"), isNil_default(axesPtr.radius.type) && (axesPtr.radius.type = "linear"), isNil_default(axesPtr.angle.zIndex) && (axesPtr.angle.zIndex = LayoutZIndex.Region + 50);
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/gauge/gauge
var GaugeChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = GaugeChartSpecTransformer, this.type = "gauge", this.seriesType = SeriesTypeEnum.gaugePointer;
  }
};
GaugeChart.type = "gauge", GaugeChart.seriesType = SeriesTypeEnum.gaugePointer, GaugeChart.transformerConstructor = GaugeChartSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/mark/cell
var CellMark = class _CellMark extends BaseSymbolMark {
  constructor() {
    super(...arguments), this.type = _CellMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      padding: 0
    });
  }
};
CellMark.type = "cell";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/heatmap/tooltip-helper
var HeatmapSeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  getDefaultTooltipPattern(activeType, dimensionInfo) {
    const pattern = super.getDefaultTooltipPattern(activeType, dimensionInfo);
    return isValid_default(pattern) && "dimension" === activeType && (pattern.visible = false), pattern;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/heatmap/heatmap-transformer
var HeatmapSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "cell");
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/heatmap/heatmap
var HeatmapSeries = class _HeatmapSeries extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.heatmap, this.transformerConstructor = HeatmapSeriesSpecTransformer;
  }
  getFieldValue() {
    return this._fieldValue;
  }
  setFieldValue(f) {
    this._fieldValue = array(f);
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this.setFieldValue(this._spec.valueField);
  }
  initMark() {
    var _a, _b, _c, _d;
    const progressive = {
      progressiveStep: this._spec.progressiveStep,
      progressiveThreshold: this._spec.progressiveThreshold,
      large: this._spec.large,
      largeThreshold: this._spec.largeThreshold
    };
    this._cellMark = this._createMark(_HeatmapSeries.mark.cell, {
      morph: shouldMarkDoMorph(this._spec, _HeatmapSeries.mark.cell.name),
      defaultMorphElementKey: this.getDimensionField()[0],
      isSeriesMark: true,
      progressive,
      customShape: null === (_a = this._spec.cell) || void 0 === _a ? void 0 : _a.customShape,
      stateSort: null === (_b = this._spec.cell) || void 0 === _b ? void 0 : _b.stateSort
    }), this._backgroundMark = this._createMark(_HeatmapSeries.mark.cellBackground, {
      progressive,
      customShape: null === (_c = this._spec.cellBackground) || void 0 === _c ? void 0 : _c.customShape,
      stateSort: null === (_d = this._spec.cellBackground) || void 0 === _d ? void 0 : _d.stateSort
    });
  }
  initMarkStyle() {
    this.initCellMarkStyle(), this.initCellBackgroundMarkStyle();
  }
  initLabelMarkStyle(textMark) {
    textMark && this.setMarkStyle(textMark, {
      fill: this.getColorAttribute(),
      text: (datum) => datum[this.getMeasureField()[0]]
    });
  }
  initCellMarkStyle() {
    this.setMarkStyle(this._cellMark, {
      x: (datum) => this.dataToPositionX(datum),
      y: (datum) => this.dataToPositionY(datum),
      size: () => [this.getCellSize(this._xAxisHelper), this.getCellSize(this._yAxisHelper)],
      fill: this.getColorAttribute()
    }, "normal", AttributeLevel.Series);
  }
  initCellBackgroundMarkStyle() {
    var _a, _b, _c;
    const padding = normalizePadding(null !== (_c = null === (_b = null === (_a = this._spec.cellBackground) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.padding) && void 0 !== _c ? _c : 0);
    this.setMarkStyle(this._backgroundMark, {
      x: (datum) => {
        const width = this.getCellSize(this._xAxisHelper);
        return this.dataToPositionX(datum) - width / 2 + padding[3];
      },
      y: (datum) => {
        const height = this.getCellSize(this._yAxisHelper);
        return this.dataToPositionY(datum) - height / 2 + padding[0];
      },
      width: () => this.getCellSize(this._xAxisHelper) - padding[1] - padding[3],
      height: () => this.getCellSize(this._yAxisHelper) - padding[0] - padding[2]
    }, "normal", AttributeLevel.Series);
  }
  getColorAttribute() {
    var _a;
    return {
      scale: null !== (_a = this._option.globalScale.getScale("color")) && void 0 !== _a ? _a : this._getDefaultColorScale(),
      field: this.getFieldValue[0]
    };
  }
  initInteraction() {
    this._parseInteractionConfig(this._cellMark ? [this._cellMark] : []);
  }
  initAnimation() {
    var _a, _b, _c;
    const appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset, animationParams = getGroupAnimationParams(this);
    this._cellMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("heatmap")) || void 0 === _c ? void 0 : _c(appearPreset), userAnimationConfig("cell", this._spec, this._markAttributeContext), animationParams));
  }
  getCellSize(axisHelper) {
    var _a, _b;
    return null !== (_b = null === (_a = axisHelper.getBandwidth) || void 0 === _a ? void 0 : _a.call(axisHelper, 0)) && void 0 !== _b ? _b : 6;
  }
  initTooltip() {
    this._tooltipHelper = new HeatmapSeriesTooltipHelper(this), this._cellMark && this._tooltipHelper.activeTriggerSet.mark.add(this._cellMark);
  }
  getDefaultShapeType() {
    return "square";
  }
  getDimensionField() {
    return [].concat(this.fieldX, this.fieldY);
  }
  getMeasureField() {
    return this.getFieldValue();
  }
  getActiveMarks() {
    return [this._cellMark];
  }
};
HeatmapSeries.type = SeriesTypeEnum.heatmap, HeatmapSeries.mark = heatmapSeriesMark, HeatmapSeries.transformerConstructor = HeatmapSeriesSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/heatmap/heatmap-transformer
var HeatmapChartSpecTransformer = class extends CartesianChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    const series2 = super._getDefaultSeriesSpec(spec);
    return Object.assign(Object.assign({}, series2), {
      valueField: spec.valueField,
      cell: spec.cell
    });
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/heatmap/heatmap
var HeatmapChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = HeatmapChartSpecTransformer, this.type = "heatmap", this.seriesType = SeriesTypeEnum.heatmap;
  }
};
HeatmapChart.type = "heatmap", HeatmapChart.seriesType = SeriesTypeEnum.heatmap, HeatmapChart.transformerConstructor = HeatmapChartSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/histogram/base/histogram-base-transformer
var BaseHistogramChartSpecTransformer = class extends CartesianChartSpecTransformer {
  transformSpec(spec) {
    super.transformSpec(spec), spec.axes.forEach((axis2) => axis2.type = "linear");
  }
  _getDefaultSeriesSpec(spec) {
    return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      x2Field: null == spec ? void 0 : spec.x2Field,
      y2Field: null == spec ? void 0 : spec.y2Field,
      barMinHeight: null == spec ? void 0 : spec.barMinHeight,
      barBackground: null == spec ? void 0 : spec.barBackground
    });
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/histogram/base/base
var BaseHistogramChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = BaseHistogramChartSpecTransformer, this._canStack = true;
  }
};
BaseHistogramChart.transformerConstructor = BaseHistogramChartSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/histogram/histogram-transformer
var HistogramChartSpecTransformer = class extends BaseHistogramChartSpecTransformer {
  transformSpec(spec) {
    super.transformSpec(spec), setDefaultCrosshairForCartesianChart(spec);
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/histogram/histogram
var HistogramChart = class extends BaseHistogramChart {
  constructor() {
    super(...arguments), this.transformerConstructor = HistogramChartSpecTransformer, this.type = "histogram", this.seriesType = SeriesTypeEnum.bar;
  }
};
HistogramChart.type = "histogram", HistogramChart.seriesType = SeriesTypeEnum.bar, HistogramChart.transformerConstructor = HistogramChartSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/histogram/3d/histogram-3d
var Histogram3dChart = class extends BaseHistogramChart {
  constructor() {
    super(...arguments), this.transformerConstructor = HistogramChartSpecTransformer, this.type = "histogram3d", this.seriesType = SeriesTypeEnum.bar3d;
  }
};
Histogram3dChart.type = "histogram3d", Histogram3dChart.seriesType = SeriesTypeEnum.bar3d, Histogram3dChart.transformerConstructor = HistogramChartSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/line/line
var LineSeries = class extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.line, this.transformerConstructor = LineLikeSeriesSpecTransformer, this._sortDataByAxis = false;
  }
  compile() {
    super.compile(), this.addSamplingCompile(), this.addOverlapCompile();
  }
  initMark() {
    var _a;
    const progressive = {
      progressiveStep: this._spec.progressiveStep,
      progressiveThreshold: this._spec.progressiveThreshold,
      large: this._spec.large,
      largeThreshold: this._spec.largeThreshold
    }, seriesMark = null !== (_a = this._spec.seriesMark) && void 0 !== _a ? _a : "line";
    this.initLineMark(progressive, "line" === seriesMark), this.initSymbolMark(progressive, "point" === seriesMark);
  }
  initTooltip() {
    super.initTooltip();
    const { dimension, group, mark } = this._tooltipHelper.activeTriggerSet;
    this._lineMark && (dimension.add(this._lineMark), group.add(this._lineMark)), this._symbolMark && (mark.add(this._symbolMark), group.add(this._symbolMark));
  }
  initMarkStyle() {
    this.initLineMarkStyle(this._direction), this.initSymbolMarkStyle();
  }
  initAnimation() {
    var _a, _b, _c, _d;
    const lineAnimationParams = {
      direction: this.direction
    }, appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
    if (this._lineMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("line")) || void 0 === _c ? void 0 : _c(lineAnimationParams, appearPreset), userAnimationConfig("line", this._spec, this._markAttributeContext))), this._symbolMark) {
      const animationParams = getGroupAnimationParams(this);
      this._symbolMark.setAnimationConfig(animationConfig(null === (_d = Factory2.getAnimationInKey("scaleInOut")) || void 0 === _d ? void 0 : _d(), userAnimationConfig("point", this._spec, this._markAttributeContext), animationParams));
    }
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx), this.reCompileSampling();
  }
  getSeriesStyle(datum) {
    var _a;
    const isLineAsSeriesMark = "point" !== (null === (_a = this._spec) || void 0 === _a ? void 0 : _a.seriesMark);
    return (attribute) => {
      var _a2, _b;
      return isLineAsSeriesMark && "fill" === attribute && (attribute = "stroke"), null !== (_b = null === (_a2 = this._seriesMark) || void 0 === _a2 ? void 0 : _a2.getAttribute(attribute, datum)) && void 0 !== _b ? _b : void 0;
    };
  }
  getDefaultShapeType() {
    return "circle";
  }
  getActiveMarks() {
    return [this._lineMark, this._symbolMark];
  }
};
LineSeries.type = SeriesTypeEnum.line, LineSeries.mark = lineSeriesMark, LineSeries.transformerConstructor = LineLikeSeriesSpecTransformer, mixin(LineSeries, LineLikeSeriesMixin);
var registerLineSeries = () => {
  registerSampleTransform(), registerMarkOverlapTransform(), registerLineMark(), registerSymbolMark(), registerLineAnimation(), registerScaleInOutAnimation(), registerCartesianBandAxis(), registerCartesianLinearAxis(), Factory2.registerSeries(LineSeries.type, LineSeries);
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/line/line-transformer
var LineChartSpecTransformer = class extends CartesianChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    var _a;
    return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      point: spec.point,
      line: spec.line,
      seriesMark: null !== (_a = spec.seriesMark) && void 0 !== _a ? _a : "line",
      activePoint: spec.activePoint,
      sampling: spec.sampling,
      samplingFactor: spec.samplingFactor,
      pointDis: spec.pointDis,
      pointDisMul: spec.pointDisMul,
      markOverlap: spec.markOverlap,
      lineLabel: spec.lineLabel
    });
  }
  transformSpec(spec) {
    super.transformSpec(spec), setDefaultCrosshairForCartesianChart(spec);
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/line/line
var LineChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = LineChartSpecTransformer, this.type = "line", this.seriesType = SeriesTypeEnum.line, this._canStack = true;
  }
};
LineChart.type = "line", LineChart.seriesType = SeriesTypeEnum.line, LineChart.transformerConstructor = LineChartSpecTransformer;
var registerLineChart = () => {
  registerLineSeries(), Factory2.registerChart(LineChart.type, LineChart);
};

// http-url:https://unpkg.com/@visactor/vgrammar-projection@0.13.8/es/projections
var defaultPath = path_default();
var projections = {};
var projectionProperties = ["clipAngle", "clipExtent", "scale", "translate", "center", "rotate", "precision", "reflectX", "reflectY", "parallels", "coefficient", "distance", "fraction", "lobes", "parallel", "radius", "ratio", "spacing", "tilt"];
function create(type, constructor) {
  return function projectionGenerator() {
    const p = constructor();
    return p.type = type, p.path = path_default().projection(p), p.copy = p.copy || function() {
      const c3 = projectionGenerator();
      return projectionProperties.forEach((prop) => {
        p[prop] && c3[prop](p[prop]());
      }), c3.path.pointRadius(p.path.pointRadius()), c3;
    }, p;
  };
}
function projection2(type, proj) {
  type && isString_default(type) || error2("Projection type must be a name string.");
  const projectionType = type.toLowerCase();
  return arguments.length > 1 && (projections[projectionType] = create(projectionType, proj)), projections[projectionType] || null;
}
var builtInProjections = {
  albers: albers_default,
  albersusa: albersUsa_default,
  azimuthalequalarea: azimuthalEqualArea_default,
  azimuthalequidistant: azimuthalEquidistant_default,
  conicconformal: conicConformal_default,
  conicequalarea: conicEqualArea_default,
  conicequidistant: conicEquidistant_default,
  equalEarth: equalEarth_default,
  equirectangular: equirectangular_default,
  gnomonic: gnomonic_default,
  identity: identity_default3,
  mercator: mercator_default,
  naturalEarth1: naturalEarth1_default,
  orthographic: orthographic_default,
  stereographic: stereographic_default,
  transversemercator: transverseMercator_default
};
Object.keys(builtInProjections).forEach((projectionType) => {
  projection2(projectionType, builtInProjections[projectionType]);
});

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/data/transforms/lookup
var lookup = (data, opt) => {
  if (!opt.from || !opt.from())
    return data;
  const fields2 = opt.fields, key = opt.key, values = opt.values, defaultValue = opt.default, as = opt.as || [fields2], index = opt.from().reduce(function(map4, obj) {
    return obj[fields2] && map4.set(obj[fields2], obj), map4;
  }, /* @__PURE__ */ new Map());
  let set;
  if (isFunction_default(opt.set))
    set = function(d) {
      const v = index.get(d[key]);
      opt.set(d, v);
    };
  else if (values) {
    const m4 = values.length;
    set = function(d) {
      const v = index.get(d[key]);
      if (isNil_default(v))
        for (let i = 0; i < m4; ++i)
          d[as[i]] = defaultValue;
      else
        for (let i = 0; i < m4; ++i)
          d[as[i]] = v[values[i]];
    };
  } else
    set = function(d) {
      const v = index.get(d[key]);
      d[as[0]] = isValid_default(v) ? v : defaultValue;
    };
  return 0 === data.length ? [] : data.map((d) => (set(d), d));
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/geo/geo
var GeoSeries = class extends BaseSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.geo, this.coordinate = "geo", this._nameProperty = "name";
  }
  getMapViewData() {
    var _a;
    return null === (_a = this._mapViewData) || void 0 === _a ? void 0 : _a.getDataView();
  }
  get nameField() {
    return this._nameField;
  }
  set nameField(f) {
    this._nameField = f;
  }
  get valueField() {
    return this._valueField;
  }
  set valueField(f) {
    this._valueField = f;
  }
  getNameProperty() {
    return this._nameProperty;
  }
  getCentroidProperty() {
    return this._centroidProperty;
  }
  getCoordinateHelper() {
    return this._coordinateHelper;
  }
  setCoordinateHelper(h) {
    this._coordinateHelper = h;
  }
  getStatisticFields() {
    const fields2 = [];
    return fields2.push({
      key: this._nameField,
      operations: ["values"]
    }), fields2.push({
      key: this._valueField,
      operations: ["max", "min"]
    }), fields2;
  }
  getGroupFields() {
    return null;
  }
  dataToPosition(datum, checkInViewData) {
    var _a;
    let result2 = null;
    if (!datum)
      return result2;
    if (checkInViewData && !this.isDatumInViewData(datum))
      return result2;
    const { dataToPosition, latitudeField, longitudeField } = this._coordinateHelper;
    if (result2 = this.nameToPosition(datum), null === result2) {
      const lonValue = longitudeField ? null == datum ? void 0 : datum[longitudeField] : Number.NaN, latValue = latitudeField ? null == datum ? void 0 : datum[latitudeField] : Number.NaN;
      result2 = null !== (_a = null == dataToPosition ? void 0 : dataToPosition([lonValue, latValue])) && void 0 !== _a ? _a : null;
    }
    return result2;
  }
  nameToPosition(datum) {
    const name = this.getDatumName(datum);
    return isNil_default(name) ? null : this.nameValueToPosition(name);
  }
  nameValueToPosition(name) {
    var _a, _b;
    const mapData = null === (_b = null === (_a = this.getMapViewData()) || void 0 === _a ? void 0 : _a.latestData) || void 0 === _b ? void 0 : _b.filter((data) => this.getDatumName(data) === name)[0];
    if (isNil_default(mapData))
      return null;
    const { dataToPosition } = this._coordinateHelper, center2 = this.getDatumCenter(mapData), pos = null == dataToPosition ? void 0 : dataToPosition(center2);
    return isNil_default(pos) || isNaN(pos.x) || isNaN(pos.y) ? null : pos;
  }
  dataToLatitude(latValue) {
    if (!this._coordinateHelper)
      return Number.NaN;
    const { dataToLatitude } = this._coordinateHelper;
    return dataToLatitude(latValue);
  }
  dataToLongitude(lonValue) {
    if (!this._coordinateHelper)
      return Number.NaN;
    const { dataToLatitude } = this._coordinateHelper;
    return dataToLatitude(lonValue);
  }
  valueToPosition(lonValue, latValue) {
    return {
      x: this.dataToLongitude(lonValue),
      y: this.dataToLatitude(latValue)
    };
  }
  positionToData(p) {
  }
  latitudeToData(lat) {
  }
  longitudeToData(lon) {
  }
  dataToPositionX(data) {
    var _a;
    return null === (_a = this._option) || void 0 === _a || _a.onError("Method not implemented."), 0;
  }
  dataToPositionY(data) {
    var _a;
    return null === (_a = this._option) || void 0 === _a || _a.onError("Method not implemented."), 0;
  }
  dataToPositionZ(data) {
    var _a;
    return null === (_a = this._option) || void 0 === _a || _a.onError("Method not implemented."), 0;
  }
  release() {
    super.release(), this._mapViewData.release(), this._mapViewData = this._mapViewDataStatistics = null;
  }
  getStackGroupFields() {
    return [this._nameField];
  }
  getStackValueField() {
    return this._spec.valueField;
  }
  compileData() {
    var _a;
    null === (_a = this._mapViewData) || void 0 === _a || _a.compile();
  }
  initStatisticalData() {
    if (super.initStatisticalData(), this._mapViewData) {
      const viewDataName = `${PREFIX}_series_${this.id}_mapViewDataStatic`;
      this._mapViewDataStatistics = this.createStatisticalData(viewDataName, this._mapViewData.getDataView()), this._mapViewData.getDataView().target.removeListener("change", this._mapViewDataStatistics.reRunAllTransform);
    }
  }
  getSeriesKeys() {
    var _a, _b, _c, _d, _e;
    return this._seriesField ? null !== (_e = null !== (_b = null === (_a = this.getRawDataStatisticsByField(this._seriesField)) || void 0 === _a ? void 0 : _a.values) && void 0 !== _b ? _b : null === (_d = null === (_c = this._mapViewDataStatistics) || void 0 === _c ? void 0 : _c.latestData[this._seriesField]) || void 0 === _d ? void 0 : _d.values) && void 0 !== _e ? _e : [] : this.name ? [this.name] : this.userId ? [`${this.userId}`] : [`${this.type}_${this.id}`];
  }
  fillData() {
    var _a, _b;
    super.fillData(), null === (_a = this._mapViewData.getDataView()) || void 0 === _a || _a.reRunAllTransform(), null === (_b = this._mapViewDataStatistics) || void 0 === _b || _b.reRunAllTransform();
  }
  getActiveMarks() {
    return [];
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/data/transforms/map
var DEFAULT_MAP_LOOK_UP_KEY = `${PREFIX}_MAP_LOOK_UP_KEY`;
var map3 = (data, opt) => (data.features && data.features.forEach((f, index) => {
  var _a;
  f[DEFAULT_DATA_INDEX] = index;
  const name = null === (_a = f.properties) || void 0 === _a ? void 0 : _a[opt.nameProperty];
  opt.nameMap && opt.nameMap[name] ? f[DEFAULT_MAP_LOOK_UP_KEY] = opt.nameMap[name] : f[DEFAULT_MAP_LOOK_UP_KEY] = name;
}), data.features);

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/map/tooltip-helper
var MapSeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  constructor() {
    super(...arguments), this.dimensionTooltipTitleCallback = (datum) => {
      var _a;
      const series2 = this.series;
      return null !== (_a = this._getDimensionData(datum)) && void 0 !== _a ? _a : series2.getDatumName(datum);
    };
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/geo/projection
var Projection = class {
  constructor(projectionSpec) {
    this.projection = projection2(projectionSpec.type)();
  }
  fit(start, size, features) {
    const fitData = {
      type: "FeatureCollection",
      features
    };
    this.projection.fitExtent([start, size], fitData);
  }
  center(center2) {
    var _a, _b;
    null === (_b = null === (_a = this.projection) || void 0 === _a ? void 0 : _a.center) || void 0 === _b || _b.call(_a, center2);
  }
  project(point5) {
    var _a;
    return null === (_a = this.projection) || void 0 === _a ? void 0 : _a.call(this, point5);
  }
  shape(data) {
    var _a, _b;
    return null === (_b = null === (_a = this.projection) || void 0 === _a ? void 0 : _a.path) || void 0 === _b ? void 0 : _b.call(_a, data);
  }
  invert(point5) {
    var _a, _b;
    return null === (_b = null === (_a = this.projection) || void 0 === _a ? void 0 : _a.invert) || void 0 === _b ? void 0 : _b.call(_a, point5);
  }
  scale(scale4) {
    var _a;
    if (null === (_a = this.projection) || void 0 === _a ? void 0 : _a.scale) {
      if (void 0 === scale4)
        return this.projection.scale();
      this.projection.scale(scale4);
    }
  }
  translate(point5) {
    var _a;
    if (null === (_a = this.projection) || void 0 === _a ? void 0 : _a.scale) {
      if (void 0 === point5)
        return this.projection.translate();
      this.projection.translate(point5);
    }
  }
  evaluate(start, size, features) {
    const tmp = this.projection.copy();
    return null == tmp ? void 0 : tmp.fitExtent([start, size], {
      type: "FeatureCollection",
      features
    });
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/interaction/zoom/zoomable
var delayMap4 = {
  debounce: debounce_default,
  throttle: throttle_default
};
var Zoomable = class {
  constructor() {
    this._isGestureListener = false;
  }
  initZoomable(evt, mode = RenderModeEnum["desktop-browser"]) {
    this._eventObj = evt, this._renderMode = mode, this._gestureController = this._option.getChart().getVGrammarView().renderer._gestureController, this._isGestureListener = isMobileLikeMode(this._renderMode) || isMiniAppLikeMode(this._renderMode), getDefaultTriggerEventByMode(this._renderMode) && (this._clickEnable = true, this._zoomableTrigger = new (this._getZoomTriggerEvent("trigger"))());
  }
  _getZoomTriggerEvent(type) {
    return getDefaultTriggerEventByMode(this._renderMode)[type];
  }
  _zoomEventDispatch(params2, regionOrSeries, callback) {
    if (!this._isGestureListener && !params2.event)
      return;
    const event = this._isGestureListener ? params2 : params2.event.clone();
    this._zoomableTrigger.parserZoomEvent(event);
    const { zoomDelta, zoomX, zoomY } = event;
    isNil_default(zoomDelta) || pointInRect({
      x: zoomX,
      y: zoomY
    }, this._getRegionOrSeriesLayout(regionOrSeries), false) && (callback && callback({
      zoomDelta,
      zoomX,
      zoomY
    }, event), this._eventObj.emit("zoom", {
      scale: event.zoomDelta,
      scaleCenter: {
        x: event.zoomX,
        y: event.zoomY
      },
      model: this
    }));
  }
  _getRegionOrSeriesLayout(rs) {
    "region" !== rs.type && (rs = rs.getRegion());
    const { x, y, width, height } = rs.layout.getLayout();
    return {
      x1: x,
      y1: y,
      x2: x + width,
      y2: y + height
    };
  }
  _bindZoomEventAsRegion(eventObj, regionOrSeries, callback, option) {
    var _a, _b;
    const delayType = null !== (_a = null == option ? void 0 : option.delayType) && void 0 !== _a ? _a : "throttle", delayTime = null !== (_b = null == option ? void 0 : option.delayTime) && void 0 !== _b ? _b : 0, event = this._isGestureListener ? this._gestureController : eventObj, zoomParams = this._isGestureListener ? [this._getZoomTriggerEvent("zoom")] : [this._getZoomTriggerEvent("zoom"), {
      level: Event_Bubble_Level.chart,
      consume: true
    }], zoomEndParams = this._isGestureListener ? [this._getZoomTriggerEvent("zoomEnd")] : [this._getZoomTriggerEvent("zoomEnd"), {
      level: Event_Bubble_Level.chart,
      consume: false
    }];
    event.on(...zoomEndParams, delayMap4[delayType]((params2) => {
      this._zoomableTrigger.clearZoom();
    }, delayTime)), event.on(...zoomParams, delayMap4[delayType]((params2) => {
      this._zoomEventDispatch(params2, regionOrSeries, callback);
    }, delayTime));
  }
  initZoomEventOfSeries(s2, callback, option) {
    this._option.disableTriggerEvent || getDefaultTriggerEventByMode(this._renderMode) && this._bindZoomEventAsRegion(s2.event, s2, callback, option);
  }
  initZoomEventOfRegions(regions, filter2, callback, option) {
    this._option.disableTriggerEvent || getDefaultTriggerEventByMode(this._renderMode) && regions.forEach((r) => {
      filter2 ? r.getSeries().forEach((s2) => {
        filter2(s2) && this._bindZoomEventAsRegion(s2.event, s2, callback, option);
      }) : this._bindZoomEventAsRegion(this._eventObj, r, callback, option);
    });
  }
  _scrollEventDispatch(params2, regionOrSeries, callback) {
    let stopBubble = false;
    if (!this._isGestureListener && (!params2.event || this._option.disableTriggerEvent))
      return stopBubble;
    const event = this._isGestureListener ? params2 : params2.event;
    this._zoomableTrigger.parserScrollEvent(event);
    const { scrollX, scrollY, canvasX, canvasY } = event;
    return isNil_default(scrollX) && isNil_default(scrollY) ? stopBubble : pointInRect({
      x: canvasX,
      y: canvasY
    }, this._getRegionOrSeriesLayout(regionOrSeries), false) ? (callback && (stopBubble = callback({
      scrollX,
      scrollY
    }, event)), this._eventObj.emit("scroll", {
      scrollX,
      scrollY,
      model: this
    }), stopBubble) : stopBubble;
  }
  _bindScrollEventAsRegion(eventObj, regionOrSeries, callback, option) {
    var _a, _b;
    const delayType = null !== (_a = null == option ? void 0 : option.delayType) && void 0 !== _a ? _a : "throttle", delayTime = null !== (_b = null == option ? void 0 : option.delayTime) && void 0 !== _b ? _b : 0, event = this._isGestureListener ? this._gestureController : eventObj, scrollParams = this._isGestureListener ? [this._getZoomTriggerEvent("scroll")] : [this._getZoomTriggerEvent("scroll"), {
      level: Event_Bubble_Level.chart,
      consume: true
    }], scrollEndParams = this._isGestureListener ? [this._getZoomTriggerEvent("scrollEnd")] : [this._getZoomTriggerEvent("scrollEnd"), {
      level: Event_Bubble_Level.chart,
      consume: false
    }];
    event.on(...scrollEndParams, delayMap4[delayType]((params2) => {
      this._zoomableTrigger.clearScroll();
    }, delayTime)), event.on(...scrollParams, delayMap4[delayType]((params2) => this._scrollEventDispatch(params2, regionOrSeries, callback), delayTime));
  }
  initScrollEventOfSeries(s2, callback, option) {
    getDefaultTriggerEventByMode(this._renderMode) && this._bindScrollEventAsRegion(s2.event, s2, callback, option);
  }
  initScrollEventOfRegions(regions, filter2, callback, option) {
    this._option.disableTriggerEvent || getDefaultTriggerEventByMode(this._renderMode) && regions.forEach((r) => {
      filter2 ? r.getSeries().forEach((s2) => {
        filter2(s2) && this._bindScrollEventAsRegion(s2.event, s2, callback, option);
      }) : this._bindScrollEventAsRegion(this._eventObj, r, callback, option);
    });
  }
  _bindDragEventAsRegion(eventObj, regionOrSeries, callback, option) {
    eventObj.on(this._getZoomTriggerEvent("start"), {
      level: Event_Bubble_Level.chart
    }, (params2) => {
      if (!params2.event)
        return;
      const { event } = params2;
      pointInRect({
        x: event.canvasX,
        y: event.canvasY
      }, this._getRegionOrSeriesLayout(regionOrSeries), false) && this._handleDrag(params2, callback, option);
    }), eventObj.on("click", {
      level: Event_Bubble_Level.chart
    }, () => !this._clickEnable);
  }
  initDragEventOfSeries(s2, callback, option) {
    this._option.disableTriggerEvent || getDefaultTriggerEventByMode(this._renderMode) && s2.event.on(this._getZoomTriggerEvent("start"), {
      level: Event_Bubble_Level.model,
      filter: ({ model }) => (null == model ? void 0 : model.id) === s2.id
    }, (params2) => {
      this._handleDrag(params2, callback, option);
    });
  }
  initDragEventOfRegions(regions, filter2, callback, option) {
    this._option.disableTriggerEvent || getDefaultTriggerEventByMode(this._renderMode) && regions.forEach((r) => {
      filter2 ? r.getSeries().forEach((s2) => {
        filter2(s2) && (s2.event.on(this._getZoomTriggerEvent("start"), {
          level: Event_Bubble_Level.model,
          filter: ({ model }) => (null == model ? void 0 : model.id) === s2.id
        }, (params2) => {
          this._handleDrag(params2, callback);
        }), s2.event.on("click", {
          level: Event_Bubble_Level.model,
          filter: ({ model }) => (null == model ? void 0 : model.id) === s2.id
        }, () => !this._clickEnable));
      }) : this._bindDragEventAsRegion(this._eventObj, r, callback, option);
    });
  }
  _handleDrag(params2, callback, option) {
    var _a, _b, _c;
    if (this._option.disableTriggerEvent)
      return;
    if (this._clickEnable = false, !this._zoomableTrigger.parserDragEvent(params2.event))
      return;
    const delayType = null !== (_a = null == option ? void 0 : option.delayType) && void 0 !== _a ? _a : "throttle", delayTime = null !== (_b = null == option ? void 0 : option.delayTime) && void 0 !== _b ? _b : 0, realTime = null === (_c = null == option ? void 0 : option.realTime) || void 0 === _c || _c, move = this._getZoomTriggerEvent("move"), end = this._getZoomTriggerEvent("end"), event = params2.event;
    let moveX = event.canvasX, moveY = event.canvasY, upX = event.canvasX, upY = event.canvasY;
    const mouseup = delayMap4[delayType]((params3) => {
      this._clickEnable = true;
      const event2 = params3.event, delta = [event2.canvasX - upX, event2.canvasY - upY];
      upX = event2.canvasX, upY = event2.canvasY, !realTime && callback && callback(delta, params3.event), this._eventObj.emit("panend", {
        delta,
        model: this
      }), this._zoomableTrigger.pointerId = null, this._eventObj.off(move, {
        level: Event_Bubble_Level.chart,
        source: Event_Source_Type.chart
      }, mousemove), this._eventObj.off(end, {
        level: Event_Bubble_Level.chart,
        source: Event_Source_Type.window
      }, mouseup);
    }, delayTime), mousemove = delayMap4[delayType]((params3) => {
      if (!this._zoomableTrigger.parserDragEvent(params3.event))
        return;
      this._clickEnable = false;
      const event2 = params3.event, delta = [event2.canvasX - moveX, event2.canvasY - moveY];
      moveX = event2.canvasX, moveY = event2.canvasY, realTime && callback && callback(delta, params3.event), this._eventObj.emit("panmove", {
        delta,
        model: this
      });
    }, delayTime);
    this._eventObj.on(move, {
      level: Event_Bubble_Level.chart,
      source: Event_Source_Type.chart
    }, mousemove), this._eventObj.on(end, {
      level: Event_Bubble_Level.chart,
      source: Event_Source_Type.chart
    }, mouseup);
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/geo/geo-coordinate
function projectionName(key, id2) {
  return `${PREFIX}_${id2}_${key}`;
}
var GeoCoordinate = class extends BaseComponent {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.geoCoordinate, this.name = ComponentTypeEnum.geoCoordinate, this.layoutType = "none", this.layoutZIndex = LayoutZIndex2.Mark, this._projectionSpec = {
      name: projectionName(this.type, this.id),
      type: "mercator"
    }, this._actualScale = 1, this._initialScale = 1, this.effect = {
      scaleUpdate: () => {
        this.coordinateHelper();
      }
    }, this._handleChartZoom = (params2, event) => {
      var _a, _b, _c, _d, _e, _f;
      let scale4 = params2.zoomDelta;
      const _lastActualScale = this._actualScale;
      return this._actualScale *= scale4, this._actualScale < (null === (_a = this._spec.zoomLimit) || void 0 === _a ? void 0 : _a.min) ? (this._actualScale = null === (_b = this._spec.zoomLimit) || void 0 === _b ? void 0 : _b.min, scale4 = (null === (_c = this._spec.zoomLimit) || void 0 === _c ? void 0 : _c.min) / _lastActualScale) : this._actualScale > (null === (_d = this._spec.zoomLimit) || void 0 === _d ? void 0 : _d.max) && (this._actualScale = null === (_e = this._spec.zoomLimit) || void 0 === _e ? void 0 : _e.max, scale4 = (null === (_f = this._spec.zoomLimit) || void 0 === _f ? void 0 : _f.max) / _lastActualScale), event && (event.zoomDelta = scale4), this.zoom(scale4, [params2.zoomX, params2.zoomY]), scale4;
    }, this.pan = (delta = [0, 0]) => {
      var _a, _b, _c;
      const t = null !== (_b = null === (_a = this._projection) || void 0 === _a ? void 0 : _a.translate()) && void 0 !== _b ? _b : [0, 0];
      let t_x = t[0], t_y = t[1];
      t_x += delta[0], t_y += delta[1], null === (_c = this._projection) || void 0 === _c || _c.translate([t_x, t_y]);
    };
  }
  get longitudeField() {
    return this._longitudeField;
  }
  get latitudeField() {
    return this._latitudeField;
  }
  get projectionSpec() {
    return this._projectionSpec;
  }
  setProjection(projectionSpec) {
    this._projectionSpec = Object.assign(Object.assign({}, projectionSpec), {
      name: this._projectionSpec.name
    });
  }
  getZoom() {
    return this._actualScale;
  }
  static getSpecInfo(chartSpec) {
    if (isNil_default(chartSpec))
      return null;
    const specInfos = [];
    return chartSpec.region.forEach((r, i) => {
      if ("geo" === r.coordinate) {
        const spec = Object.assign(Object.assign({}, r), {
          padding: 0
        });
        specInfos.push({
          spec,
          regionIndex: i,
          type: ComponentTypeEnum.geoCoordinate,
          specInfoPath: ["component", "geoCoordinate", i]
        });
      }
    }), specInfos;
  }
  setAttrFromSpec() {
    var _a, _b, _c;
    super.setAttrFromSpec(), this._spec.roam && this.initZoomable(this.event, this._option.mode), this._projectionSpec = mergeSpec(this._projectionSpec, this._spec.projection), this._projectionSpec.zoom > (null === (_a = this._spec.zoomLimit) || void 0 === _a ? void 0 : _a.max) && (this._projectionSpec.zoom = this._spec.zoomLimit.max), this._projectionSpec.zoom < (null === (_b = this._spec.zoomLimit) || void 0 === _b ? void 0 : _b.min) && (this._projectionSpec.zoom = this._spec.zoomLimit.min), this._actualScale = null !== (_c = this._projectionSpec.zoom) && void 0 !== _c ? _c : 1, this._initialScale = this._actualScale, this._longitudeField = this._spec.longitudeField, this._latitudeField = this._spec.latitudeField;
  }
  created() {
    super.created(), this._regions = this._option.getRegionsInIndex([this._option.regionIndex]), this.initProjection(), this.coordinateHelper(), this.initEvent(), this._initCenterCache();
  }
  dispatchZoom(zoomDelta, center2) {
    const scaleCenter = center2 || {
      x: this.getLayoutStartPoint().x + this.getLayoutRect().width / 2,
      y: this.getLayoutStartPoint().y + this.getLayoutRect().height / 2
    }, scale4 = this._handleChartZoom({
      zoomDelta,
      zoomX: scaleCenter.x,
      zoomY: scaleCenter.y
    });
    1 !== scale4 && this.event.emit("zoom", {
      scale: scale4,
      scaleCenter,
      model: this
    });
  }
  initEvent() {
    this.event.on(ChartEvent.scaleUpdate, {
      filter: ({ model }) => (null == model ? void 0 : model.id) === this.id
    }, this.effect.scaleUpdate.bind(this)), this._spec.roam && (this.initZoomEventOfRegions(this._regions, null, this._handleChartZoom), this.initDragEventOfRegions(this._regions, () => true, this.pan), this._regions.forEach((r) => {
      r.getSeries().forEach((s2) => {
        s2.event.on("zoom", (e) => (s2.handleZoom(e), true)), s2.event.on("panmove", (e) => (s2.handlePan(e), true));
      });
    }));
  }
  initProjection() {
    var _a;
    this._projection = new Projection(this._projectionSpec), null !== this._projection.projection || null === (_a = this._option) || void 0 === _a || _a.onError("unsupported projection type!");
  }
  coordinateHelper() {
    const helper = {
      longitudeField: this._longitudeField,
      latitudeField: this._latitudeField,
      dataToPosition: this.dataToPosition.bind(this),
      dataToLongitude: this.dataToLongitude.bind(this),
      dataToLatitude: this.dataToLatitude.bind(this),
      shape: this.shape.bind(this),
      getCoordinateId: () => this.id
    };
    this._regions.forEach((r) => {
      r.getSeries().forEach((s2) => {
        s2.type === SeriesTypeEnum.map ? s2.setCoordinateHelper(helper) : (s2.setXAxisHelper(Object.assign(Object.assign({}, helper), {
          isContinuous: true,
          dataToPosition: (values, option) => {
            var _a;
            let value = values[0];
            if (isNil_default(value) && (null == option ? void 0 : option.datum)) {
              const nameFieldValue = option.datum[s2.getDimensionField()[0]];
              value = null === (_a = this._centerCache.get(nameFieldValue)) || void 0 === _a ? void 0 : _a.x;
            }
            return this.dataToLongitude(value);
          },
          valueToPosition: (value, option) => {
            var _a;
            if (isNil_default(value) && (null == option ? void 0 : option.datum)) {
              const nameFieldValue = option.datum[s2.getDimensionField()[0]];
              value = null === (_a = this._centerCache.get(nameFieldValue)) || void 0 === _a ? void 0 : _a.x;
            }
            return this.dataToLongitude(value);
          },
          getFields: () => [this._longitudeField],
          getAxisType: () => this.type,
          getAxisId: () => this.id,
          isInverse: () => false
        })), s2.setYAxisHelper(Object.assign(Object.assign({}, helper), {
          isContinuous: true,
          dataToPosition: (values, option) => {
            var _a;
            let value = values[0];
            if (isNil_default(value) && (null == option ? void 0 : option.datum)) {
              const nameFieldValue = option.datum[s2.getDimensionField()[0]];
              value = null === (_a = this._centerCache.get(nameFieldValue)) || void 0 === _a ? void 0 : _a.y;
            }
            return this.dataToLatitude(value);
          },
          valueToPosition: (value, option) => {
            var _a;
            if (isNil_default(value) && (null == option ? void 0 : option.datum)) {
              const nameFieldValue = option.datum[s2.getDimensionField()[0]];
              value = null === (_a = this._centerCache.get(nameFieldValue)) || void 0 === _a ? void 0 : _a.y;
            }
            return this.dataToLatitude(value);
          },
          getFields: () => [this._latitudeField],
          getAxisType: () => this.type,
          getAxisId: () => this.id,
          isInverse: () => false
        })));
      });
    });
  }
  onLayoutEnd(ctx) {
    this.setLayoutRect(this._regions[0].getLayoutRect()), this.setLayoutStartPosition(this._regions[0].getLayoutStartPoint());
    const { width, height } = this.getLayoutRect(), { translate: translate2, scale: scale4, center: center2 } = this.evaluateProjection([0, 0], [width, height]);
    translate2 && this._projection.translate(translate2), scale4 && this._projection.scale(scale4), center2 && this._projection.center(center2), eachSeries(this._regions, (s2) => {
      var _a;
      if (s2.type === SeriesTypeEnum.map) {
        s2.areaPath.clear();
        const pathGroup = null === (_a = s2.getRootMark().getProduct()) || void 0 === _a ? void 0 : _a.getGroupGraphicItem();
        pathGroup && pathGroup.attribute.postMatrix && pathGroup.setAttributes({
          postMatrix: new Matrix()
        });
      }
    }), this._actualScale = this._initialScale, super.onLayoutEnd(ctx);
  }
  onRender(ctx) {
  }
  changeRegions(regions) {
  }
  _getNeedClearVRenderComponents() {
    return [];
  }
  collectFeatures() {
    const features = [];
    return this._regions.forEach((r) => {
      r.getSeries().forEach((s2) => {
        var _a, _b;
        s2.type === SeriesTypeEnum.map && features.push(...null !== (_b = null === (_a = s2.getMapViewData()) || void 0 === _a ? void 0 : _a.latestData) && void 0 !== _b ? _b : []);
      });
    }), features;
  }
  dataToPosition(values = []) {
    var _a;
    const point5 = null === (_a = this._projection) || void 0 === _a ? void 0 : _a.project([values[0], values[1]]);
    return {
      x: null == point5 ? void 0 : point5[0],
      y: null == point5 ? void 0 : point5[1]
    };
  }
  dataToLatitude(lat) {
    var _a;
    const point5 = null === (_a = this._projection) || void 0 === _a ? void 0 : _a.project([0, lat]);
    return null == point5 ? void 0 : point5[1];
  }
  dataToLongitude(lon) {
    var _a;
    const point5 = null === (_a = this._projection) || void 0 === _a ? void 0 : _a.project([lon, 0]);
    return null == point5 ? void 0 : point5[0];
  }
  zoom(p, anchor = [0, 0]) {
    var _a, _b, _c, _d, _e, _f;
    let s2 = null !== (_b = null === (_a = this._projection) || void 0 === _a ? void 0 : _a.scale()) && void 0 !== _b ? _b : 0;
    const t = null !== (_d = null === (_c = this._projection) || void 0 === _c ? void 0 : _c.translate()) && void 0 !== _d ? _d : [0, 0];
    let t_x = t[0], t_y = t[1];
    s2 *= p, t_x -= (anchor[0] - t_x) * (p - 1), t_y -= (anchor[1] - t_y) * (p - 1), null === (_e = this._projection) || void 0 === _e || _e.scale(s2), null === (_f = this._projection) || void 0 === _f || _f.translate([t_x, t_y]);
  }
  shape(datum) {
    return this._projection.shape(datum);
  }
  invert(point5) {
    return this._projection.invert(point5);
  }
  evaluateProjection(start, size) {
    var _a;
    const evaluated = this._projection.evaluate(start, size, this.collectFeatures());
    let translate2 = evaluated.translate();
    const scale4 = evaluated.scale() * this._initialScale, center2 = null !== (_a = this._projectionSpec.center) && void 0 !== _a ? _a : evaluated.invert([size[0] / 2, size[1] / 2]);
    return center2 && (translate2 = [size[0] / 2, size[1] / 2]), {
      translate: translate2,
      scale: scale4,
      center: center2
    };
  }
  _initCenterCache() {
    this._centerCache || (this._centerCache = /* @__PURE__ */ new Map()), this._regions.forEach((r) => {
      r.getSeries().forEach((s2) => {
        var _a, _b;
        if ("map" === s2.type) {
          (null !== (_b = null === (_a = s2.getMapViewData()) || void 0 === _a ? void 0 : _a.latestData) && void 0 !== _b ? _b : []).forEach((feature = {}) => {
            const key = feature[s2.getDimensionField()[0]] || feature[DEFAULT_MAP_LOOK_UP_KEY], center2 = s2.getDatumCenter(feature);
            key && isValid_default(center2) && this._centerCache.set(key, {
              x: center2[0],
              y: center2[1]
            });
          });
        }
      });
    });
  }
  release() {
    super.release(), this._centerCache && this._centerCache.clear(), this._centerCache = null;
  }
};
GeoCoordinate.type = ComponentTypeEnum.geoCoordinate, mixin(GeoCoordinate, Zoomable);

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/map/map-transformer
var MapSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "area", void 0, void 0, false);
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/map/map
var MapSeries = class _MapSeries extends GeoSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.map, this.transformerConstructor = MapSeriesSpecTransformer, this._areaCache = /* @__PURE__ */ new Map();
  }
  getNameMap() {
    return this._nameMap;
  }
  get areaPath() {
    return this._areaCache;
  }
  setAttrFromSpec() {
    var _a, _b;
    super.setAttrFromSpec(), this.map = this._spec.map, this._nameMap = this._spec.nameMap, this._nameField = this._spec.nameField, this._valueField = this._spec.valueField, this._spec.nameProperty && (this._nameProperty = this._spec.nameProperty), this._spec.centroidProperty && (this._centroidProperty = this._spec.centroidProperty), this.map || null === (_a = this._option) || void 0 === _a || _a.onError(`map type '${this.map}' is not specified !`), geoSourceMap.get(this.map) || null === (_b = this._option) || void 0 === _b || _b.onError(`'${this.map}' data is not registered !`);
  }
  initData() {
    var _a, _b;
    super.initData(), registerDataSetInstanceTransform(this._dataSet, "copyDataView", copyDataView), registerDataSetInstanceTransform(this._dataSet, "map", map3), registerDataSetInstanceTransform(this._dataSet, "lookup", lookup);
    const features = geoSourceMap.get(this.map);
    features || null === (_a = this._option) || void 0 === _a || _a.onError("no valid map data found!");
    const mapData = new DataView(this._dataSet, {
      name: `map_${this.id}_data`
    });
    mapData.parse([features], {
      type: "dataview"
    }).transform({
      type: "copyDataView",
      options: {
        deep: true
      },
      level: TransformLevel.copyDataView
    }).transform({
      type: "map",
      options: {
        nameMap: this._nameMap,
        nameProperty: this._nameProperty
      }
    }).transform({
      type: "lookup",
      options: {
        from: () => {
          var _a2;
          return null === (_a2 = this._data) || void 0 === _a2 ? void 0 : _a2.getLatestData();
        },
        key: DEFAULT_MAP_LOOK_UP_KEY,
        fields: this._nameField,
        set: (feature, datum) => {
          datum && Object.keys(datum).forEach((key) => {
            key in feature || (feature[key] = datum[key]);
          });
        }
      }
    }), null === (_b = this._data) || void 0 === _b || _b.getDataView().target.addListener("change", mapData.reRunAllTransform), this._mapViewData = new SeriesData(this._option, mapData);
  }
  initMark() {
    this._pathMark = this._createMark(_MapSeries.mark.area, {
      morph: shouldMarkDoMorph(this._spec, _MapSeries.mark.area.name),
      defaultMorphElementKey: this.getDimensionField()[0],
      groupKey: this.getDimensionField()[0],
      isSeriesMark: true,
      skipBeforeLayouted: true,
      dataView: this._mapViewData.getDataView(),
      dataProductId: this._mapViewData.getProductId()
    });
  }
  initMarkStyle() {
    const pathMark = this._pathMark;
    pathMark && (this.setMarkStyle(pathMark, {
      fill: (datum) => {
        var _a, _b, _c, _d;
        return isValid_default(datum[null !== (_a = this._seriesField) && void 0 !== _a ? _a : DEFAULT_DATA_SERIES_FIELD2]) ? (null !== (_b = this._option.globalScale.getScale("color")) && void 0 !== _b ? _b : this._getDefaultColorScale()).scale(datum[null !== (_c = this._seriesField) && void 0 !== _c ? _c : DEFAULT_DATA_SERIES_FIELD2]) : null === (_d = this._spec) || void 0 === _d ? void 0 : _d.defaultFillColor;
      },
      path: this.getPath.bind(this)
    }, "normal", AttributeLevel2.Series), pathMark.setPostProcess("fill", (result2) => isValid_default(result2) ? result2 : this._spec.defaultFillColor), this.setMarkStyle(pathMark, {
      smoothScale: true
    }, "normal", AttributeLevel2.Built_In));
  }
  initLabelMarkStyle(labelMark) {
    labelMark && (this._labelMark = labelMark, this.setMarkStyle(labelMark, {
      text: (datum) => this.getDatumName(datum),
      x: (datum) => {
        var _a;
        return null === (_a = this.dataToPosition(datum)) || void 0 === _a ? void 0 : _a.x;
      },
      y: (datum) => {
        var _a;
        return null === (_a = this.dataToPosition(datum)) || void 0 === _a ? void 0 : _a.y;
      }
    }));
  }
  initAnimation() {
    var _a;
    this._pathMark.setAnimationConfig(animationConfig(null === (_a = Factory2.getAnimationInKey("fadeInOut")) || void 0 === _a ? void 0 : _a(), userAnimationConfig("area", this._spec, this._markAttributeContext)));
  }
  initTooltip() {
    this._tooltipHelper = new MapSeriesTooltipHelper(this), this._pathMark && this._tooltipHelper.activeTriggerSet.mark.add(this._pathMark);
  }
  getPath(datum) {
    var _a;
    const area2 = this._areaCache.get(datum[DEFAULT_DATA_INDEX2]);
    if (area2)
      return area2.shape;
    const shape = null === (_a = this._coordinateHelper) || void 0 === _a ? void 0 : _a.shape(datum);
    return this._areaCache.set(datum[DEFAULT_DATA_INDEX2], {
      shape
    }), shape;
  }
  onEvaluateEnd() {
    this._mapViewData.updateData();
  }
  getDimensionField() {
    return [this.nameField];
  }
  getMeasureField() {
    return [this.valueField];
  }
  release() {
    super.release(), this._areaCache.clear(), this._nameMap = {}, this._mapViewData = null;
  }
  handleZoom(e) {
    var _a, _b, _c;
    const { scale: scale4, scaleCenter } = e;
    if (1 === scale4)
      return;
    const pathGroup = null === (_a = this.getRootMark().getProduct()) || void 0 === _a ? void 0 : _a.getGroupGraphicItem();
    pathGroup && (pathGroup.attribute.postMatrix || pathGroup.setAttributes({
      postMatrix: new Matrix()
    }), pathGroup.scale(scale4, scale4, scaleCenter));
    const vgrammarLabel = null === (_c = null === (_b = this._labelMark) || void 0 === _b ? void 0 : _b.getComponent()) || void 0 === _c ? void 0 : _c.getProduct();
    vgrammarLabel && vgrammarLabel.evaluate(null, null);
  }
  handlePan(e) {
    var _a, _b, _c;
    const { delta } = e;
    if (0 === delta[0] && 0 === delta[1])
      return;
    const pathGroup = null === (_a = this.getRootMark().getProduct()) || void 0 === _a ? void 0 : _a.getGroupGraphicItem();
    pathGroup && (pathGroup.attribute.postMatrix || pathGroup.setAttributes({
      postMatrix: new Matrix()
    }), pathGroup.translate(delta[0], delta[1]));
    const vgrammarLabel = null === (_c = null === (_b = this._labelMark) || void 0 === _b ? void 0 : _b.getComponent()) || void 0 === _c ? void 0 : _c.getProduct();
    vgrammarLabel && vgrammarLabel.evaluate(null, null);
  }
  getDatumCenter(datum) {
    var _a, _b, _c, _d;
    return this._centroidProperty && (null === (_a = datum.properties) || void 0 === _a ? void 0 : _a[this._centroidProperty]) ? null === (_b = datum.properties) || void 0 === _b ? void 0 : _b[this._centroidProperty] : isValidNumber_default(datum.centroidX * datum.centroidY) ? [datum.centroidX, datum.centroidY] : (null === (_c = datum.properties) || void 0 === _c ? void 0 : _c.center) ? datum.properties.center : (null === (_d = datum.properties) || void 0 === _d ? void 0 : _d.centroid) ? datum.properties.centroid : [Number.NaN, Number.NaN];
  }
  getDatumName(datum) {
    var _a;
    if (datum[this.nameField])
      return datum[this.nameField];
    const name = null === (_a = datum.properties) || void 0 === _a ? void 0 : _a[this._nameProperty];
    if (name) {
      if (this._spec.nameMap && this._spec.nameMap[name])
        return this._spec.nameMap[name];
      if (this._spec.showDefaultName || !this._spec.nameMap)
        return name;
    }
    return "";
  }
  dataToPositionX(data) {
    var _a;
    return null === (_a = this._option) || void 0 === _a || _a.onError("Method not implemented."), 0;
  }
  dataToPositionY(data) {
    var _a;
    return null === (_a = this._option) || void 0 === _a || _a.onError("Method not implemented."), 0;
  }
  viewDataUpdate(d) {
    var _a, _b, _c;
    super.viewDataUpdate(d), null === (_b = null === (_a = this._mapViewData) || void 0 === _a ? void 0 : _a.getDataView()) || void 0 === _b || _b.reRunAllTransform(), null === (_c = this._mapViewData) || void 0 === _c || _c.updateData();
  }
  _getDataIdKey() {
    return DEFAULT_DATA_INDEX2;
  }
  getActiveMarks() {
    return [this._pathMark];
  }
};
MapSeries.type = SeriesTypeEnum.map, MapSeries.mark = mapSeriesMark, MapSeries.transformerConstructor = MapSeriesSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/data/transforms/waterfall
var waterfall2 = (lastData, op) => {
  if (!lastData || 0 === lastData.length)
    return lastData;
  const { indexField, total: totalSpec, groupData: groupData2 } = op, totalData = [], { dimensionValues, dimensionData } = groupData2().latestData, indexValues = Array.from(dimensionValues[indexField]);
  let temp3 = {
    start: 0,
    end: 0,
    lastIndex: null
  };
  return indexValues.forEach((key, index) => {
    const total = {
      start: temp3.end,
      end: temp3.end,
      lastIndex: temp3.lastIndex,
      lastEnd: temp3.end,
      index: key,
      isTotal: false
    }, indexData = dimensionData[key];
    if (null == indexData || indexData.forEach((d, i) => {
      i === indexData.length - 1 ? d[STACK_FIELD_TOTAL_TOP] = true : delete d[STACK_FIELD_TOTAL_TOP];
    }), indexData.length > 1) {
      const isTotalCheck = (d) => {
        if (totalSpec && "end" !== totalSpec.type) {
          if ("field" === totalSpec.type || "custom" === totalSpec.type) {
            return !!d[totalSpec.tagField];
          }
        } else if (index === indexValues.length - 1)
          return true;
        return false;
      };
      if (indexData.some((d) => isTotalCheck(d)))
        return temp3 = computeTotalWithMultipleData(indexData, key, total, totalData, temp3, indexValues, index, op, isTotalCheck), void totalData.push(total);
    }
    temp3 = computeNormalData(indexData, key, total, totalData, temp3, indexValues, index, op), totalData.push(total);
  }), totalData;
};
function computeTotalWithMultipleData(indexData, key, total, totalData, temp3, indexValues, index, op, isTotalCheck) {
  total.isTotal = true;
  const { valueField, startAs, endAs, total: totalSpec } = op, _normalTemp = [], _totalTemp = [];
  if (indexData.forEach((d) => {
    isTotalCheck(d) ? _totalTemp.push(d) : _normalTemp.push(d);
  }), _totalTemp.length === indexData.length) {
    const result2 = computeNormalData([indexData[0]], key, total, totalData, temp3, indexValues, index, op);
    return _totalTemp.forEach((d) => {
      d[startAs] = indexData[0][startAs], d[endAs] = indexData[0][endAs], d[valueField] = indexData[0][valueField];
    }), result2;
  }
  const totalConfigData = _totalTemp[0];
  let { start, end } = getTotalStartEnd(totalConfigData, total, totalData, temp3, totalSpec);
  total.start = start, total.end = end;
  let valueTemp = end - start;
  return _normalTemp.forEach((d) => {
    d[startAs] = +start, d[endAs] = precisionAdd(d[startAs], +d[valueField]), start = d[endAs], valueTemp = precisionSub(valueTemp, +d[valueField]);
  }), _totalTemp.forEach((d) => {
    d[startAs] = +start, d[endAs] = precisionAdd(d[startAs], valueTemp), d[valueField] = valueTemp;
  }), Object.assign(Object.assign({}, total), {
    lastIndex: key
  });
}
function computeNormalData(indexData, key, total, totalData, temp3, indexValues, index, op) {
  const { valueField, startAs, endAs, total: totalSpec, seriesField, seriesFieldName } = op;
  return indexData.forEach((d) => {
    let isTotalTag = false;
    if (totalSpec && "end" !== totalSpec.type) {
      if ("field" === totalSpec.type || "custom" === totalSpec.type) {
        if (d[totalSpec.tagField]) {
          isTotalTag = true;
          const { start, end } = getTotalStartEnd(d, total, totalData, temp3, totalSpec);
          d[startAs] = start, d[endAs] = end, d[valueField] = end - start, total.start = start, total.end = end;
        }
      }
    } else
      index === indexValues.length - 1 && (total.start = 0, d[startAs] = total.start, d[endAs] = total.end, isTotalTag = true);
    isTotalTag || (d[startAs] = +total.end, d[endAs] = precisionAdd(d[startAs], +d[valueField]), total.end = d[endAs]), total.isTotal = isTotalTag, (isNil_default(seriesField) || seriesField === WaterfallDefaultSeriesField) && (d[WaterfallDefaultSeriesField] = isTotalTag ? seriesFieldName.total : +d[valueField] >= 0 ? seriesFieldName.increase : seriesFieldName.decrease);
  }), Object.assign(Object.assign({}, total), {
    lastIndex: key
  });
}
function getTotalStartEnd(d, total, totalData, temp3, totalSpec) {
  return totalSpec && "end" !== totalSpec.type ? "field" === totalSpec.type || "custom" === totalSpec.type ? "custom" === totalSpec.type ? getTotalInCustomType(d, temp3, totalSpec) : totalSpec.collectCountField && !isNil_default(d[totalSpec.collectCountField]) ? getTotalInCollectField(d, totalData, total, totalSpec) : getTotalInField(d, total, totalSpec) : {
    start: 0,
    end: 0
  } : getTotalInEndType(total);
}
function getTotalInEndType(total) {
  return {
    start: 0,
    end: total.end
  };
}
function getTotalInCustomType(d, temp3, totalSpec) {
  return totalSpec.product(d, temp3);
}
function getTotalInCollectField(d, totalData, total, totalSpec) {
  let start = 0, end = total.end;
  const startIndex = totalData.length - +d[totalSpec.collectCountField], endIndex = totalData.length - 1;
  return startIndex < 0 ? warn("total.collectCountField error") : start = totalData[startIndex].start, endIndex < 0 ? warn("total.collectCountField error") : end = totalData[endIndex].end, {
    start,
    end
  };
}
function getTotalInField(d, total, totalSpec) {
  let start = 0, end = total.end;
  return totalSpec.startField && !isNil_default(d[totalSpec.startField]) && (start = +d[totalSpec.startField]), totalSpec.valueField && !isNil_default(d[totalSpec.valueField]) && (end = precisionAdd(start, +d[totalSpec.valueField])), {
    start,
    end
  };
}
var waterfallFillTotal = (data, op) => {
  if (!data)
    return data;
  const { indexField, valueField, total, seriesField } = op, totalData = {
    [indexField]: (null == total ? void 0 : total.text) || "total",
    [valueField]: data.reduce((pre, cur) => precisionAdd(pre, +cur[valueField]), 0)
  };
  return seriesField && (totalData[seriesField] = "total"), data.push(totalData), data;
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/data/transforms/dimension-data
var dimensionTree = (data, op) => {
  if (!op.fields)
    return data;
  const dimensionValues = {};
  return {
    dimensionValues,
    dimensionData: groups(data.map((d) => d.latestData).flat(), op.fields, dimensionValues)
  };
};
function groups(data, fields2, dimensionValues) {
  if (0 === fields2.length)
    return data;
  const first = fields2[0], _rest = fields2.slice(1);
  dimensionValues[first] = /* @__PURE__ */ new Set();
  const grouped = groupBy(data, first, dimensionValues[first]);
  return _rest.length ? mapValues(grouped, (value, key) => groups(value, _rest, dimensionValues)) : grouped;
}
function groupBy(data, field3, set) {
  const groups2 = {};
  return data.forEach((d) => {
    const key = d[field3];
    groups2[key] || (groups2[key] = [], set.add(key)), groups2[key].push(d);
  }), groups2;
}
function mapValues(target, fn) {
  return Object.keys(target).reduce((result2, key) => (result2[key] = fn(target[key], key), result2), {});
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/base/group
var Group2 = class {
  get fields() {
    return this._fields;
  }
  get groupData() {
    return this._groupData;
  }
  constructor(fields2) {
    this._fields = [], this._fields = fields2;
  }
  initData(viewData, dataSet) {
    const dataName = viewData.name, groupData2 = new DataView(dataSet instanceof DataSet ? dataSet : viewData.dataSet);
    groupData2.name = dataName, groupData2.parse([viewData], {
      type: "dataview"
    }), registerDataSetInstanceTransform(dataSet, "dimensionTree", dimensionTree), groupData2.transform({
      type: "dimensionTree",
      options: {
        fields: this._fields
      }
    }, false), groupData2.target.addListener("change", this.groupDataUpdate.bind(this)), this._groupData = groupData2;
  }
  groupDataUpdate() {
  }
  getGroupValueInField(field3) {
    var _a, _b, _c;
    const values = null === (_c = null === (_b = null === (_a = this.groupData) || void 0 === _a ? void 0 : _a.latestData) || void 0 === _b ? void 0 : _b.dimensionValues) || void 0 === _c ? void 0 : _c[field3];
    return values ? Array.from(values) : [];
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/waterfall/waterfall-transformer
var WaterfallSeriesSpecTransformer = class extends BarSeriesSpecTransformer {
  constructor() {
    super(...arguments), this._supportStack = false;
  }
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "bar"), this._addMarkLabelSpec(spec, "bar", "stackLabel");
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/label/util
var labelRuleMap = {
  rect: barLabel,
  symbol: symbolLabel2,
  arc: pieLabel,
  point: pointLabel2,
  "line-data": lineDataLabel2,
  stackLabel,
  line: LineLabel,
  area: LineLabel,
  rect3d: barLabel,
  arc3d: pieLabel,
  treemap: treemapLabel,
  venn: vennLabel
};
function defaultLabelConfig(rule, labelInfo) {
  var _a;
  const { labelSpec } = labelInfo;
  labelSpec.overlap && !isObject_default(labelSpec.overlap) && (labelSpec.overlap = {});
  return (null !== (_a = labelRuleMap[rule]) && void 0 !== _a ? _a : labelRuleMap.point)(labelInfo);
}
function textAttribute(labelInfo, datum, formatMethod, formatter) {
  var _a;
  const { labelMark, series: series2 } = labelInfo, textAttribute2 = {
    text: datum[series2.getMeasureField()[0]],
    data: datum,
    textType: null !== (_a = labelInfo.labelSpec.textType) && void 0 !== _a ? _a : "text"
  }, attributes = Object.keys(labelMark.stateStyle.normal);
  for (const key of attributes) {
    const attr = labelMark.getAttribute(key, datum);
    textAttribute2[key] = attr;
  }
  const { formatFunc, args } = getFormatFunction(formatMethod, formatter, textAttribute2.text, datum);
  return formatFunc && (textAttribute2.text = formatFunc(...args, {
    series: series2
  })), textAttribute2;
}
function uniformLabelPosition(position) {
  return isFunction_default(position) ? (datum) => position(datum.data) : position;
}
function symbolLabel2(labelInfo) {
  var _a, _b, _c;
  const { series: series2, labelSpec } = labelInfo, defaultPosition = "horizontal" === series2.direction ? "right" : "top", position = null !== (_a = uniformLabelPosition(labelSpec.position)) && void 0 !== _a ? _a : defaultPosition;
  let overlap2;
  return overlap2 = false !== labelSpec.overlap && {
    strategy: null !== (_c = null === (_b = labelSpec.overlap) || void 0 === _b ? void 0 : _b.strategy) && void 0 !== _c ? _c : symbolLabelOverlapStrategy(),
    avoidBaseMark: "center" !== position
  }, {
    position,
    overlap: overlap2
  };
}
function lineDataLabel2(labelInfo) {
  const result2 = symbolLabel2(labelInfo);
  return isBoolean_default(result2.overlap) || (result2.overlap.avoidBaseMark = false), result2;
}
function symbolLabelOverlapStrategy() {
  return [{
    type: "position",
    position: ["top", "bottom", "right", "left", "top-right", "top-left", "bottom-left", "bottom-right"]
  }];
}
function barLabel(labelInfo) {
  var _a, _b, _c, _d, _e, _f;
  const { series: series2, labelSpec = {} } = labelInfo, originPosition = null !== (_a = uniformLabelPosition(labelSpec.position)) && void 0 !== _a ? _a : "outside", direction2 = null !== (_b = series2.direction) && void 0 !== _b ? _b : "vertical", isInverse = "horizontal" === series2.direction ? null === (_c = series2.getXAxisHelper()) || void 0 === _c ? void 0 : _c.isInverse() : null === (_d = series2.getYAxisHelper()) || void 0 === _d ? void 0 : _d.isInverse();
  let overlap2, position = originPosition;
  isString_default(originPosition) && "outside" === originPosition && (position = (data) => {
    const { data: datum } = data, dataField = series2.getMeasureField()[0], index = (null == datum ? void 0 : datum[dataField]) >= 0 && isInverse || (null == datum ? void 0 : datum[dataField]) < 0 && !isInverse ? 1 : 0;
    return {
      vertical: ["top", "bottom"],
      horizontal: ["right", "left"]
    }[direction2][index];
  }), overlap2 = false !== labelSpec.overlap && {
    strategy: null !== (_f = null === (_e = labelSpec.overlap) || void 0 === _e ? void 0 : _e.strategy) && void 0 !== _f ? _f : barLabelOverlapStrategy(series2)
  };
  let smartInvert = false;
  return isString_default(originPosition) && originPosition.includes("inside") && (smartInvert = true), {
    position,
    overlap: overlap2,
    smartInvert
  };
}
function barLabelOverlapStrategy(series2) {
  return [{
    type: "position",
    position: (data) => {
      var _a, _b;
      const { data: datum } = data, dataField = series2.getMeasureField()[0];
      return ("horizontal" === series2.direction ? null === (_a = series2.getXAxisHelper()) || void 0 === _a ? void 0 : _a.isInverse() : null === (_b = series2.getYAxisHelper()) || void 0 === _b ? void 0 : _b.isInverse()) ? (null == datum ? void 0 : datum[dataField]) >= 0 ? "horizontal" === series2.direction ? ["left", "inside-left"] : ["bottom", "inside-bottom"] : "horizontal" === series2.direction ? ["right", "inside-right"] : ["top", "inside-top"] : (null == datum ? void 0 : datum[dataField]) >= 0 ? "horizontal" === series2.direction ? ["right", "inside-right"] : ["top", "inside-top"] : "horizontal" === series2.direction ? ["left", "inside-left"] : ["bottom", "inside-bottom"];
    }
  }];
}
function pointLabel2(labelInfo) {
  const { labelSpec } = labelInfo;
  let overlap2;
  return overlap2 = false !== labelSpec.overlap && {
    avoidBaseMark: false
  }, {
    position: "center",
    overlap: overlap2
  };
}
function pieLabel(labelInfo) {
  var _a;
  const { labelSpec } = labelInfo, labelPosition = null !== (_a = uniformLabelPosition(labelSpec.position)) && void 0 !== _a ? _a : "outside", position = labelPosition;
  let smartInvert;
  return smartInvert = labelSpec.smartInvert ? labelSpec.smartInvert : isString_default(labelPosition) && labelPosition.includes("inside"), {
    position,
    smartInvert
  };
}
function stackLabelX(datum2, series2, pos, offset) {
  return "horizontal" === series2.direction ? "middle" === pos ? 0.5 * (series2.totalPositionX(datum2, "end") + series2.totalPositionY(datum2, "start")) : "max" === pos ? series2.totalPositionX(datum2, datum2.end >= datum2.start ? "end" : "start") + offset : "min" === pos ? series2.totalPositionX(datum2, datum2.end >= datum2.start ? "start" : "end") - offset : series2.totalPositionX(datum2, "end") + (datum2.end >= datum2.start ? offset : -offset) : series2.totalPositionX(datum2, "index", 0.5);
}
function stackLabelY(datum2, series2, pos, offset) {
  return "horizontal" === series2.direction ? series2.totalPositionY(datum2, "index", 0.5) : "middle" === pos ? 0.5 * (series2.totalPositionY(datum2, "end") + series2.totalPositionY(datum2, "start")) : "max" === pos ? series2.totalPositionY(datum2, datum2.end >= datum2.start ? "end" : "start") - offset : "min" === pos ? series2.totalPositionY(datum2, datum2.end >= datum2.start ? "start" : "end") + offset : series2.totalPositionY(datum2, "end") + (datum2.end >= datum2.start ? -offset : offset);
}
function stackLabel(labelInfo, datumTransform, attributeTransform) {
  const series2 = labelInfo.series, labelSpec = labelInfo.labelSpec || {}, totalData = series2.getTotalData();
  return {
    customLayoutFunc: (labels) => labels.map((label) => {
      const pos = labelSpec.position || "withChange", offset = labelSpec.offset || 0, datum = datumTransform ? datumTransform(label.data) : label.data, attribute = textAttribute(labelInfo, datum, labelSpec.formatMethod);
      return attribute.x = stackLabelX(datum, series2, pos, offset), attribute.y = stackLabelY(datum, series2, pos, offset), "horizontal" === series2.direction ? attribute.textAlign = "middle" === pos ? "center" : "withChange" === pos && datum.end - datum.start >= 0 || "max" === pos ? "left" : "right" : attribute.textBaseline = "middle" === pos ? pos : "withChange" === pos && datum.end - datum.start >= 0 || "max" === pos ? "bottom" : "top", null == attributeTransform || attributeTransform(label, datum, attribute), createText(Object.assign(Object.assign({}, attribute), {
        id: label.id
      }));
    }),
    dataFilter: (labels) => {
      const result2 = [];
      return totalData.forEach((total) => {
        const label = labels.find((labelItem) => {
          var _a;
          return total.index === (null === (_a = labelItem.data) || void 0 === _a ? void 0 : _a[series2.getDimensionField()[0]]);
        });
        label && (label.data = total, result2.push(label));
      }), result2;
    },
    overlap: {
      strategy: []
    }
  };
}
function treemapLabel(labelInfo) {
  return {
    customLayoutFunc: (labels, text2) => text2,
    overlap: false
  };
}
function vennLabel(labelInfo) {
  return {
    customLayoutFunc: (labels, text2) => text2,
    smartInvert: true
  };
}
function LineLabel(labelInfo) {
  var _a, _b, _c, _d;
  const { labelSpec, series: series2 } = labelInfo, seriesData = null === (_c = null === (_b = null === (_a = series2.getViewDataStatistics) || void 0 === _a ? void 0 : _a.call(series2).latestData) || void 0 === _b ? void 0 : _b[series2.getSeriesField()]) || void 0 === _c ? void 0 : _c.values, data = seriesData ? seriesData.map((d, index) => ({
    [series2.getSeriesField()]: d,
    index
  })) : [];
  return {
    position: null !== (_d = labelSpec.position) && void 0 !== _d ? _d : "end",
    data
  };
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/waterfall/waterfall
var WaterfallSeries = class _WaterfallSeries extends BarSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.waterfall, this.transformerConstructor = WaterfallSeriesSpecTransformer, this._leaderLineMark = null, this._stackLabelMark = null, this._labelMark = null;
  }
  getTotalData() {
    var _a;
    return null === (_a = this._totalData) || void 0 === _a ? void 0 : _a.getLatestData();
  }
  initGroups() {
    const groupFields = this.getGroupFields();
    groupFields && groupFields.length && (this._groups = new Group2(groupFields), this._data && this._groups.initData(this._data.getDataView(), this._dataSet));
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this.setValueFieldToStack(), this._fieldX = [this._fieldX[0]], this._fieldY = [this._fieldY[0]], isNil_default(this._seriesField) && (this._seriesField = WaterfallDefaultSeriesField);
  }
  getSeriesKeys() {
    return this._seriesField === WaterfallDefaultSeriesField ? [this._theme.seriesFieldName.increase, this._theme.seriesFieldName.decrease, this._theme.seriesFieldName.total] : super.getSeriesKeys();
  }
  initData() {
    var _a;
    super.initData(), registerDataSetInstanceTransform(this._dataSet, "waterfallFillTotal", waterfallFillTotal), registerDataSetInstanceTransform(this._dataSet, "waterfall", waterfall2), (isNil_default(this._spec.total) || "end" === this._spec.total.type) && (null === (_a = this._rawData) || void 0 === _a || _a.transform({
      type: "waterfallFillTotal",
      options: {
        indexField: this.getGroupFields()[0],
        valueField: this.getStackValueField(),
        seriesField: this.getSeriesField(),
        seriesFieldName: this._theme.seriesFieldName,
        total: this._spec.total
      }
    }, false));
    const totalData = dataViewFromDataView(this.getViewData(), this._dataSet, {
      name: `${PREFIX}_series_${this.id}_totalData`
    });
    this.getViewData().target.removeListener("change", totalData.reRunAllTransform), this._totalData = new SeriesData(this._option, totalData), totalData.transform({
      type: "waterfall",
      options: {
        indexField: this.getGroupFields()[0],
        valueField: this.getStackValueField(),
        seriesField: this.getSeriesField(),
        seriesFieldName: this._theme.seriesFieldName,
        startAs: STACK_FIELD_START2,
        endAs: STACK_FIELD_END2,
        total: this._spec.total,
        groupData: () => this.getGroups().groupData
      }
    }, false);
  }
  initAnimation() {
    var _a, _b, _c, _e;
    const waterfallAnimationParams = {
      yField: "horizontal" === this.direction ? this._fieldY[0] : this.getStackValueField(),
      xField: "horizontal" === this.direction ? this.getStackValueField() : this._fieldX[0],
      direction: this.direction,
      growFrom: () => {
        var _a2, _b2;
        return "horizontal" === this.direction ? null === (_a2 = this._xAxisHelper) || void 0 === _a2 ? void 0 : _a2.getScale(0).scale(0) : null === (_b2 = this._yAxisHelper) || void 0 === _b2 ? void 0 : _b2.getScale(0).scale(0);
      }
    }, appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset, animationParams = getGroupAnimationParams(this);
    this._barMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("waterfall")) || void 0 === _c ? void 0 : _c(waterfallAnimationParams, appearPreset), userAnimationConfig("bar", this._spec, this._markAttributeContext), animationParams)), this._leaderLineMark && this._leaderLineMark.setAnimationConfig(animationConfig(null === (_e = Factory2.getAnimationInKey("fadeInOut")) || void 0 === _e ? void 0 : _e(), userAnimationConfig("leaderLine", this._spec, this._markAttributeContext)));
  }
  viewDataUpdate(d) {
    this._totalData.getDataView().reRunAllTransform(), this._totalData.updateData(), super.viewDataUpdate(d);
  }
  addViewDataFilter(_option) {
  }
  reFilterViewData() {
  }
  onEvaluateEnd(ctx) {
    super.onEvaluateEnd(ctx), this._totalData.updateData();
  }
  initMark() {
    var _a, _b;
    super.initMark();
    const leaderLine = this._createMark(_WaterfallSeries.mark.leaderLine, {
      key: "index",
      customShape: null === (_a = this._spec.leaderLine) || void 0 === _a ? void 0 : _a.customShape,
      stateSort: null === (_b = this._spec.leaderLine) || void 0 === _b ? void 0 : _b.stateSort
    });
    leaderLine && (this._leaderLineMark = leaderLine, leaderLine.setDataView(this._totalData.getDataView(), this._totalData.getProductId()));
  }
  initLabelMarkStyle(labelMark) {
    var _a;
    if (labelMark) {
      if (!this._labelMark && (null === (_a = this._spec.label) || void 0 === _a ? void 0 : _a.visible))
        return super.initLabelMarkStyle(labelMark), void (this._labelMark = labelMark);
      this._stackLabelMark = labelMark, labelMark.skipEncode = true, labelMark.setRule("stackLabel"), labelMark.setDataView(this._totalData.getDataView(), this._totalData.getProductId()), this.setMarkStyle(labelMark, {
        text: (datum) => {
          var _a2;
          return "absolute" === (null === (_a2 = this._spec.stackLabel) || void 0 === _a2 ? void 0 : _a2.valueType) ? datum.end : precisionSub(datum.end, datum.start);
        }
      });
    }
  }
  initTotalLabelMarkStyle(labelMark) {
    this.setMarkStyle(labelMark, {
      text: (datum) => {
        var _a;
        return "end" in datum ? "absolute" === (null === (_a = this._spec.totalLabel) || void 0 === _a ? void 0 : _a.valueType) ? datum.end : precisionSub(datum.end, datum.start) : "horizontal" === this.direction ? datum[this._fieldX[0]] : datum[this._fieldY[0]];
      }
    });
  }
  getTotalLabelComponentStyle(info) {
    return stackLabel(Object.assign(Object.assign({}, info), {
      series: this,
      labelSpec: this._spec.totalLabel
    }), (d) => {
      const index = "vertical" === this.direction ? d[this._fieldX[0]] : d[this._fieldY[0]];
      return this._totalData.getLatestData().find((_d) => _d.index === index);
    });
  }
  totalPositionX(datum, field3, pos = 0.5) {
    const { dataToPosition, getBandwidth } = this._xAxisHelper;
    return "horizontal" === this._direction ? valueInScaleRange(dataToPosition([datum[field3]], {
      bandPosition: this._bandPosition
    })) : dataToPosition([datum[field3]], {
      bandPosition: this._bandPosition
    }) + 0.5 * getBandwidth(0) - this._barMark.getAttribute("width", datum) * (0.5 - pos);
  }
  totalPositionY(datum, field3, pos = 0.5) {
    const { dataToPosition, getBandwidth } = this._yAxisHelper;
    return "horizontal" === this._direction ? dataToPosition([datum[field3]], {
      bandPosition: this._bandPosition
    }) + 0.5 * getBandwidth(0) - this._barMark.getAttribute("height", datum) * (0.5 - pos) : valueInScaleRange(dataToPosition([datum[field3]], {
      bandPosition: this._bandPosition
    }));
  }
  initMarkStyle() {
    super.initMarkStyle(), this._leaderLineMark && ("horizontal" === this._direction ? this.setMarkStyle(this._leaderLineMark, {
      visible: (datum) => !isNil_default(datum.lastIndex),
      x: (datum) => this.totalPositionX(datum, "lastEnd", 0),
      x1: (datum) => this.totalPositionX(datum, datum.isTotal ? "end" : "start", 0),
      y: (datum) => datum.lastIndex ? this.totalPositionY(datum, "lastIndex", 1) : 0,
      y1: (datum) => this.totalPositionY(datum, "index", 0)
    }, "normal", AttributeLevel2.Series) : this.setMarkStyle(this._leaderLineMark, {
      visible: (datum) => !isNil_default(datum.lastIndex),
      x: (datum) => datum.lastIndex ? this.totalPositionX(datum, "lastIndex", 1) : 0,
      x1: (datum) => this.totalPositionX(datum, "index", 0),
      y: (datum) => this.totalPositionY(datum, "lastEnd", 0),
      y1: (datum) => this.totalPositionY(datum, datum.isTotal ? "end" : "start", 0)
    }, "normal", AttributeLevel2.Series));
  }
};
WaterfallSeries.type = SeriesTypeEnum.waterfall, WaterfallSeries.mark = waterfallSeriesMark, WaterfallSeries.transformerConstructor = WaterfallSeriesSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/util/label-mark
function setRectLabelPos(component2, labelMark, position, offset, x, x14, y, y14, direction2) {
  component2.setMarkStyle(labelMark, {
    textAlign: (datum) => {
      if ("vertical" === direction2())
        return "center";
      const _x = x(datum), _x1 = x14(datum);
      if ("middle" === position)
        return "center";
      if (_x >= _x1) {
        if ("start" === position)
          return "left";
        if ("end" === position)
          return "right";
        if ("outside" === position)
          return "left";
      } else {
        if ("start" === position)
          return "right";
        if ("end" === position)
          return "left";
        if ("outside" === position)
          return "right";
      }
      return "center";
    },
    textBaseline: (datum) => {
      if ("horizontal" === direction2())
        return "middle";
      const _y = y(datum), _y1 = y14(datum);
      if ("middle" === position)
        return "middle";
      if (_y1 >= _y) {
        if ("start" === position)
          return "bottom";
        if ("end" === position)
          return "top";
        if ("outside" === position)
          return "bottom";
      } else {
        if ("start" === position)
          return "top";
        if ("end" === position)
          return "bottom";
        if ("outside" === position)
          return "top";
      }
      return "middle";
    }
  }), component2.setMarkStyle(labelMark, {
    x: (datum) => {
      const d = direction2(), _x = x(datum), _x1 = x14(datum);
      if ("vertical" === d)
        return (_x + _x1) / 2;
      if ("middle" === position)
        return (_x + _x1) / 2;
      if (_x >= _x1) {
        if ("start" === position)
          return _x1 + offset;
        if ("end" === position)
          return _x - offset;
        if ("outside" === position)
          return _x + offset;
      } else {
        if ("start" === position)
          return _x1 - offset;
        if ("end" === position)
          return _x + offset;
        if ("outside" === position)
          return _x - offset;
      }
      return (_x + _x1) / 2;
    },
    y: (datum) => {
      const d = direction2(), _y = y(datum), _y1 = y14(datum);
      if ("horizontal" === d)
        return (_y + _y1) / 2;
      if ("middle" === position)
        return (_y + _y1) / 2;
      if (_y >= _y1) {
        if ("start" === position)
          return _y1 + offset;
        if ("end" === position)
          return _y - offset;
        if ("outside" === position)
          return _y + offset;
      } else {
        if ("start" === position)
          return _y1 - offset;
        if ("end" === position)
          return _y + offset;
        if ("outside" === position)
          return _y - offset;
      }
      return (_y + _y1) / 2;
    }
  }, "normal", AttributeLevel.Series);
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/range-column/tooltip-helper
var RangeColumnSeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  getDefaultTooltipPattern(activeType) {
    return {
      visible: true,
      activeType,
      title: {
        key: void 0,
        value: this.dimensionTooltipTitleCallback,
        hasShape: false
      },
      content: [{
        key: this.markTooltipKeyCallback,
        value: (datum) => "horizontal" === this.series.getSpec().direction ? datum[this.series.getSpec().xField[0]] + "-" + datum[this.series.getSpec().xField[1]] : datum[this.series.getSpec().yField[0]] + "-" + datum[this.series.getSpec().yField[1]],
        hasShape: true,
        shapeType: this.shapeTypeCallback,
        shapeColor: this.shapeColorCallback,
        shapeStroke: this.shapeStrokeCallback,
        shapeHollow: false
      }]
    };
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/range-column/range-column-transformer
var RangeColumnSeriesSpecTransformer = class extends BarSeriesSpecTransformer {
  constructor() {
    super(...arguments), this._supportStack = false;
  }
  _transformLabelSpec(spec) {
    var _a;
    "bothEnd" !== (null === (_a = spec.label) || void 0 === _a ? void 0 : _a.position) && this._addMarkLabelSpec(spec, "bar");
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/range-column/range-column
var RangeColumnSeries = class _RangeColumnSeries extends BarSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.rangeColumn, this._barMarkType = "rect", this._barName = SeriesTypeEnum.bar, this.transformerConstructor = RangeColumnSeriesSpecTransformer;
  }
  initMark() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    this._initBarBackgroundMark();
    const labelPosition = null === (_a = this._spec.label) || void 0 === _a ? void 0 : _a.position;
    this._barMark = this._createMark(_RangeColumnSeries.mark.bar, {
      morph: shouldMarkDoMorph(this._spec, _RangeColumnSeries.mark.bar.name),
      defaultMorphElementKey: this.getDimensionField()[0],
      groupKey: this._seriesField,
      isSeriesMark: true,
      customShape: null === (_b = this._spec.bar) || void 0 === _b ? void 0 : _b.customShape,
      stateSort: null === (_c = this._spec.bar) || void 0 === _c ? void 0 : _c.stateSort
    }), false !== (null === (_d = this._spec.label) || void 0 === _d ? void 0 : _d.visible) && "bothEnd" === labelPosition && (false !== (null === (_f = null === (_e = this._spec.label) || void 0 === _e ? void 0 : _e.minLabel) || void 0 === _f ? void 0 : _f.visible) && (this._minLabelMark = this._createMark(_RangeColumnSeries.mark.minLabel, {
      markSpec: null === (_g = this._spec.label) || void 0 === _g ? void 0 : _g.minLabel
    })), false !== (null === (_j = null === (_h = this._spec.label) || void 0 === _h ? void 0 : _h.maxLabel) || void 0 === _j ? void 0 : _j.visible) && (this._maxLabelMark = this._createMark(_RangeColumnSeries.mark.maxLabel, {
      markSpec: null === (_k = this._spec.label) || void 0 === _k ? void 0 : _k.maxLabel
    })));
  }
  initMarkStyle() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    super.initMarkStyle();
    const minLabelMark = this._minLabelMark, minLabelSpec = null === (_a = this._spec.label) || void 0 === _a ? void 0 : _a.minLabel;
    if (minLabelMark) {
      this.setMarkStyle(minLabelMark, {
        fill: null !== (_c = null === (_b = null == minLabelSpec ? void 0 : minLabelSpec.style) || void 0 === _b ? void 0 : _b.fill) && void 0 !== _c ? _c : this.getColorAttribute(),
        text: (datum) => {
          const min3 = "horizontal" === this._spec.direction ? datum[this._spec.xField[0]] : datum[this._spec.yField[0]];
          return (null == minLabelSpec ? void 0 : minLabelSpec.formatMethod) ? minLabelSpec.formatMethod(min3, datum) : min3;
        }
      });
      const position = null !== (_d = null == minLabelSpec ? void 0 : minLabelSpec.position) && void 0 !== _d ? _d : "end", offset = null !== (_e = null == minLabelSpec ? void 0 : minLabelSpec.offset) && void 0 !== _e ? _e : "vertical" === this._direction ? -20 : -25;
      setRectLabelPos(this, minLabelMark, position, offset, (datum) => this._barMark.getAttribute("x", datum), (datum) => "vertical" === this._direction ? this._barMark.getAttribute("x", datum) + this._barMark.getAttribute("width", datum) : this._barMark.getAttribute("x1", datum), (datum) => this._barMark.getAttribute("y", datum), (datum) => "vertical" === this._direction ? this._barMark.getAttribute("y1", datum) : this._barMark.getAttribute("y", datum) + this._barMark.getAttribute("height", datum), () => this._direction);
    }
    const maxLabelMark = this._maxLabelMark, maxLabelSpec = null === (_f = this._spec.label) || void 0 === _f ? void 0 : _f.maxLabel;
    if (maxLabelMark) {
      this.setMarkStyle(maxLabelMark, {
        fill: null !== (_h = null === (_g = null == maxLabelSpec ? void 0 : maxLabelSpec.style) || void 0 === _g ? void 0 : _g.fill) && void 0 !== _h ? _h : this.getColorAttribute(),
        text: (datum) => {
          const max3 = "horizontal" === this._spec.direction ? datum[this._spec.xField[1]] : datum[this._spec.yField[1]];
          return (null == maxLabelSpec ? void 0 : maxLabelSpec.formatMethod) ? maxLabelSpec.formatMethod(max3, datum) : max3;
        }
      });
      const position = null !== (_j = null == maxLabelSpec ? void 0 : maxLabelSpec.position) && void 0 !== _j ? _j : "start", offset = null !== (_k = null == maxLabelSpec ? void 0 : maxLabelSpec.offset) && void 0 !== _k ? _k : "vertical" === this._direction ? -20 : -25;
      setRectLabelPos(this, maxLabelMark, position, offset, (datum) => this._barMark.getAttribute("x", datum), (datum) => "vertical" === this._direction ? this._barMark.getAttribute("x", datum) + this._barMark.getAttribute("width", datum) : this._barMark.getAttribute("x1", datum), (datum) => this._barMark.getAttribute("y", datum), (datum) => "vertical" === this._direction ? this._barMark.getAttribute("y1", datum) : this._barMark.getAttribute("y", datum) + this._barMark.getAttribute("height", datum), () => this._direction);
    }
  }
  initLabelMarkStyle(labelMark) {
    labelMark && (this.setMarkStyle(labelMark, {
      text: (datum) => {
        let min3, max3;
        return "horizontal" === this._spec.direction ? (min3 = datum[this._spec.xField[0]], max3 = datum[this._spec.xField[1]]) : (min3 = datum[this._spec.yField[0]], max3 = datum[this._spec.yField[1]]), min3 + "-" + max3;
      },
      z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
    }), this._labelMark = labelMark);
  }
  _dataToPosX(datum) {
    return this._xAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this._spec.xField[0]), {
      bandPosition: this._bandPosition
    });
  }
  _dataToPosX1(datum) {
    return this._xAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this._spec.xField[1]), {
      bandPosition: this._bandPosition
    });
  }
  _dataToPosY(datum) {
    return this._yAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this._spec.yField[0]), {
      bandPosition: this._bandPosition
    });
  }
  _dataToPosY1(datum) {
    return this._yAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this._spec.yField[1]), {
      bandPosition: this._bandPosition
    });
  }
  initAnimation() {
    var _a, _b, _c, _d, _e;
    const animationParams = getGroupAnimationParams(this), appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
    this._barMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("rangeColumn")) || void 0 === _c ? void 0 : _c({
      direction: this.direction
    }, appearPreset), userAnimationConfig("bar", this._spec, this._markAttributeContext), animationParams)), this._minLabelMark && this._minLabelMark.setAnimationConfig(animationConfig(null === (_d = Factory2.getAnimationInKey("fadeInOut")) || void 0 === _d ? void 0 : _d(), userAnimationConfig("label", this._spec, this._markAttributeContext), animationParams)), this._maxLabelMark && this._maxLabelMark.setAnimationConfig(animationConfig(null === (_e = Factory2.getAnimationInKey("fadeInOut")) || void 0 === _e ? void 0 : _e(), userAnimationConfig("label", this._spec, this._markAttributeContext), animationParams));
  }
  initTooltip() {
    this._tooltipHelper = new RangeColumnSeriesTooltipHelper(this), this._barMark && this._tooltipHelper.activeTriggerSet.mark.add(this._barMark), this._minLabelMark && this._tooltipHelper.ignoreTriggerSet.mark.add(this._minLabelMark), this._maxLabelMark && this._tooltipHelper.ignoreTriggerSet.mark.add(this._maxLabelMark), this._labelMark && this._tooltipHelper.ignoreTriggerSet.mark.add(this._labelMark);
  }
};
RangeColumnSeries.type = SeriesTypeEnum.rangeColumn, RangeColumnSeries.mark = rangeColumnSeriesMark, RangeColumnSeries.transformerConstructor = RangeColumnSeriesSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/range-column/3d/range-column-3d
var RangeColumn3dSeries = class extends RangeColumnSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.rangeColumn3d, this._barMarkType = "rect3d", this._barName = SeriesTypeEnum.bar3d;
  }
};
RangeColumn3dSeries.type = SeriesTypeEnum.rangeColumn3d, RangeColumn3dSeries.mark = rangeColumn3dSeriesMark;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/range-area/tooltip-helper
var RangeAreaSeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  getDefaultTooltipPattern(activeType, dimensionInfo) {
    switch (activeType) {
      case "mark":
      case "group":
        return {
          visible: true,
          activeType,
          title: {
            key: void 0,
            value: this.dimensionTooltipTitleCallback,
            hasShape: false
          },
          content: [{
            key: this.markTooltipKeyCallback,
            value: this.markTooltipValueCallback,
            hasShape: true,
            shapeType: this.shapeTypeCallback,
            shapeColor: this.shapeColorCallback,
            shapeStroke: this.shapeStrokeCallback,
            shapeHollow: false
          }]
        };
      case "dimension":
        if (dimensionInfo) {
          const title3 = {
            key: void 0,
            value: this._getDimensionData,
            hasShape: false
          }, content = [];
          return dimensionInfo.forEach(({ data }) => data.forEach(({ series: series2 }) => {
            "rangeArea" === series2.type && content.push({
              seriesId: series2.id,
              key: this.markTooltipKeyCallback,
              value: (datum) => "horizontal" === this.series.getSpec().direction ? datum[this.series.getSpec().xField[0]] + "-" + datum[this.series.getSpec().xField[1]] : datum[this.series.getSpec().yField[0]] + "-" + datum[this.series.getSpec().yField[1]],
              hasShape: true,
              shapeType: this.shapeTypeCallback,
              shapeColor: this.shapeColorCallback,
              shapeStroke: this.shapeStrokeCallback,
              shapeHollow: false
            });
          })), {
            visible: true,
            activeType,
            title: title3,
            content
          };
        }
    }
    return null;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/range-area/range-area
var RangeAreaSeries = class _RangeAreaSeries extends AreaSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.rangeArea;
  }
  initMark() {
    var _a;
    const { customShape, stateSort } = null !== (_a = this._spec.area) && void 0 !== _a ? _a : {};
    this._areaMark = this._createMark(_RangeAreaSeries.mark.area, {
      defaultMorphElementKey: this.getDimensionField()[0],
      groupKey: this._seriesField,
      isSeriesMark: true,
      customShape,
      stateSort
    });
  }
  initMarkStyle() {
    this.initAreaMarkStyle();
  }
  initAreaMarkStyle() {
    const areaMark = this._areaMark;
    areaMark && (super.initAreaMarkStyle(), "horizontal" === this._direction ? this.setMarkStyle(this._areaMark, {
      x1: (datum) => {
        if (!this._xAxisHelper)
          return Number.NaN;
        const { dataToPosition } = this._xAxisHelper;
        return dataToPosition(this.getDatumPositionValues(datum, this._spec.xField[1]), {
          bandPosition: this._bandPosition
        });
      }
    }, "normal", AttributeLevel.Series) : this.setMarkStyle(this._areaMark, {
      y1: (datum) => {
        if (!this._yAxisHelper)
          return Number.NaN;
        const { dataToPosition } = this._yAxisHelper;
        return dataToPosition(this.getDatumPositionValues(datum, this._spec.yField[1]), {
          bandPosition: this._bandPosition
        });
      }
    }, "normal", AttributeLevel.Series), this.setMarkStyle(areaMark, {
      stroke: false
    }, "normal", AttributeLevel.Series));
  }
  initTooltip() {
    this._tooltipHelper = new RangeAreaSeriesTooltipHelper(this), this._areaMark && this._tooltipHelper.activeTriggerSet.dimension.add(this._areaMark);
  }
  _isFieldAllValid() {
    const viewStatistics = this.getViewDataStatistics(), fields2 = this.fieldY;
    return !!(viewStatistics && viewStatistics.latestData && fields2.length) && fields2.every((field3) => viewStatistics.latestData[field3] && viewStatistics.latestData[field3].allValid);
  }
};
RangeAreaSeries.type = SeriesTypeEnum.rangeArea, RangeAreaSeries.mark = rangeAreaSeriesMark;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/data/transforms/pie
function transformInvalidValue(value) {
  return couldBeValidNumber(value) ? Number.parseFloat(value) : 0;
}
var pie2 = (originData, op) => {
  const data = originData.map((datum) => Object.assign({}, datum));
  if (!data || 0 === data.length)
    return data;
  const { angleField, startAngle, endAngle, minAngle, asStartAngle, asEndAngle, asMiddleAngle, asRadian, asRatio, asQuadrant, asK } = op, appendArcInfo = (data2, startAngle2, angle2) => {
    data2[asStartAngle] = startAngle2, data2[asEndAngle] = startAngle2 + angle2, data2[asMiddleAngle] = startAngle2 + angle2 / 2, data2[asRadian] = angle2, data2[asQuadrant] = computeQuadrant(startAngle2 + angle2 / 2);
  };
  let total = 0, max3 = -1 / 0;
  for (let index = 0; index < data.length; index++) {
    const angleFieldValue = transformInvalidValue(data[index][angleField]);
    total += angleFieldValue, max3 = Math.max(angleFieldValue, max3), data[index][ARC_TRANSFORM_VALUE] = angleFieldValue;
  }
  const valueList = data.map((d) => Number(d[angleField])), angleRange = endAngle - startAngle;
  let lastAngle = startAngle, restAngle = angleRange, largeThanMinAngleTotal = 0;
  const percents = getPercentValue(valueList);
  if (data.forEach((d, i) => {
    const angleFieldValue = d[ARC_TRANSFORM_VALUE], ratio = total ? angleFieldValue / total : 0;
    let radian = ratio * angleRange;
    radian < minAngle ? (radian = minAngle, restAngle -= minAngle) : largeThanMinAngleTotal += angleFieldValue;
    const dStartAngle = lastAngle, dEndAngle = lastAngle + radian;
    d[asRatio] = ratio, d[asK] = max3 ? angleFieldValue / max3 : 0, d._percent_ = percents[i], appendArcInfo(d, dStartAngle, radian), lastAngle = dEndAngle;
  }), restAngle < angleRange)
    if (restAngle <= 1e-3) {
      const angle2 = angleRange / data.length;
      data.forEach((d, index) => {
        appendArcInfo(d, startAngle + index * angle2, angle2);
      });
    } else {
      const unitRadian = restAngle / largeThanMinAngleTotal;
      lastAngle = startAngle, data.forEach((d) => {
        const angle2 = d[asRadian] === minAngle ? minAngle : d[ARC_TRANSFORM_VALUE] * unitRadian;
        appendArcInfo(d, lastAngle, angle2), lastAngle += angle2;
      });
    }
  return 0 !== total && (data[data.length - 1][asEndAngle] = endAngle), data;
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/pie/animation/animation
function pieGrowOption(pieParams, isOverall, state) {
  return (datum, element, params2) => isOverall ? "radius" === pieParams.growField ? {
    overall: 0
  } : {
    overall: pieParams.growFrom(datum, element, state)
  } : {
    overall: false
  };
}
var Appear_Grow2 = (params2) => ({
  type: "radius" === params2.growField ? "growRadiusIn" : "growAngleIn",
  options: pieGrowOption(params2, true, AnimationStateEnum.appear)
});
var Appear_FadeIn3 = {
  type: "fadeIn"
};
var pieEnter = (params2) => ({
  type: "radius" === params2.growField ? "growRadiusIn" : "growAngleIn",
  easing: "linear",
  options: pieGrowOption(params2, true, AnimationStateEnum.enter)
});
var pieExit = (params2) => ({
  type: "radius" === params2.growField ? "growRadiusOut" : "growAngleOut",
  easing: "linear",
  options: pieGrowOption(params2, true, AnimationStateEnum.exit)
});
var pieDisappear = (params2) => ({
  type: "radius" === params2.growField ? "growRadiusOut" : "growAngleOut",
  options: pieGrowOption(params2, true, AnimationStateEnum.exit)
});
function piePresetAnimation(params2, preset) {
  if (false === preset)
    return {};
  switch (preset) {
    case "fadeIn":
      return Appear_FadeIn3;
    case "growRadius":
      return Appear_Grow2(Object.assign(Object.assign({}, params2), {
        growField: "radius"
      }));
    default:
      return Appear_Grow2(Object.assign(Object.assign({}, params2), {
        growField: "angle"
      }));
  }
}
var registerPieAnimation = () => {
  Factory2.registerAnimation("pie", (params2, preset) => ({
    appear: piePresetAnimation(params2, preset),
    enter: pieEnter(params2),
    exit: pieExit(params2),
    disappear: pieDisappear(params2)
  }));
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/pie/animation/centerOffset
function centerOffsetConfig(mark, originalConfig) {
  var _a, _b, _c, _d;
  const offset = null !== (_b = null === (_a = originalConfig.options) || void 0 === _a ? void 0 : _a.distance) && void 0 !== _b ? _b : 10, duration = isValidNumber_default(originalConfig.duration) ? originalConfig.duration / 2 : 1e3, easing = null !== (_c = originalConfig.options.easing) && void 0 !== _c ? _c : "cubicOut";
  return {
    oneByOne: originalConfig.oneByOne,
    loop: null !== (_d = originalConfig.loop) && void 0 !== _d && _d,
    timeSlices: [{
      duration,
      effects: {
        easing,
        channel: {
          x: {
            from: (datum) => mark.getAttribute("x", datum),
            to: (datum) => mark.getAttribute("x", datum) + polarToCartesian({
              x: 0,
              y: 0
            }, offset, datum[ARC_MIDDLE_ANGLE]).x
          },
          y: {
            from: (datum) => mark.getAttribute("y", datum),
            to: (datum) => mark.getAttribute("y", datum) + polarToCartesian({
              x: 0,
              y: 0
            }, offset, datum[ARC_MIDDLE_ANGLE]).y
          }
        }
      }
    }, {
      duration,
      effects: {
        easing,
        channel: {
          x: {
            to: (datum) => mark.getAttribute("x", datum),
            from: (datum) => mark.getAttribute("x", datum) + polarToCartesian({
              x: 0,
              y: 0
            }, offset, datum[ARC_MIDDLE_ANGLE]).x
          },
          y: {
            to: (datum) => mark.getAttribute("y", datum),
            from: (datum) => mark.getAttribute("y", datum) + polarToCartesian({
              x: 0,
              y: 0
            }, offset, datum[ARC_MIDDLE_ANGLE]).y
          }
        }
      }
    }]
  };
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/pie/pie-transformer
var PieSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "pie");
  }
  _mergeThemeToSpec(spec, chartSpec) {
    const theme2 = this._theme;
    let newSpec = spec;
    if (this._shouldMergeThemeToSpec()) {
      const specFromChart = this._getDefaultSpecFromChart(chartSpec);
      newSpec = mergeSpec({}, this._theme, specFromChart, spec);
      const getMergedLabelSpec = (position, label) => mergeSpec({}, "inside" === position ? this._theme.innerLabel : this._theme.outerLabel, label);
      isArray_default(newSpec.label) ? newSpec.label = newSpec.label.map((label) => getMergedLabelSpec(label.position, label)) : newSpec.label = getMergedLabelSpec(newSpec.label.position, newSpec.label);
    }
    return {
      spec: newSpec,
      theme: theme2
    };
  }
  _getDefaultSpecFromChart(chartSpec) {
    var _a;
    const spec = null !== (_a = super._getDefaultSpecFromChart(chartSpec)) && void 0 !== _a ? _a : {}, { centerX, centerY } = chartSpec;
    return isValid_default(centerX) && (spec.centerX = centerX), isValid_default(centerY) && (spec.centerY = centerY), Object.keys(spec).length > 0 ? spec : void 0;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/pie/pie
var BasePieSeries = class _BasePieSeries extends PolarSeries {
  constructor() {
    super(...arguments), this.transformerConstructor = PieSeriesSpecTransformer, this._pieMarkName = "pie", this._pieMarkType = "arc", this._startAngle = POLAR_START_RADIAN, this._endAngle = POLAR_END_RADIAN, this._pieMark = null, this._labelMark = null, this._labelLineMark = null, this.dataToCentralPosition = (datum) => {
      const angle2 = datum[ARC_MIDDLE_ANGLE];
      if (isNil_default(angle2))
        return null;
      const radius = this.computeDatumRadius(datum), innerRadius = this.computeDatumInnerRadius(datum), center2 = this.computeCenter(datum);
      return polarToCartesian(center2, (radius + innerRadius) / 2, angle2);
    };
  }
  getCenter() {
    var _a, _b, _c, _d;
    const { width, height } = this._region.getLayoutRect();
    return {
      x: null !== (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.centerX) && void 0 !== _b ? _b : width / 2,
      y: null !== (_d = null === (_c = this._spec) || void 0 === _c ? void 0 : _c.centerY) && void 0 !== _d ? _d : height / 2
    };
  }
  _buildMarkAttributeContext() {
    super._buildMarkAttributeContext(), this._markAttributeContext.getCenter = () => ({
      x: () => this.getCenter().x,
      y: () => this.getCenter().y
    }), this._markAttributeContext.startAngleScale = (datum) => this.startAngleScale(datum), this._markAttributeContext.endAngleScale = (datum) => this.endAngleScale(datum);
  }
  setAttrFromSpec() {
    var _a, _b;
    super.setAttrFromSpec(), this._centerOffset = null !== (_a = this._spec.centerOffset) && void 0 !== _a ? _a : 0, this._cornerRadius = null !== (_b = this._spec.cornerRadius) && void 0 !== _b ? _b : 0;
    const normalized = normalizeStartEndAngle(isValid_default(this._spec.startAngle) ? degreeToRadian(this._spec.startAngle) : this._startAngle, isValid_default(this._spec.endAngle) ? degreeToRadian(this._spec.endAngle) : this._endAngle);
    this._startAngle = normalized.startAngle, this._endAngle = normalized.endAngle, this._padAngle = isValid_default(this._spec.padAngle) ? degreeToRadian(this._spec.padAngle) : 0, this.setAngleField(this._spec.valueField || this._spec.angleField), this._spec.categoryField && this.setSeriesField(this._spec.categoryField), this._radiusField = [], this._specAngleField = this._angleField.slice(), this._specRadiusField = [];
  }
  initData() {
    super.initData();
    const viewData = this.getViewData();
    if (!viewData)
      return;
    registerDataSetInstanceTransform(this._dataSet, "pie", pie2), viewData.transform({
      type: "pie",
      options: {
        angleField: this._angleField[0],
        startAngle: this._startAngle,
        endAngle: this._endAngle,
        minAngle: isValid_default(this._spec.minAngle) ? degreeToRadian(this._spec.minAngle) : 0,
        asStartAngle: ARC_START_ANGLE,
        asEndAngle: ARC_END_ANGLE,
        asRatio: ARC_RATIO,
        asMiddleAngle: ARC_MIDDLE_ANGLE,
        asRadian: ARC_RADIAN,
        asQuadrant: ARC_QUADRANT,
        asK: ARC_K
      }
    }, false);
    const viewDataLabel = new DataView(this._dataSet, {
      name: `${PREFIX}_series_${this.id}_viewDataLabel`
    });
    viewDataLabel.parse([this.getViewData()], {
      type: "dataview"
    }), this._viewDataLabel = new SeriesData(this._option, viewDataLabel);
  }
  initMark() {
    var _a, _b;
    this._pieMark = this._createMark(Object.assign(Object.assign({}, _BasePieSeries.mark.pie), {
      name: this._pieMarkName,
      type: this._pieMarkType
    }), {
      morph: shouldMarkDoMorph(this._spec, this._pieMarkName),
      defaultMorphElementKey: this._seriesField,
      key: DEFAULT_DATA_KEY,
      groupKey: this._seriesField,
      skipBeforeLayouted: true,
      isSeriesMark: true,
      customShape: null === (_a = this._spec.pie) || void 0 === _a ? void 0 : _a.customShape,
      stateSort: null === (_b = this._spec.pie) || void 0 === _b ? void 0 : _b.stateSort
    });
  }
  startAngleScale(datum) {
    return field2(ARC_START_ANGLE)(datum);
  }
  endAngleScale(datum) {
    return field2(ARC_END_ANGLE)(datum);
  }
  initMarkStyle() {
    const pieMark = this._pieMark;
    pieMark && this.setMarkStyle(pieMark, {
      x: () => this.getCenter().x,
      y: () => this.getCenter().y,
      fill: this.getColorAttribute(),
      outerRadius: isSpecValueWithScale(this._outerRadius) ? this._outerRadius : () => this._computeLayoutRadius() * this._outerRadius,
      innerRadius: isSpecValueWithScale(this._innerRadius) ? this._innerRadius : () => this._computeLayoutRadius() * this._innerRadius,
      cornerRadius: () => this._computeLayoutRadius() * this._cornerRadius,
      startAngle: (datum) => this.startAngleScale(datum),
      endAngle: (datum) => this.endAngleScale(datum),
      padAngle: this._padAngle,
      centerOffset: this._centerOffset
    }, "normal", AttributeLevel.Series);
  }
  initInteraction() {
    this._parseInteractionConfig(this._pieMark ? [this._pieMark] : []);
  }
  initTooltip() {
    super.initTooltip(), this._pieMark && this._tooltipHelper.activeTriggerSet.mark.add(this._pieMark);
  }
  initMarkStyleWithSpec(mark, spec, key) {
    if (super.initMarkStyleWithSpec(mark, spec, key), mark.name === this._pieMarkName) {
      const pieSpec = this.getSpec()[mark.name];
      if (pieSpec)
        for (const state in pieSpec.state || {})
          this.setMarkStyle(mark, this.generateRadiusStyle(pieSpec.state[state]), state, AttributeLevel.User_Mark);
    }
  }
  initLabelMarkStyle(textMark) {
    textMark && this.setMarkStyle(textMark, {
      visible: field2(DEFAULT_LABEL_VISIBLE).bind(this),
      text: (datum) => datum[this.getDimensionField()[0]],
      fill: this.getColorAttribute(),
      z: this.dataToPositionZ.bind(this)
    });
  }
  afterInitMark() {
    super.afterInitMark();
  }
  initEvent() {
    var _a;
    super.initEvent(), null === (_a = this._viewDataLabel.getDataView()) || void 0 === _a || _a.target.addListener("change", this.viewDataLabelUpdate.bind(this));
  }
  initGroups() {
  }
  onLayoutEnd(ctx) {
    this._viewDataLabel.getDataView().reRunAllTransform(), this.onMarkPositionUpdate(), super.onLayoutEnd(ctx);
  }
  getDimensionField() {
    return this._seriesField ? [this._seriesField] : [];
  }
  getMeasureField() {
    return this._specAngleField;
  }
  viewDataLabelUpdate() {
    this.event.emit(ChartEvent.viewDataLabelUpdate, {
      model: this
    }), this._viewDataLabel.updateData();
  }
  generateRadiusStyle(spec) {
    if (!spec)
      return;
    const style = {};
    return spec.outerRadius && (style.outerRadius = () => this._computeLayoutRadius() * spec.outerRadius), spec.innerRadius && (style.innerRadius = () => this._computeLayoutRadius() * spec.innerRadius), spec.cornerRadius && (style.cornerRadius = () => this._computeLayoutRadius() * spec.cornerRadius), style;
  }
  computeCenter(datum) {
    return {
      x: this._pieMark.getAttribute("x", datum, "normal"),
      y: this._pieMark.getAttribute("y", datum, "normal")
    };
  }
  getRadius(state = "normal") {
    var _a, _b, _c, _d, _e, _f, _g;
    const styleRadius = "normal" === state ? null === (_c = null === (_b = this.getSpec()[(null === (_a = this._pieMark) || void 0 === _a ? void 0 : _a.name) || "pie"]) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.outerRadius : null === (_g = null === (_f = null === (_e = this.getSpec()[(null === (_d = this._pieMark) || void 0 === _d ? void 0 : _d.name) || "pie"]) || void 0 === _e ? void 0 : _e.state) || void 0 === _f ? void 0 : _f[state]) || void 0 === _g ? void 0 : _g.outerRadius;
    return null != styleRadius ? styleRadius : this._outerRadius;
  }
  getInnerRadius(state = "normal") {
    var _a, _b, _c, _d, _e, _f, _g;
    const styleRadius = "normal" === state ? null === (_c = null === (_b = this.getSpec()[(null === (_a = this._pieMark) || void 0 === _a ? void 0 : _a.name) || "pie"]) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.innerRadius : null === (_g = null === (_f = null === (_e = this.getSpec()[(null === (_d = this._pieMark) || void 0 === _d ? void 0 : _d.name) || "pie"]) || void 0 === _e ? void 0 : _e.state) || void 0 === _f ? void 0 : _f[state]) || void 0 === _g ? void 0 : _g.innerRadius;
    return null != styleRadius ? styleRadius : this._innerRadius;
  }
  computeRadius(r, k2) {
    return this._computeLayoutRadius() * r * (isNil_default(k2) ? 1 : k2) + this._centerOffset;
  }
  computeDatumRadius(datum, state) {
    return this._computeLayoutRadius() * this.getRadius(state) + this._centerOffset;
  }
  _compareSpec(spec, prevSpec, ignoreCheckKeys) {
    (ignoreCheckKeys = null != ignoreCheckKeys ? ignoreCheckKeys : {
      data: true
    }).centerX = true, ignoreCheckKeys.centerX = true, ignoreCheckKeys.centerY = true, ignoreCheckKeys.centerOffset = true, ignoreCheckKeys.radius = true, ignoreCheckKeys.innerRadius = true, ignoreCheckKeys.cornerRadius = true, ignoreCheckKeys.startAngle = true, ignoreCheckKeys.endAngle = true, ignoreCheckKeys.padAngle = true;
    const { centerX, centerY, centerOffset, radius, innerRadius, cornerRadius, startAngle, endAngle, padAngle } = prevSpec, result2 = super._compareSpec(spec, prevSpec, ignoreCheckKeys);
    return (spec = null != spec ? spec : {}).centerY === centerY && spec.centerX === centerX && spec.centerOffset === centerOffset && spec.radius === radius && spec.innerRadius === innerRadius && spec.cornerRadius === cornerRadius && spec.startAngle === startAngle && spec.endAngle === endAngle && spec.padAngle === padAngle || (result2.reRender = true, result2.change = true), result2;
  }
  computeDatumInnerRadius(datum, state) {
    return this._computeLayoutRadius() * this.getInnerRadius(state) + this._centerOffset;
  }
  dataToPosition(datum, checkInViewData) {
    const angle2 = datum[ARC_MIDDLE_ANGLE];
    if (isNil_default(angle2))
      return null;
    if (checkInViewData && !this.isDatumInViewData(datum))
      return null;
    const radius = this.computeDatumRadius(datum), center2 = this.computeCenter(datum);
    return polarToCartesian(center2, radius, angle2);
  }
  initAnimation() {
    var _a, _b;
    const animationParams = {
      growFrom: (datum, element, state) => {
        var _a2;
        if (state === AnimationStateEnum.appear)
          return this._startAngle;
        if (state === AnimationStateEnum.disappear)
          return this._endAngle;
        const outState = [AnimationStateEnum.disappear, AnimationStateEnum.exit], markElements = element.mark.elements, data = datum, dataIndex = null == data ? void 0 : data[DEFAULT_DATA_INDEX];
        if (void 0 === markElements.find((e) => {
          var _a3;
          return (null === (_a3 = e.data[0]) || void 0 === _a3 ? void 0 : _a3[DEFAULT_DATA_INDEX]) < dataIndex;
        }))
          return this._startAngle;
        if (void 0 === markElements.find((e) => {
          var _a3;
          return (null === (_a3 = e.data[0]) || void 0 === _a3 ? void 0 : _a3[DEFAULT_DATA_INDEX]) > dataIndex;
        }))
          return this._endAngle;
        const prevMarkElement = [...markElements].reverse().find((e) => {
          var _a3;
          return (null === (_a3 = e.data[0]) || void 0 === _a3 ? void 0 : _a3[DEFAULT_DATA_INDEX]) < dataIndex;
        });
        return outState.includes(state) ? null === (_a2 = null == prevMarkElement ? void 0 : prevMarkElement.getNextGraphicAttributes()) || void 0 === _a2 ? void 0 : _a2.endAngle : null == prevMarkElement ? void 0 : prevMarkElement.getGraphicAttribute("endAngle", true);
      }
    }, appearPreset = null === (_a = this._spec.animationAppear) || void 0 === _a ? void 0 : _a.preset;
    if (this._pieMark) {
      const pieAnimationConfig = animationConfig(null === (_b = Factory2.getAnimationInKey("pie")) || void 0 === _b ? void 0 : _b(animationParams, appearPreset), userAnimationConfig("pie", this._spec, this._markAttributeContext));
      pieAnimationConfig.normal && pieAnimationConfig.normal.type && (pieAnimationConfig.normal = centerOffsetConfig(this._pieMark, pieAnimationConfig.normal)), this._pieMark.setAnimationConfig(pieAnimationConfig);
    }
  }
  getDefaultShapeType() {
    return "circle";
  }
  getGroupFields() {
    return [];
  }
  getStackGroupFields() {
    return [];
  }
  getStackValueField() {
    return "";
  }
  _noAnimationDataKey(datum, index) {
    return index;
  }
  getActiveMarks() {
    return [this._pieMark];
  }
};
BasePieSeries.transformerConstructor = PieSeriesSpecTransformer, BasePieSeries.mark = pieSeriesMark;
var PieSeries = class extends BasePieSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.pie;
  }
};
PieSeries.type = SeriesTypeEnum.pie;
var registerPieSeries = () => {
  registerArcMark(), registerPieAnimation(), Factory2.registerSeries(PieSeries.type, PieSeries);
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/mark/arc-3d
var Arc3dMark = class _Arc3dMark extends BaseArcMark {
  constructor() {
    super(...arguments), this.type = _Arc3dMark.type, this._support3d = true;
  }
};
Arc3dMark.type = "arc3d";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/pie/3d/pie-3d-transformer
var Pie3dSeriesSpecTransformer = class extends PieSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "pie3d");
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/pie/3d/pie-3d
var Pie3dSeries = class extends BasePieSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.pie3d, this._pieMarkName = "pie3d", this._pieMarkType = "arc3d", this.transformerConstructor = Pie3dSeriesSpecTransformer;
  }
  setAttrFromSpec() {
    var _a, _b;
    super.setAttrFromSpec(), this._angle3d = null !== (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.angle3d) && void 0 !== _b ? _b : -Math.PI / 3;
  }
  initMarkStyle() {
    super.initMarkStyle();
    const pieMark = this._pieMark;
    pieMark && this.setMarkStyle(pieMark, {
      beta: () => this._angle3d
    }, "normal", AttributeLevel.Series);
  }
  initLabelMarkStyle(textMark, spec = {}) {
    if (!textMark)
      return;
    super.initLabelMarkStyle(textMark);
    const params3d = {};
    textMark.setSupport3d(true), params3d.beta = this._angle3d, params3d.anchor3d = (datum) => {
      const { x, y } = this.getCenter();
      return [x, y];
    }, params3d.angle = (datum) => {
      const angle2 = datum[ARC_MIDDLE_ANGLE];
      return "inside" === spec.position ? radianToDegree(angle2) : 0;
    }, this.setMarkStyle(textMark, Object.assign(Object.assign({}, params3d), {
      z: 100
    }), void 0, AttributeLevel.Mark);
  }
};
Pie3dSeries.type = SeriesTypeEnum.pie3d, Pie3dSeries.mark = pie3dSeriesMark, Pie3dSeries.transformerConstructor = Pie3dSeriesSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/constant/scatter
var SCATTER_DEFAULT_SIZE = 10;
var SCATTER_DEFAULT_RANGE_SIZE = [10, 20];
var SCATTER_DEFAULT_SIZE_SCALE_TYPE = ScaleEnum.Linear;
var SCATTER_DEFAULT_SHAPE = "circle";
var SCATTER_DEFAULT_SHAPE_SCALE_TYPE = ScaleEnum.Ordinal;
var SCATTER_DEFAULT_RANGE_SHAPE = ["circle", "square", "triangle", "diamond", "star"];

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/scatter/scatter-transformer
var ScatterSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "point");
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/scatter/scatter
var ScatterSeries = class _ScatterSeries extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.scatter, this.transformerConstructor = ScatterSeriesSpecTransformer, this._invalidType = "zero";
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this._size = this._spec.size, this._sizeField = this._spec.sizeField, this._shape = this._spec.shape, this._shapeField = this._spec.shapeField;
  }
  _getSeriesAttribute(field3, spec, { defaultScaleType, defaultRange }, key) {
    var _a, _b, _c, _d;
    if (isFunction_default(spec))
      return spec;
    if (isArray_default(spec)) {
      if (isNil_default(field3))
        return null === (_a = this._option) || void 0 === _a || _a.onError(`${key}Field is required.`), spec;
      if ("ordinal" !== defaultScaleType && spec.length > 2)
        return null === (_b = this._option) || void 0 === _b || _b.onError(`${key} length is invalid, specify up to 2 ${key}s.`), spec;
      const scaleName = `${PREFIX}_series_scatter_${this.id}_scale_${key}`;
      return this._option.globalScale.registerModelScale({
        id: scaleName,
        type: defaultScaleType,
        domain: [{
          dataId: this._rawData.name,
          fields: [field3]
        }],
        range: spec
      }), {
        scale: scaleName,
        field: field3
      };
    }
    if (isObject_default(spec)) {
      if (isNil_default(field3))
        return null === (_c = this._option) || void 0 === _c || _c.onError(`${key}Field is required.`), spec;
      const scaleName = `${PREFIX}_series_scatter_${this.id}_scale_${key}`, visualSpec = Object.assign({
        id: scaleName,
        type: defaultScaleType,
        domain: [{
          dataId: this._rawData.name,
          fields: [field3]
        }],
        range: defaultRange
      }, spec);
      return this._option.globalScale.registerModelScale(visualSpec), {
        scale: visualSpec.id,
        field: field3
      };
    }
    return null === (_d = this._option) || void 0 === _d || _d.onError(`${key} attribute is invalid.`), spec;
  }
  getSizeAttribute(field3, sizeSpec) {
    return isNil_default(sizeSpec) ? SCATTER_DEFAULT_SIZE : isNumber_default(sizeSpec) ? sizeSpec : isString_default(sizeSpec) && isNumeric_default(sizeSpec) ? parseFloat(sizeSpec) : this._getSeriesAttribute(field3, sizeSpec, {
      defaultScaleType: SCATTER_DEFAULT_SIZE_SCALE_TYPE,
      defaultRange: SCATTER_DEFAULT_RANGE_SIZE
    }, "size");
  }
  getShapeAttribute(field3, shapeSpec) {
    return isNil_default(shapeSpec) ? SCATTER_DEFAULT_SHAPE : isString_default(shapeSpec) ? shapeSpec : this._getSeriesAttribute(field3, shapeSpec, {
      defaultScaleType: SCATTER_DEFAULT_SHAPE_SCALE_TYPE,
      defaultRange: SCATTER_DEFAULT_RANGE_SHAPE
    }, "shape");
  }
  initMark() {
    var _a, _b;
    const progressive = {
      progressiveStep: this._spec.progressiveStep,
      progressiveThreshold: this._spec.progressiveThreshold,
      large: this._spec.large,
      largeThreshold: this._spec.largeThreshold
    };
    this._symbolMark = this._createMark(_ScatterSeries.mark.point, {
      morph: shouldMarkDoMorph(this._spec, _ScatterSeries.mark.point.name),
      defaultMorphElementKey: this.getDimensionField()[0],
      groupKey: this._seriesField,
      progressive,
      isSeriesMark: true,
      customShape: null === (_a = this._spec.point) || void 0 === _a ? void 0 : _a.customShape,
      stateSort: null === (_b = this._spec.point) || void 0 === _b ? void 0 : _b.stateSort
    });
  }
  initMarkStyle() {
    this.initSymbolMarkStyle();
  }
  initAnimation() {
    var _a, _b, _c;
    const animationParams = getGroupAnimationParams(this), appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
    this._symbolMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("scatter")) || void 0 === _c ? void 0 : _c({}, appearPreset), userAnimationConfig("point", this._spec, this._markAttributeContext), animationParams));
  }
  initSymbolMarkStyle() {
    const symbolMark = this._symbolMark;
    symbolMark && ("zero" !== this._invalidType && this.setMarkStyle(symbolMark, {
      visible: this._getInvalidDefined.bind(this)
    }), this.setMarkStyle(symbolMark, {
      x: this.dataToPositionX.bind(this),
      y: this.dataToPositionY.bind(this),
      z: this._fieldZ ? this.dataToPositionZ.bind(this) : null,
      fill: this.getColorAttribute(),
      size: isNumber_default(this._size) || isFunction_default(this._size) ? this._size : SCATTER_DEFAULT_SIZE,
      symbolType: isString_default(this._shape) || isFunction_default(this._shape) ? this._shape : SCATTER_DEFAULT_SHAPE
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series), (isValid_default(this._sizeField) || isValid_default(this._size)) && this.setMarkStyle(symbolMark, {
      size: this.getSizeAttribute(this._sizeField, this._size)
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.User_Mark), (isValid_default(this._shapeField) || isValid_default(this._shape)) && this.setMarkStyle(symbolMark, {
      symbolType: this.getShapeAttribute(this._shapeField, this._shape)
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.User_Mark));
  }
  initTooltip() {
    super.initTooltip(), this._symbolMark && this._tooltipHelper.activeTriggerSet.mark.add(this._symbolMark);
  }
  viewDataStatisticsUpdate(d) {
    super.viewDataStatisticsUpdate(d);
    const allValid = [this.getDimensionField()[0], this.getStackValueField()].every((field3) => {
      var _a, _b, _c;
      return field3 && (null === (_c = null === (_b = null === (_a = this.getViewDataStatistics()) || void 0 === _a ? void 0 : _a.latestData) || void 0 === _b ? void 0 : _b[field3]) || void 0 === _c ? void 0 : _c.allValid);
    });
    "zero" === this._invalidType || allValid ? this.setMarkStyle(this._symbolMark, {
      visible: true
    }, "normal", AttributeLevel.Series) : this.setMarkStyle(this._symbolMark, {
      visible: this._getInvalidDefined.bind(this)
    }, "normal", AttributeLevel.Series), this._symbolMark.getProduct() && this._symbolMark.compileEncode();
  }
  initLabelMarkStyle(labelMark) {
    labelMark && (this._labelMark = labelMark, this.setMarkStyle(labelMark, {
      fill: this.getColorAttribute(),
      text: (datum) => datum[this.getStackValueField()],
      z: this._fieldZ ? this.dataToPositionZ.bind(this) : null
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series), "zero" !== this._invalidType && this.setMarkStyle(labelMark, {
      visible: this._getInvalidDefined.bind(this)
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series));
  }
  handleZoom(e) {
    var _a, _b;
    this.getMarksWithoutRoot().forEach((mark) => {
      const vGrammarMark = mark.getProduct();
      if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length)
        return;
      vGrammarMark.elements.forEach((el, i) => {
        const graphicItem = el.getGraphicItem(), datum = el.getDatum(), newPosition = this.dataToPosition(datum);
        newPosition && graphicItem && graphicItem.translateTo(newPosition.x, newPosition.y);
      });
    });
    const vgrammarLabel = null === (_b = null === (_a = this._labelMark) || void 0 === _a ? void 0 : _a.getComponent()) || void 0 === _b ? void 0 : _b.getProduct();
    vgrammarLabel && vgrammarLabel.evaluate(null, null);
  }
  handlePan(e) {
    var _a, _b;
    this.getMarksWithoutRoot().forEach((mark) => {
      const vGrammarMark = mark.getProduct();
      if (!vGrammarMark || !vGrammarMark.elements || !vGrammarMark.elements.length)
        return;
      vGrammarMark.elements.forEach((el, i) => {
        const graphicItem = el.getGraphicItem(), datum = el.getDatum(), newPosition = this.dataToPosition(datum);
        newPosition && graphicItem && graphicItem.translateTo(newPosition.x, newPosition.y);
      });
    });
    const vgrammarLabel = null === (_b = null === (_a = this._labelMark) || void 0 === _a ? void 0 : _a.getComponent()) || void 0 === _b ? void 0 : _b.getProduct();
    vgrammarLabel && vgrammarLabel.evaluate(null, null);
  }
  getDefaultShapeType() {
    return "circle";
  }
  getActiveMarks() {
    return [this._symbolMark];
  }
};
ScatterSeries.type = SeriesTypeEnum.scatter, ScatterSeries.mark = scatterSeriesMark, ScatterSeries.transformerConstructor = ScatterSeriesSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/polar/rose-like/rose-like
var RoseLikeSeries = class extends PolarSeries {
  getStackGroupFields() {
    return this._angleField;
  }
  getStackValueField() {
    return array(this._spec.valueField)[0] || array(this._spec.radiusField)[0];
  }
  getGroupFields() {
    return this._angleField;
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this.setAngleField(this._spec.categoryField || this._spec.angleField), this.setRadiusField(this._spec.valueField || this._spec.radiusField), this._specAngleField = this._angleField.slice(), this._specRadiusField = this._radiusField.slice(), this.setInnerRadiusField(this._spec.valueField || this._spec.radiusField), this.getStack() && this.setValueFieldToStack(), this.getPercent() && this.setValueFieldToPercent();
  }
  setValueFieldToStack() {
    this.setRadiusField(STACK_FIELD_END), this.setInnerRadiusField(STACK_FIELD_START);
  }
  setValueFieldToPercent() {
    this.setRadiusField(STACK_FIELD_END_PERCENT), this.setInnerRadiusField(STACK_FIELD_START_PERCENT);
  }
  getDimensionField() {
    return this._specAngleField;
  }
  getMeasureField() {
    return this._specRadiusField;
  }
  getDefaultShapeType() {
    return "square";
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/rose/rose-transformer
var RoseSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  constructor() {
    super(...arguments), this._supportStack = true;
  }
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "rose");
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/rose/rose
var RoseSeries = class _RoseSeries extends RoseLikeSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.rose, this.transformerConstructor = RoseSeriesSpecTransformer, this._roseMark = null, this._labelMark = null;
  }
  initMark() {
    this.initRoseMark();
  }
  initMarkStyle() {
    this.initRoseMarkStyle();
  }
  _buildMarkAttributeContext() {
    super._buildMarkAttributeContext(), this._markAttributeContext.getCenter = () => ({
      x: () => this.angleAxisHelper.center().x,
      y: () => this.angleAxisHelper.center().y
    }), this._markAttributeContext.startAngleScale = (datum) => this.startAngleScale(datum), this._markAttributeContext.endAngleScale = (datum) => this.endAngleScale(datum);
  }
  initRoseMark() {
    var _a, _b;
    this._roseMark = this._createMark(_RoseSeries.mark.rose, {
      morph: shouldMarkDoMorph(this._spec, _RoseSeries.mark.rose.name),
      defaultMorphElementKey: this.getDimensionField()[0],
      groupKey: this._seriesField,
      isSeriesMark: true,
      customShape: null === (_a = this._spec.rose) || void 0 === _a ? void 0 : _a.customShape,
      stateSort: null === (_b = this._spec.rose) || void 0 === _b ? void 0 : _b.stateSort
    });
  }
  getRoseAngle() {
    var _a, _b, _c;
    return null !== (_c = null === (_b = (_a = this.angleAxisHelper).getBandwidth) || void 0 === _b ? void 0 : _b.call(_a, this._groups ? this._groups.fields.length - 1 : 0)) && void 0 !== _c ? _c : 0.5;
  }
  startAngleScale(datum) {
    return this.angleAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this.getGroupFields())) - 0.5 * this.angleAxisHelper.getBandwidth(this.getGroupFields().length - 1);
  }
  endAngleScale(datum) {
    return this.angleAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this.getGroupFields())) + this.getRoseAngle() - 0.5 * this.angleAxisHelper.getBandwidth(this.getGroupFields().length - 1);
  }
  initRoseMarkStyle() {
    const roseMark = this._roseMark;
    roseMark && this.setMarkStyle(roseMark, {
      x: () => this.angleAxisHelper.center().x,
      y: () => this.angleAxisHelper.center().y,
      startAngle: (datum) => this.startAngleScale(datum),
      endAngle: (datum) => this.endAngleScale(datum),
      fill: this.getColorAttribute(),
      outerRadius: (datum) => valueInScaleRange(this.radiusAxisHelper.dataToPosition([datum[this._radiusField[0]]]), this.radiusAxisHelper.getScale(0)),
      innerRadius: (datum) => {
        var _a;
        if (!this.getStack())
          return 0;
        const stackStart = valueInScaleRange(this.radiusAxisHelper.dataToPosition([datum[this._innerRadiusField[0]]]), this.radiusAxisHelper.getScale(0));
        return stackStart <= Number.MIN_VALUE ? this._computeLayoutRadius() * (null !== (_a = this._spec.innerRadius) && void 0 !== _a ? _a : 0) : stackStart;
      }
    });
  }
  initTooltip() {
    super.initTooltip(), this._roseMark && this._tooltipHelper.activeTriggerSet.mark.add(this._roseMark);
  }
  initLabelMarkStyle(textMark) {
    textMark && this.setMarkStyle(textMark, {
      text: (datum) => datum[this.getDimensionField()[0]],
      fill: this.getColorAttribute(),
      z: 0
    });
  }
  initAnimation() {
    var _a, _b, _c;
    const appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
    if (this._roseMark) {
      const animationParams = {
        innerRadius: () => {
          var _a2;
          return this._computeLayoutRadius() * (null !== (_a2 = this._spec.innerRadius) && void 0 !== _a2 ? _a2 : 0);
        }
      };
      this._roseMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("rose")) || void 0 === _c ? void 0 : _c(animationParams, appearPreset), userAnimationConfig("rose", this._spec, this._markAttributeContext)));
    }
  }
  getDefaultShapeType() {
    return "circle";
  }
  getActiveMarks() {
    return [this._roseMark];
  }
};
RoseSeries.type = SeriesTypeEnum.rose, RoseSeries.mark = roseSeriesMark, RoseSeries.transformerConstructor = RoseSeriesSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/radar/radar
var RadarSeries = class _RadarSeries extends RoseLikeSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.radar, this.transformerConstructor = LineLikeSeriesSpecTransformer, this._sortDataByAxis = false;
  }
  initGroups() {
  }
  compile() {
    super.compile(), this.addOverlapCompile();
  }
  initMark() {
    var _a, _b, _c, _d;
    const progressive = {
      progressiveStep: this._spec.progressiveStep,
      progressiveThreshold: this._spec.progressiveThreshold,
      large: this._spec.large,
      largeThreshold: this._spec.largeThreshold
    }, isAreaVisible = false !== (null === (_a = this._spec.area) || void 0 === _a ? void 0 : _a.visible) && false !== (null === (_c = null === (_b = this._spec.area) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.visible), seriesMark = null !== (_d = this._spec.seriesMark) && void 0 !== _d ? _d : "area";
    this.initAreaMark(progressive, isAreaVisible && "area" === seriesMark), this.initLineMark(progressive, "line" === seriesMark || "area" === seriesMark && !isAreaVisible), this.initSymbolMark(progressive, "point" === seriesMark);
  }
  initMarkStyle() {
    this.initAreaMarkStyle(), this.initLineMarkStyle(), this.initSymbolMarkStyle();
  }
  initAreaMark(progressive, isSeriesMark) {
    var _a, _b;
    this._areaMark = this._createMark(_RadarSeries.mark.area, {
      progressive,
      isSeriesMark,
      customShape: null === (_a = this._spec.area) || void 0 === _a ? void 0 : _a.customShape,
      stateSort: null === (_b = this._spec.area) || void 0 === _b ? void 0 : _b.stateSort
    });
  }
  initAreaMarkStyle() {
    const areaMark = this._areaMark;
    areaMark && (this.setMarkStyle(areaMark, {
      x: this.dataToPositionX.bind(this),
      y: this.dataToPositionY.bind(this),
      x1: (datum) => datum && this.angleAxisHelper && this.radiusAxisHelper ? this.valueToPosition(this.getDatumPositionValues(datum, this._angleField), this.getStack() ? this.getDatumPositionValues(datum, this._innerRadiusField) : this.radiusScale.domain()[0]).x : Number.NaN,
      y1: (datum) => {
        if (!datum || !this.angleAxisHelper || !this.radiusAxisHelper)
          return Number.NaN;
        return this.valueToPosition(this.getDatumPositionValues(datum, this._angleField), this.getStack() ? this.getDatumPositionValues(datum, this._innerRadiusField) : this.radiusScale.domain()[0]).y;
      },
      fill: this.getColorAttribute(),
      curveType: DEFAULT_LINEAR_INTERPOLATE,
      closePath: true
    }, "normal", AttributeLevel.Series), "zero" !== this._invalidType && this.setMarkStyle(areaMark, {
      defined: this._getInvalidDefined.bind(this),
      connectedType: this._getInvalidConnectType()
    }, "normal", AttributeLevel.Series), this.event.on(ChartEvent.viewDataStatisticsUpdate, {
      filter: (param) => param.model === this
    }, () => {
      this.encodeDefined(areaMark, "defined");
    }));
  }
  initTooltip() {
    super.initTooltip();
    const { dimension, group, mark } = this._tooltipHelper.activeTriggerSet;
    this._lineMark && (dimension.add(this._lineMark), group.add(this._lineMark)), this._areaMark && (dimension.add(this._areaMark), group.add(this._areaMark)), this._symbolMark && (mark.add(this._symbolMark), group.add(this._symbolMark));
  }
  initAnimation() {
    var _a, _b, _c, _d;
    const animationParams = {
      center: () => {
        var _a2;
        return null === (_a2 = this.angleAxisHelper) || void 0 === _a2 ? void 0 : _a2.center();
      },
      radius: () => {
        const rect = this.getLayoutRect();
        return Math.min(rect.width, rect.height);
      },
      startAngle: isValid_default(this._spec.startAngle) ? degreeToRadian(this._spec.startAngle) : POLAR_START_RADIAN,
      pointToCoord: (point5) => {
        var _a2;
        return null === (_a2 = this.angleAxisHelper) || void 0 === _a2 ? void 0 : _a2.pointToCoord(point5);
      },
      coordToPoint: (coord) => this.angleAxisHelper.coordToPoint(coord)
    }, appearPreset = null !== (_c = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset) && void 0 !== _c ? _c : "clipIn";
    "clipIn" === appearPreset && this._rootMark && this._rootMark.setAnimationConfig(animationConfig(null === (_d = Factory2.getAnimationInKey("radarGroup")) || void 0 === _d ? void 0 : _d(animationParams, appearPreset), userAnimationConfig("group", this._spec, this._markAttributeContext)));
    [[this._areaMark, "radar"], [this._lineMark, "radar"], [this._symbolMark, "radarSymbol"]].forEach(([mark, animation]) => {
      if (isValid_default(mark)) {
        const getAnimation = Factory2.getAnimationInKey(animation);
        mark.setAnimationConfig(animationConfig(null == getAnimation ? void 0 : getAnimation(animationParams, appearPreset), userAnimationConfig(mark.name, this._spec, this._markAttributeContext)));
      }
    });
  }
  getDefaultShapeType() {
    return "square";
  }
  getActiveMarks() {
    return [this._areaMark, this._symbolMark, this._lineMark];
  }
  getSeriesStyle(datum) {
    return (attribute) => {
      var _a, _b, _c, _d;
      let result2 = null !== (_b = null === (_a = this._seriesMark) || void 0 === _a ? void 0 : _a.getAttribute(attribute, datum)) && void 0 !== _b ? _b : void 0;
      return "fill" !== attribute || result2 || (attribute = "stroke", result2 = null !== (_d = null === (_c = this._seriesMark) || void 0 === _c ? void 0 : _c.getAttribute(attribute, datum)) && void 0 !== _d ? _d : void 0), "stroke" === attribute && isArray_default(result2) ? result2[0] : result2;
    };
  }
};
RadarSeries.type = SeriesTypeEnum.radar, RadarSeries.mark = radarSeriesMark, RadarSeries.transformerConstructor = LineLikeSeriesSpecTransformer, mixin(RadarSeries, LineLikeSeriesMixin);

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/dot/tooltip-helper
var DotSeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  updateTooltipSpec() {
    var _a;
    super.updateTooltipSpec(), isValid_default(null === (_a = this.spec) || void 0 === _a ? void 0 : _a.mark) && (this.spec.mark.updateContent = (prev, datum, params2) => {
      const childrenContent = [], childrenPrev = prev.filter((p) => "children" === p.key);
      return childrenPrev.length > 0 && childrenPrev[0].value.forEach((element) => {
        let flag = true;
        for (const key in element)
          childrenContent.push({
            shapeType: "circle",
            hasShape: flag,
            shapeColor: this.shapeColorCallback(datum[0].datum[0]),
            shapeStroke: this.shapeStrokeCallback(datum[0].datum[0]),
            key,
            value: element[key] + ""
          }), flag = false;
      }), prev.concat(childrenContent);
    });
  }
  getDefaultTooltipPattern(activeType) {
    return "mark" === activeType ? {
      visible: true,
      activeType,
      title: {
        key: "event info",
        value: "event info"
      },
      content: [{
        hasShape: true,
        shapeType: "square",
        shapeColor: this.shapeColorCallback,
        shapeStroke: this.shapeStrokeCallback,
        key: (datum) => datum.type,
        value: (datum) => datum.id
      }, {
        hasShape: true,
        shapeType: "square",
        shapeColor: this.shapeColorCallback,
        shapeStroke: this.shapeStrokeCallback,
        key: "event_time",
        value: (datum) => TimeUtil.getInstance().timeFormat("%Y%m%d", datum.event_time)
      }, {
        hasShape: true,
        shapeType: "square",
        shapeColor: this.shapeColorCallback,
        shapeStroke: this.shapeStrokeCallback,
        key: "action_type",
        value: (datum) => datum.action_type
      }, {
        shapeType: "square",
        hasShape: true,
        shapeColor: this.shapeColorCallback,
        shapeStroke: this.shapeStrokeCallback,
        key: "children",
        value: (datum) => datum.children
      }],
      updateContent: (prev, datum, params2) => {
        const childrenContent = [];
        return prev[3].value.forEach((element) => {
          let flag = true;
          for (const key in element)
            childrenContent.push({
              shapeType: "circle",
              hasShape: flag,
              shapeColor: this.shapeColorCallback(datum[0].datum[0]),
              shapeStroke: this.shapeStrokeCallback(datum[0].datum[0]),
              key,
              value: element[key] + ""
            }), flag = false;
        }), prev.concat(childrenContent);
      }
    } : null;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/data/transforms/obj-flat
var objFlat = (data, op) => {
  var _a;
  const dataCollect = (null === (_a = data[0]) || void 0 === _a ? void 0 : _a.latestData) ? data[0].latestData : data || [], result2 = [];
  return dataCollect.forEach((datum) => {
    const dataKey = {};
    for (const key in datum)
      key !== op && (dataKey[key] = datum[key]);
    const dataOp = datum[op];
    null == dataOp || dataOp.forEach((d) => {
      result2.push(Object.assign({}, dataKey, d));
    });
  }), result2;
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/dot/config
var DEFAULT_GRID_BACKGROUND = {
  fill: "#bbb",
  fillOpacity: 0.2
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/dot/dot
var DotSeries = class _DotSeries extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.dot;
  }
  getSeriesGroupField() {
    return this._seriesField;
  }
  setSeriesGroupField(field3) {
    isValid_default(field3) && (this._seriesGroupField = field3);
  }
  getTitleField() {
    return this._titleField;
  }
  setTitleField(field3) {
    isValid_default(field3) && (this._titleField = field3);
  }
  getSubTitleField() {
    return this._subTitleField;
  }
  setSubTitleField(field3) {
    isValid_default(field3) && (this._subTitleField = field3);
  }
  getDotTypeField() {
    return this._dotTypeField;
  }
  setDotTypeField(field3) {
    isValid_default(field3) && (this._dotTypeField = field3);
  }
  getHighLightSeriesGroup() {
    return this._highLightSeriesGroup;
  }
  setHighLightSeriesGroup(field3) {
    isValid_default(field3) && (this._highLightSeriesGroup = field3);
  }
  setGridBackground(gridBackground) {
    isValid_default(gridBackground) && (this._gridBackground = gridBackground);
  }
  initData() {
    var _a;
    super.initData(), this._xDimensionStatisticsDomain = this.getRawData().latestData.map((d) => d[this._fieldY[0]]), registerDataSetInstanceTransform(this._option.dataSet, "objFlat", objFlat), registerDataSetInstanceTransform(this._option.dataSet, "copyDataView", copyDataView), registerDataSetInstanceParser(this._option.dataSet, "dataview", dataViewParser), null === (_a = this.getViewData()) || void 0 === _a || _a.transform({
      type: "objFlat",
      options: "dots",
      level: TransformLevel.dotObjFlat
    }, false);
  }
  setSeriesField(field3) {
    isValid_default(field3) && (this._seriesField = field3, this.getMarksInType(["line", "area"]).forEach((m4) => {
      m4.setFacet(this._seriesField);
    }));
  }
  getStatisticFields() {
    return [{
      key: this._fieldY[0],
      operations: ["values"],
      customize: this._xDimensionStatisticsDomain
    }];
  }
  setAttrFromSpec() {
    var _a;
    super.setAttrFromSpec(), this.setSeriesGroupField(this._spec.seriesGroupField), this.setTitleField(this._spec.titleField), this.setSubTitleField(this._spec.subTitleField), this.setDotTypeField(this._spec.dotTypeField), this.setHighLightSeriesGroup(this._spec.highLightSeriesGroup), this.setGridBackground(mergeSpec(DEFAULT_GRID_BACKGROUND, (null === (_a = this._spec.grid) || void 0 === _a ? void 0 : _a.background) || {}));
  }
  initMark() {
    this._clipMark = this._createMark(_DotSeries.mark.group), this._containerMark = this._createMark(_DotSeries.mark.group, {
      parent: this._clipMark,
      dataView: this.getRawData()
    }), this._gridBackgroundMark = this._createMark(_DotSeries.mark.gridBackground, {
      parent: this._containerMark,
      dataView: this.getRawData()
    }), this._gridMark = this._createMark(_DotSeries.mark.grid, {
      parent: this._containerMark,
      dataView: this.getRawData()
    }), this._dotMark = this._createMark(_DotSeries.mark.dot, {
      skipBeforeLayouted: false,
      isSeriesMark: true,
      parent: this._containerMark
    }), this._titleMark = this._createMark(_DotSeries.mark.title, {
      parent: this._containerMark,
      dataView: this.getRawData()
    }), this._subTitleMark = this._createMark(_DotSeries.mark.subTitle, {
      parent: this._containerMark,
      dataView: this.getRawData()
    }), this._symbolMark = this._createMark(_DotSeries.mark.symbol, {
      parent: this._containerMark,
      dataView: this.getRawData()
    });
  }
  initMarkStyle() {
    const clipMark = this._clipMark;
    clipMark && (this.setMarkStyle(clipMark, {
      x: -this._spec.leftAppendPadding,
      y: 0,
      width: 1e4,
      height: this._spec.clipHeight,
      clip: true
    }, "normal", AttributeLevel2.Series), clipMark.setInteractive(false));
    const containerMark = this._containerMark;
    containerMark && (this.setMarkStyle(containerMark, {
      x: this._spec.leftAppendPadding
    }, "normal", AttributeLevel2.Series), containerMark.setInteractive(false));
    const gridBackgroundMark = this._gridBackgroundMark;
    gridBackgroundMark && this.setMarkStyle(gridBackgroundMark, {
      x: this.getRegionRectLeft.bind(this),
      x1: this.getRegionRectRight.bind(this),
      y: this.dataToGridBackgroundPositionY.bind(this),
      y1: this.dataToGridBackgroundPositionY1.bind(this),
      fill: this._gridBackground.fill,
      fillOpacity: this.dataToGridBackgroundOpacity.bind(this)
    }, "normal", AttributeLevel2.Series);
    const gridMark = this._gridMark;
    gridMark && this.setMarkStyle(gridMark, {
      stroke: this.getColorAttribute(),
      x: this.getRegionRectLeft.bind(this),
      y: this.dataToPositionY.bind(this),
      x1: this.getRegionRectRight.bind(this),
      y1: this.dataToPositionY.bind(this)
    }, "normal", AttributeLevel2.Series);
    const dotMark = this._dotMark;
    dotMark && this.setMarkStyle(dotMark, {
      x: this.dataToPositionX.bind(this),
      y: this.dataToPositionY.bind(this),
      fill: this.getDotColorAttribute(),
      fillOpacity: this.dataToOpacity.bind(this)
    }, "normal", AttributeLevel2.Series);
    const titleMark = this._titleMark;
    titleMark && this.setMarkStyle(titleMark, {
      fill: this.getColorAttribute(),
      text: (datum) => datum[this.getTitleField()],
      x: this.getRegionRectLeft.bind(this),
      y: this.dataToPositionY.bind(this)
    }, "normal", AttributeLevel2.Series);
    const subTitleMark = this._subTitleMark;
    subTitleMark && this.setMarkStyle(subTitleMark, {
      fill: this.getColorAttribute(),
      text: (datum) => datum[this.getSubTitleField()],
      x: this.getRegionRectLeft.bind(this),
      y: this.dataToPositionY.bind(this)
    }, "normal", AttributeLevel2.Series);
    const symbolMark = this._symbolMark;
    symbolMark && this.setMarkStyle(symbolMark, {
      x: this.getRegionRectLeft.bind(this),
      y: this.dataToPositionY.bind(this),
      fill: this.getColorAttribute()
    }, "normal", AttributeLevel2.Series);
  }
  dataToGridBackgroundPositionY(datum) {
    if (!this._yAxisHelper)
      return Number.NaN;
    const { dataToPosition, getBandwidth } = this._yAxisHelper;
    return dataToPosition(this.getDatumPositionValues(datum, this._fieldY), {
      bandPosition: this._bandPosition
    }) - getBandwidth(0) / 2;
  }
  dataToGridBackgroundPositionY1(datum) {
    if (!this._yAxisHelper)
      return Number.NaN;
    const { dataToPosition, getBandwidth } = this._yAxisHelper;
    return dataToPosition(this.getDatumPositionValues(datum, this._fieldY), {
      bandPosition: this._bandPosition
    }) + getBandwidth(0) / 2;
  }
  dataToOpacity(datum) {
    var _a, _b, _c, _d;
    if (!this._xAxisHelper)
      return Number.NaN;
    const { dataToPosition, getScale: getScale2 } = this._xAxisHelper;
    return dataToPosition(this.getDatumPositionValues(datum, this._fieldX), {
      bandPosition: this._bandPosition
    }) < getScale2(0).range()[0] || dataToPosition(this.getDatumPositionValues(datum, this._fieldX), {
      bandPosition: this._bandPosition
    }) > getScale2(0).range()[1] ? 0 : null !== (_d = null === (_c = null === (_b = null === (_a = this._theme) || void 0 === _a ? void 0 : _a.dot) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.fillOpacity) && void 0 !== _d ? _d : 1;
  }
  dataToGridBackgroundOpacity(datum) {
    return datum[this._seriesGroupField] === this._highLightSeriesGroup ? this._gridBackground.fillOpacity : 0;
  }
  onLayoutEnd(ctx) {
    var _a, _b;
    super.onLayoutEnd(ctx);
    const layoutOffsetX = null !== (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.leftAppendPadding) && void 0 !== _b ? _b : 0;
    this.setMarkStyle(this._clipMark, {
      width: this.getLayoutRect().width + layoutOffsetX
    }, "normal", AttributeLevel2.Series);
  }
  getDefaultColorDomain() {
    var _a, _b;
    return this._seriesGroupField ? null === (_a = this.getViewDataStatistics()) || void 0 === _a ? void 0 : _a.latestData[this._seriesGroupField].values : this._seriesField ? null === (_b = this.getViewDataStatistics()) || void 0 === _b ? void 0 : _b.latestData[this._seriesField].values : [];
  }
  getColorAttribute() {
    var _a, _b, _c;
    return {
      scale: null !== (_a = this._option.globalScale.getScale("color")) && void 0 !== _a ? _a : this._getDefaultColorScale(),
      field: null !== (_c = null !== (_b = this._seriesGroupField) && void 0 !== _b ? _b : this._seriesField) && void 0 !== _c ? _c : DEFAULT_DATA_SERIES_FIELD2
    };
  }
  getDotColorScale() {
    var _a, _b, _c;
    const colorDomain = this._dotTypeField ? null === (_a = this.getViewDataStatistics()) || void 0 === _a ? void 0 : _a.latestData[this._dotTypeField].values : this._seriesGroupField ? null === (_b = this.getViewDataStatistics()) || void 0 === _b ? void 0 : _b.latestData[this._seriesGroupField].values : this._seriesField ? null === (_c = this.getViewDataStatistics()) || void 0 === _c ? void 0 : _c.latestData[this._seriesField].values : [], colorRange = this._getDataScheme();
    return new ColorOrdinalScale().domain(colorDomain).range(colorRange);
  }
  getDotColorAttribute() {
    var _a, _b, _c, _d;
    return {
      scale: null !== (_a = this._option.globalScale.getScale("color")) && void 0 !== _a ? _a : this.getDotColorScale(),
      field: null !== (_d = null !== (_c = null !== (_b = this._dotTypeField) && void 0 !== _b ? _b : this._seriesGroupField) && void 0 !== _c ? _c : this._seriesField) && void 0 !== _d ? _d : DEFAULT_DATA_SERIES_FIELD2
    };
  }
  initTooltip() {
    this._tooltipHelper = new DotSeriesTooltipHelper(this), this._dotMark && this._tooltipHelper.activeTriggerSet.mark.add(this._dotMark);
  }
  onEvaluateEnd(ctx) {
    super.onEvaluateEnd(ctx);
  }
  onMarkTreePositionUpdate(marks) {
    marks.forEach((m4) => {
      "group" === m4.type ? this.onMarkTreePositionUpdate(m4.getMarks()) : m4.updateLayoutState();
    });
  }
  getDotData() {
    var _a;
    return null === (_a = this._dotMark) || void 0 === _a ? void 0 : _a.getData();
  }
  _getDataIdKey() {
  }
  getStackValueField() {
    return null;
  }
  getActiveMarks() {
    return [this._dotMark];
  }
};
DotSeries.type = SeriesTypeEnum.dot, DotSeries.mark = dotSeriesMark;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/link/tooltip-helper
var LinkSeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  getDefaultTooltipPattern(activeType) {
    return "mark" === activeType ? {
      visible: true,
      activeType,
      title: {
        key: "link info",
        value: "link info"
      },
      content: [{
        hasShape: true,
        shapeType: "square",
        shapeColor: this.shapeColorCallback,
        shapeStroke: this.shapeStrokeCallback,
        key: "time",
        value: (datum) => TimeUtil.getInstance().timeFormat("%Y%m%d %H:%M", datum.from.split("_")[1])
      }, {
        hasShape: true,
        shapeType: "square",
        shapeColor: this.shapeColorCallback,
        shapeStroke: this.shapeStrokeCallback,
        key: "type",
        value: (datum) => datum.action_type
      }, {
        hasShape: true,
        shapeType: "square",
        shapeColor: this.shapeColorCallback,
        shapeStroke: this.shapeStrokeCallback,
        key: "from",
        value: (datum) => datum.from
      }, {
        hasShape: true,
        shapeType: "square",
        shapeColor: this.shapeColorCallback,
        shapeStroke: this.shapeStrokeCallback,
        key: "to",
        value: (datum) => datum.to
      }]
    } : null;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/data/transforms/link-dot-info
var linkDotInfo = (data, op) => {
  const { infoKey, fields: fields2, linkData, dotData } = op, { fromField, toField, xField, yField } = fields2(), dataLinkObj = linkData(), dataDotObj = dotData(), dataLinkDotHash = {};
  return dataDotObj.forEach((datum) => {
    const dataCopy = {};
    for (const key in datum)
      key !== infoKey && (dataCopy[key] = datum[key]);
    const dataOp = datum[infoKey];
    null == dataOp || dataOp.forEach((d) => {
      dataLinkDotHash[d.node_name] = Object.assign({}, dataCopy, d);
    });
  }), dataLinkObj.forEach((datum) => {
    var _a, _b, _c, _d;
    datum[fromField + "_xField"] = null === (_a = null == dataLinkDotHash ? void 0 : dataLinkDotHash[datum[fromField]]) || void 0 === _a ? void 0 : _a[xField], datum[fromField + "_yField"] = null === (_b = null == dataLinkDotHash ? void 0 : dataLinkDotHash[datum[fromField]]) || void 0 === _b ? void 0 : _b[yField], datum[toField + "_xField"] = null === (_c = null == dataLinkDotHash ? void 0 : dataLinkDotHash[datum[toField]]) || void 0 === _c ? void 0 : _c[xField], datum[toField + "_yField"] = null === (_d = null == dataLinkDotHash ? void 0 : dataLinkDotHash[datum[toField]]) || void 0 === _d ? void 0 : _d[yField];
  }), dataLinkObj;
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/link/link
var LinkSeries = class _LinkSeries extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.link;
  }
  getFromField() {
    return this._fromField;
  }
  setFromField(field3) {
    isValid_default(field3) && (this._fromField = field3);
  }
  getToField() {
    return this._toField;
  }
  setToField(field3) {
    isValid_default(field3) && (this._toField = field3);
  }
  getDotTypeField() {
    return this._dotTypeField;
  }
  setDotTypeField(field3) {
    isValid_default(field3) && (this._dotTypeField = field3);
  }
  getDotSeriesSpec() {
    return this._dotSeriesSpec;
  }
  setDotSeriesSpec(spec) {
    isValid_default(spec) && (this._dotSeriesSpec = spec);
  }
  _getDotData() {
    const dotSeries = this._option.getChart().getSeriesInIndex([this._spec.dotSeriesIndex])[0];
    return dotSeries ? dotSeries.getRawData().latestData : [];
  }
  initData() {
    var _a;
    super.initData(), registerDataSetInstanceTransform(this._option.dataSet, "linkDotInfo", linkDotInfo), null === (_a = this.getViewData()) || void 0 === _a || _a.transform({
      type: "linkDotInfo",
      options: {
        infoKey: "dots",
        fields: () => ({
          fromField: this._fromField,
          toField: this._toField,
          xField: this._dotSeriesSpec.xField,
          yField: this._dotSeriesSpec.yField
        }),
        linkData: () => this._rawData.latestData,
        dotData: () => this._getDotData()
      },
      level: TransformLevel.linkDotInfo
    }, false);
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this.setFromField(this._spec.fromField), this.setToField(this._spec.toField), this.setDotTypeField(this._spec.dotTypeField), this.setDotSeriesSpec(this._spec.dotSeriesSpec);
  }
  initMark() {
    this._clipMark = this._createMark(_LinkSeries.mark.group), this._containerMark = this._createMark(_LinkSeries.mark.group, {
      parent: this._clipMark
    }), this._linkMark = this._createMark(_LinkSeries.mark.link, {
      skipBeforeLayouted: false,
      parent: this._containerMark
    }), this._arrowMark = this._createMark(_LinkSeries.mark.arrow, {
      skipBeforeLayouted: false,
      isSeriesMark: true,
      parent: this._containerMark
    });
  }
  initMarkStyle() {
    var _a, _b, _c, _d;
    const clipMark = this._clipMark;
    clipMark && (this.setMarkStyle(clipMark, {
      x: -this._spec.leftAppendPadding,
      y: 0,
      width: 1e4,
      height: this._spec.clipHeight,
      clip: true
    }, "normal", AttributeLevel2.Series), clipMark.setInteractive(false));
    const containerMark = this._containerMark;
    containerMark && (this.setMarkStyle(containerMark, {
      x: this._spec.leftAppendPadding,
      width: this.getLayoutRect().width
    }, "normal", AttributeLevel2.Series), containerMark.setInteractive(false));
    const linkMark = this._linkMark;
    linkMark && this.setMarkStyle(linkMark, {
      stroke: this.getColorAttribute(),
      strokeOpacity: this.dataToOpacity.bind(this),
      x: this.dataToPositionXFrom.bind(this),
      y: this.dataToPositionYFrom.bind(this),
      x1: this.dataToPositionXTo.bind(this),
      y1: this.dataToPositionYTo.bind(this)
    }, "normal", AttributeLevel2.Series);
    const arrowMark = this._arrowMark;
    if (arrowMark) {
      const arrowSize = null !== (_d = null === (_c = null === (_b = null === (_a = this._theme) || void 0 === _a ? void 0 : _a.arrow) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.size) && void 0 !== _d ? _d : 10;
      this.setMarkStyle(arrowMark, {
        x: this.dataToPositionXTo.bind(this),
        y: (datum) => this.dataToPositionArrowYTo(datum, arrowSize),
        fill: this.getColorAttribute(),
        fillOpacity: this.dataToOpacity.bind(this),
        size: arrowSize,
        symbolType: (datum) => this.isPositionYFromHigher(datum) ? "triangleDown" : "triangleUp"
      }, "normal", AttributeLevel2.Series);
    }
  }
  afterInitMark() {
    super.afterInitMark();
  }
  dataToPositionXFrom(datum) {
    if (!this._xAxisHelper)
      return Number.NaN;
    const { dataToPosition } = this._xAxisHelper;
    return dataToPosition(this.getDatumPositionValues(datum, this._fromField + "_xField"), {
      bandPosition: this._bandPosition
    });
  }
  dataToPositionYFrom(datum) {
    if (!this._yAxisHelper)
      return Number.NaN;
    const { dataToPosition } = this._yAxisHelper;
    return dataToPosition(this.getDatumPositionValues(datum, this._fromField + "_yField"));
  }
  dataToPositionXTo(datum) {
    if (!this._xAxisHelper)
      return Number.NaN;
    const { dataToPosition } = this._xAxisHelper;
    return dataToPosition(this.getDatumPositionValues(datum, this._toField + "_xField"), {
      bandPosition: this._bandPosition
    });
  }
  dataToPositionYTo(datum) {
    if (!this._yAxisHelper)
      return Number.NaN;
    const { dataToPosition } = this._yAxisHelper;
    return dataToPosition(this.getDatumPositionValues(datum, this._toField + "_yField"), {
      bandPosition: this._bandPosition
    });
  }
  dataToPositionArrowYTo(datum, arrowSize) {
    if (!this._yAxisHelper)
      return Number.NaN;
    const { dataToPosition } = this._yAxisHelper, offset = this.isPositionYFromHigher(datum) ? -arrowSize / 2 : arrowSize / 2;
    return dataToPosition(this.getDatumPositionValues(datum, this._toField + "_yField"), {
      bandPosition: this._bandPosition
    }) + offset;
  }
  dataToOpacity(datum) {
    return this.isPositionXOuterRange(datum, this._fromField + "_xField") || this.isPositionXOuterRange(datum, this._toField + "_xField") || datum[this._fromField] === datum[this._toField] ? 0 : 1;
  }
  isPositionYFromHigher(datum) {
    return this.dataToPositionYFrom(datum) < this.dataToPositionYTo(datum);
  }
  isPositionXOuterRange(datum, field3) {
    if (!this._xAxisHelper)
      return false;
    const { dataToPosition, getScale: getScale2 } = this._xAxisHelper;
    return dataToPosition(this.getDatumPositionValues(datum, field3), {
      bandPosition: this._bandPosition
    }) < getScale2(0).range()[0] || dataToPosition(this.getDatumPositionValues(datum, field3), {
      bandPosition: this._bandPosition
    }) > getScale2(0).range()[1];
  }
  getDefaultColorDomain() {
    var _a, _b;
    return this._dotTypeField ? null === (_a = this.getViewDataStatistics()) || void 0 === _a ? void 0 : _a.latestData[this._dotTypeField].values : this._seriesField ? null === (_b = this.getViewDataStatistics()) || void 0 === _b ? void 0 : _b.latestData[this._seriesField].values : [];
  }
  getColorAttribute() {
    var _a, _b, _c;
    return {
      scale: null !== (_a = this._option.globalScale.getScale("color")) && void 0 !== _a ? _a : this._getDefaultColorScale(),
      field: null !== (_c = null !== (_b = this._dotTypeField) && void 0 !== _b ? _b : this._seriesField) && void 0 !== _c ? _c : DEFAULT_DATA_SERIES_FIELD2
    };
  }
  initInteraction() {
    const marks = [];
    this._linkMark && marks.push(this._linkMark), this._arrowMark && marks.push(this._arrowMark), this._parseInteractionConfig(marks);
  }
  initTooltip() {
    this._tooltipHelper = new LinkSeriesTooltipHelper(this), this._linkMark && this._tooltipHelper.activeTriggerSet.mark.add(this._linkMark), this._arrowMark && this._tooltipHelper.activeTriggerSet.mark.add(this._arrowMark);
  }
  onMarkTreePositionUpdate(marks) {
    marks.forEach((m4) => {
      "group" === m4.type ? this.onMarkTreePositionUpdate(m4.getMarks()) : m4.updateLayoutState();
    });
  }
  getDotInfoData() {
    var _a, _b;
    return null === (_b = null !== (_a = this._linkMark) && void 0 !== _a ? _a : this._arrowMark) || void 0 === _b ? void 0 : _b.getData();
  }
  getActiveMarks() {
    return [this._linkMark, this._arrowMark];
  }
};
LinkSeries.type = SeriesTypeEnum.link, LinkSeries.mark = linkSeriesMark;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/progress/circular/circular-transformer
var CircularProgressSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  constructor() {
    super(...arguments), this._supportStack = true;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/progress/circular/circular
var CircularProgressSeries = class _CircularProgressSeries extends ProgressLikeSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.circularProgress, this.transformerConstructor = CircularProgressSeriesSpecTransformer, this._progressMark = null, this._trackMark = null, this._getRadiusValueStart = (datum) => {
      if (this.getGroupFields().length > 1) {
        const value = this.radiusAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this.getGroupFields()));
        if (isValidNumber_default(value))
          return value;
      }
      return this.radiusAxisHelper.dataToPosition([datum[this._radiusField[0]]]);
    }, this._getRadiusValueEnd = (datum) => {
      var _a, _b;
      if (this.getGroupFields().length > 1) {
        const value = this.radiusAxisHelper.dataToPosition(this.getDatumPositionValues(datum, this.getGroupFields())) + (null === (_b = (_a = this.radiusAxisHelper).getBandwidth) || void 0 === _b ? void 0 : _b.call(_a, this._groups ? this._groups.fields.length - 1 : 0));
        if (isValidNumber_default(value))
          return value;
      }
      return this.radiusAxisHelper.dataToPosition([datum[this._radiusField[0]]]) + this.radiusAxisHelper.getScale(0).step();
    };
  }
  getStackGroupFields() {
    return this.getGroupFields();
  }
  getGroupFields() {
    return this._radiusField;
  }
  initMark() {
    super.initMark(), this._initTrackMark(), this._initProgressMark();
  }
  initMarkStyle() {
    super.initMarkStyle(), this._initTrackMarkStyle(), this._initProgressMarkStyle();
  }
  _initProgressMark() {
    var _a, _b;
    return this._progressMark = this._createMark(_CircularProgressSeries.mark.progress, {
      parent: this._arcGroupMark,
      isSeriesMark: true,
      customShape: null === (_a = this._spec.progress) || void 0 === _a ? void 0 : _a.customShape,
      stateSort: null === (_b = this._spec.progress) || void 0 === _b ? void 0 : _b.stateSort
    }), this._progressMark;
  }
  _initProgressMarkStyle() {
    var _a;
    const progressMark = this._progressMark;
    progressMark && this.setMarkStyle(progressMark, {
      x: () => this.angleAxisHelper.center().x,
      y: () => this.angleAxisHelper.center().y,
      startAngle: this._getAngleValueStart,
      endAngle: this._getAngleValueEnd,
      innerRadius: this._getRadiusValueStart,
      outerRadius: this._getRadiusValueEnd,
      cap: null !== (_a = this._spec.roundCap) && void 0 !== _a && _a,
      boundsMode: "imprecise",
      cornerRadius: this._spec.cornerRadius,
      fill: this.getColorAttribute(),
      zIndex: 200,
      forceShowCap: true
    }, "normal", AttributeLevel.Series);
  }
  initInteraction() {
    const marks = [];
    this._trackMark && marks.push(this._trackMark), this._progressMark && marks.push(this._progressMark), this._parseInteractionConfig(marks);
  }
  initTooltip() {
    super.initTooltip(), this._progressMark && this._tooltipHelper.activeTriggerSet.mark.add(this._progressMark);
  }
  _initTrackMark() {
    var _a, _b;
    return this._trackMark = this._createMark(_CircularProgressSeries.mark.track, {
      parent: this._arcGroupMark,
      customShape: null === (_a = this._spec.track) || void 0 === _a ? void 0 : _a.customShape,
      stateSort: null === (_b = this._spec.track) || void 0 === _b ? void 0 : _b.stateSort
    }), this._trackMark;
  }
  _initTrackMarkStyle() {
    const trackMark = this._trackMark;
    trackMark && this.setMarkStyle(trackMark, {
      visible: (datum) => {
        const range2 = this.angleAxisHelper.getScale(0).range(), min3 = Math.min(range2[0], range2[range2.length - 1]), startValue = this._getAngleValueStartWithoutMask(datum);
        return Math.abs(startValue - min3) <= 1e-14;
      },
      x: () => this.angleAxisHelper.center().x,
      y: () => this.angleAxisHelper.center().y,
      startAngle: () => {
        const fieldName = this.getStack() ? STACK_FIELD_START : this._angleField[0], domain = this.angleAxisHelper.getScale(0).domain();
        return this._getAngleValueStart({
          [fieldName]: domain[0]
        });
      },
      endAngle: () => {
        const fieldName = this.getStack() ? STACK_FIELD_END : this._angleField[0], domain = this.angleAxisHelper.getScale(0).domain();
        return this._getAngleValueEnd({
          [fieldName]: domain[domain.length - 1]
        });
      },
      innerRadius: this._getRadiusValueStart,
      outerRadius: this._getRadiusValueEnd,
      cornerRadius: this._spec.cornerRadius,
      fill: this.getColorAttribute(),
      zIndex: 100
    }, "normal", AttributeLevel.Series);
  }
  initAnimation() {
    var _a, _b, _c, _d;
    const appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
    this._progressMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("circularProgress")) || void 0 === _c ? void 0 : _c({
      startAngle: this._startAngle
    }, appearPreset), userAnimationConfig("progress", this._spec, this._markAttributeContext))), this._trackMark.setAnimationConfig(animationConfig(null === (_d = Factory2.getAnimationInKey("fadeInOut")) || void 0 === _d ? void 0 : _d(), userAnimationConfig("track", this._spec, this._markAttributeContext)));
  }
  getActiveMarks() {
    return [this._progressMark];
  }
};
CircularProgressSeries.type = SeriesTypeEnum.circularProgress, CircularProgressSeries.mark = circularProgressSeriesMark, CircularProgressSeries.transformerConstructor = CircularProgressSeriesSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/progress/linear/tooltip-helper
var LinearProgressSeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  getDefaultTooltipPattern(activeType, dimensionInfo) {
    const result2 = super.getDefaultTooltipPattern(activeType, dimensionInfo);
    switch (activeType) {
      case "mark":
      case "group":
        return result2;
      case "dimension":
        return result2.visible = false, result2;
    }
    return null;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/progress/linear/linear
var LinearProgressSeries = class _LinearProgressSeries extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.linearProgress, this._progressMark = null, this._trackMark = null, this._progressGroupMark = null;
  }
  initMark() {
    this._initProgressGroupMark(), this._initTrackMark(), this._initProgressMark();
  }
  initMarkStyle() {
    this._initProgressGroupMarkStyle(), this._initTrackMarkStyle(), this._initProgressMarkStyle();
  }
  _initProgressMark() {
    var _a, _b;
    return this._progressMark = this._createMark(_LinearProgressSeries.mark.progress, {
      isSeriesMark: true,
      parent: this._progressGroupMark,
      customShape: null === (_a = this._spec.progress) || void 0 === _a ? void 0 : _a.customShape,
      stateSort: null === (_b = this._spec.progress) || void 0 === _b ? void 0 : _b.stateSort
    }), this._progressMark;
  }
  _initProgressMarkStyle() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const progressMark = this._progressMark;
    if (progressMark)
      if ("vertical" === this._spec.direction) {
        const leftPadding = null !== (_b = null === (_a = this._spec.progress) || void 0 === _a ? void 0 : _a.leftPadding) && void 0 !== _b ? _b : 0, rightPadding = null !== (_d = null === (_c = this._spec.progress) || void 0 === _c ? void 0 : _c.rightPadding) && void 0 !== _d ? _d : 0;
        this.setMarkStyle(progressMark, {
          x: (datum) => {
            var _a2, _b2;
            return valueInScaleRange(this.dataToPositionX(datum), null === (_b2 = null === (_a2 = this._xAxisHelper) || void 0 === _a2 ? void 0 : _a2.getScale) || void 0 === _b2 ? void 0 : _b2.call(_a2, 0)) - this._spec.bandWidth / 2 + leftPadding;
          },
          y: (datum) => {
            var _a2, _b2;
            return valueInScaleRange(this.dataToPositionY(datum), null === (_b2 = null === (_a2 = this._yAxisHelper) || void 0 === _a2 ? void 0 : _a2.getScale) || void 0 === _b2 ? void 0 : _b2.call(_a2, 0));
          },
          height: () => {
            var _a2;
            return null === (_a2 = this._yAxisHelper) || void 0 === _a2 ? void 0 : _a2.dataToPosition([0], {
              bandPosition: this._bandPosition
            });
          },
          width: this._spec.bandWidth - leftPadding - rightPadding,
          cornerRadius: this._spec.cornerRadius,
          fill: this.getColorAttribute()
        }, "normal", AttributeLevel.Series);
      } else {
        const topPadding = null !== (_f = null === (_e = this._spec.progress) || void 0 === _e ? void 0 : _e.topPadding) && void 0 !== _f ? _f : 0, bottomPadding = null !== (_h = null === (_g = this._spec.progress) || void 0 === _g ? void 0 : _g.bottomPadding) && void 0 !== _h ? _h : 0;
        this.setMarkStyle(progressMark, {
          x: (datum) => {
            var _a2, _b2;
            return valueInScaleRange(this.dataToPositionX(datum), null === (_b2 = null === (_a2 = this._xAxisHelper) || void 0 === _a2 ? void 0 : _a2.getScale) || void 0 === _b2 ? void 0 : _b2.call(_a2, 0)) - this._xAxisHelper.dataToPosition([1], {
              bandPosition: this._bandPosition
            });
          },
          y: (datum) => {
            var _a2, _b2;
            return valueInScaleRange(this.dataToPositionY(datum), null === (_b2 = null === (_a2 = this._yAxisHelper) || void 0 === _a2 ? void 0 : _a2.getScale) || void 0 === _b2 ? void 0 : _b2.call(_a2, 0)) - this._spec.bandWidth / 2 + topPadding;
          },
          height: this._spec.bandWidth - topPadding - bottomPadding,
          width: () => {
            var _a2;
            return null === (_a2 = this._xAxisHelper) || void 0 === _a2 ? void 0 : _a2.dataToPosition([1], {
              bandPosition: this._bandPosition
            });
          },
          cornerRadius: this._spec.cornerRadius,
          fill: this.getColorAttribute()
        }, "normal", AttributeLevel.Series);
      }
  }
  _initTrackMark() {
    var _a, _b;
    return this._trackMark = this._createMark(_LinearProgressSeries.mark.track, {
      parent: this._progressGroupMark,
      customShape: null === (_a = this._spec.track) || void 0 === _a ? void 0 : _a.customShape,
      stateSort: null === (_b = this._spec.track) || void 0 === _b ? void 0 : _b.stateSort
    }), this._trackMark;
  }
  _initTrackMarkStyle() {
    const trackMark = this._trackMark;
    trackMark && ("vertical" === this._spec.direction ? this.setMarkStyle(trackMark, {
      x: (datum) => {
        var _a, _b;
        return valueInScaleRange(this.dataToPositionX(datum), null === (_b = null === (_a = this._xAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0)) - this._spec.bandWidth / 2;
      },
      y: 0,
      width: this._spec.bandWidth,
      height: () => this._scaleY.range()[0],
      cornerRadius: this._spec.cornerRadius
    }, "normal", AttributeLevel.Series) : this.setMarkStyle(trackMark, {
      x: 0,
      y: (datum) => {
        var _a, _b;
        return valueInScaleRange(this.dataToPositionY(datum), null === (_b = null === (_a = this._yAxisHelper) || void 0 === _a ? void 0 : _a.getScale) || void 0 === _b ? void 0 : _b.call(_a, 0)) - this._spec.bandWidth / 2;
      },
      height: this._spec.bandWidth,
      width: () => this._scaleX.range()[1],
      cornerRadius: this._spec.cornerRadius
    }, "normal", AttributeLevel.Series));
  }
  _initProgressGroupMark() {
    return this._progressGroupMark = this._createMark(_LinearProgressSeries.mark.group, {
      skipBeforeLayouted: false
    }), this._progressGroupMark;
  }
  _initProgressGroupMarkStyle() {
    const groupMark = this._progressGroupMark;
    groupMark.setZIndex(this.layoutZIndex), groupMark.created(), this.setMarkStyle(groupMark, {
      clip: true,
      x: 0,
      y: 0,
      path: () => {
        var _a;
        const rectPaths = [];
        return null === (_a = this._rawData) || void 0 === _a || _a.rawData.forEach((datum, index) => {
          var _a2, _b, _c, _d;
          if ("vertical" === this._spec.direction) {
            const x = valueInScaleRange(this.dataToPositionX(datum), null === (_b = null === (_a2 = this._xAxisHelper) || void 0 === _a2 ? void 0 : _a2.getScale) || void 0 === _b ? void 0 : _b.call(_a2, 0)) - this._spec.bandWidth / 2, height = this._scaleY.range()[0];
            rectPaths.push(createRect({
              x,
              y: 0,
              height,
              width: this._spec.bandWidth,
              cornerRadius: this._spec.cornerRadius,
              fill: true
            }));
          } else {
            const y = valueInScaleRange(this.dataToPositionY(datum), null === (_d = null === (_c = this._yAxisHelper) || void 0 === _c ? void 0 : _c.getScale) || void 0 === _d ? void 0 : _d.call(_c, 0)) - this._spec.bandWidth / 2, width = this._scaleX.range()[1];
            rectPaths.push(createRect({
              x: 0,
              y,
              height: this._spec.bandWidth,
              width,
              cornerRadius: this._spec.cornerRadius,
              fill: true
            }));
          }
        }), rectPaths;
      }
    }, "normal", AttributeLevel.Series), this._progressGroupMark.setInteractive(false);
  }
  initInteraction() {
    const marks = [];
    this._trackMark && marks.push(this._trackMark), this._progressMark && marks.push(this._progressMark), this._parseInteractionConfig(marks);
  }
  initAnimation() {
    var _a, _b, _c, _d;
    const animationParams = {
      direction: this.direction
    }, appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
    this._progressMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("linearProgress")) || void 0 === _c ? void 0 : _c(animationParams, appearPreset), userAnimationConfig("progress", this._spec, this._markAttributeContext))), this._trackMark.setAnimationConfig(animationConfig(null === (_d = Factory2.getAnimationInKey("fadeInOut")) || void 0 === _d ? void 0 : _d(), userAnimationConfig("track", this._spec, this._markAttributeContext)));
  }
  initTooltip() {
    this._tooltipHelper = new LinearProgressSeriesTooltipHelper(this), this._progressMark && this._tooltipHelper.activeTriggerSet.mark.add(this._progressMark), this._trackMark && this._tooltipHelper.activeTriggerSet.mark.add(this._trackMark);
  }
  getActiveMarks() {
    return [this._progressMark];
  }
};
LinearProgressSeries.type = SeriesTypeEnum.linearProgress, LinearProgressSeries.mark = linearProgressSeriesMark;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/word-cloud/config
var DEFAULT_ROTATE_ANGLES = [0];
var DEFAULT_DRAW_OUT_OF_BOUND = "hidden";
var DEFAULT_MIN_FONT_SIZE = 20;
var DEFAULT_FONTSIZE_RANGE = [20, 40];
var DEFAULT_FONT_WEIGHT_RANGE = [200, 500];
var DEFAULT_MASK_SHAPE = "circle";
var DEFAULT_ZOOM_TO_FIT = {
  shrink: false,
  enlarge: false,
  fontSizeLimitMin: 0
};
var DEFAULT_RANDOM = true;
var DEFAULT_FONT_PADDING = 1;
var SHAPE_TYPE = ["triangleForward", "triangle", "diamond", "square", "star", "cardioid", "circle", "pentagon", "rect"];

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/constant/word-cloud
var WORD_CLOUD_ANGLE = `${PREFIX}_WORD_CLOUD_ANGLE`;
var WORD_CLOUD_FILLING_ANGLE = `${PREFIX}_WORD_CLOUD_FILLING_ANGLE`;
var WORD_CLOUD_WEIGHT = `${PREFIX}_WORD_CLOUD_WEIGHT`;
var WORDCLOUD_COLOR = `${PREFIX}_WORDCLOUD_COLOR`;
var WORDCLOUD_DATA_TOTAL = `${PREFIX}_WORDCLOUD_DATA_TOTAL`;
var WORD_CLOUD_TEXT = `${PREFIX}_WORD_CLOUD_TEXT`;
var WORDCLOUD_SHAPE_DATA_TOTAL = `${PREFIX}_WORDCLOUD_SHAPE_DATA_TOTAL`;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/word-cloud/base
var BaseWordCloudSeries = class _BaseWordCloudSeries extends BaseSeries {
  constructor() {
    super(...arguments), this._fontSizeRange = [DEFAULT_MIN_FONT_SIZE, DEFAULT_MIN_FONT_SIZE], this._isWordCloudShape = false, this._dataChange = true, this.getWordColor = (datum) => datum.isFillingWord ? (this._fillingColorCallback && !this._dataChange || (this._fillingColorCallback = this._wordCloudShapeConfig.fillingColorHexField ? (datum2) => datum2[this._wordCloudShapeConfig.fillingColorHexField] : this.initColorCallback(this._wordCloudShapeConfig.fillingSeriesField, true)), this._fillingColorCallback(datum)) : (this._keyWordColorCallback && !this._dataChange || (this._keyWordColorCallback = this._colorHexField ? (datum2) => datum2[this._colorHexField] : this.initColorCallback(this._seriesField, false)), this._keyWordColorCallback(datum));
  }
  setValueField(field3) {
    isValid_default(field3) && (this._valueField = field3);
  }
  setFontSizeRange(fontSizeRange) {
    isValid_default(fontSizeRange) ? this._fontSizeRange = fontSizeRange : this._fontSizeRange = DEFAULT_FONTSIZE_RANGE;
  }
  setAttrFromSpec() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    super.setAttrFromSpec(), this._padding = this._option.getChart().padding, this._nameField = this._spec.nameField, this._fontFamilyField = this._spec.fontFamilyField, this._fontWeightField = this._spec.fontWeightField, this._fontStyleField = this._spec.fontStyleField, this._colorHexField = this._spec.colorHexField, this._colorMode = null !== (_a = this._spec.colorMode) && void 0 !== _a ? _a : "ordinal", this._colorList = this._spec.colorList, this.setValueField(this._spec.valueField), this._fontWeightRange = null !== (_b = this._spec.fontWeightRange) && void 0 !== _b ? _b : DEFAULT_FONT_WEIGHT_RANGE, this._rotateAngles = null !== (_c = this._spec.rotateAngles) && void 0 !== _c ? _c : DEFAULT_ROTATE_ANGLES, this.setFontSizeRange(this._spec.fontSizeRange), this._maskShape = null !== (_d = this._spec.maskShape) && void 0 !== _d ? _d : DEFAULT_MASK_SHAPE, this._keepAspect = this._spec.keepAspect, this._random = null !== (_e = this._spec.random) && void 0 !== _e ? _e : DEFAULT_RANDOM, this._fontPadding = null !== (_g = null === (_f = this._spec.word) || void 0 === _f ? void 0 : _f.padding) && void 0 !== _g ? _g : DEFAULT_FONT_PADDING, this._textField = (null === (_h = this._spec.word) || void 0 === _h ? void 0 : _h.formatMethod) ? WORD_CLOUD_TEXT : this._nameField, this._wordCloudConfig = Object.assign({
      drawOutOfBound: DEFAULT_DRAW_OUT_OF_BOUND,
      layoutMode: "default",
      zoomToFit: DEFAULT_ZOOM_TO_FIT
    }, this._spec.wordCloudConfig), this._wordCloudShapeConfig = Object.assign({
      fillingSeriesField: this.getSeriesField(),
      fillingRotateAngles: DEFAULT_ROTATE_ANGLES,
      layoutMode: "default"
    }, this._spec.wordCloudShapeConfig), this._fillingFontPadding = null !== (_k = null === (_j = this._spec.fillingWord) || void 0 === _j ? void 0 : _j.padding) && void 0 !== _k ? _k : DEFAULT_FONT_PADDING, this._isWordCloudShape = !SHAPE_TYPE.includes(this._maskShape), this._defaultFontFamily = this._option.getTheme().fontFamily;
  }
  initData() {
    var _a, _b;
    super.initData(), null === (_b = null === (_a = this.getViewData()) || void 0 === _a ? void 0 : _a.target) || void 0 === _b || _b.addListener("change", () => {
      this._dataChange = true, this.compile();
    });
  }
  initMark() {
    this._wordMark = this._createMark(_BaseWordCloudSeries.mark.word, {
      key: DEFAULT_DATA_KEY,
      defaultMorphElementKey: this._seriesField,
      groupKey: this._seriesField,
      isSeriesMark: true
    });
  }
  initMarkStyle() {
    var _a, _b, _c;
    const wordMark = this._wordMark, wordSpec = null !== (_a = this._spec.word) && void 0 !== _a ? _a : {};
    wordMark && (this.setMarkStyle(wordMark, {
      fill: this.getWordColor,
      text: (datum) => datum[this._textField],
      x: (datum) => datum.x,
      y: (datum) => datum.y,
      fontFamily: (datum) => datum.fontFamily,
      fontSize: (datum) => datum.fontSize,
      fontStyle: (datum) => datum.fontStyle,
      fontWeight: (datum) => datum.fontWeight,
      angle: (datum) => datum.angle,
      visible: (datum) => datum.visible
    }, "normal", AttributeLevel.Series), this.setMarkStyle(wordMark, {
      fontFamily: null !== (_c = null === (_b = wordSpec.style) || void 0 === _b ? void 0 : _b.fontFamily) && void 0 !== _c ? _c : this._defaultFontFamily
    }, "normal", AttributeLevel.User_Mark));
  }
  initTooltip() {
    super.initTooltip(), this._wordMark && this._tooltipHelper.activeTriggerSet.mark.add(this._wordMark);
  }
  initAnimation() {
    var _a, _b;
    const mark = this._wordMark;
    if (mark) {
      const appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset, params2 = {
        animationConfig: () => {
          var _a2, _b2;
          return null === (_b2 = null === (_a2 = mark.getAnimationConfig()) || void 0 === _a2 ? void 0 : _a2.appear) || void 0 === _b2 ? void 0 : _b2[0];
        }
      };
      mark.setAnimationConfig(animationConfig(Factory2.getAnimationInKey("wordCloud")(params2, appearPreset), userAnimationConfig("word", this._spec, this._markAttributeContext)));
    }
  }
  getWordOrdinalColorScale(field3, isFillingWord) {
    var _a, _b, _c, _d, _e;
    const colorList = isFillingWord ? this._wordCloudShapeConfig.fillingColorList : this._colorList, colorDomain = field3 ? null === (_a = this.getViewData()) || void 0 === _a ? void 0 : _a.latestData.map((datum) => datum[field3]) : [], colorRange = null !== (_c = null != colorList ? colorList : null === (_b = this._option.globalScale.getScale("color")) || void 0 === _b ? void 0 : _b.range()) && void 0 !== _c ? _c : this._getDataScheme();
    return null === (_e = (_d = new ColorOrdinalScale().domain(colorDomain)).range) || void 0 === _e ? void 0 : _e.call(_d, colorRange);
  }
  initColorCallback(field3, isFillingWord) {
    var _a;
    if ("ordinal" === this._colorMode) {
      const scale4 = this.getWordOrdinalColorScale(field3, isFillingWord);
      return (datum) => {
        var _a2;
        return scale4.scale(datum[null !== (_a2 = this._seriesField) && void 0 !== _a2 ? _a2 : DEFAULT_DATA_SERIES_FIELD]);
      };
    }
    let colorList = null !== (_a = isFillingWord ? this._colorList : this._wordCloudShapeConfig.fillingColorList) && void 0 !== _a ? _a : this._option.globalScale.getScale("color").range();
    return 1 === colorList.length && (colorList = [colorList[0], colorList[0]]), (datum) => colorList[0];
  }
  compile() {
    var _a, _b;
    super.compile();
    const { width, height } = this._region.getLayoutRect();
    if (!isValidNumber_default(width) || !isValidNumber_default(height) || !(height > 0 && width > 0))
      return;
    const wordCloudTransforms = [], valueField = this._valueField, valueScale = new LinearScale(), fontWeightRange = this._fontWeightRange;
    if (valueField) {
      const [minValue, maxValue] = extent(null === (_a = this.getViewData()) || void 0 === _a ? void 0 : _a.latestData.map((datum) => +datum[valueField]));
      valueScale.domain([minValue, maxValue], true).range(fontWeightRange), wordCloudTransforms.push({
        type: "map",
        as: WORD_CLOUD_WEIGHT,
        callback: (datum) => minValue === maxValue ? valueScale.scale(maxValue) : valueScale.scale(datum[valueField])
      });
    }
    const wordSpec = null !== (_b = this._spec.word) && void 0 !== _b ? _b : {};
    wordSpec.formatMethod && wordCloudTransforms.push({
      type: "map",
      as: WORD_CLOUD_TEXT,
      callback: wordSpec.formatMethod
    }), this._isWordCloudShape ? wordCloudTransforms.push(Object.assign({
      type: "wordcloudShape"
    }, this._wordCloudShapeTransformOption())) : wordCloudTransforms.push(Object.assign({
      type: "wordcloud"
    }, this._wordCloudTransformOption())), this._wordMark.getProduct().transform(wordCloudTransforms);
  }
  _wordCloudTransformOption() {
    var _a, _b, _c, _d, _e;
    const { width, height } = this._region.getLayoutRect(), wordStyleSpec = null !== (_b = null === (_a = this._spec.word) || void 0 === _a ? void 0 : _a.style) && void 0 !== _b ? _b : {};
    return {
      layoutType: isTrueBrowser(this._option.mode) ? this._wordCloudConfig.layoutMode : "fast",
      size: [width, height],
      shape: this._maskShape,
      dataIndexKey: DEFAULT_DATA_KEY,
      text: {
        field: this._textField
      },
      fontSize: this._valueField ? {
        field: this._valueField
      } : this._fontSizeRange[0],
      fontSizeRange: "auto" === this._fontSizeRange ? null : this._fontSizeRange,
      padding: this._fontPadding,
      rotate: this._rotateAngles,
      fontFamily: null !== (_d = null !== (_c = this._fontFamilyField) && void 0 !== _c ? _c : wordStyleSpec.fontFamily) && void 0 !== _d ? _d : this._defaultFontFamily,
      fontWeight: this._fontWeightField ? {
        field: this._fontWeightField
      } : this._valueField ? {
        field: WORD_CLOUD_WEIGHT
      } : null,
      fontStyle: null !== (_e = this._fontStyleField) && void 0 !== _e ? _e : wordStyleSpec.fontStyle,
      randomVisible: this._random,
      clip: "clip" === this._wordCloudConfig.drawOutOfBound,
      shrink: this._wordCloudConfig.zoomToFit.shrink,
      enlarge: this._wordCloudConfig.zoomToFit.enlarge,
      minFontSize: this._wordCloudConfig.zoomToFit.fontSizeLimitMin,
      progressiveTime: this._wordCloudConfig.progressiveTime,
      progressiveStep: this._wordCloudConfig.progressiveStep
    };
  }
  _wordCloudShapeTransformOption() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    const { width, height } = this._region.getLayoutRect(), wordStyleSpec = null !== (_b = null === (_a = this._spec.word) || void 0 === _a ? void 0 : _a.style) && void 0 !== _b ? _b : {}, wordCloudShapeConfig = null !== (_c = this._wordCloudShapeConfig) && void 0 !== _c ? _c : {}, fillingRotateAngles = this._wordCloudShapeConfig.fillingRotateAngles;
    return {
      dataIndexKey: DEFAULT_DATA_KEY,
      size: [width, height],
      shape: this._maskShape,
      text: {
        field: this._textField
      },
      fontSize: this._valueField ? {
        field: this._valueField
      } : this._fontSizeRange[0],
      fontSizeRange: "auto" === this._fontSizeRange ? null : this._fontSizeRange,
      padding: this._fontPadding,
      rotateList: this._rotateAngles,
      fontFamily: null !== (_e = null !== (_d = this._fontFamilyField) && void 0 !== _d ? _d : wordStyleSpec.fontFamily) && void 0 !== _e ? _e : this._defaultFontFamily,
      fontWeight: this._fontWeightField ? {
        field: this._fontWeightField
      } : this._valueField ? {
        field: WORD_CLOUD_WEIGHT
      } : null,
      fontStyle: null !== (_f = this._fontStyleField) && void 0 !== _f ? _f : wordStyleSpec.fontStyle,
      fillingFontFamily: null !== (_h = null !== (_g = wordCloudShapeConfig.fillingFontFamilyField) && void 0 !== _g ? _g : wordStyleSpec.fontFamily) && void 0 !== _h ? _h : this._defaultFontFamily,
      fillingPadding: this._fillingFontPadding,
      fillingFontStyle: null !== (_j = wordCloudShapeConfig.fillingFontStyleField) && void 0 !== _j ? _j : wordStyleSpec.fontStyle,
      fillingFontWeight: null !== (_k = wordCloudShapeConfig.fillingFontWeightField) && void 0 !== _k ? _k : wordStyleSpec.fontWeight,
      fillingRotateList: fillingRotateAngles,
      fillingTimes: wordCloudShapeConfig.fillingTimes,
      fillingXStep: wordCloudShapeConfig.fillingXStep,
      fillingYStep: wordCloudShapeConfig.fillingYStep,
      fillingXRatioStep: wordCloudShapeConfig.fillingXRatioStep,
      fillingYRatioStep: wordCloudShapeConfig.fillingYRatioStep,
      fillingInitialOpacity: wordCloudShapeConfig.fillingInitialOpacity,
      fillingDeltaOpacity: wordCloudShapeConfig.fillingDeltaOpacity,
      fillingInitialFontSize: wordCloudShapeConfig.fillingInitialFontSize,
      fillingDeltaFontSize: wordCloudShapeConfig.fillingDeltaFontSize,
      ratio: wordCloudShapeConfig.ratio,
      fillingRatio: wordCloudShapeConfig.fillingRatio,
      removeWhiteBorder: wordCloudShapeConfig.removeWhiteBorder,
      textLayoutTimes: wordCloudShapeConfig.textLayoutTimes,
      fontSizeShrinkFactor: wordCloudShapeConfig.fontSizeShrinkFactor,
      stepFactor: wordCloudShapeConfig.stepFactor,
      layoutMode: wordCloudShapeConfig.layoutMode,
      importantWordCount: wordCloudShapeConfig.importantWordCount,
      globalShinkLimit: wordCloudShapeConfig.globalShinkLimit,
      fontSizeEnlargeFactor: wordCloudShapeConfig.fontSizeEnlargeFactor,
      fillingDeltaFontSizeFactor: wordCloudShapeConfig.fillingDeltaFontSizeFactor
    };
  }
  getStatisticFields() {
    const fields2 = [];
    return fields2.push({
      key: this._nameField,
      operations: ["values"]
    }), fields2.push({
      key: this._valueField,
      operations: ["max", "min"]
    }), fields2;
  }
  dataToPosition(data) {
    return null;
  }
  dataToPositionX(data) {
    return null;
  }
  dataToPositionY(data) {
    return null;
  }
  dataToPositionZ(data) {
    return null;
  }
  valueToPosition(value1, value2) {
    return null;
  }
  getGroupFields() {
    return [];
  }
  getStackGroupFields() {
    return [];
  }
  getStackValueField() {
    return "";
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx), this.compile(), this._dataChange = false;
  }
  getActiveMarks() {
    return [this._wordMark];
  }
  reInit() {
    super.reInit(), this._keyWordColorCallback && (this._keyWordColorCallback = null), this._fillingColorCallback && (this._fillingColorCallback = null);
  }
};
BaseWordCloudSeries.mark = wordCloudSeriesMark;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/word-cloud/word-cloud
var WordCloudSeries = class extends BaseWordCloudSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.wordCloud;
  }
};
WordCloudSeries.type = SeriesTypeEnum.wordCloud;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/word-cloud/word-cloud-3d
var WordCloud3dSeries = class extends BaseWordCloudSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.wordCloud3d;
  }
  _wordCloudTransformOption() {
    var _a;
    return Object.assign(Object.assign({}, super._wordCloudTransformOption()), {
      postProjection: null !== (_a = this._spec.postProjection) && void 0 !== _a ? _a : "StereographicProjection",
      depth_3d: this._spec.depth_3d
    });
  }
  _wordCloudShapeTransformOption() {
    var _a;
    return Object.assign(Object.assign({}, super._wordCloudShapeTransformOption()), {
      postProjection: null !== (_a = this._spec.postProjection) && void 0 !== _a ? _a : "StereographicProjection",
      depth_3d: this._spec.depth_3d
    });
  }
  initMark() {
    this._wordMark = this._createMark(BaseWordCloudSeries.mark.word, {
      groupKey: this._seriesField,
      support3d: true,
      isSeriesMark: true
    });
  }
  initMarkStyle() {
    super.initMarkStyle();
    const wordMark = this._wordMark;
    wordMark && this.setMarkStyle(wordMark, {
      z: (datum) => {
        var _a;
        return null !== (_a = datum.z) && void 0 !== _a ? _a : 0;
      }
    }, "normal", AttributeLevel.Series);
  }
  initAnimation() {
    var _a, _b;
    const padding = null !== (_a = this._padding) && void 0 !== _a ? _a : {};
    this._wordMark && this._wordMark.setAnimationConfig(animationConfig(null === (_b = Factory2.getAnimationInKey("wordCloud3d")) || void 0 === _b ? void 0 : _b(() => {
      var _a2;
      const srView = this.getCompiler().getVGrammarView(), width = srView.width() - padding.left || 0 - padding.right || 0, height = srView.height() - padding.top || 0 - padding.bottom || 0, r = Math.max(width, height) / 2;
      return {
        center: {
          x: r,
          y: r,
          z: null !== (_a2 = this._spec.depth_3d) && void 0 !== _a2 ? _a2 : r
        },
        r
      };
    }), userAnimationConfig("word", this._spec, this._markAttributeContext)));
  }
};
WordCloud3dSeries.type = SeriesTypeEnum.wordCloud3d;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/data/transforms/sunburst
var sunburstLayout = (data, op) => {
  if (!data)
    return data;
  const options = op(), { width, height } = options;
  return new SunburstLayout(options).layout(data, {
    width,
    height
  });
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/constant/sunburst
var SUNBURST_AUTO_VISIBLE_DEFAULT_THRESHOLD = 10;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/sunburst/tooltip-helper
var SunburstTooltipHelper = class extends BaseSeriesTooltipHelper {
  constructor() {
    super(...arguments), this.markTooltipKeyCallback = (datum) => null == datum ? void 0 : datum[this.series.getDimensionField()[0]];
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/sunburst/sunburst
var SunburstSeries = class _SunburstSeries extends PolarSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.sunburst;
  }
  setCategoryField(f) {
    return this._categoryField = f, this._categoryField;
  }
  getCategoryField() {
    return this._categoryField;
  }
  setValueField(f) {
    return this._valueField = f, this._valueField;
  }
  getValueField() {
    return this._valueField;
  }
  getDimensionField() {
    return [this._categoryField];
  }
  getMeasureField() {
    return [this._valueField];
  }
  setAttrFromSpec() {
    var _a;
    super.setAttrFromSpec(), this.setCategoryField(this._spec.categoryField), this.setValueField(this._spec.valueField), this.setSeriesField(null !== (_a = this._spec.seriesField) && void 0 !== _a ? _a : DEFAULT_HIERARCHY_ROOT), this._spec.drill && this.initDrillable({
      event: this.event,
      mode: this._option.mode,
      drillField: () => {
        var _a2;
        return null !== (_a2 = this._spec.drillField) && void 0 !== _a2 ? _a2 : DEFAULT_DATA_KEY;
      },
      getRawData: () => this.getRawData()
    }), this._startAngle = degreeToRadian(this._spec.startAngle), this._endAngle = degreeToRadian(this._spec.endAngle), this._centerX = this._spec.centerX, this._centerY = this._spec.centerY, this._offsetX = this._spec.offsetX, this._offsetY = this._spec.offsetY, this.__innerRadius = this._spec.innerRadius, this.__outerRadius = this._spec.outerRadius, this._gap = this._spec.gap, this._labelLayout = this._spec.labelLayout, this._sunburst = this._spec.sunburst, this._label = this._spec.label, this._labelAutoVisible = this._spec.labelAutoVisible;
  }
  initData() {
    super.initData();
    const rawData = this.getRawData();
    rawData && (this._spec.drill && this.initDrillableData(this._dataSet), registerDataSetInstanceTransform(this._dataSet, "sunburstLayout", sunburstLayout), registerDataSetInstanceTransform(this._dataSet, "flatten", flatten), rawData.transform({
      type: "sunburstLayout",
      options: () => {
        const { innerRadius, outerRadius, gap, label } = this._computeLevel();
        return {
          nodeKey: this._categoryField,
          width: this.getLayoutRect().width,
          height: this.getLayoutRect().height,
          center: [isValid_default(this._centerX) ? this._centerX : this.getLayoutRect().width / 2, isValid_default(this._centerY) ? this._centerY : this.getLayoutRect().height / 2],
          startAngle: this._startAngle,
          endAngle: this._endAngle,
          innerRadius,
          outerRadius,
          gapRadius: gap,
          label
        };
      }
    }), rawData.transform({
      type: "flatten",
      options: {
        callback: (node) => {
          if (node.datum) {
            const nodeData = node.datum[node.depth];
            return Object.assign(Object.assign({}, node), nodeData);
          }
          return node;
        }
      }
    }));
  }
  getStatisticFields() {
    return super.getStatisticFields().concat([{
      key: this._categoryField,
      operations: ["values"]
    }, {
      key: this._valueField,
      operations: ["max", "min"]
    }, {
      key: DEFAULT_HIERARCHY_DEPTH,
      operations: ["max", "min", "values"]
    }, {
      key: DEFAULT_HIERARCHY_ROOT,
      operations: ["values"]
    }]);
  }
  _addDataIndexAndKey() {
    const rawData = this.getRawData();
    isNil_default(null == rawData ? void 0 : rawData.dataSet) || (registerDataSetInstanceTransform(rawData.dataSet, "addVChartProperty", addVChartProperty), rawData.transform({
      type: "addVChartProperty",
      options: {
        beforeCall: initHierarchyKeyMap.bind(this),
        call: addHierarchyDataKey
      }
    }));
  }
  initMark() {
    this._initArcMark(), this._initLabelMark();
  }
  initMarkStyle() {
    this._initArcMarkStyle(), this._initLabelMarkStyle();
  }
  _initArcMark() {
    var _a, _b;
    if (false === this._sunburst.visible)
      return;
    const sunburstMark = this._createMark(_SunburstSeries.mark.sunburst, {
      isSeriesMark: true,
      customShape: null === (_a = this._spec.sunburst) || void 0 === _a ? void 0 : _a.customShape,
      stateSort: null === (_b = this._spec.sunburst) || void 0 === _b ? void 0 : _b.stateSort
    });
    this._sunburstMark = sunburstMark;
  }
  _initArcMarkStyle() {
    isNil_default(this._sunburstMark) || this.setMarkStyle(this._sunburstMark, {
      x: (d) => d.x + (isValid_default(this._offsetX) ? this._offsetX : 0),
      y: (d) => d.y + (isValid_default(this._offsetY) ? this._offsetY : 0),
      outerRadius: (d) => d.outerRadius,
      innerRadius: (d) => d.innerRadius,
      startAngle: (d) => d.startAngle,
      endAngle: (d) => d.endAngle,
      fill: this.getColorAttribute()
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  _initLabelMark() {
    if (true !== this._label.visible)
      return;
    const labelMark = this._createMark(_SunburstSeries.mark.label, {
      isSeriesMark: false
    });
    this._labelMark = labelMark;
  }
  _initLabelMarkStyle() {
    isNil_default(this._labelMark) || this.setMarkStyle(this._labelMark, {
      visible: (d) => {
        var _a;
        const labelAutoVisible = this._labelAutoVisible;
        return isObject_default(labelAutoVisible) && true === labelAutoVisible.enable ? (d.endAngle - d.startAngle) * (d.outerRadius - d.innerRadius) > (null !== (_a = null == labelAutoVisible ? void 0 : labelAutoVisible.circumference) && void 0 !== _a ? _a : SUNBURST_AUTO_VISIBLE_DEFAULT_THRESHOLD) : this._spec.label.visible;
      },
      x: (d) => {
        var _a;
        return (null === (_a = d.label) || void 0 === _a ? void 0 : _a.x) + (isValid_default(this._offsetX) ? this._offsetX : 0);
      },
      y: (d) => {
        var _a;
        return (null === (_a = d.label) || void 0 === _a ? void 0 : _a.y) + (isValid_default(this._offsetY) ? this._offsetY : 0);
      },
      textBaseline: (d) => {
        var _a;
        return null === (_a = d.label) || void 0 === _a ? void 0 : _a.textBaseline;
      },
      textAlign: (d) => {
        var _a;
        return null === (_a = d.label) || void 0 === _a ? void 0 : _a.textAlign;
      },
      angle: (d) => {
        var _a, _b;
        return null !== (_b = null === (_a = d.label) || void 0 === _a ? void 0 : _a.angle) && void 0 !== _b ? _b : 0;
      },
      fontSize: 10,
      text: (d) => d.name
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  initTooltip() {
    this._tooltipHelper = new SunburstTooltipHelper(this), this._sunburstMark && this._tooltipHelper.activeTriggerSet.mark.add(this._sunburstMark), this._labelMark && this._tooltipHelper.activeTriggerSet.mark.add(this._labelMark);
  }
  initAnimation() {
    var _a, _b;
    const animationParams = {
      animationInfo: () => ({
        innerRadius: this._computeRadius(array(this.__innerRadius))[0],
        outerRadius: this._computeRadius(array(this.__outerRadius))[0],
        startAngle: array(this._startAngle)[0],
        endAngle: array(this._endAngle)[0]
      })
    }, appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
    this.getMarksInType("arc").forEach((mark) => {
      var _a2;
      mark.setAnimationConfig(animationConfig(null === (_a2 = Factory2.getAnimationInKey("sunburst")) || void 0 === _a2 ? void 0 : _a2(animationParams, appearPreset), userAnimationConfig(mark.name, this._spec, this._markAttributeContext)));
    }), this.getMarksInType("text").forEach((mark) => {
      var _a2;
      mark.setAnimationConfig(animationConfig(null === (_a2 = Factory2.getAnimationInKey("fadeInOut")) || void 0 === _a2 ? void 0 : _a2(), userAnimationConfig(mark.name, this._spec, this._markAttributeContext)));
    });
  }
  initEvent() {
    super.initEvent(), this._spec.drill && this.bindDrillEvent();
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx), this._rawData.reRunAllTransform();
  }
  _computeRadius(radius) {
    return isArray_default(radius) ? radius.map((r) => this._computeLayoutRadius() * r) : this._computeLayoutRadius() * radius;
  }
  _computeLevel() {
    return {
      innerRadius: this._computeRadius(this.__innerRadius),
      outerRadius: this._computeRadius(this.__outerRadius),
      gap: this._gap,
      label: this._labelLayout
    };
  }
  getGroupFields() {
    return [];
  }
  getStackGroupFields() {
    return [];
  }
  getStackValueField() {
    return "";
  }
  _noAnimationDataKey(datum, index) {
  }
  getActiveMarks() {
    return [this._sunburstMark];
  }
};
SunburstSeries.type = SeriesTypeEnum.sunburst, SunburstSeries.mark = sunburstSeriesMark, mixin(SunburstSeries, Drillable);

// http-url:https://unpkg.com/@visactor/vgrammar-sankey@0.13.8/es/hierarchy
var calculateNodeValue2 = (subTree) => {
  let sum4 = 0;
  return subTree.forEach((node, index) => {
    var _a;
    isNil_default(node.value) && ((null === (_a = node.children) || void 0 === _a ? void 0 : _a.length) ? node.value = calculateNodeValue2(node.children) : node.value = 0), sum4 += Math.abs(node.value);
  }), sum4;
};

// http-url:https://unpkg.com/@visactor/vgrammar-sankey@0.13.8/es/layout
function left(node) {
  return node.depth;
}
function right(node, maxDepth2) {
  return maxDepth2 - 1 - node.endDepth;
}
function justify(node, maxDepth2) {
  return node.sourceLinks.length ? node.depth : maxDepth2 - 1;
}
function center(node, maxDepth2, nodeMap) {
  return node.targetLinks.length ? node.depth : node.sourceLinks.length ? minInArray(node.sourceLinks.map((link3) => nodeMap[link3.target].depth)) - 1 : 0;
}
var ascendingNodeBreadth = (a3, b) => (null == a3 ? void 0 : a3.y0) - (null == b ? void 0 : b.y0);
var calcDivideValue = (node, isTarget) => {
  if (isNil_default(node.value))
    return null;
  const res = (isTarget ? node.targetLinks : node.sourceLinks).reduce((res2, sLink) => (isNil_default(sLink.value) ? res2.count += 1 : res2.sum += sLink.value, res2), {
    sum: 0,
    count: 0
  });
  return res.count > 0 ? (node.value - res.sum) / res.count : null;
};
var alignFunctions = {
  left,
  right,
  justify,
  center,
  start: left,
  end: right
};
var linkClampe = clamper(0, 1);
var SankeyLayout = class _SankeyLayout {
  constructor(options) {
    this._ascendingSourceBreadth = (a3, b) => ascendingNodeBreadth(this._nodeMap[a3.source], this._nodeMap[b.source]) || a3.index - b.index, this._ascendingTargetBreadth = (a3, b) => ascendingNodeBreadth(this._nodeMap[a3.target], this._nodeMap[b.target]) || a3.index - b.index, this.options = Object.assign({}, _SankeyLayout.defaultOptions, options);
    const keyOption = this.options.nodeKey, keyFunc = isFunction_default(keyOption) ? keyOption : keyOption ? field(keyOption) : null;
    this._getNodeKey = keyFunc, this._logger = Logger.getInstance(), this._alignFunc = isFunction_default(this.options.setNodeLayer) ? (node) => this.options.setNodeLayer(node.datum) : alignFunctions[this.options.nodeAlign];
  }
  layout(data, config2) {
    if (!data)
      return null;
    const viewBox = "width" in config2 ? {
      x0: 0,
      x1: config2.width,
      y0: 0,
      y1: config2.height,
      width: config2.width,
      height: config2.height
    } : {
      x0: Math.min(config2.x0, config2.x1),
      x1: Math.max(config2.x0, config2.x1),
      y0: Math.min(config2.y0, config2.y1),
      y1: Math.max(config2.y0, config2.y1),
      width: Math.abs(config2.x1 - config2.x0),
      height: Math.abs(config2.y1 - config2.y0)
    };
    isVertical(this.options.direction) ? this._viewBox = {
      x0: viewBox.y0,
      x1: viewBox.y1,
      y0: viewBox.x0,
      y1: viewBox.x1,
      width: viewBox.height,
      height: viewBox.width
    } : this._viewBox = viewBox;
    const result2 = this.computeNodeLinks(data), nodes = result2.nodes;
    let links = result2.links;
    if (this._nodeMap = result2.nodeMap, this.computeNodeValues(nodes), this.computeNodeDepths(nodes), ["right", "end", "justify"].includes(this.options.nodeAlign) && this.computeNodeEndDepths(nodes), this._maxDepth <= 1)
      return null;
    const columns = this.computeNodeBreadths(nodes);
    return this.computeLinkBreadths(nodes), nodes.forEach((node) => {
      node.sourceLinks = node.sourceLinks.filter((link3) => !isNil_default(link3.source) && !isNil_default(link3.target)), node.targetLinks = node.targetLinks.filter((link3) => !isNil_default(link3.source) && !isNil_default(link3.target));
    }), links = links.filter((link3) => !isNil_default(link3.source) && !isNil_default(link3.target)), isVertical(this.options.direction) && (nodes.forEach((node) => {
      const y05 = node.y0, y14 = node.y1;
      node.y0 = node.x0, node.y1 = node.x1, node.x0 = y05, node.x1 = y14;
    }), links.forEach((link3) => {
      link3.vertical = true;
      const x05 = link3.x0, x14 = link3.x1;
      link3.x0 = link3.y0, link3.x1 = link3.y1, link3.y0 = x05, link3.y1 = x14;
    })), links.forEach((link3) => {
      const sourceNode = this._nodeMap[link3.source], targetNode = this._nodeMap[link3.target];
      link3.sourceRect = {
        x0: sourceNode.x0,
        x1: sourceNode.x1,
        y0: sourceNode.y0,
        y1: sourceNode.y1
      }, link3.targetRect = {
        x0: targetNode.x0,
        x1: targetNode.x1,
        y1: targetNode.y1,
        y0: targetNode.y0
      };
    }), {
      nodes,
      links,
      columns
    };
  }
  computeHierarchicNodeLinks(originalNodes) {
    const nodes = [], links = [], nodeMap = {}, linkMap = {}, originalLinks = [];
    calculateNodeValue2(originalNodes);
    const doSubTree = (subTree, depth, parents) => {
      subTree.forEach((node, index) => {
        const nodeKey = this._getNodeKey ? this._getNodeKey(node) : parents ? `${parents[parents.length - 1].key}-${index}` : `${depth}-${index}`, nodeValue = isNil_default(node.value) ? 0 : toValidNumber(node.value);
        if (nodeMap[nodeKey])
          nodeMap[nodeKey].value = void 0;
        else {
          const nodeElement = {
            depth,
            datum: node,
            index,
            key: nodeKey,
            value: nodeValue,
            sourceLinks: [],
            targetLinks: []
          };
          nodeMap[nodeKey] = nodeElement, nodes.push(nodeElement);
        }
        parents && originalLinks.push({
          source: parents[parents.length - 1].key,
          target: nodeKey,
          value: nodeValue,
          parents
        }), node.children && node.children.length && doSubTree(node.children, depth + 1, parents ? parents.concat([nodeMap[nodeKey]]) : [nodeMap[nodeKey]]);
      });
    };
    return doSubTree(originalNodes, 0, null), originalLinks.forEach((link3, index) => {
      const key = `${link3.source}-${link3.target}`;
      if (linkMap[key])
        return linkMap[key].value += toValidNumber(link3.value), void linkMap[key].datum.push(link3);
      const linkElement = {
        index,
        key: `${link3.source}-${link3.target}`,
        source: link3.source,
        target: link3.target,
        datum: [link3],
        value: link3.value,
        parents: link3.parents.map((parent) => parent.key)
      };
      links.push(linkElement), nodeMap[link3.source].sourceLinks.push(linkElement), nodeMap[link3.target].targetLinks.push(linkElement), linkMap[key] = linkElement;
    }), {
      nodes,
      links,
      nodeMap
    };
  }
  computeSourceTargetNodeLinks(data) {
    const nodes = [], links = [], nodeMap = {};
    data.nodes && data.nodes.forEach((node, index) => {
      const nodeElement = {
        depth: -1,
        datum: node,
        index,
        key: this._getNodeKey ? this._getNodeKey(node) : index,
        value: node.value,
        sourceLinks: [],
        targetLinks: []
      };
      nodeMap[nodeElement.key] = nodeElement, nodes.push(nodeElement);
    });
    const invalidLinks = [];
    return data.links.forEach((link3, index) => {
      const hasSource = !isNil_default(link3.source), hasTarget = !isNil_default(link3.target);
      if (data.nodes && (!nodeMap[link3.source] || !nodeMap[link3.target]))
        return;
      data.nodes || !hasSource || nodeMap[link3.source] || (nodeMap[link3.source] = {
        value: void 0,
        depth: -1,
        index: nodes.length,
        key: link3.source,
        datum: null,
        sourceLinks: [],
        targetLinks: []
      }, nodes.push(nodeMap[link3.source])), data.nodes || !hasTarget || nodeMap[link3.target] || (nodeMap[link3.target] = {
        value: void 0,
        depth: -1,
        index: nodes.length,
        key: link3.target,
        datum: null,
        sourceLinks: [],
        targetLinks: []
      }, nodes.push(nodeMap[link3.target]));
      const linkElement = {
        index,
        source: link3.source,
        target: link3.target,
        datum: link3,
        value: link3.value
      };
      this.options.divideNodeValueToLink && isNil_default(link3.value) && invalidLinks.push(linkElement), links.push(linkElement), hasSource && nodeMap[link3.source].sourceLinks.push(linkElement), hasTarget && nodeMap[link3.target].targetLinks.push(linkElement);
    }), this.options.divideNodeValueToLink && invalidLinks.length && invalidLinks.forEach((link3) => {
      const values = [calcDivideValue(nodeMap[link3.source]), calcDivideValue(nodeMap[link3.target], true)].filter((entry) => !isNil_default(entry));
      values.length && (link3.value = minInArray(values));
    }), {
      nodeMap,
      nodes,
      links
    };
  }
  computeNodeLinks(data) {
    let res;
    "links" in data ? res = this.computeSourceTargetNodeLinks(data) : (this._isHierarchic = true, res = this.computeHierarchicNodeLinks(data.nodes));
    let nodes = res.nodes;
    const links = res.links;
    if (this.options.linkSortBy)
      for (let i = 0, len = nodes.length; i < len; i++)
        nodes[i].sourceLinks.sort(this.options.linkSortBy), nodes[i].targetLinks.sort(this.options.linkSortBy);
    return this.options.dropIsolatedNode && (nodes = nodes.filter((node) => node.targetLinks.length || node.sourceLinks.length)), {
      nodes,
      links,
      nodeMap: res.nodeMap
    };
  }
  computeNodeValues(nodes) {
    for (let i = 0, len = nodes.length; i < len; i++) {
      const node = nodes[i];
      node.value = Math.max(isNil_default(node.value) ? 0 : toValidNumber(node.value), node.sourceLinks.reduce((sum4, link3) => {
        var _a;
        return sum4 + (null !== (_a = toValidNumber(link3.value)) && void 0 !== _a ? _a : 0);
      }, 0), node.targetLinks.reduce((sum4, link3) => {
        var _a;
        return sum4 + (null !== (_a = toValidNumber(link3.value)) && void 0 !== _a ? _a : 0);
      }, 0));
    }
  }
  computeNodeDepths(nodes) {
    const n = nodes.length;
    let next, nextMap, current = nodes, depth = 0;
    for (; current.length && depth < n; ) {
      next = [], nextMap = {};
      for (let i = 0, curLen = current.length; i < curLen; i++) {
        const node = current[i];
        if (node && (node.depth = depth, node.sourceLinks && node.sourceLinks.length))
          for (let j = 0, linkLen = node.sourceLinks.length; j < linkLen; j++) {
            const link3 = node.sourceLinks[j];
            nextMap[link3.target] || (next.push(this._nodeMap[link3.target]), nextMap[link3.target] = true);
          }
      }
      current = next, depth += 1;
    }
    depth > n && this._logger.warn("Error: there is a circular link"), this._maxDepth = depth;
  }
  computeNodeEndDepths(nodes) {
    const n = nodes.length;
    let next, nextMap, current = nodes, depth = 0;
    for (; current.length && depth < n; ) {
      next = [], nextMap = {};
      for (let i = 0, curLen = current.length; i < curLen; i++) {
        const node = current[i];
        if (node) {
          node.endDepth = depth;
          for (let j = 0, linkLen = node.targetLinks.length; j < linkLen; j++) {
            const link3 = node.targetLinks[j];
            nextMap[link3.source] || (next.push(this._nodeMap[link3.source]), nextMap[link3.source] = true);
          }
        }
      }
      current = next, depth += 1;
    }
    depth > n && this._logger.warn("Error: there is a circular link");
  }
  computeNodeLayers(nodes) {
    const nodeWidthOption = this.options.nodeWidth, linkWidthOption = this.options.linkWidth, minStepWidth = this.options.minStepWidth, width = this._viewBox.width;
    let nodeWidth = null, linkWidth = null, isEvenWidth = false;
    if (isString_default(nodeWidthOption)) {
      const ratio = clamp_default(parseFloat(nodeWidthOption.replace("%", "")) / 100, 0, 1);
      let stepWidth = width / (this._maxDepth - 1 + ratio);
      minStepWidth > 0 && (stepWidth = Math.max(minStepWidth, stepWidth)), nodeWidth = stepWidth * ratio, linkWidth = stepWidth * (1 - ratio), isEvenWidth = true;
    } else if (isNumber_default(nodeWidthOption)) {
      if (nodeWidth = nodeWidthOption, isNumber_default(linkWidthOption))
        linkWidth = linkWidthOption;
      else if (isNil_default(linkWidthOption)) {
        let stepWidth = (width - nodeWidthOption) / (this._maxDepth - 1);
        minStepWidth > 0 && (stepWidth = Math.max(minStepWidth, stepWidth)), linkWidth = stepWidth - nodeWidthOption;
      }
      isEvenWidth = true;
    } else
      isFunction_default(nodeWidthOption) && isNumber_default(linkWidthOption) && (linkWidth = linkWidthOption);
    const columns = [];
    for (let i = 0, len = nodes.length; i < len; i++) {
      const node = nodes[i];
      node.layer = this._isHierarchic ? node.depth : clamp_default(Math.floor(this._alignFunc(node, this._maxDepth, this._nodeMap)), 0, this._maxDepth - 1);
      const layer = node.layer;
      layer === this._maxDepth - 1 && (node.isLastLayer = true), isEvenWidth && (node.x0 = this._viewBox.x0 + layer * (nodeWidth + linkWidth), node.x1 = node.x0 + nodeWidth), columns[layer] ? columns[layer].push(node) : columns[layer] = [node];
    }
    if (this.options.nodeSortBy)
      for (let j = 0, colLen = columns.length; j < colLen; j++)
        columns[j].sort(this.options.nodeSortBy);
    if (!isEvenWidth && isFunction_default(nodeWidthOption)) {
      let curLayerX = this._viewBox.x0;
      for (let i = 0; i < this._maxDepth; i++) {
        const column = columns[i];
        let maxNodeWidth = 0, maxLinkWidth = 0;
        for (let j = 0, colLen = column && column.length; j < colLen; j++) {
          const node = column[j], curNodeWidth = nodeWidthOption(node);
          node.x0 = curLayerX, node.x1 = curLayerX + curNodeWidth, maxNodeWidth = Math.max(nodeWidth, curNodeWidth);
          const sourceLinks = node.sourceLinks;
          for (let k2 = 0, linkLen = sourceLinks.length; k2 < linkLen; k2++) {
            const link3 = sourceLinks[k2], curLinkWidth = isFunction_default(linkWidthOption) ? linkWidthOption(link3, this._viewBox) : linkWidth;
            maxLinkWidth = Math.max(maxLinkWidth, curLinkWidth);
          }
        }
        curLayerX += maxNodeWidth + maxLinkWidth;
      }
    }
    return columns;
  }
  initializeNodeBreadths(columns) {
    var _a, _b;
    const minLinkHeight = null !== (_a = this.options.minLinkHeight) && void 0 !== _a ? _a : 0;
    let minNodeHeight = null !== (_b = this.options.minNodeHeight) && void 0 !== _b ? _b : 0;
    (isNil_default(minNodeHeight) || minNodeHeight < minLinkHeight) && (minNodeHeight = minLinkHeight);
    let ky2 = 0, getGapY = null, forceNodeHeight = null;
    if (isFunction_default(this.options.nodeGap))
      getGapY = this.options.nodeGap, ky2 = columns.reduce((val, column) => {
        const sumValue = column.reduce((sum4, node) => sum4 + node.value, 0), sumGapY = column.reduce((sum4, node) => sum4 + this.options.nodeGap(node), 0);
        return Math.min(val, (this._viewBox.height - sumGapY) / sumValue);
      }, 1 / 0);
    else {
      const maxRowCount = columns.reduce((cnt, column) => Math.max(cnt, column.length), 0), gapY = Math.min(minNodeHeight > 0 ? Math.max(this.options.nodeGap, minNodeHeight) : this.options.nodeGap, this._viewBox.height / maxRowCount);
      getGapY = () => gapY, this._gapY = gapY, this.options.equalNodeHeight ? forceNodeHeight = this._viewBox.height / maxRowCount - gapY : ky2 = columns.reduce((val, column) => {
        const sumValue = column.reduce((sum4, node) => sum4 + node.value, 0);
        return Math.min(val, (this._viewBox.height - (column.length - 1) * gapY) / sumValue);
      }, 1 / 0);
    }
    const isStartGap = "start" === this.options.gapPosition, isMiddleGap = !isStartGap && "end" !== this.options.gapPosition, getNodeHeight = isNumber_default(this.options.nodeHeight) ? (node) => this.options.nodeHeight : isFunction_default(this.options.nodeHeight) ? this.options.nodeHeight : forceNodeHeight > 0 ? (node) => forceNodeHeight : (node) => Math.max(node.value * ky2, minNodeHeight, 0), getLinkHeight = isNumber_default(this.options.linkHeight) ? () => this.options.linkHeight : isFunction_default(this.options.linkHeight) ? this.options.linkHeight : (link3, sourceNode, sourceNodeHeight) => Math.max(sourceNode.value ? sourceNodeHeight * linkClampe(link3.value / sourceNode.value) : 0, minLinkHeight, 0);
    for (let i = 0, columnCount = columns.length; i < columnCount; i++) {
      const nodes = columns[i];
      if (!nodes || !nodes.length)
        continue;
      let y = this._viewBox.y0, gapY = 0, nodeHeight = 0;
      for (let j = 0, len = nodes.length; j < len; j++) {
        const node = nodes[j];
        gapY = getGapY(node), isStartGap && (y += gapY), nodeHeight = getNodeHeight(node), node.y0 = y, node.y1 = y + nodeHeight, y = isStartGap ? node.y1 : node.y1 + gapY;
        for (let k2 = 0, linkLen = node.sourceLinks.length; k2 < linkLen; k2++) {
          const link3 = node.sourceLinks[k2];
          link3.thickness = getLinkHeight(link3, node, nodeHeight);
        }
      }
      let deltaY = this._viewBox.y1 - y + (isMiddleGap ? gapY : 0);
      if (deltaY > 0)
        if ("start" === this.options.crossNodeAlign)
          ;
        else if ("end" === this.options.crossNodeAlign)
          for (let j = 0, len = nodes.length; j < len; ++j) {
            const node = nodes[j];
            node.y0 += deltaY, node.y1 += deltaY;
          }
        else {
          deltaY /= nodes.length + 1;
          for (let j = 0, len = nodes.length; j < len; ++j) {
            const node = nodes[j];
            node.y0 += deltaY * (j + 1), node.y1 += deltaY * (j + 1);
          }
        }
      else if (deltaY < 0 && nodes.length > 1 && (deltaY /= nodes.length - 1, gapY + deltaY > 0)) {
        gapY += deltaY, this._gapY = Math.min(gapY);
        for (let j = 1, len = nodes.length; j < len; ++j) {
          const node = nodes[j];
          node.y0 += deltaY * j, node.y1 += deltaY * j;
        }
      }
      this.reorderLinks(nodes);
    }
  }
  computeNodeBreadths(nodes) {
    const columns = this.computeNodeLayers(nodes);
    this.initializeNodeBreadths(columns);
    const iterations2 = this.options.iterations;
    if (!this._isHierarchic && !isFunction_default(this.options.setNodeLayer) && !isFunction_default(this.options.nodeGap))
      for (let i = 0; i < iterations2; ++i) {
        const alpha = Math.pow(0.99, i), beta = Math.max(1 - alpha, (i + 1) / iterations2);
        this.relaxRightToLeft(columns, alpha, beta), this.relaxLeftToRight(columns, alpha, beta);
      }
    return columns;
  }
  relaxLeftToRight(columns, alpha, beta) {
    for (let i = 1, n = columns.length; i < n; ++i) {
      const column = columns[i];
      for (let j = 0, colLen = column.length; j < colLen; j++) {
        const target = column[j];
        let y = 0, w = 0;
        for (let k2 = 0, linkLen = target.targetLinks.length; k2 < linkLen; k2++) {
          const link3 = target.targetLinks[k2], v = link3.value * (target.layer - this._nodeMap[link3.source].layer);
          y += this.targetTop(this._nodeMap[link3.source], target) * v, w += v;
        }
        if (!(w > 0))
          continue;
        const dy = (y / w - target.y0) * alpha;
        target.y0 += dy, target.y1 += dy, this.reorderNodeLinks(target);
      }
      isNil_default(this.options.nodeSortBy) && column.sort(ascendingNodeBreadth), this.resolveCollisions(column, beta);
    }
  }
  relaxRightToLeft(columns, alpha, beta) {
    for (let i = columns.length - 2; i >= 0; --i) {
      const column = columns[i];
      for (let j = 0, colLen = column.length; j < colLen; j++) {
        const source = column[j];
        let y = 0, w = 0;
        for (let k2 = 0, linkLen = source.sourceLinks.length; k2 < linkLen; k2++) {
          const link3 = source.sourceLinks[k2], v = link3.value * (this._nodeMap[link3.target].layer - source.layer);
          y += this.sourceTop(source, this._nodeMap[link3.target]) * v, w += v;
        }
        if (!(w > 0))
          continue;
        const dy = (y / w - source.y0) * alpha;
        source.y0 += dy, source.y1 += dy, this.reorderNodeLinks(source);
      }
      void 0 === this.options.nodeSortBy && column.sort(ascendingNodeBreadth), this.resolveCollisions(column, beta);
    }
  }
  resolveCollisions(nodes, alpha) {
    const i = nodes.length >> 1, subject = nodes[i];
    this.resolveCollisionsBottomToTop(nodes, subject.y0 - this._gapY, i - 1, alpha), this.resolveCollisionsTopToBottom(nodes, subject.y1 + this._gapY, i + 1, alpha), this.resolveCollisionsBottomToTop(nodes, this._viewBox.y1, nodes.length - 1, alpha), this.resolveCollisionsTopToBottom(nodes, this._viewBox.y0, 0, alpha);
  }
  resolveCollisionsTopToBottom(nodes, y, i, alpha) {
    for (; i < nodes.length; ++i) {
      const node = nodes[i], dy = (y - node.y0) * alpha;
      dy > 1e-6 && (node.y0 += dy, node.y1 += dy), y = node.y1 + this._gapY;
    }
  }
  resolveCollisionsBottomToTop(nodes, y, i, alpha) {
    for (; i >= 0; --i) {
      const node = nodes[i], dy = (node.y1 - y) * alpha;
      dy > 1e-6 && (node.y0 -= dy, node.y1 -= dy), y = node.y0 - this._gapY;
    }
  }
  targetTop(source, target) {
    let i, len, link3, y = source.y0 - (source.sourceLinks.length - 1) * this._gapY / 2;
    for (i = 0, len = source.sourceLinks.length; i < len && (link3 = source.sourceLinks[i], link3.target !== target.key); i++)
      y += link3.thickness + this._gapY;
    for (i = 0, len = target.targetLinks.length; i < len && (link3 = target.targetLinks[i], link3.source !== source.key); i++)
      y -= link3.thickness;
    return y;
  }
  sourceTop(source, target) {
    let i, len, link3, y = target.y0 - (target.targetLinks.length - 1) * this._gapY / 2;
    for (i = 0, len = target.targetLinks.length; i < len && (link3 = target.targetLinks[i], link3.source !== source.key); i++)
      y += link3.thickness + this._gapY;
    for (i = 0, len = source.sourceLinks.length; i < len && (link3 = source.sourceLinks[i], link3.target !== target.key); i++)
      y -= link3.thickness;
    return y;
  }
  computeLinkBreadthsNoOverlap(nodes) {
    for (let i = 0, len = nodes.length; i < len; i++) {
      const node = nodes[i];
      let y05 = node.y0, reachBottom = false;
      for (let j = 0, linkLen = node.sourceLinks.length; j < linkLen; j++) {
        const link3 = node.sourceLinks[j];
        reachBottom || (link3.y0 = y05 + link3.thickness / 2), link3.x0 = node.x1, y05 + link3.thickness > node.y1 || reachBottom ? (link3.y0 = node.y1 - link3.thickness / 2, reachBottom = true) : y05 += link3.thickness;
      }
      let y14 = node.y0;
      reachBottom = false;
      for (let j = 0, linkLen = node.targetLinks.length; j < linkLen; j++) {
        const link3 = node.targetLinks[j];
        reachBottom || (link3.y1 = y14 + link3.thickness / 2), link3.x1 = node.x0, y14 + link3.thickness > node.y1 || reachBottom ? (link3.y1 = node.y1 - link3.thickness / 2, reachBottom = true) : y14 += link3.thickness;
      }
    }
  }
  computeLinkBreadthsOverlap(nodes) {
    const linkOverlap = this.options.linkOverlap;
    for (let i = 0, len = nodes.length; i < len; i++) {
      const node = nodes[i], pos = "start" === linkOverlap ? node.y0 : "end" === linkOverlap ? node.y1 : (node.y0 + node.y1) / 2, sign3 = "start" === linkOverlap ? 0.5 : "end" === linkOverlap ? -0.5 : 0;
      for (let j = 0, linkLen = node.sourceLinks.length; j < linkLen; j++) {
        const link3 = node.sourceLinks[j];
        link3.y0 = pos + sign3 * link3.thickness, link3.x0 = node.x1;
      }
      for (let j = 0, linkLen = node.targetLinks.length; j < linkLen; j++) {
        const link3 = node.targetLinks[j];
        link3.y1 = pos + sign3 * link3.thickness, link3.x1 = node.x0;
      }
    }
  }
  computeLinkBreadths(nodes) {
    this.options.linkOverlap ? this.computeLinkBreadthsOverlap(nodes) : this.computeLinkBreadthsNoOverlap(nodes);
  }
  reorderNodeLinks(node) {
    if (isNil_default(this.options.linkSortBy)) {
      const targetLinks = node.targetLinks, sourceLinks = node.sourceLinks;
      for (let j = 0, linkLen = targetLinks.length; j < linkLen; j++) {
        const link3 = targetLinks[j];
        this._nodeMap[link3.source].sourceLinks.sort(this._ascendingTargetBreadth);
      }
      for (let j = 0, linkLen = sourceLinks.length; j < linkLen; j++) {
        const link3 = sourceLinks[j];
        this._nodeMap[link3.target].targetLinks.sort(this._ascendingSourceBreadth);
      }
    }
  }
  reorderLinks(nodes) {
    if (isNil_default(this.options.linkSortBy))
      for (let i = 0, len = nodes.length; i < len; i++) {
        const node = nodes[i];
        node.sourceLinks.sort(this._ascendingTargetBreadth), node.targetLinks.sort(this._ascendingSourceBreadth);
      }
  }
};
SankeyLayout.defaultOptions = {
  iterations: 6,
  nodeAlign: "justify",
  direction: "horizontal",
  nodeWidth: 24,
  nodeGap: 8,
  crossNodeAlign: "middle",
  dropIsolatedNode: true
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/data/transforms/sankey
var collectHierarchyField = (set, data, field3) => {
  data.forEach((obj) => {
    isNil_default(obj[field3]) || set.add(obj[field3]), obj.children && obj.children.length > 0 && collectHierarchyField(set, obj.children, field3);
  });
};
var sankeyFormat = (data) => {
  var _a;
  if (!data || !isArray_default(data))
    return [];
  if (data.length > 1) {
    const updateData = {
      links: [],
      nodes: []
    };
    return data.forEach((datum) => {
      "links" !== datum.id && "nodes" !== datum.id || (updateData[datum.id] = datum.values);
    }), [updateData];
  }
  return (null === (_a = data[0]) || void 0 === _a ? void 0 : _a.latestData) ? data[0].latestData : data;
};
var sankeyLayout = (data, op) => {
  if (!data || !(null == op ? void 0 : op.view) || !data.length)
    return [];
  const view = op.view();
  if (view.x1 - view.x0 == 0 || view.y1 - view.y0 == 0 || view.x1 - view.x0 == -1 / 0 || view.x1 - view.x0 == 1 / 0 || view.y1 - view.y0 == -1 / 0 || view.y1 - view.y0 == 1 / 0)
    return [];
  const originalData = data[0];
  if (("source" !== op.sourceField || "target" !== op.targetField || "value" !== op.valueField) && originalData.links) {
    const updatedData = [];
    originalData.links.forEach((datum) => {
      const updatedDatum = {};
      for (const key in datum)
        key === op.sourceField ? updatedDatum.source = datum[op.sourceField] : key === op.targetField ? updatedDatum.target = datum[op.targetField] : key === op.valueField ? updatedDatum.value = datum[op.valueField] : updatedDatum[key] = datum[key];
      updatedData.push(updatedDatum);
    }), originalData.links = updatedData;
  }
  const layout = new SankeyLayout(op), result2 = [];
  return result2.push(layout.layout(originalData, view)), result2;
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/data/transforms/sankey-nodes
var sankeyNodes = (data) => {
  var _a, _b;
  return data && isArray_default(data) && (null === (_a = data[0]) || void 0 === _a ? void 0 : _a.latestData) && data[0].latestData.length && data[0].latestData[0] && null !== (_b = data[0].latestData[0].nodes) && void 0 !== _b ? _b : [];
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/data/transforms/sankey-links
var sankeyLinks = (data) => {
  var _a, _b;
  return data && isArray_default(data) && (null === (_a = data[0]) || void 0 === _a ? void 0 : _a.latestData) && data[0].latestData.length && data[0].latestData[0] && null !== (_b = data[0].latestData[0].links) && void 0 !== _b ? _b : [];
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/sankey/tooltip-helper
var SankeySeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  getDefaultTooltipPattern(activeType, dimensionInfo) {
    switch (activeType) {
      case "mark":
        return {
          visible: true,
          activeType,
          title: {
            key: void 0,
            value: (datum) => {
              if (datum.source) {
                if (isNumber_default(datum.source)) {
                  const seriesKeys = this.series.getSeriesKeys();
                  return seriesKeys[datum.source] + " => " + seriesKeys[datum.target];
                }
                return datum.source + " => " + datum.target;
              }
              return datum.datum ? datum.datum[this.series.getSpec().categoryField] : datum.key;
            },
            hasShape: false
          },
          content: [{
            key: this.markTooltipKeyCallback,
            value: (datum) => datum.value,
            hasShape: true,
            shapeType: this.shapeTypeCallback,
            shapeColor: this.shapeColorCallback,
            shapeStroke: this.shapeStrokeCallback,
            shapeHollow: false
          }]
        };
      case "dimension":
        if (dimensionInfo) {
          const title3 = {
            key: void 0,
            value: this._getDimensionData,
            hasShape: false
          }, content = [];
          return dimensionInfo.forEach(({ data }) => data.forEach(({ series: series2 }) => {
            content.push({
              seriesId: series2.id,
              key: this.markTooltipKeyCallback,
              value: this.markTooltipValueCallback,
              hasShape: true,
              shapeType: this.shapeTypeCallback,
              shapeColor: this.shapeColorCallback,
              shapeStroke: this.shapeStrokeCallback,
              shapeHollow: false
            });
          })), {
            visible: true,
            activeType,
            title: title3,
            content
          };
        }
    }
    return null;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/mark/link-path
var LinkPathMark = class _LinkPathMark extends BaseMark {
  constructor() {
    super(...arguments), this.type = _LinkPathMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      x: 0,
      y: 0,
      x0: 0,
      y0: 0,
      x1: 100,
      y1: 100,
      thickness: 1,
      round: true
    });
  }
  _initProduct(group) {
    const view = this.getVGrammarView(), id2 = this.getProductId(), direction2 = this.getStyle("direction");
    this._product = view.glyph("linkPath", null != group ? group : view.rootMark).id(id2).configureGlyph({
      direction: direction2
    }), this._compiledProductId = id2;
  }
};
LinkPathMark.type = "linkPath";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/sankey/sankey
var SankeySeries = class _SankeySeries extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.sankey, this._nodeLayoutZIndex = LayoutZIndex.Node, this._labelLayoutZIndex = LayoutZIndex.Label, this._viewBox = new Bounds(), this._fillByNode = (datum) => {
      var _a, _b, _c, _d, _e;
      if (datum && datum.sourceRect && datum.targetRect)
        return this._fillByLink(datum);
      const fill = null === (_b = null === (_a = this._spec.node) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.fill;
      if (isValid_default(fill))
        return fill;
      if (isValid_default(this._spec.seriesField)) {
        const colorScale = null === (_d = null === (_c = this._option) || void 0 === _c ? void 0 : _c.globalScale) || void 0 === _d ? void 0 : _d.getScale("color"), nodeDatum = (null == datum ? void 0 : datum.datum) ? datum.datum : datum;
        return null == colorScale ? void 0 : colorScale.scale(null == nodeDatum ? void 0 : nodeDatum[this._spec.seriesField]);
      }
      return null === (_e = this._colorScale) || void 0 === _e ? void 0 : _e.scale(this._getNodeNameFromData(datum));
    }, this._fillByLink = (datum) => {
      var _a, _b, _c, _d, _e, _f, _g;
      const fill = null === (_b = null === (_a = this._spec.link) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.fill;
      if (fill)
        return fill;
      if (isValid_default(this._spec.seriesField)) {
        const sourceNode = null === (_d = null === (_c = this._nodesSeriesData) || void 0 === _c ? void 0 : _c.getLatestData()) || void 0 === _d ? void 0 : _d.find((entry) => datum.source === entry.key), nodeDatum = null == sourceNode ? void 0 : sourceNode.datum, colorScale = null === (_f = null === (_e = this._option) || void 0 === _e ? void 0 : _e.globalScale) || void 0 === _f ? void 0 : _f.getScale("color");
        return null == colorScale ? void 0 : colorScale.scale(null == nodeDatum ? void 0 : nodeDatum[this._spec.seriesField]);
      }
      const sourceName = isNumber_default(datum.source) ? this.getNodeList()[datum.source] : datum.source;
      return null === (_g = this._colorScale) || void 0 === _g ? void 0 : _g.scale(sourceName);
    }, this._handleEmphasisElement = (params2) => {
      var _a;
      const emphasisSpec = null !== (_a = this._spec.emphasis) && void 0 !== _a ? _a : {}, element = params2.item;
      "adjacency" === emphasisSpec.effect ? element && element.mark.id().includes("node") ? this._handleNodeAdjacencyClick(element) : element && element.mark.id().includes("link") ? this._handleLinkAdjacencyClick(element) : this._handleClearEmpty() : "related" === emphasisSpec.effect && (element && element.mark.id().includes("node") ? this._handleNodeRelatedClick(element) : element && element.mark.id().includes("link") ? this._handleLinkRelatedClick(element) : this._handleClearEmpty());
    }, this._handleClearEmpty = () => {
      var _a, _b, _c;
      const allNodeElements = null === (_a = this._nodeMark) || void 0 === _a ? void 0 : _a.getProductElements();
      if (!allNodeElements || !allNodeElements.length)
        return;
      const allLinkElements = null === (_b = this._linkMark) || void 0 === _b ? void 0 : _b.getProductElements();
      if (!allLinkElements || !allLinkElements.length)
        return;
      const allLabelElements = null === (_c = this._labelMark) || void 0 === _c ? void 0 : _c.getProductElements();
      if (!allLabelElements || !allLabelElements.length)
        return;
      const states = [STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS, STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE];
      allNodeElements.forEach((el) => {
        el.removeState(states);
      }), allLinkElements.forEach((el) => {
        el.removeState(states);
      }), allLabelElements.forEach((el) => {
        el.removeState(states);
      });
    }, this._handleNodeAdjacencyClick = (element) => {
      const nodeDatum = element.getDatum(), highlightNodes = [nodeDatum.key];
      if (this._linkMark) {
        const allLinkElements = this._linkMark.getProductElements();
        if (!allLinkElements || !allLinkElements.length)
          return;
        allLinkElements.forEach((linkEl, i) => {
          const linkDatum = linkEl.getDatum(), father = (null == linkDatum ? void 0 : linkDatum.parents) ? "parents" : "source";
          if (array(linkDatum[father]).includes(nodeDatum.key)) {
            let ratio;
            if (highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target), "parents" === father) {
              const originalDatum = linkDatum.datum;
              ratio = (originalDatum ? originalDatum.filter((entry) => entry.parents.some((par) => par.key === nodeDatum.key)).reduce((sum4, d) => sum4 + d.value, 0) : 0) / linkDatum.value;
            }
            linkEl.removeState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE), linkEl.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS), linkEl.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS, {
              ratio
            });
          } else
            linkDatum.target === nodeDatum.key ? highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source) : (linkEl.removeState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS), linkEl.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE));
        });
      }
      this._nodeMark && this._highLightElements(this._nodeMark.getProductElements(), highlightNodes), this._labelMark && this._highLightElements(this._labelMark.getProductElements(), highlightNodes);
    }, this._handleLinkAdjacencyClick = (element) => {
      const curLinkDatum = element.getDatum(), highlightNodes = [curLinkDatum.source, curLinkDatum.target];
      if (this._linkMark) {
        const allLinkElements = this._linkMark.getProductElements();
        if (!allLinkElements || !allLinkElements.length)
          return;
        allLinkElements.forEach((linkEl) => {
          linkEl === element ? (linkEl.removeState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE), linkEl.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS, {
            ratio: 1
          })) : (linkEl.removeState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS), linkEl.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE));
        });
      }
      this._nodeMark && this._highLightElements(this._nodeMark.getProductElements(), highlightNodes), this._labelMark && this._highLightElements(this._labelMark.getProductElements(), highlightNodes);
    }, this._handleNodeRelatedClick = (element) => {
      var _a;
      const nodeDatum = element.getDatum(), allNodeElements = this._nodeMark.getProductElements();
      if (!allNodeElements || !allNodeElements.length)
        return;
      const allLinkElements = this._linkMark.getProductElements();
      if (!allLinkElements || !allLinkElements.length)
        return;
      if ("source" === ((null === (_a = allLinkElements[0].getDatum()) || void 0 === _a ? void 0 : _a.parents) ? "parents" : "source")) {
        const highlightNodes = [nodeDatum.key], highlightLinks = [];
        if (allLinkElements.forEach((linkEl, i) => {
          var _a2, _b, _c, _d;
          const linkDatum = linkEl.getDatum(), father = (null == linkDatum ? void 0 : linkDatum.parents) ? "parents" : "source";
          if (array(linkDatum[father]).includes(nodeDatum.key)) {
            if (highlightLinks.includes(null !== (_a2 = linkDatum.key) && void 0 !== _a2 ? _a2 : linkDatum.index) || highlightLinks.push(null !== (_b = linkDatum.key) && void 0 !== _b ? _b : linkDatum.index), highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), !highlightNodes.includes(linkDatum.target)) {
              highlightNodes.push(linkDatum.target);
              let targetNodeSourceLinks = allNodeElements.find((nodeElement) => nodeElement.data[0].key === linkDatum.target).data[0].sourceLinks;
              for (; (null == targetNodeSourceLinks ? void 0 : targetNodeSourceLinks.length) > 0; ) {
                const newTargetNodeSourceLinks = [];
                return targetNodeSourceLinks.forEach((targetNodeSourceLinkDatum) => {
                  var _a3, _b2;
                  if (!highlightLinks.includes(null !== (_a3 = targetNodeSourceLinkDatum.key) && void 0 !== _a3 ? _a3 : targetNodeSourceLinkDatum.index) && (highlightLinks.push(null !== (_b2 = targetNodeSourceLinkDatum.key) && void 0 !== _b2 ? _b2 : targetNodeSourceLinkDatum.index), !highlightNodes.includes(targetNodeSourceLinkDatum.target))) {
                    highlightNodes.push(targetNodeSourceLinkDatum.target);
                    const sourceNodeTemp = allNodeElements.find((nodeElement) => nodeElement.data[0].key === targetNodeSourceLinkDatum.target);
                    newTargetNodeSourceLinks.push(sourceNodeTemp.data[0].targetLinks);
                  }
                }), void (targetNodeSourceLinks = newTargetNodeSourceLinks);
              }
            }
          } else if (linkDatum.target === nodeDatum.key && (highlightLinks.includes(null !== (_c = linkDatum.key) && void 0 !== _c ? _c : linkDatum.index) || highlightLinks.push(null !== (_d = linkDatum.key) && void 0 !== _d ? _d : linkDatum.index), !highlightNodes.includes(linkDatum.source))) {
            highlightNodes.push(linkDatum.source);
            let sourceNodeTargetLinks = allNodeElements.find((nodeElement) => nodeElement.data[0].key === linkDatum.source).data[0].targetLinks;
            for (; (null == sourceNodeTargetLinks ? void 0 : sourceNodeTargetLinks.length) > 0; ) {
              const newSourceNodeTargetLinks = [];
              return sourceNodeTargetLinks.forEach((sourceNodeTargetLinkDatum) => {
                var _a3, _b2;
                if (!highlightLinks.includes(null !== (_a3 = sourceNodeTargetLinkDatum.key) && void 0 !== _a3 ? _a3 : sourceNodeTargetLinkDatum.index) && (highlightLinks.push(null !== (_b2 = sourceNodeTargetLinkDatum.key) && void 0 !== _b2 ? _b2 : sourceNodeTargetLinkDatum.index), !highlightNodes.includes(sourceNodeTargetLinkDatum.source))) {
                  highlightNodes.push(sourceNodeTargetLinkDatum.source);
                  const sourceNodeTemp = allNodeElements.find((nodeElement) => nodeElement.data[0].key === sourceNodeTargetLinkDatum.source);
                  newSourceNodeTargetLinks.push(sourceNodeTemp.data[0].targetLinks);
                }
              }), void (sourceNodeTargetLinks = newSourceNodeTargetLinks);
            }
          }
        }), this._linkMark) {
          const allLinkElements2 = this._linkMark.getProductElements();
          if (!allLinkElements2 || !allLinkElements2.length)
            return;
          allLinkElements2.forEach((linkEl, i) => {
            var _a2;
            highlightLinks.includes(null !== (_a2 = linkEl.getDatum().key) && void 0 !== _a2 ? _a2 : linkEl.getDatum().index) ? (linkEl.removeState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE), linkEl.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS)) : (linkEl.removeState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS), linkEl.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE));
          });
        }
        this._nodeMark && this._highLightElements(this._nodeMark.getProductElements(), highlightNodes), this._labelMark && this._highLightElements(this._labelMark.getProductElements(), highlightNodes);
      } else {
        const highlightNodes = [nodeDatum.key], upstreamLinks = nodeDatum.targetLinks.reduce((res, link3) => (array(link3.datum).forEach((dividedLink) => {
          const parents = dividedLink.parents, len = parents.length;
          for (let i = 0; i < len; i++) {
            const source = parents[i].key, target = parents[i + 1] ? parents[i + 1].key : nodeDatum.key, value = dividedLink.value, existingItem = res.find((item) => item.source === source && item.target === target);
            existingItem ? existingItem.value += value : res.push({
              source,
              target,
              value
            });
          }
        }), res), []);
        allLinkElements.forEach((linkEl, i) => {
          const linkDatum = linkEl.getDatum(), father = (null == linkDatum ? void 0 : linkDatum.parents) ? "parents" : "source", originalDatum = linkDatum.datum, selectedDatum = originalDatum ? originalDatum.filter((entry) => entry[father].some((par) => par.key === nodeDatum.key)) : null, upSelectedLink = upstreamLinks.find((upLink) => upLink.source === linkDatum.source && upLink.target === linkDatum.target);
          if (selectedDatum && selectedDatum.length) {
            highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target);
            const ratio = selectedDatum.reduce((sum4, d) => sum4 + d.value, 0) / linkDatum.value;
            return linkEl.removeState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE), linkEl.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS), void linkEl.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS, {
              ratio
            });
          }
          if (upSelectedLink)
            return highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target), linkEl.removeState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE), linkEl.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS), void linkEl.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS, {
              ratio: upSelectedLink.value / linkDatum.value
            });
          linkEl.removeState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS), linkEl.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE);
        }), this._nodeMark && this._highLightElements(this._nodeMark.getProductElements(), highlightNodes), this._labelMark && this._highLightElements(this._labelMark.getProductElements(), highlightNodes);
      }
    }, this._handleLinkRelatedClick = (element) => {
      var _a;
      const allNodeElements = this._nodeMark.getProductElements();
      if (!allNodeElements || !allNodeElements.length)
        return;
      const allLinkElements = this._linkMark.getProductElements();
      if (!allLinkElements || !allLinkElements.length)
        return;
      if ("source" === ((null === (_a = element.getDatum()) || void 0 === _a ? void 0 : _a.parents) ? "parents" : "source")) {
        const states = [STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS, STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE];
        if (this._linkMark && allLinkElements.forEach((linkEl) => {
          linkEl.removeState(states);
        }), this._nodeMark && allNodeElements.forEach((el) => {
          el.removeState(states);
        }), this._labelMark) {
          const allLabelElements = this._labelMark.getProductElements();
          if (!allLabelElements || !allLabelElements.length)
            return;
          allLabelElements.forEach((el) => {
            el.removeState(states);
          });
        }
      } else {
        const curLinkDatum = element.getDatum(), highlightNodes = [curLinkDatum.source, curLinkDatum.target], upstreamLinks = [];
        array(curLinkDatum.datum).forEach((dividedLink) => {
          const parents = dividedLink.parents, len = parents.length;
          for (let i = 0; i < len - 1; i++) {
            const source = parents[i].key, target = parents[i + 1].key, value = dividedLink.value, existingItem = upstreamLinks.find((item) => item.source === source && item.target === target);
            upstreamLinks.push({
              source: parents[i].key,
              target: parents[i + 1].key,
              value: dividedLink.value
            }), existingItem ? existingItem.value += value : upstreamLinks.push({
              source,
              target,
              value
            });
          }
        }), allLinkElements.forEach((linkEl) => {
          const linkDatum = linkEl.getDatum(), originalDatum = linkDatum.datum;
          if (linkDatum.source === curLinkDatum.source && linkDatum.target === curLinkDatum.target)
            return linkEl.removeState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE), void linkEl.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS, {
              ratio: 1
            });
          const selectedDatum = originalDatum ? originalDatum.filter((entry) => {
            const parentKeysList = entry.parents.map((item) => item.key);
            return parentKeysList.includes(curLinkDatum.source) && parentKeysList.includes(curLinkDatum.target);
          }) : null;
          if (selectedDatum && selectedDatum.length) {
            highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target);
            const val = selectedDatum.filter((entry) => entry.parents.some((par, index) => {
              var _a2;
              return par.key === curLinkDatum.source && (null === (_a2 = entry.parents[index + 1]) || void 0 === _a2 ? void 0 : _a2.key) === curLinkDatum.target;
            })).reduce((sum4, d) => sum4 + d.value, 0), ratio = val / linkDatum.value;
            return linkEl.removeState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE), linkEl.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS), void linkEl.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS, {
              ratio
            });
          }
          const upSelectedLink = upstreamLinks.find((upLink) => upLink.source === linkDatum.source && upLink.target === linkDatum.target);
          if (upSelectedLink)
            return highlightNodes.includes(linkDatum.source) || highlightNodes.push(linkDatum.source), highlightNodes.includes(linkDatum.target) || highlightNodes.push(linkDatum.target), linkEl.removeState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE), linkEl.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS), void linkEl.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS, {
              ratio: upSelectedLink.value / linkDatum.value
            });
          linkEl.removeState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS), linkEl.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE);
        }), this._highLightElements(allNodeElements, highlightNodes), this._labelMark && this._highLightElements(this._labelMark.getProductElements(), highlightNodes);
      }
    };
  }
  getCategoryField() {
    return this._categoryField;
  }
  setCategoryField(f) {
    return this._categoryField = f, this._categoryField;
  }
  getValueField() {
    return this._valueField;
  }
  setValueField(f) {
    return this._valueField = f, this._valueField;
  }
  setAttrFromSpec() {
    var _a, _b, _c;
    super.setAttrFromSpec(), this.setCategoryField(this._spec.categoryField), this.setValueField(this._spec.valueField), this.setSeriesField(null !== (_a = this._spec.seriesField) && void 0 !== _a ? _a : this._spec.categoryField), this._labelLimit = null !== (_c = null === (_b = this._spec.label) || void 0 === _b ? void 0 : _b.limit) && void 0 !== _c ? _c : 100;
  }
  initData() {
    var _a, _b, _c, _d;
    super.initData();
    const viewData = this.getViewData(), rawData = this.getRawData();
    if (rawData && viewData) {
      registerDataSetInstanceTransform(this._dataSet, "sankeyLayout", sankeyLayout), registerDataSetInstanceTransform(this._dataSet, "sankeyFormat", sankeyFormat), rawData.transform({
        type: "sankeyFormat"
      }, false), viewData.transform({
        type: "sankeyLayout",
        options: {
          view: () => ({
            x0: this._viewBox.x1,
            x1: this._viewBox.x2,
            y0: this._viewBox.y1,
            y1: this._viewBox.y2
          }),
          sourceField: this._spec.sourceField,
          targetField: this._spec.targetField,
          valueField: this._spec.valueField,
          direction: this._spec.direction,
          nodeAlign: null !== (_a = this._spec.nodeAlign) && void 0 !== _a ? _a : "justify",
          nodeGap: null !== (_b = this._spec.nodeGap) && void 0 !== _b ? _b : 8,
          nodeWidth: null !== (_c = this._spec.nodeWidth) && void 0 !== _c ? _c : 10,
          linkWidth: this._spec.linkWidth,
          minStepWidth: this._spec.minStepWidth,
          minNodeHeight: null !== (_d = this._spec.minNodeHeight) && void 0 !== _d ? _d : 4,
          minLinkHeight: this._spec.minLinkHeight,
          iterations: this._spec.iterations,
          nodeKey: this._spec.nodeKey,
          linkSortBy: this._spec.linkSortBy,
          nodeSortBy: this._spec.nodeSortBy,
          setNodeLayer: this._spec.setNodeLayer,
          dropIsolatedNode: this._spec.dropIsolatedNode,
          nodeHeight: this._spec.nodeHeight,
          linkHeight: this._spec.linkHeight,
          equalNodeHeight: this._spec.equalNodeHeight,
          linkOverlap: this._spec.linkOverlap
        },
        level: TransformLevel.sankeyLayout
      });
      const { dataSet } = this._option;
      registerDataSetInstanceTransform(dataSet, "sankeyNodes", sankeyNodes), registerDataSetInstanceTransform(dataSet, "flatten", flatten);
      const nodesDataView = new DataView(dataSet, {
        name: `sankey-node-${this.id}-data`
      });
      nodesDataView.parse([this.getViewData()], {
        type: "dataview"
      }), nodesDataView.transform({
        type: "sankeyNodes"
      }), nodesDataView.transform({
        type: "flatten",
        options: {
          callback: (node) => {
            if (node.datum) {
              const nodeData = node.datum[node.depth];
              return Object.assign(Object.assign({}, node), nodeData);
            }
            return node;
          }
        }
      }, false), nodesDataView.transform({
        type: "addVChartProperty",
        options: {
          beforeCall: initKeyMap.bind(this),
          call: addDataKey
        }
      }, false), this._nodesSeriesData = new SeriesData(this._option, nodesDataView), registerDataSetInstanceTransform(dataSet, "sankeyLinks", sankeyLinks);
      const linksDataView = new DataView(dataSet, {
        name: `sankey-link-${this.id}-data`
      });
      linksDataView.parse([this.getViewData()], {
        type: "dataview"
      }), linksDataView.transform({
        type: "sankeyLinks"
      }), linksDataView.transform({
        type: "addVChartProperty",
        options: {
          beforeCall: initKeyMap.bind(this),
          call: addDataKey
        }
      }, false), this._linksSeriesData = new SeriesData(this._option, linksDataView);
    }
  }
  initMark() {
    var _a, _b, _c, _d;
    const nodeMark = this._createMark(_SankeySeries.mark.node, {
      isSeriesMark: true,
      dataView: this._nodesSeriesData.getDataView(),
      dataProductId: this._nodesSeriesData.getProductId(),
      customShape: null === (_a = this._spec.node) || void 0 === _a ? void 0 : _a.customShape,
      stateSort: null === (_b = this._spec.node) || void 0 === _b ? void 0 : _b.stateSort
    });
    nodeMark && (nodeMark.setZIndex(this._nodeLayoutZIndex), this._nodeMark = nodeMark);
    const linkMark = this._createMark(_SankeySeries.mark.link, {
      dataView: this._linksSeriesData.getDataView(),
      dataProductId: this._linksSeriesData.getProductId(),
      customShape: null === (_c = this._spec.link) || void 0 === _c ? void 0 : _c.customShape,
      stateSort: null === (_d = this._spec.link) || void 0 === _d ? void 0 : _d.stateSort
    });
    if (linkMark && (this._linkMark = linkMark), this._spec.label && this._spec.label.visible) {
      const labelMark = this._createMark(_SankeySeries.mark.label, {
        dataView: this._nodesSeriesData.getDataView(),
        dataProductId: this._nodesSeriesData.getProductId()
      });
      labelMark && (this._labelMark = labelMark);
    }
  }
  _buildMarkAttributeContext() {
    super._buildMarkAttributeContext(), this._markAttributeContext.valueToNode = this.valueToNode.bind(this), this._markAttributeContext.valueToLink = this.valueToLink.bind(this);
  }
  valueToNode(value) {
    const nodes = this._nodesSeriesData.getLatestData(), specifyValue = array(value)[0];
    return nodes && nodes.find((node) => node.key === specifyValue);
  }
  valueToLink(value) {
    const links = this._linksSeriesData.getLatestData(), specifyValue = array(value);
    return links && links.find((link3) => link3 && link3.source === specifyValue[0] && link3.target === specifyValue[1]);
  }
  valueToPositionX(value) {
    const node = this.valueToNode(value);
    return null == node ? void 0 : node.x0;
  }
  valueToPositionY(value) {
    const node = this.valueToNode(value);
    return null == node ? void 0 : node.y0;
  }
  initMarkStyle() {
    this._initNodeMarkStyle(), this._initLinkMarkStyle(), this._initLabelMarkStyle();
  }
  _initNodeMarkStyle() {
    const nodeMark = this._nodeMark;
    nodeMark && this.setMarkStyle(nodeMark, {
      x: (datum) => datum.x0,
      x1: (datum) => datum.x1,
      y: (datum) => datum.y0,
      y1: (datum) => datum.y1,
      fill: this._fillByNode
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Mark);
  }
  _initLinkMarkStyle() {
    var _a;
    const linkMark = this._linkMark;
    linkMark && this.setMarkStyle(linkMark, {
      x0: (datum) => datum.x0,
      x1: (datum) => datum.x1,
      y0: (datum) => datum.y0,
      y1: (datum) => datum.y1,
      thickness: (datum) => datum.thickness,
      fill: this._fillByLink,
      direction: null !== (_a = this._spec.direction) && void 0 !== _a ? _a : "horizontal"
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  _initLabelMarkStyle() {
    this._labelMark && ("vertical" === this._spec.direction ? "inside-start" === this._spec.label.position ? this.setMarkStyle(this._labelMark, {
      x: (datum) => datum.x0,
      y: (datum) => (datum.y0 + datum.y1) / 2,
      fill: "#ffffff",
      text: (datum) => this._createText(datum),
      limit: (datum) => {
        var _a;
        return null !== (_a = this._spec.label.limit) && void 0 !== _a ? _a : datum.x1 - datum.x0;
      },
      textAlign: "left",
      textBaseline: "middle"
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series) : "inside-middle" === this._spec.label.position ? this.setMarkStyle(this._labelMark, {
      x: (datum) => (datum.x0 + datum.x1) / 2,
      y: (datum) => (datum.y0 + datum.y1) / 2,
      fill: "#ffffff",
      text: (datum) => this._createText(datum),
      limit: (datum) => {
        var _a;
        return null !== (_a = this._spec.label.limit) && void 0 !== _a ? _a : datum.x1 - datum.x0;
      },
      textAlign: "center",
      textBaseline: "middle"
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series) : "inside-end" === this._spec.label.position ? this.setMarkStyle(this._labelMark, {
      x: (datum) => datum.x1,
      y: (datum) => (datum.y0 + datum.y1) / 2,
      fill: "#ffffff",
      text: (datum) => this._createText(datum),
      limit: (datum) => {
        var _a;
        return null !== (_a = this._spec.label.limit) && void 0 !== _a ? _a : datum.x1 - datum.x0;
      },
      textAlign: "right",
      textBaseline: "middle"
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series) : this.setMarkStyle(this._labelMark, {
      x: (datum) => (datum.x0 + datum.x1) / 2,
      y: (datum) => datum.y1 >= this._viewBox.y2 ? datum.y0 : datum.y1,
      fill: this._fillByNode,
      text: (datum) => this._createText(datum),
      limit: this._labelLimit,
      textAlign: "center",
      textBaseline: (datum) => datum.y1 >= this._viewBox.y2 ? "bottom" : "top"
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series) : "inside-start" === this._spec.label.position ? this.setMarkStyle(this._labelMark, {
      x: (datum) => datum.x0,
      y: (datum) => (datum.y0 + datum.y1) / 2,
      fill: "#ffffff",
      text: (datum) => this._createText(datum),
      limit: (datum) => {
        var _a;
        return null !== (_a = this._spec.label.limit) && void 0 !== _a ? _a : datum.x1 - datum.x0;
      },
      textAlign: "left",
      textBaseline: "middle"
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series) : "inside-middle" === this._spec.label.position ? this.setMarkStyle(this._labelMark, {
      x: (datum) => (datum.x0 + datum.x1) / 2,
      y: (datum) => (datum.y0 + datum.y1) / 2,
      fill: "#ffffff",
      text: (datum) => this._createText(datum),
      limit: (datum) => {
        var _a;
        return null !== (_a = this._spec.label.limit) && void 0 !== _a ? _a : datum.x1 - datum.x0;
      },
      textAlign: "center",
      textBaseline: "middle"
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series) : "inside-end" === this._spec.label.position ? this.setMarkStyle(this._labelMark, {
      x: (datum) => datum.x1,
      y: (datum) => (datum.y0 + datum.y1) / 2,
      fill: "#ffffff",
      text: (datum) => this._createText(datum),
      limit: (datum) => {
        var _a;
        return null !== (_a = this._spec.label.limit) && void 0 !== _a ? _a : datum.x1 - datum.x0;
      },
      textAlign: "right",
      textBaseline: "middle"
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series) : "left" === this._spec.label.position ? this.setMarkStyle(this._labelMark, {
      x: (datum) => datum.x0,
      y: (datum) => (datum.y0 + datum.y1) / 2,
      fill: this._fillByNode,
      text: (datum) => this._createText(datum),
      limit: this._labelLimit,
      textAlign: "right",
      textBaseline: "middle"
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series) : "right" === this._spec.label.position ? this.setMarkStyle(this._labelMark, {
      x: (datum) => datum.x1,
      y: (datum) => (datum.y0 + datum.y1) / 2,
      fill: this._fillByNode,
      text: (datum) => this._createText(datum),
      limit: this._labelLimit,
      textAlign: "left",
      textBaseline: "middle"
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series) : this.setMarkStyle(this._labelMark, {
      x: (datum) => datum.x1 >= this._viewBox.x2 ? datum.x0 : datum.x1,
      y: (datum) => (datum.y0 + datum.y1) / 2,
      fill: this._fillByNode,
      text: (datum) => this._createText(datum),
      limit: this._labelLimit,
      textAlign: (datum) => datum.x1 >= this._viewBox.x2 ? "right" : "left",
      textBaseline: "middle"
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series), this._labelMark.setZIndex(this._labelLayoutZIndex));
  }
  _createText(datum) {
    var _a;
    if (isNil_default(datum) || isNil_default(datum.datum))
      return "";
    let text2 = datum.datum[this._spec.categoryField] || "";
    return (null === (_a = this._spec.label) || void 0 === _a ? void 0 : _a.formatMethod) && (text2 = this._spec.label.formatMethod(text2, datum.datum)), text2;
  }
  initAnimation() {
    var _a, _b, _c, _d, _e;
    const animationParams = {
      direction: this.direction,
      growFrom: () => {
        var _a2, _b2;
        return "horizontal" === this.direction ? null === (_a2 = this._xAxisHelper) || void 0 === _a2 ? void 0 : _a2.getScale(0).scale(0) : null === (_b2 = this._yAxisHelper) || void 0 === _b2 ? void 0 : _b2.getScale(0).scale(0);
      }
    }, appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
    this._nodeMark && this._nodeMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("sankeyNode")) || void 0 === _c ? void 0 : _c(animationParams, appearPreset), userAnimationConfig("node", this._spec, this._markAttributeContext))), this._linkMark && this._linkMark.setAnimationConfig(animationConfig(null === (_d = Factory2.getAnimationInKey("sankeyLinkPath")) || void 0 === _d ? void 0 : _d(animationParams, appearPreset), userAnimationConfig("link", this._spec, this._markAttributeContext))), this._labelMark && this._labelMark.setAnimationConfig(animationConfig(null === (_e = Factory2.getAnimationInKey("fadeInOut")) || void 0 === _e ? void 0 : _e(), userAnimationConfig("label", this._spec, this._markAttributeContext)));
  }
  initEvent() {
    var _a, _b, _c;
    super.initEvent(), null === (_a = this._nodesSeriesData.getDataView()) || void 0 === _a || _a.target.addListener("change", this.nodesSeriesDataUpdate.bind(this)), null === (_b = this._linksSeriesData.getDataView()) || void 0 === _b || _b.target.addListener("change", this.linksSeriesDataUpdate.bind(this));
    const emphasisSpec = null !== (_c = this._spec.emphasis) && void 0 !== _c ? _c : {};
    if (true !== this._option.disableTriggerEvent && emphasisSpec.enable && ("adjacency" === emphasisSpec.effect || "related" === emphasisSpec.effect)) {
      const event = "hover" === emphasisSpec.trigger ? "pointerover" : "pointerdown";
      this.event.on(event, {
        level: Event_Bubble_Level.chart
      }, this._handleEmphasisElement);
    }
  }
  nodesSeriesDataUpdate() {
    this._nodesSeriesData.updateData(), this._nodeList = null, this._setNodeOrdinalColorScale();
  }
  linksSeriesDataUpdate() {
    this._linksSeriesData.updateData();
  }
  _highLightElements(vGrammarElements, highlightNodes) {
    vGrammarElements && vGrammarElements.length && vGrammarElements.forEach((el) => {
      el.removeState([STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE, STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS]), highlightNodes.includes(el.getDatum().key) || el.addState(STATE_VALUE_ENUM.STATE_SANKEY_EMPHASIS_REVERSE);
    });
  }
  initTooltip() {
    this._tooltipHelper = new SankeySeriesTooltipHelper(this), this._nodeMark && this._tooltipHelper.activeTriggerSet.mark.add(this._nodeMark), this._linkMark && this._tooltipHelper.activeTriggerSet.mark.add(this._linkMark), this._labelMark && this._tooltipHelper.activeTriggerSet.mark.add(this._labelMark);
  }
  _setNodeOrdinalColorScale() {
    var _a, _b, _c, _d, _e;
    const colorScale = null === (_b = null === (_a = this._option) || void 0 === _a ? void 0 : _a.globalScale) || void 0 === _b ? void 0 : _b.getScale("color");
    if (null == colorScale ? void 0 : colorScale._specified)
      return void (this._colorScale = colorScale);
    let colorDomain, colorRange;
    colorScale && (colorDomain = colorScale.domain(), colorRange = colorScale.range()), colorRange || (colorRange = this._getDataScheme()), colorDomain && !isNil_default(colorDomain[0]) || (colorDomain = this.getNodeList(), colorDomain.length > 10 && (colorRange = null === (_c = this._getDataScheme()[1]) || void 0 === _c ? void 0 : _c.scheme));
    const ordinalScale = new ColorOrdinalScale();
    null === (_e = (_d = ordinalScale.domain(colorDomain)).range) || void 0 === _e || _e.call(_d, colorRange), this._colorScale = ordinalScale;
  }
  getNodeList() {
    var _a;
    if (this._nodeList)
      return this._nodeList;
    const data = this._rawData.latestData[0], nodeList = (null == data ? void 0 : data.nodes) ? (null === (_a = data.nodes[0]) || void 0 === _a ? void 0 : _a.children) ? Array.from(this.extractNamesFromTree(data.nodes, this._spec.categoryField)) : data.nodes.map((datum, index) => datum[this._spec.categoryField]) : (null == data ? void 0 : data.links) ? Array.from(this.extractNamesFromLink(data.links)) : null == data ? void 0 : data.values.map((datum, index) => datum[this._spec.categoryField]);
    return this._nodeList = nodeList, nodeList;
  }
  _getNodeNameFromData(datum) {
    var _a;
    return (null == datum ? void 0 : datum.datum) ? datum.datum[this._spec.categoryField] : null !== (_a = datum.key) && void 0 !== _a ? _a : datum[this._spec.categoryField];
  }
  extractNamesFromTree(tree, categoryName) {
    const uniqueNames = /* @__PURE__ */ new Set();
    return tree.forEach((node) => {
      if (uniqueNames.add(node[categoryName]), node.children) {
        this.extractNamesFromTree(node.children, categoryName).forEach((name) => uniqueNames.add(name));
      }
    }), uniqueNames;
  }
  extractNamesFromLink(links) {
    const uniqueNames = /* @__PURE__ */ new Set(), { sourceField, targetField } = this._spec;
    return links.forEach((link3) => {
      isValid_default(link3[sourceField]) && uniqueNames.add(link3[sourceField]), isValid_default(link3[targetField]) && uniqueNames.add(link3[targetField]);
    }), uniqueNames;
  }
  getDimensionField() {
    return [this._spec.categoryField];
  }
  getMeasureField() {
    return [this._valueField];
  }
  getRawDataStatisticsByField(field3, isNumeric2) {
    var _a;
    if (this._rawStatisticsCache || (this._rawStatisticsCache = {}), !this._rawStatisticsCache[field3]) {
      this._viewDataStatistics && this.getViewData().transformsArr.length <= 1 && (null === (_a = this._viewDataStatistics.latestData) || void 0 === _a ? void 0 : _a[field3]) ? this._rawStatisticsCache[field3] = this._viewDataStatistics.latestData[field3] : this._rawData && (this._rawStatisticsCache[field3] = {
        values: this._collectByField(field3)
      });
    }
    return this._rawStatisticsCache[field3];
  }
  _collectByField(field3) {
    var _a, _b, _c;
    const keyArray = [], rawData = null === (_b = null === (_a = this.getRawData()) || void 0 === _a ? void 0 : _a.latestData) || void 0 === _b ? void 0 : _b[0];
    if (!rawData)
      return [];
    if (rawData.links)
      (null === (_c = rawData.nodes) || void 0 === _c ? void 0 : _c.length) && rawData.nodes.forEach((node) => {
        node[this._seriesField] && keyArray.push(node[this._seriesField]);
      });
    else if (rawData.nodes) {
      const set = /* @__PURE__ */ new Set();
      return collectHierarchyField(set, rawData.nodes, this._seriesField), Array.from(set);
    }
    return keyArray;
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx), this._viewBox.set(0, 0, this._region.getLayoutRect().width, this._region.getLayoutRect().height), this.getViewData().reRunAllTransform();
  }
  getDefaultShapeType() {
    return "square";
  }
  _noAnimationDataKey(datum, index) {
  }
  getActiveMarks() {
    return [this._nodeMark, this._linkMark];
  }
};
SankeySeries.type = SeriesTypeEnum.sankey, SankeySeries.mark = sankeySeriesMark;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/data/transforms/hierarchy-dimension-statistics
var hierarchyDimensionStatistics = (data, op) => {
  let result2 = {}, fields2 = op.fields;
  if (isFunction_default(fields2) && (fields2 = fields2()), !(null == fields2 ? void 0 : fields2.length) || !(null == data ? void 0 : data.length))
    return result2;
  if (!data[0].latestData)
    return result2;
  const hierarchyData = data[0].latestData, flatData = flatten(hierarchyData);
  return result2 = dimensionStatistics([{
    latestData: flatData
  }], op), result2;
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/treemap/tooltip-helper
var TreemapTooltipHelper = class extends BaseSeriesTooltipHelper {
  constructor() {
    super(...arguments), this.markTooltipKeyCallback = (datum) => null == datum ? void 0 : datum[this.series.getDimensionField()[0]];
  }
  get defaultShapeType() {
    return "square";
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/treemap/treemap-transform
var TreemapSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "nonLeaf", "nonLeafLabel", "initNonLeafLabelMarkStyle"), this._addMarkLabelSpec(spec, "leaf");
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/treemap/treemap
var TreemapSeries = class _TreemapSeries extends CartesianSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.treemap, this.transformerConstructor = TreemapSeriesSpecTransformer, this._viewBox = new Bounds(), this._enableAnimationHook = this.enableMarkAnimation.bind(this), this.isHierarchyData = () => true;
  }
  getCategoryField() {
    return this._categoryField;
  }
  setCategoryField(f) {
    return this._categoryField = f, this._categoryField;
  }
  getValueField() {
    return this._valueField;
  }
  setValueField(f) {
    return this._valueField = f, this._valueField;
  }
  setAttrFromSpec() {
    var _a;
    super.setAttrFromSpec(), this.setCategoryField(this._spec.categoryField), this.setValueField(this._spec.valueField), this.setSeriesField(null !== (_a = this._spec.seriesField) && void 0 !== _a ? _a : DEFAULT_HIERARCHY_ROOT), this._spec.roam && (this.initZoomable(this.event, this._option.mode), this._matrix = new Matrix()), this._spec.drill && this.initDrillable({
      event: this.event,
      mode: this._option.mode,
      drillField: () => {
        var _a2, _b;
        return null !== (_b = null !== (_a2 = this._spec.drillField) && void 0 !== _a2 ? _a2 : this._categoryField) && void 0 !== _b ? _b : DEFAULT_DATA_KEY;
      },
      getRawData: () => this.getRawData()
    }), isValidNumber_default(this._spec.maxDepth) && (this._maxDepth = this._spec.maxDepth - 1);
  }
  initData() {
    super.initData(), this.getViewData() && this._spec.drill && this.initDrillableData(this._dataSet);
  }
  compile() {
    super.compile(), this._runTreemapTransform();
  }
  _runTreemapTransform(render = false) {
    var _a, _b, _c, _d;
    const viewDataProduct = this._data.getProduct();
    viewDataProduct && viewDataProduct.transform([{
      type: "treemap",
      x0: this._viewBox.x1,
      x1: this._viewBox.x2,
      y0: this._viewBox.y1,
      y1: this._viewBox.y2,
      maxDepth: this._maxDepth,
      gapWidth: this._spec.gapWidth,
      padding: this._spec.nodePadding,
      splitType: this._spec.splitType,
      aspectRatio: this._spec.aspectRatio,
      labelPadding: (null === (_a = this._spec.nonLeafLabel) || void 0 === _a ? void 0 : _a.visible) ? null === (_b = this._spec.nonLeafLabel) || void 0 === _b ? void 0 : _b.padding : 0,
      labelPosition: null === (_c = this._spec.nonLeafLabel) || void 0 === _c ? void 0 : _c.position,
      minVisibleArea: null !== (_d = this._spec.minVisibleArea) && void 0 !== _d ? _d : 10,
      minChildrenVisibleArea: this._spec.minChildrenVisibleArea,
      minChildrenVisibleSize: this._spec.minChildrenVisibleSize,
      flatten: true
    }, {
      type: "map",
      callback: (datum) => (datum && [DEFAULT_HIERARCHY_ROOT, "name"].forEach((key) => {
        datum[key] = datum.datum[datum.depth][key];
      }), datum)
    }]), render && this.getCompiler().renderNextTick();
  }
  _addDataIndexAndKey() {
    var _a;
    (null === (_a = this._rawData) || void 0 === _a ? void 0 : _a.dataSet) && (registerDataSetInstanceTransform(this._rawData.dataSet, "addVChartProperty", addVChartProperty), this._rawData.transform({
      type: "addVChartProperty",
      options: {
        beforeCall: initHierarchyKeyMap.bind(this),
        call: addHierarchyDataKey
      }
    }));
  }
  getRawDataStatisticsByField(field3, isNumeric2) {
    var _a;
    if (!this._rawDataStatistics) {
      const rawDataName = `${this.type}_${this.id}_rawDataStatic`;
      this._rawDataStatistics = this._createHierarchyDataStatistics(rawDataName, [this._rawData]), this._rawData.target.removeListener("change", this._rawDataStatistics.reRunAllTransform), this._rawDataStatistics.reRunAllTransform();
    }
    return null === (_a = this._rawDataStatistics.latestData) || void 0 === _a ? void 0 : _a[field3];
  }
  _createHierarchyDataStatistics(dataName, rawData) {
    registerDataSetInstanceTransform(this._dataSet, "hierarchyDimensionStatistics", hierarchyDimensionStatistics), registerDataSetInstanceTransform(this._dataSet, "flatten", flatten);
    const data = new DataView(this._dataSet, {
      name: dataName
    });
    return data.parse(rawData, {
      type: "dataview"
    }), data.transform({
      type: "hierarchyDimensionStatistics",
      options: {
        fields: () => {
          const fields2 = this.getStatisticFields();
          return this._seriesField && this._seriesField !== this._categoryField && fields2.push({
            key: this._seriesField,
            operations: ["values"]
          }), fields2;
        }
      }
    }, false), data;
  }
  getStatisticFields() {
    return super.getStatisticFields().concat([{
      key: this._categoryField,
      operations: ["values"]
    }, {
      key: this._valueField,
      operations: ["max", "min"]
    }, {
      key: DEFAULT_HIERARCHY_DEPTH,
      operations: ["max", "min", "values"]
    }, {
      key: DEFAULT_HIERARCHY_ROOT,
      operations: ["values"]
    }]);
  }
  initMark() {
    var _a, _b, _c, _d;
    const nonLeafMark = this._createMark(_TreemapSeries.mark.nonLeaf, {
      isSeriesMark: true,
      customShape: null === (_a = this._spec.nonLeaf) || void 0 === _a ? void 0 : _a.customShape,
      stateSort: null === (_b = this._spec.nonLeaf) || void 0 === _b ? void 0 : _b.stateSort
    });
    nonLeafMark && (nonLeafMark.setTransform([{
      type: "filter",
      callback: (datum) => !this._shouldFilterElement(datum, "nonLeaf")
    }]), this._nonLeafMark = nonLeafMark);
    const leafMark = this._createMark(_TreemapSeries.mark.leaf, {
      isSeriesMark: true,
      customShape: null === (_c = this._spec.leaf) || void 0 === _c ? void 0 : _c.customShape,
      stateSort: null === (_d = this._spec.leaf) || void 0 === _d ? void 0 : _d.stateSort
    });
    leafMark && (leafMark.setTransform([{
      type: "filter",
      callback: (datum) => !this._shouldFilterElement(datum, "leaf")
    }]), this._leafMark = leafMark);
  }
  initMarkStyle() {
    this._initLeafMarkStyle(), this._initNonLeafMarkStyle();
  }
  _initLeafMarkStyle() {
    this._leafMark && this.setMarkStyle(this._leafMark, {
      x: (datum) => datum.x0,
      y: (datum) => datum.y0,
      x1: (datum) => datum.x1,
      y1: (datum) => datum.y1,
      fill: this.getColorAttribute()
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  _initNonLeafMarkStyle() {
    this._nonLeafMark && this.setMarkStyle(this._nonLeafMark, {
      x: (datum) => datum.x0,
      y: (datum) => datum.y0,
      x1: (datum) => datum.x1,
      y1: (datum) => datum.y1,
      fill: this.getColorAttribute()
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  initLabelMarkStyle(labelMark) {
    labelMark && (this._labelMark = labelMark, labelMark.setRule("treemap"), this.setMarkStyle(labelMark, {
      x: (datum) => (datum.x0 + datum.x1) / 2,
      y: (datum) => (datum.y0 + datum.y1) / 2,
      text: (datum) => {
        var _a;
        return null === (_a = datum.datum[datum.depth]) || void 0 === _a ? void 0 : _a[this.getDimensionField()[0]];
      },
      maxLineWidth: (datum) => datum.x1 === datum.x0 ? Number.MIN_VALUE : datum.x1 - datum.x0
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series), "rich" === labelMark.getTextType() && this.setMarkStyle(labelMark, {
      maxWidth: (datum) => Math.abs(datum.x0 - datum.x1),
      maxHeight: (datum) => Math.abs(datum.y0 - datum.y1),
      ellipsis: true
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series));
  }
  initNonLeafLabelMarkStyle(labelMark) {
    labelMark && (this._nonLeafLabelMark = labelMark, labelMark.setRule("treemap"), this.setMarkStyle(labelMark, {
      x: (datum) => datum.labelRect ? (datum.labelRect.x0 + datum.labelRect.x1) / 2 : (datum.x0 + datum.x1) / 2,
      y: (datum) => datum.labelRect ? (datum.labelRect.y0 + datum.labelRect.y1) / 2 : (datum.y0 + datum.y1) / 2,
      text: (datum) => {
        var _a;
        return null === (_a = datum.datum[datum.depth]) || void 0 === _a ? void 0 : _a[this.getDimensionField()[0]];
      },
      maxLineWidth: (datum) => datum.x1 === datum.x0 ? Number.MIN_VALUE : datum.x1 - datum.x0
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series), "rich" === labelMark.getTextType() && this.setMarkStyle(labelMark, {
      maxWidth: (datum) => Math.abs(datum.x0 - datum.x1),
      maxHeight: (datum) => Math.abs(datum.y0 - datum.y1),
      ellipsis: true
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series));
  }
  initAnimation() {
    this.getMarksInType("rect").forEach((mark) => {
      var _a;
      mark.setAnimationConfig(animationConfig(null === (_a = Factory2.getAnimationInKey("treemap")) || void 0 === _a ? void 0 : _a(), userAnimationConfig(mark.name, this._spec, this._markAttributeContext)));
    });
  }
  initEvent() {
    super.initEvent(), this._spec.roam && (this.initDragEventOfSeries(this), this.event.on("panmove", (e) => {
      this.handlePan(e);
    }), this.initZoomEventOfSeries(this), this.event.on("zoom", (e) => {
      this.handleZoom(e);
    })), this._spec.drill && this.bindDrillEvent();
  }
  _getDataIdKey() {
    return "key";
  }
  initTooltip() {
    this._tooltipHelper = new TreemapTooltipHelper(this), this._leafMark && this._tooltipHelper.activeTriggerSet.mark.add(this._leafMark), this._nonLeafMark && this._tooltipHelper.activeTriggerSet.mark.add(this._nonLeafMark);
  }
  _shouldFilterElement(datum, nodeType) {
    const isLeaf = datum.isLeaf;
    return "leaf" === nodeType ? !isLeaf : isLeaf;
  }
  handlePan(event) {
    const { delta } = event;
    if (0 === delta[0] && 0 === delta[1])
      return;
    this._matrix.reset(), this._matrix.translate(delta[0], delta[1]);
    const { a: a3, b, c: c3, d, e, f } = this._matrix;
    this._matrix.multiply(a3, b, c3, d, e, f), this._viewBox.transformWithMatrix(this._matrix), this._runTreemapTransform(true);
  }
  handleZoom(event) {
    const { scale: scale4, scaleCenter } = event;
    if (1 === scale4)
      return;
    this._matrix.reset();
    const { x, y } = scaleCenter;
    this._matrix.translate(x, y), this._matrix.scale(scale4, scale4), this._matrix.translate(-x, -y);
    const { a: a3, b, c: c3, d, e, f } = this._matrix;
    this._matrix.multiply(a3, b, c3, d, e, f), this.disableMarkAnimation(), this.event.on(HOOK_EVENT.AFTER_DO_RENDER, this._enableAnimationHook), this._viewBox.transformWithMatrix(this._matrix), this._runTreemapTransform(true);
  }
  getDimensionField() {
    return [this._categoryField];
  }
  getMeasureField() {
    return [this._valueField];
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx), this._viewBox.set(0, 0, this.getLayoutRect().width, this.getLayoutRect().height), this._runTreemapTransform();
  }
  enableMarkAnimation() {
    this.getMarks().forEach((mark) => {
      var _a;
      null === (_a = mark.getProduct().animate) || void 0 === _a || _a.enable();
    }), [this._labelMark, this._nonLeafLabelMark].forEach((m4) => {
      m4 && m4.getComponent() && m4.getComponent().getProduct().getGroupGraphicItem().enableAnimation();
    }), this.event.off(HOOK_EVENT.AFTER_DO_RENDER, this._enableAnimationHook);
  }
  disableMarkAnimation() {
    this.getMarks().forEach((mark) => {
      var _a;
      null === (_a = mark.getProduct().animate) || void 0 === _a || _a.disable();
    }), [this._labelMark, this._nonLeafLabelMark].forEach((m4) => {
      m4 && m4.getComponent() && m4.getComponent().getProduct().getGroupGraphicItem().disableAnimation();
    });
  }
  getDefaultShapeType() {
    return "square";
  }
  getActiveMarks() {
    return [this._nonLeafMark, this._leafMark];
  }
};
TreemapSeries.type = SeriesTypeEnum.treemap, TreemapSeries.mark = treemapSeriesMark, TreemapSeries.transformerConstructor = TreemapSeriesSpecTransformer, mixin(TreemapSeries, Drillable), mixin(TreemapSeries, Zoomable);

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/data/transforms/correlation
var correlation2 = (data, options) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
  if (!data || !(null == options ? void 0 : options.view) || !isArray_default(data))
    return data;
  const viewBox = options.view();
  if (viewBox.x1 - viewBox.x0 == 0 || viewBox.y1 - viewBox.y0 == 0 || viewBox.x1 - viewBox.x0 == -1 / 0 || viewBox.x1 - viewBox.x0 == 1 / 0 || viewBox.y1 - viewBox.y0 == -1 / 0 || viewBox.y1 - viewBox.y0 == 1 / 0)
    return data;
  const startAngle = degreeToRadian(null !== (_a = options.startAngle) && void 0 !== _a ? _a : -90), endAngle = degreeToRadian(null !== (_b = options.endAngle) && void 0 !== _b ? _b : 270), maxRadius = Math.max((viewBox.x1 - viewBox.x0) / 2, (viewBox.y1 - viewBox.y0) / 2), innerRadius = toPercent(null !== (_c = options.innerRadius) && void 0 !== _c ? _c : 0, maxRadius), outerRadius = toPercent(options.outerRadius, maxRadius), center2 = [isNumber_default(null === (_d = options.center) || void 0 === _d ? void 0 : _d[0]) ? options.center[0] : viewBox.x0 + toPercent(null !== (_f = null === (_e = options.center) || void 0 === _e ? void 0 : _e[0]) && void 0 !== _f ? _f : "50%", viewBox.x1 - viewBox.x0), isNumber_default(null === (_g = options.center) || void 0 === _g ? void 0 : _g[1]) ? options.center[1] : viewBox.y0 + toPercent(null !== (_j = null === (_h = options.center) || void 0 === _h ? void 0 : _h[1]) && void 0 !== _j ? _j : "50%", viewBox.y1 - viewBox.y0)], fieldAccessor = field(options.field), values = data.map(fieldAccessor), [min3, max3] = extent(values), radiusScale = min3 === max3 ? (val) => (innerRadius + outerRadius) / 2 : (val) => innerRadius + (outerRadius - innerRadius) * (val - min3) / (max3 - min3), sizeAccessor = isNil_default(options.radiusField) ? fieldAccessor : field(options.radiusField), defaultSize = null !== (_l = null === (_k = null == options ? void 0 : options.radiusRange) || void 0 === _k ? void 0 : _k[1]) && void 0 !== _l ? _l : 5;
  let sizeScale = (datum) => defaultSize;
  if (sizeAccessor) {
    const [minSize, maxSize] = sizeAccessor !== fieldAccessor ? extent(data.map(sizeAccessor)) : [min3, max3], minR = null !== (_o = null === (_m = options.radiusRange) || void 0 === _m ? void 0 : _m[0]) && void 0 !== _o ? _o : 5, maxR = null !== (_q = null === (_p = options.radiusRange) || void 0 === _p ? void 0 : _p[1]) && void 0 !== _q ? _q : 5;
    minSize !== maxSize && (sizeScale = (datum) => minR + (maxR - minR) * (sizeAccessor(datum) - minSize) / (maxSize - minSize));
  }
  const minAngle = Math.min(startAngle, endAngle), maxAngle = Math.max(startAngle, endAngle), angles = getPartialAngles(minAngle, maxAngle, data.length), res = [], searchAngle = (maxAngle - minAngle) / 60;
  return data.forEach((datum, index) => {
    const radius = radiusScale(values[index]), size = sizeScale(datum);
    let x, y, angle2 = angles[index];
    for (let i = 0; i < 60 && (x = center2[0] + radius * Math.cos(angle2), y = center2[1] + radius * Math.sin(angle2), hasOverlap3({
      x,
      y,
      size
    }, res) || x - size < viewBox.x0 || x + size > viewBox.x1 || y - size < viewBox.y0 || y + size > viewBox.y1); i++)
      i < 59 && (angle2 += searchAngle, angle2 > maxAngle ? angle2 = minAngle : angle2 < minAngle && (angle2 = maxAngle));
    res.push(Object.assign({
      [CORRELATION_X]: x,
      [CORRELATION_Y]: y,
      [CORRELATION_SIZE]: size
    }, datum));
  }), res;
};
var getPartialAngles = (minAngle, maxAngle, count) => {
  let offsetAngle = 0, stepCount = Math.max(Math.ceil(2 * (maxAngle - minAngle) / Math.PI), 2), stepAngle = (maxAngle - minAngle) / stepCount, stepIndex = 0, stepSign = 1, i = 0, j = 0;
  const res = [];
  let startAngle = minAngle;
  for (; i < count; )
    j < stepCount && (res.push(startAngle + (j % 2 ? Math.floor(j / 2) + Math.floor(stepCount / 2) : j / 2) * stepAngle * stepSign), j++), i++, j === stepCount && (j = 0, stepIndex += 1, stepSign *= -1, 0 === offsetAngle ? offsetAngle = stepAngle / 2 : offsetAngle /= 2, startAngle = -1 === stepSign ? maxAngle - offsetAngle : minAngle + offsetAngle, stepIndex >= 2 && (stepAngle /= 2, stepCount *= 2));
  return res;
};
var hasOverlap3 = (item, arr) => !(!arr || !arr.length) && arr.some((entry) => Math.pow(item.x - entry.x, 2) + Math.pow(item.y - entry.y, 2) < Math.pow(item.size + entry.size, 2));

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/data/transforms/correlation-center
var correlationCenter = (data, options) => {
  if (!data || !isArray_default(data))
    return [];
  const { keyword, categoryField } = options, nodeInfo = data[0].latestData[0];
  return {
    [categoryField]: keyword,
    [DEFAULT_DATA_INDEX]: null == nodeInfo ? void 0 : nodeInfo[DEFAULT_DATA_INDEX],
    [DEFAULT_DATA_SERIES_FIELD]: null == nodeInfo ? void 0 : nodeInfo[DEFAULT_DATA_SERIES_FIELD]
  };
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/mark/ripple
var RippleMark = class _RippleMark extends BaseMark {
  constructor() {
    super(...arguments), this.type = _RippleMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      x: 0,
      y: 0,
      ripple: 0
    });
  }
  _initProduct(group) {
    const view = this.getVGrammarView(), id2 = this.getProductId();
    this._product = view.glyph("ripplePoint", null != group ? group : view.rootMark).id(id2), this._compiledProductId = id2;
  }
};
RippleMark.type = "ripple";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/correlation/correlation-transformer
var CorrelationSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "nodePoint"), this._addMarkLabelSpec(spec, "centerPoint", "centerLabel");
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/correlation/correlation
var CorrelationSeries = class _CorrelationSeries extends PolarSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.correlation, this.transformerConstructor = CorrelationSeriesSpecTransformer, this._viewBox = new Bounds();
  }
  getCategoryField() {
    return this._categoryField;
  }
  setCategoryField(f) {
    return this._categoryField = f, this._categoryField;
  }
  getValueField() {
    return this._valueField;
  }
  setValueField(f) {
    return this._valueField = f, this._valueField;
  }
  getSeriesField() {
    return this._seriesField;
  }
  setSeriesField(field3) {
    isValid_default(field3) && (this._seriesField = field3);
  }
  getSizeField() {
    return this._sizeField;
  }
  setSizeField(field3) {
    isValid_default(field3) && (this._sizeField = field3);
  }
  getSizeRange() {
    return this._sizeRange;
  }
  setSizeRange(range2) {
    isValid_default(range2) && (this._sizeRange = range2);
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this.setCategoryField(this._spec.categoryField), this.setValueField(this._spec.valueField), this.setSeriesField(this._spec.seriesField), this.setSizeField(this._spec.sizeField), this.setSizeRange(this._spec.sizeRange);
  }
  initData() {
    var _a, _b, _c;
    if (super.initData(), !this._data)
      return;
    registerDataSetInstanceTransform(this._dataSet, "correlation", correlation2);
    const centerDataSet = new DataSet();
    registerDataSetInstanceParser(centerDataSet, "dataview", dataViewParser), registerDataSetInstanceTransform(centerDataSet, "correlationCenter", correlationCenter);
    const centerDataView = new DataView(centerDataSet, {
      name: `${this.type}_${this.id}_center`
    });
    centerDataView.parse([this.getViewData()], {
      type: "dataview"
    }), centerDataView.transform({
      type: "correlationCenter",
      options: {
        keyword: null !== (_c = null === (_b = null === (_a = this._spec.centerLabel) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.text) && void 0 !== _c ? _c : "",
        categoryField: this._spec.categoryField
      }
    }), this._centerSeriesData = new SeriesData(this._option, centerDataView);
  }
  _statisticViewData() {
    super._statisticViewData(), this._data.getDataView().transform({
      type: "correlation",
      options: {
        view: () => ({
          x0: this._viewBox.x1,
          x1: this._viewBox.x2,
          y0: this._viewBox.y1,
          y1: this._viewBox.y2
        }),
        field: this._spec.valueField,
        radiusRange: this._spec.sizeRange,
        radiusField: this._spec.sizeField,
        center: [this._spec.centerX, this._spec.centerY],
        innerRadius: this._spec.innerRadius,
        outerRadius: this._spec.outerRadius,
        startAngle: this._spec.startAngle,
        endAngle: this._spec.endAngle
      }
    });
  }
  initMark() {
    var _a, _b, _c, _d;
    const nodePointMark = this._createMark(_CorrelationSeries.mark.nodePoint, {
      groupKey: this._seriesField,
      isSeriesMark: true,
      key: DEFAULT_DATA_INDEX,
      customShape: null === (_a = this._spec.nodePoint) || void 0 === _a ? void 0 : _a.customShape,
      stateSort: null === (_b = this._spec.nodePoint) || void 0 === _b ? void 0 : _b.stateSort
    });
    nodePointMark && (nodePointMark.setZIndex(LayoutZIndex.Node), this._nodePointMark = nodePointMark);
    const ripplePointMark = this._createMark(_CorrelationSeries.mark.ripplePoint, {
      key: DEFAULT_DATA_INDEX,
      dataView: this._centerSeriesData.getDataView(),
      dataProductId: this._centerSeriesData.getProductId()
    });
    ripplePointMark && (this._ripplePointMark = ripplePointMark);
    const centerPointMark = this._createMark(_CorrelationSeries.mark.centerPoint, {
      key: DEFAULT_DATA_INDEX,
      dataView: this._centerSeriesData.getDataView(),
      dataProductId: this._centerSeriesData.getProductId(),
      customShape: null === (_c = this._spec.centerPoint) || void 0 === _c ? void 0 : _c.customShape,
      stateSort: null === (_d = this._spec.centerPoint) || void 0 === _d ? void 0 : _d.stateSort
    });
    centerPointMark && (centerPointMark.setZIndex(LayoutZIndex.Node), this._centerPointMark = centerPointMark);
  }
  initMarkStyle() {
    this._initNodePointMarkStyle(), this._initRipplePointMarkStyle(), this._initCenterPointMarkStyle();
  }
  _initNodePointMarkStyle() {
    var _a, _b, _c, _d;
    const nodePointMark = this._nodePointMark;
    if (!nodePointMark)
      return;
    const nodePointStyle = null !== (_b = null === (_a = this._spec.nodePoint) || void 0 === _a ? void 0 : _a.style) && void 0 !== _b ? _b : {};
    this.setMarkStyle(nodePointMark, {
      x: (datum) => datum[CORRELATION_X],
      y: (datum) => datum[CORRELATION_Y],
      size: (datum) => datum[CORRELATION_SIZE],
      fill: null !== (_c = nodePointStyle.fill) && void 0 !== _c ? _c : this.getColorAttribute(),
      fillOpacity: null !== (_d = nodePointStyle.fillOpacity) && void 0 !== _d ? _d : 1,
      lineWidth: 0
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  _initRipplePointMarkStyle() {
    var _a, _b, _c, _d, _e;
    const ripplePointMark = this._ripplePointMark;
    if (!ripplePointMark)
      return;
    const ripplePointStyle = null !== (_b = null === (_a = this._spec.ripplePoint) || void 0 === _a ? void 0 : _a.style) && void 0 !== _b ? _b : {};
    this.setMarkStyle(ripplePointMark, {
      x: () => {
        var _a2;
        return null !== (_a2 = this._spec.centerX) && void 0 !== _a2 ? _a2 : (this._viewBox.x1 + this._viewBox.x2) / 2;
      },
      y: () => {
        var _a2;
        return null !== (_a2 = this._spec.centerY) && void 0 !== _a2 ? _a2 : (this._viewBox.y1 + this._viewBox.y2) / 2;
      },
      size: () => Math.max(this._viewBox.x2 - this._viewBox.x1, this._viewBox.y2 - this._viewBox.y1) / 2,
      fill: null !== (_c = ripplePointStyle.fill) && void 0 !== _c ? _c : this.getColorAttribute(),
      opacity: null !== (_d = ripplePointStyle.fillOpacity) && void 0 !== _d ? _d : 0.2,
      ripple: null !== (_e = ripplePointStyle.ripple) && void 0 !== _e ? _e : 0
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  _initCenterPointMarkStyle() {
    var _a, _b, _c, _d, _e, _f;
    const centerPointMark = this._centerPointMark;
    centerPointMark && this.setMarkStyle(centerPointMark, {
      x: () => {
        var _a2;
        return null !== (_a2 = this._spec.centerX) && void 0 !== _a2 ? _a2 : (this._viewBox.x1 + this._viewBox.x2) / 2;
      },
      y: () => {
        var _a2;
        return null !== (_a2 = this._spec.centerY) && void 0 !== _a2 ? _a2 : (this._viewBox.y1 + this._viewBox.y2) / 2;
      },
      size: () => 0.2 * Math.max(this._viewBox.x2 - this._viewBox.x1, this._viewBox.y2 - this._viewBox.y1) / 2,
      fill: null !== (_c = null === (_b = null === (_a = this._spec.centerPoint) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.fill) && void 0 !== _c ? _c : this.getColorAttribute(),
      fillOpacity: null !== (_f = null === (_e = null === (_d = this._spec.centerPoint) || void 0 === _d ? void 0 : _d.style) || void 0 === _e ? void 0 : _e.fillOpacity) && void 0 !== _f ? _f : 1
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  initTooltip() {
    super.initTooltip(), this._nodePointMark && this._tooltipHelper.activeTriggerSet.mark.add(this._nodePointMark);
  }
  initLabelMarkStyle(labelMark) {
    labelMark && this.setMarkStyle(labelMark, {
      fill: this.getColorAttribute(),
      text: (datum) => datum[this._categoryField],
      z: this.dataToPositionZ.bind(this)
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  initAnimation() {
    var _a, _b;
    const appearPreset = null === (_a = this._spec.animationAppear) || void 0 === _a ? void 0 : _a.preset;
    this._nodePointMark.setAnimationConfig(animationConfig(null === (_b = Factory2.getAnimationInKey("correlation")) || void 0 === _b ? void 0 : _b({}, appearPreset), userAnimationConfig("nodePoint", this._spec, this._markAttributeContext)));
  }
  getGroupFields() {
    return [];
  }
  getStackGroupFields() {
    return [];
  }
  getStackValueField() {
    return "";
  }
  getActiveMarks() {
    return [this._nodePointMark, this._centerPointMark];
  }
  getDimensionField() {
    return [this._categoryField];
  }
  getMeasureField() {
    return [this._valueField];
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx), this._viewBox.set(0, 0, this._region.getLayoutRect().width, this._region.getLayoutRect().height), this._rawData.reRunAllTransform(), this.getViewData().reRunAllTransform();
  }
};
CorrelationSeries.type = SeriesTypeEnum.correlation, CorrelationSeries.mark = correlationSeriesMark, CorrelationSeries.transformerConstructor = CorrelationSeriesSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/mark/liquid
var LiquidMark = class _LiquidMark extends BaseMark {
  constructor() {
    super(...arguments), this.type = _LiquidMark.type;
  }
  _getDefaultStyle() {
    return Object.assign(Object.assign({}, super._getDefaultStyle()), {
      wave: 0
    });
  }
  _initProduct(group) {
    const view = this.getVGrammarView(), id2 = this.getProductId();
    this._product = view.glyph("wave", null != group ? group : view.rootMark).id(id2), this._compiledProductId = id2;
  }
};
LiquidMark.type = "liquid";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/liquid/util
var getShapes = (shapesType, size) => "drop" === shapesType ? pin(0, 0, size / 2) : shapesType;
function pin(x, y, radius) {
  const w = 4 * radius / 3, h = Math.max(w, 2 * radius), r = w / 2, cx = x, cy = r + y - h / 2, theta = Math.asin(r / (0.85 * (h - r))), dy = Math.sin(theta) * r, dx = Math.cos(theta) * r, x05 = cx - dx, y05 = cy + dy, cpX = x, cpY = cy + r / Math.sin(theta);
  return `
      M ${x05} ${y05}
      A ${r} ${r} 0 1 1 ${x05 + 2 * dx} ${y05}
      Q ${cpX} ${cpY} ${x} ${y + h / 2}
      Q ${cpX} ${cpY} ${x05} ${y05}
      Z 
    `;
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/liquid/tooltip-helper
var LiquidSeriesTooltipHelper = class extends BaseSeriesTooltipHelper {
  constructor() {
    super(...arguments), this.getContentKey = () => (datum) => this.series.getValueField(), this.getContentValue = () => (datum) => datum[this.series.getValueField()], this.getLiquidFillColor = (datum) => this.series.getMarkInName("liquid").getAttribute("fill", datum);
  }
  getDefaultTooltipPattern(activeType) {
    return {
      visible: true,
      activeType,
      title: {
        key: void 0,
        value: this.dimensionTooltipTitleCallback,
        hasShape: false
      },
      content: [{
        key: this.getContentKey(),
        value: this.getContentValue(),
        hasShape: true,
        shapeType: this.shapeTypeCallback,
        shapeColor: this.getLiquidFillColor,
        shapeStroke: this.getLiquidFillColor,
        shapeHollow: false
      }]
    };
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/liquid/liquid
var LiquidSeries = class _LiquidSeries extends BaseSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.liquid, this.transformerConstructor = LineLikeSeriesSpecTransformer, this._liquidBackgroundMark = null, this._liquidOutlineMark = null;
  }
  setValueField(field3) {
    isValid_default(field3) && (this._valueField = field3);
  }
  getValueField() {
    return this._valueField;
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this._marginSpec = normalizeLayoutPaddingSpec(this._spec.outlineMargin), this._paddingSpec = normalizeLayoutPaddingSpec(this._spec.outlinePadding), this.setValueField(this._spec.valueField);
  }
  rawDataUpdate(d) {
    super.rawDataUpdate(d), this._heightRatio = max(...this._data.getLatestData().map((d2) => d2[this._valueField]));
  }
  initMark() {
    this._initLiquidOutlineMark(), this._initLiquidBackgroundMark(), this._initLiquidMark();
  }
  initMarkStyle() {
    this._initLiquidOutlineMarkStyle(), this._initLiquidBackgroundMarkStyle(), this._initLiquidMarkStyle();
  }
  _initLiquidOutlineMark() {
    return this._liquidOutlineMark = this._createMark(_LiquidSeries.mark.liquidOutline, {
      isSeriesMark: true,
      skipBeforeLayouted: false
    }), this._liquidOutlineMark;
  }
  _initLiquidBackgroundMark() {
    return this._liquidBackgroundMark = this._createMark(_LiquidSeries.mark.liquidBackground, {
      isSeriesMark: true,
      skipBeforeLayouted: false
    }), this._liquidBackgroundMark;
  }
  _initLiquidMark() {
    return this._liquidMark = this._createMark(_LiquidSeries.mark.liquid, {
      parent: this._liquidBackgroundMark,
      isSeriesMark: true,
      skipBeforeLayouted: false
    }), this._liquidMark;
  }
  _getPosAndSizeFormRegion(isOutline = false) {
    const { top: marginTop = 0, bottom: marginBottom = 0, left: marginLeft = 0, right: marginRight = 0 } = this._marginSpec, { top: paddingTop = 0, bottom: paddingBottom = 0, left: paddingLeft = 0, right: paddingRight = 0 } = this._paddingSpec, { width: regionWidth, height: regionHeight } = this._region.getLayoutRect();
    return isOutline ? {
      x: regionWidth / 2 + (marginLeft - marginRight) / 2,
      y: regionHeight / 2 + (marginTop - marginBottom) / 2,
      size: Math.min(regionWidth - (marginLeft + marginRight), regionHeight - (marginTop + marginBottom))
    } : {
      x: regionWidth / 2 + (marginLeft + paddingRight - (marginRight + paddingRight)) / 2,
      y: regionHeight / 2 + (marginTop + paddingTop - (marginBottom + paddingBottom)) / 2,
      size: Math.min(regionWidth - (marginLeft + marginRight + paddingLeft + paddingRight), regionHeight - (marginTop + marginBottom + paddingTop + paddingBottom))
    };
  }
  _initLiquidOutlineMarkStyle() {
    const liquidOutlineMark = this._liquidOutlineMark;
    liquidOutlineMark.setZIndex(this.layoutZIndex), liquidOutlineMark.created(), this.setMarkStyle(liquidOutlineMark, {
      stroke: this.getColorAttribute(),
      x: () => this._getPosAndSizeFormRegion(true).x,
      y: () => this._getPosAndSizeFormRegion(true).y,
      size: () => this._getPosAndSizeFormRegion(true).size,
      symbolType: () => {
        var _a;
        return getShapes(null !== (_a = this._spec.maskShape) && void 0 !== _a ? _a : "circle", this._getPosAndSizeFormRegion(true).size);
      }
    }, "normal", AttributeLevel.Series), this._liquidOutlineMark.setInteractive(false);
  }
  _initLiquidBackgroundMarkStyle() {
    const liquidBackgroundMark = this._liquidBackgroundMark;
    liquidBackgroundMark.setZIndex(this.layoutZIndex), liquidBackgroundMark.created(), this.setMarkStyle(liquidBackgroundMark, {
      clip: true,
      width: () => this._region.getLayoutRect().width,
      height: () => this._region.getLayoutRect().height,
      path: () => {
        var _a;
        const { x, y, size } = this._getPosAndSizeFormRegion();
        return [createSymbol({
          x,
          y,
          size,
          symbolType: getShapes(null !== (_a = this._spec.maskShape) && void 0 !== _a ? _a : "circle", size),
          fill: true
        })];
      }
    }, "normal", AttributeLevel.Series), this._liquidBackgroundMark.setInteractive(false);
  }
  _initLiquidMarkStyle() {
    const liquidMark = this._liquidMark;
    liquidMark && this.setMarkStyle(liquidMark, {
      dx: () => this._region.getLayoutStartPoint().x + this._region.getLayoutRect().width / 2,
      y: () => {
        const { y: liquidBackY, size: liquidBackSize } = this._getPosAndSizeFormRegion();
        return liquidBackY - liquidBackSize / 2 + liquidBackSize - liquidBackSize * this._heightRatio;
      },
      height: () => {
        const { size: liquidBackSize } = this._getPosAndSizeFormRegion();
        return liquidBackSize * this._heightRatio;
      },
      fill: this.getColorAttribute(),
      wave: 0
    }, "normal", AttributeLevel.Series);
  }
  initTooltip() {
    this._tooltipHelper = new LiquidSeriesTooltipHelper(this), this._liquidMark && this._tooltipHelper.activeTriggerSet.mark.add(this._liquidMark);
  }
  initInteraction() {
    this._parseInteractionConfig(this._liquidMark ? [this._liquidMark] : []);
  }
  initAnimation() {
    var _a, _b, _c;
    const animationParams = {
      y: {
        from: () => {
          const { y: liquidBackY, size: liquidBackSize } = this._getPosAndSizeFormRegion();
          return liquidBackY - liquidBackSize / 2 + liquidBackSize;
        },
        to: () => {
          const { y: liquidBackY, size: liquidBackSize } = this._getPosAndSizeFormRegion();
          return liquidBackY - liquidBackSize / 2 + liquidBackSize - liquidBackSize * this._heightRatio;
        }
      },
      height: {
        from: 0,
        to: () => {
          const { size: liquidBackSize } = this._getPosAndSizeFormRegion();
          return liquidBackSize * this._heightRatio;
        }
      }
    }, appearPreset = null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.animationAppear) || void 0 === _b ? void 0 : _b.preset;
    this._liquidMark.setAnimationConfig(animationConfig(null === (_c = Factory2.getAnimationInKey("liquid")) || void 0 === _c ? void 0 : _c(animationParams, appearPreset), userAnimationConfig("liquid", this._spec, this._markAttributeContext)));
  }
  initEvent() {
    super.initEvent(), this._spec.indicatorSmartInvert && this._option.getChart().getComponentsByKey("indicator") && this.event.on(ChartEvent.renderFinished, () => {
      this._option.getChart().getComponentsByKey("indicator").forEach((indicatorComponent) => {
        var _a, _b;
        const waveItem = this._liquidMark.getProduct().elements[0].glyphGraphicItems.wave1;
        let { y1: waveY1, y2: waveY2 } = waveItem.globalAABBBounds;
        waveY1 += this._region.getLayoutStartPoint().y, waveY2 += this._region.getLayoutStartPoint().y, null === (_b = null === (_a = null == indicatorComponent ? void 0 : indicatorComponent.getIndicatorComponent()) || void 0 === _a ? void 0 : _a.getChildren()[0]) || void 0 === _b || _b.getChildren().forEach((text2) => {
          const { y1: textY1, y2: textY2 } = text2.globalAABBBounds;
          if (waveY1 < textY1 && waveY2 > textY2) {
            const foregroundColor = text2.attribute.fill, backgroundColor = waveItem.attribute.fill, invertColor = labelSmartInvert(foregroundColor, backgroundColor);
            text2.setAttribute("fill", invertColor);
          }
        });
      });
    });
  }
  dataToPosition(data) {
    return null;
  }
  dataToPositionX(data) {
    return null;
  }
  dataToPositionY(data) {
    return null;
  }
  valueToPosition(value1, value2) {
    return null;
  }
  getStatisticFields() {
    return [];
  }
  getGroupFields() {
    return [];
  }
  getStackGroupFields() {
    return [];
  }
  getStackValueField() {
    return "";
  }
  getActiveMarks() {
    return [this._liquidMark];
  }
};
LiquidSeries.type = SeriesTypeEnum.liquid, LiquidSeries.mark = LiquidSeriesMark, LiquidSeries.transformerConstructor = LineLikeSeriesSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/venn/util
var getVennSeriesDataKey = (sets) => array(sets).join(",");

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/venn/tooltip-helper
var VennTooltipHelper = class extends BaseSeriesTooltipHelper {
  constructor() {
    super(...arguments), this.dimensionTooltipTitleCallback = (datum) => getVennSeriesDataKey(null == datum ? void 0 : datum[this.series.getDimensionField()[0]]), this.markTooltipKeyCallback = (datum) => getVennSeriesDataKey(null == datum ? void 0 : datum[this.series.getDimensionField()[0]]);
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/venn/venn-transform
var VennSeriesSpecTransformer = class extends BaseSeriesSpecTransformer {
  _transformLabelSpec(spec) {
    this._addMarkLabelSpec(spec, "circle"), this._addMarkLabelSpec(spec, "overlap", "overlapLabel", "initOverlapLabelMarkStyle");
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/series/venn/venn
var VennSeries = class _VennSeries extends BaseSeries {
  constructor() {
    super(...arguments), this.type = SeriesTypeEnum.venn, this.transformerConstructor = VennSeriesSpecTransformer, this._viewBox = new Bounds();
  }
  getCategoryField() {
    return this._categoryField;
  }
  setCategoryField(f) {
    return this._categoryField = f, this._categoryField;
  }
  getValueField() {
    return this._valueField;
  }
  setValueField(f) {
    return this._valueField = f, this._valueField;
  }
  setAttrFromSpec() {
    var _a, _b, _c;
    super.setAttrFromSpec(), this.setCategoryField(null !== (_a = this._spec.categoryField) && void 0 !== _a ? _a : "sets"), this.setValueField(null !== (_b = this._spec.valueField) && void 0 !== _b ? _b : "size"), this.setSeriesField(null !== (_c = this._spec.seriesField) && void 0 !== _c ? _c : DEFAULT_DATA_KEY);
  }
  compile() {
    super.compile(), this._runVennTransform();
  }
  _runVennTransform(render = false) {
    const viewDataProduct = this._data.getProduct();
    viewDataProduct && viewDataProduct.transform([{
      type: "venn",
      x0: this._viewBox.x1,
      x1: this._viewBox.x2,
      y0: this._viewBox.y1,
      y1: this._viewBox.y2,
      setField: this._categoryField,
      valueField: this._valueField
    }]), render && this.getCompiler().renderNextTick();
  }
  initMark() {
    const circleMark = this._createMark(_VennSeries.mark.circle, {
      isSeriesMark: true
    });
    circleMark && (circleMark.setTransform([{
      type: "vennMark",
      datumType: "circle"
    }]), this._circleMark = circleMark);
    const overlapMark = this._createMark(_VennSeries.mark.overlap, {
      isSeriesMark: true
    });
    overlapMark && (overlapMark.setTransform([{
      type: "vennMark",
      datumType: "overlap"
    }]), this._overlapMark = overlapMark);
  }
  initMarkStyle() {
    this._initCircleMarkStyle(), this._initOverlapMarkStyle();
  }
  _initCircleMarkStyle() {
    this._circleMark && this.setMarkStyle(this._circleMark, {
      x: (datum) => datum.x,
      y: (datum) => datum.y,
      innerRadius: 0,
      outerRadius: (datum) => datum.radius,
      startAngle: 0,
      endAngle: 2 * Math.PI,
      fill: this.getColorAttribute(),
      stroke: this.getColorAttribute()
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series);
  }
  _initOverlapMarkStyle() {
    this._overlapMark && (this.setMarkStyle(this._overlapMark, {
      x: (datum) => datum.x,
      y: (datum) => datum.y,
      path: (datum) => datum.path,
      arcs: (datum) => datum.arcs,
      fill: this.getColorAttribute(),
      stroke: this.getColorAttribute(),
      zIndex: (datum) => 100 * datum.sets.length
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series), this.setMarkStyle(this._overlapMark, {
      zIndex: (datum) => 100 * datum.sets.length + 1
    }, STATE_VALUE_ENUM.STATE_HOVER, AttributeLevel.Series));
  }
  initLabelMarkStyle(labelMark) {
    labelMark && (this._labelMark = labelMark, labelMark.setRule("venn"), this.setMarkStyle(labelMark, {
      x: (datum) => datum.labelX,
      y: (datum) => datum.labelY,
      text: (datum) => getVennSeriesDataKey(datum.sets),
      maxLineWidth: (datum) => {
        const { x, radius, labelX } = datum, circleX0 = x - radius, circleX1 = x + radius;
        return Math.min(labelX - circleX0, circleX1 - labelX);
      }
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series));
  }
  initOverlapLabelMarkStyle(labelMark) {
    labelMark && (this._labelMark = labelMark, labelMark.setRule("venn"), this.setMarkStyle(labelMark, {
      x: (datum) => datum.labelX,
      y: (datum) => datum.labelY,
      text: (datum) => getVennSeriesDataKey(datum.sets)
    }, STATE_VALUE_ENUM.STATE_NORMAL, AttributeLevel.Series));
  }
  initTooltip() {
    this._tooltipHelper = new VennTooltipHelper(this), this._circleMark && this._tooltipHelper.activeTriggerSet.mark.add(this._circleMark), this._overlapMark && this._tooltipHelper.activeTriggerSet.mark.add(this._overlapMark);
  }
  getDimensionField() {
    return [this._categoryField];
  }
  getMeasureField() {
    return [this._valueField];
  }
  onLayoutEnd(ctx) {
    super.onLayoutEnd(ctx), this._viewBox.set(0, 0, this.getLayoutRect().width, this.getLayoutRect().height), this._runVennTransform();
  }
  getDefaultShapeType() {
    return "circle";
  }
  getActiveMarks() {
    return [this._circleMark, this._overlapMark];
  }
  getStatisticFields() {
    const fields2 = [];
    return fields2.push({
      key: this._categoryField,
      operations: ["values"]
    }), fields2.push({
      key: this._valueField,
      operations: ["max", "min"]
    }), fields2;
  }
  getGroupFields() {
    return null;
  }
  dataToPosition(data, checkInViewData) {
    return {
      x: data.x,
      y: data.y
    };
  }
  dataToPositionX(data) {
    return data.x;
  }
  dataToPositionY(data) {
    return data.y;
  }
  valueToPosition(value1, value2) {
    throw new Error("Method not implemented.");
  }
  getStackGroupFields() {
    return [];
  }
  getStackValueField() {
    return null;
  }
  _getSeriesInfo(field3, keys2) {
    const defaultShapeType = this.getDefaultShapeType();
    return keys2.map((originalKey) => ({
      key: getVennSeriesDataKey(originalKey),
      originalKey,
      style: this.getSeriesStyle({
        [field3]: originalKey
      }),
      shapeType: defaultShapeType
    }));
  }
  getSeriesFieldValue(datum, seriesField) {
    const value = super.getSeriesFieldValue(datum, seriesField);
    return getVennSeriesDataKey(value);
  }
  legendSelectedFilter(component2, selectedKeys) {
    if (component2.type === ComponentTypeEnum.discreteLegend) {
      const originalLegendKeys = component2.getLegendDefaultData(true);
      if (0 === selectedKeys.length && originalLegendKeys.length)
        return [];
      if (selectedKeys.length === originalLegendKeys.length)
        return selectedKeys;
      const selectedFilter = {};
      selectedKeys.forEach((s2) => {
        selectedFilter[s2] = true;
      });
      const disableKeys = originalLegendKeys.filter((key) => !selectedFilter[getVennSeriesDataKey(key)]), derivedDisableKeys = originalLegendKeys.filter((key) => !disableKeys.includes(key) && disableKeys.some((disableKey) => array(disableKey).every((k2) => key.includes(k2))));
      selectedKeys = selectedKeys.slice(), derivedDisableKeys.forEach((key) => {
        selectedKeys.splice(selectedKeys.indexOf(getVennSeriesDataKey(key)), 1);
      });
    }
    return selectedKeys;
  }
  initAnimation() {
    this.getMarksInType("arc").forEach((mark) => {
      var _a;
      mark.setAnimationConfig(animationConfig(null === (_a = Factory2.getAnimationInKey("vennCircle")) || void 0 === _a ? void 0 : _a(), userAnimationConfig(mark.name, this._spec, this._markAttributeContext)));
    }), this.getMarksInType("path").forEach((mark) => {
      var _a;
      mark.setAnimationConfig(animationConfig(null === (_a = Factory2.getAnimationInKey("vennOverlap")) || void 0 === _a ? void 0 : _a(), userAnimationConfig(mark.name, this._spec, this._markAttributeContext)));
    });
  }
};
VennSeries.type = SeriesTypeEnum.venn, VennSeries.mark = vennSeriesMark, VennSeries.transformerConstructor = VennSeriesSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/map/map-transformer
var MapChartSpecTransformer = class extends BaseChartSpecTransformer {
  _isValidSeries(type) {
    return type === SeriesTypeEnum.map;
  }
  _getDefaultSeriesSpec(spec) {
    return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      type: spec.type,
      nameField: spec.nameField,
      valueField: spec.valueField,
      seriesField: spec.seriesField,
      map: spec.map,
      nameProperty: spec.nameProperty,
      centroidProperty: spec.centroidProperty,
      nameMap: spec.nameMap,
      area: spec.area,
      defaultFillColor: spec.defaultFillColor,
      showDefaultName: spec.showDefaultName
    });
  }
  transformSpec(spec) {
    super.transformSpec(spec), spec.region.forEach((r) => {
      r.coordinate = "geo";
    });
    const defaultSeriesSpec = this._getDefaultSeriesSpec(spec);
    spec.series && 0 !== spec.series.length ? spec.series.forEach((s2) => {
      this._isValidSeries(s2.type) && Object.keys(defaultSeriesSpec).forEach((k2) => {
        k2 in s2 || (s2[k2] = defaultSeriesSpec[k2]);
      });
    }) : spec.series = [defaultSeriesSpec];
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/map/map
var MapChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = MapChartSpecTransformer, this.type = "map", this.seriesType = SeriesTypeEnum.map;
  }
};
MapChart.type = "map", MapChart.seriesType = SeriesTypeEnum.map, MapChart.transformerConstructor = MapChartSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/pie/base/pie-transformer
var BasePieChartSpecTransformer = class extends PolarChartSpecTransformer {
  needAxes() {
    return false;
  }
  _getDefaultSeriesSpec(spec) {
    return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      categoryField: spec.categoryField || spec.seriesField,
      valueField: spec.valueField || spec.angleField,
      center: spec.center,
      centerOffset: spec.centerOffset,
      cornerRadius: spec.cornerRadius,
      padAngle: spec.padAngle,
      minAngle: spec.minAngle
    });
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/pie/base/base
var BasePieChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = BasePieChartSpecTransformer;
  }
};
BasePieChart.transformerConstructor = BasePieChartSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/pie/pie
var PieChart = class extends BasePieChart {
  constructor() {
    super(...arguments), this.transformerConstructor = BasePieChartSpecTransformer, this.type = "pie", this.seriesType = SeriesTypeEnum.pie;
  }
};
PieChart.type = "pie", PieChart.seriesType = SeriesTypeEnum.pie, PieChart.transformerConstructor = BasePieChartSpecTransformer;
var registerPieChart = () => {
  registerPieSeries(), Factory2.registerChart(PieChart.type, PieChart);
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/pie/3d/pie-3d
var Pie3dChartSpecTransformer = class extends BasePieChartSpecTransformer {
  transformSpec(spec) {
    super.transformSpec(spec), spec.series.forEach((s2) => {
      "pie3d" === s2.type && (s2.angle3d = spec.angle3d);
    });
  }
};
var Pie3dChart = class extends BasePieChart {
  constructor() {
    super(...arguments), this.transformerConstructor = Pie3dChartSpecTransformer, this.type = "pie3d", this.seriesType = SeriesTypeEnum.pie3d;
  }
};
Pie3dChart.type = "pie3d", Pie3dChart.seriesType = SeriesTypeEnum.pie3d, Pie3dChart.transformerConstructor = Pie3dChartSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/progress/circular/circular-progress-transformer
var CircularProgressChartSpecTransformer = class extends ProgressLikeChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    var _a, _b;
    const series2 = super._getDefaultSeriesSpec(spec);
    return Object.assign(Object.assign({}, series2), {
      cornerRadius: null !== (_a = spec.cornerRadius) && void 0 !== _a ? _a : 0,
      roundCap: null !== (_b = spec.roundCap) && void 0 !== _b && _b,
      progress: spec.progress,
      track: spec.track,
      tickMask: spec.tickMask
    });
  }
  transformSpec(spec) {
    super.transformSpec(spec), this._transformProgressAxisSpec(spec, {
      orient: "angle",
      visible: false
    }, {
      orient: "radius",
      visible: false
    }, {
      forceInitTick: spec.tickMask && false !== spec.tickMask.visible
    });
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/progress/circular/circular
var CircularProgressChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = CircularProgressChartSpecTransformer, this.type = "circularProgress", this.seriesType = SeriesTypeEnum.circularProgress, this._canStack = true;
  }
};
CircularProgressChart.type = "circularProgress", CircularProgressChart.seriesType = SeriesTypeEnum.circularProgress, CircularProgressChart.transformerConstructor = CircularProgressChartSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/progress/linear/linear-progress-transformer
var LinearProgressChartSpecTransformer = class extends CartesianChartSpecTransformer {
  needAxes() {
    return false;
  }
  _getDefaultSeriesSpec(spec) {
    var _a, _b;
    const series2 = super._getDefaultSeriesSpec(spec);
    return Object.assign(Object.assign({}, series2), {
      direction: null !== (_a = spec.direction) && void 0 !== _a ? _a : "horizontal",
      cornerRadius: null !== (_b = spec.cornerRadius) && void 0 !== _b ? _b : 0,
      bandWidth: spec.bandWidth,
      progress: spec.progress,
      track: spec.track
    });
  }
  transformSpec(spec) {
    var _a, _b;
    if (super.transformSpec(spec), spec.axes || (spec.axes = []), "vertical" === spec.direction) {
      let leftAxis = null, bottomAxis = null;
      (null !== (_a = spec.axes) && void 0 !== _a ? _a : []).forEach((axis2) => {
        const { orient } = axis2;
        "left" === orient && (leftAxis = axis2), "bottom" === orient && (bottomAxis = axis2);
      }), leftAxis || (leftAxis = {
        orient: "left",
        visible: false
      }, spec.axes.push(leftAxis)), bottomAxis || (bottomAxis = {
        orient: "bottom",
        visible: false
      }, spec.axes.push(bottomAxis)), isNil_default(bottomAxis.type) && (bottomAxis.type = "band"), isNil_default(leftAxis.type) && (leftAxis.type = "linear");
      const domain = getLinearAxisSpecDomain(leftAxis, {
        min: 0,
        max: 1
      });
      isNil_default(leftAxis.min) && (leftAxis.min = domain.min), isNil_default(leftAxis.max) && (leftAxis.max = domain.max);
    } else {
      let leftAxis = null, bottomAxis = null;
      (null !== (_b = spec.axes) && void 0 !== _b ? _b : []).forEach((axis2) => {
        const { orient } = axis2;
        "left" === orient && (leftAxis = axis2), "bottom" === orient && (bottomAxis = axis2);
      }), leftAxis || (leftAxis = {
        type: "band",
        orient: "left",
        visible: false
      }, spec.axes.push(leftAxis)), bottomAxis || (bottomAxis = {
        orient: "bottom",
        visible: false
      }, spec.axes.push(bottomAxis)), isNil_default(bottomAxis.type) && (bottomAxis.type = "linear"), isNil_default(leftAxis.type) && (leftAxis.type = "band");
      const domain = getLinearAxisSpecDomain(bottomAxis, {
        min: 0,
        max: 1
      });
      isNil_default(bottomAxis.min) && (bottomAxis.min = domain.min), isNil_default(bottomAxis.max) && (bottomAxis.max = domain.max);
    }
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/progress/linear/linear
var LinearProgressChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = LinearProgressChartSpecTransformer, this.type = "linearProgress", this.seriesType = SeriesTypeEnum.linearProgress, this._canStack = true;
  }
};
LinearProgressChart.type = "linearProgress", LinearProgressChart.seriesType = SeriesTypeEnum.linearProgress, LinearProgressChart.transformerConstructor = LinearProgressChartSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/radar/radar-transformer
var RadarChartSpecTransformer = class extends RoseLikeChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    var _a;
    return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      seriesField: spec.seriesField,
      line: spec.line,
      point: spec.point,
      stack: spec.stack,
      percent: spec.percent,
      area: mergeSpec({
        visible: false
      }, spec.area),
      seriesMark: null !== (_a = spec.seriesMark) && void 0 !== _a ? _a : "area",
      activePoint: spec.activePoint,
      pointDis: spec.pointDis,
      pointDisMul: spec.pointDisMul,
      markOverlap: spec.markOverlap
    });
  }
  transformSpec(spec) {
    var _a;
    super.transformSpec(spec), (null !== (_a = spec.axes) && void 0 !== _a ? _a : []).forEach((axis2) => {
      "radius" === axis2.orient && (["domainLine", "label", "tick"].forEach((configName) => {
        axis2[configName] || (axis2[configName] = {
          visible: false
        });
      }), axis2.grid || (axis2.grid = {
        visible: true
      }));
    }), spec.crosshair = array(spec.crosshair || {}).map((crosshairCfg) => mergeSpec({
      categoryField: {
        visible: true,
        line: {
          visible: true,
          type: "line"
        }
      }
    }, crosshairCfg));
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/radar/radar
var RadarChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = RadarChartSpecTransformer, this.type = "radar", this.seriesType = SeriesTypeEnum.radar, this._canStack = true;
  }
};
RadarChart.type = "radar", RadarChart.seriesType = SeriesTypeEnum.radar, RadarChart.transformerConstructor = RadarChartSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/range-area/range-area-transformer
var RangeAreaChartSpecTransformer = class extends CartesianChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    var _a, _b;
    const series2 = Object.assign({}, super._getDefaultSeriesSpec(spec));
    return series2.area = spec.area, "horizontal" === spec.direction ? series2.xField = null !== (_a = spec.xField) && void 0 !== _a ? _a : [spec.minField, spec.maxField] : series2.yField = null !== (_b = spec.yField) && void 0 !== _b ? _b : [spec.minField, spec.maxField], series2.stack = false, series2;
  }
  transformSpec(spec) {
    super.transformSpec(spec), setDefaultCrosshairForCartesianChart(spec);
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/range-area/range-area
var RangeAreaChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = RangeAreaChartSpecTransformer, this.type = "rangeArea", this.seriesType = SeriesTypeEnum.rangeArea;
  }
};
RangeAreaChart.type = "rangeArea", RangeAreaChart.seriesType = SeriesTypeEnum.rangeArea, RangeAreaChart.transformerConstructor = RangeAreaChartSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/range-column/range-column-transformer
var RangeColumnChartSpecTransformer = class extends CartesianChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    var _a, _b;
    const series2 = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      barWidth: spec.barWidth,
      barMaxWidth: spec.barMaxWidth,
      barMinWidth: spec.barMinWidth,
      barGapInGroup: spec.barGapInGroup,
      barBackground: spec.barBackground,
      barMinHeight: spec.barMinHeight,
      stackCornerRadius: spec.stackCornerRadius
    });
    return series2.bar = spec.bar, "horizontal" === spec.direction ? series2.xField = null !== (_a = spec.xField) && void 0 !== _a ? _a : [spec.minField, spec.maxField] : series2.yField = null !== (_b = spec.yField) && void 0 !== _b ? _b : [spec.minField, spec.maxField], series2;
  }
  transformSpec(spec) {
    super.transformSpec(spec), setDefaultCrosshairForCartesianChart(spec);
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/range-column/range-column
var RangeColumnChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = RangeColumnChartSpecTransformer, this.type = "rangeColumn", this.seriesType = SeriesTypeEnum.rangeColumn;
  }
};
RangeColumnChart.type = "rangeColumn", RangeColumnChart.seriesType = SeriesTypeEnum.rangeColumn, RangeColumnChart.transformerConstructor = RangeColumnChartSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/range-column/3d/range-column-3d-transformer
var RangeColumn3dChartSpecTransformer = class extends CartesianChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    var _a, _b;
    const series2 = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      barGapInGroup: spec.barGapInGroup
    });
    return series2.bar3d = spec.bar3d, "horizontal" === spec.direction ? series2.xField = null !== (_a = spec.xField) && void 0 !== _a ? _a : [spec.minField, spec.maxField] : series2.yField = null !== (_b = spec.yField) && void 0 !== _b ? _b : [spec.minField, spec.maxField], series2;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/range-column/3d/range-column-3d
var RangeColumn3dChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = RangeColumn3dChartSpecTransformer, this.type = "rangeColumn3d", this.seriesType = SeriesTypeEnum.rangeColumn3d;
  }
};
RangeColumn3dChart.type = "rangeColumn3d", RangeColumn3dChart.seriesType = SeriesTypeEnum.rangeColumn3d, RangeColumn3dChart.transformerConstructor = RangeColumn3dChartSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/rose/rose-transformer
var RoseChartSpecTransformer = class extends RoseLikeChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    var _a, _b, _c;
    return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      radius: null !== (_a = spec.radius) && void 0 !== _a ? _a : POLAR_DEFAULT_RADIUS,
      outerRadius: null !== (_b = spec.outerRadius) && void 0 !== _b ? _b : POLAR_DEFAULT_RADIUS,
      innerRadius: null !== (_c = spec.innerRadius) && void 0 !== _c ? _c : 0,
      seriesField: spec.seriesField,
      stack: spec.stack,
      percent: spec.percent
    });
  }
  transformSpec(spec) {
    var _a;
    super.transformSpec(spec), (null !== (_a = spec.axes) && void 0 !== _a ? _a : []).forEach((axis2) => {
      ["domainLine", "grid", "label", "tick"].forEach((configName) => {
        axis2[configName] || (axis2[configName] = {
          visible: false
        });
      }), "angle" === axis2.orient && isNil_default(axis2.bandPosition) && (axis2.bandPosition = 0.5);
    }), spec.crosshair = array(spec.crosshair || {}).map((crosshairCfg) => mergeSpec({
      categoryField: {
        visible: true,
        line: {
          visible: true,
          type: "rect"
        }
      }
    }, crosshairCfg));
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/rose/rose
var RoseChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = RoseChartSpecTransformer, this.type = "rose", this.seriesType = SeriesTypeEnum.rose, this._canStack = true;
  }
};
RoseChart.type = "rose", RoseChart.seriesType = SeriesTypeEnum.rose, RoseChart.transformerConstructor = RoseChartSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/sankey/sankey-transformer
var SankeyChartSpecTransformer = class extends BaseChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    const series2 = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      categoryField: spec.categoryField,
      valueField: spec.valueField,
      sourceField: spec.sourceField,
      targetField: spec.targetField,
      direction: spec.direction,
      nodeAlign: spec.nodeAlign,
      nodeGap: spec.nodeGap,
      nodeWidth: spec.nodeWidth,
      linkWidth: spec.linkWidth,
      minStepWidth: spec.minStepWidth,
      minNodeHeight: spec.minNodeHeight,
      minLinkHeight: spec.minLinkHeight,
      dropIsolatedNode: spec.dropIsolatedNode,
      nodeHeight: spec.nodeHeight,
      linkHeight: spec.linkHeight,
      equalNodeHeight: spec.equalNodeHeight,
      linkOverlap: spec.linkOverlap,
      iterations: spec.iterations,
      nodeKey: spec.nodeKey,
      linkSortBy: spec.linkSortBy,
      nodeSortBy: spec.nodeSortBy,
      setNodeLayer: spec.setNodeLayer,
      node: spec.node,
      link: spec.link,
      label: spec.label,
      emphasis: spec.emphasis
    }), seriesType = this.seriesType;
    return seriesType && (series2.type = seriesType, series2[seriesType] = spec[seriesType]), series2;
  }
  transformSpec(spec) {
    super.transformSpec(spec), this.transformSeriesSpec(spec);
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/sankey/sankey
var SankeyChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = SankeyChartSpecTransformer, this.type = "sankey", this.seriesType = SeriesTypeEnum.sankey;
  }
  _setStateInDatum(stateKey, checkReverse, datum, filter2, region) {
    const activeDatum = isArray_default(datum) ? datum[0] : datum, keys2 = activeDatum ? Object.keys(activeDatum) : null;
    this.getRegionsInQuerier(region).forEach((r) => {
      if (!activeDatum)
        return void r.interaction.clearEventElement(stateKey, true);
      let hasPick = false;
      r.getSeries().forEach((s2) => {
        var _a, _b;
        let activeNodeOrLink = null;
        s2.getMarksWithoutRoot().forEach((m4) => {
          if ("text" === m4.type)
            return;
          let pickElement = null;
          const mark = m4.getProduct();
          mark && ((!filter2 || isFunction_default(filter2) && filter2(s2, m4)) && (pickElement = mark.elements.find((e) => keys2.every((k2) => {
            var _a2;
            let datum2 = null === (_a2 = e.getDatum()) || void 0 === _a2 ? void 0 : _a2.datum;
            return isArray_default(datum2) && (datum2 = datum2[0]), activeDatum[k2] == (null == datum2 ? void 0 : datum2[k2]);
          }))), pickElement && (hasPick = true, r.interaction.startInteraction(stateKey, pickElement), (mark.id().includes("node") || mark.id().includes("link")) && (activeNodeOrLink = pickElement)));
        }), activeNodeOrLink && (null === (_b = (_a = s2)._handleEmphasisElement) || void 0 === _b || _b.call(_a, {
          item: activeNodeOrLink
        }));
      }), checkReverse && hasPick && r.interaction.reverseEventElement(stateKey);
    });
  }
};
SankeyChart.type = "sankey", SankeyChart.seriesType = SeriesTypeEnum.sankey, SankeyChart.transformerConstructor = SankeyChartSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/scatter/scatter-transformer
var ScatterChartSpecTransformer = class extends CartesianChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      point: spec.point,
      size: spec.size,
      sizeField: spec.sizeField,
      shape: spec.shape,
      shapeField: spec.shapeField
    });
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/scatter/scatter
var ScatterChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = ScatterChartSpecTransformer, this.type = "scatter", this.seriesType = SeriesTypeEnum.scatter, this._canStack = true;
  }
};
ScatterChart.type = "scatter", ScatterChart.seriesType = SeriesTypeEnum.scatter, ScatterChart.transformerConstructor = ScatterChartSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/constant/scroll-bar
var SCROLL_BAR_DEFAULT_SIZE = 12;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/sequence/sequence-transformer
var SequenceChartSpecTransformer = class extends BaseChartSpecTransformer {
  _getSeriesDataLength(spec, seriesSpec) {
    var _a, _b;
    if (seriesSpec.data) {
      const _d = array(seriesSpec.data)[0];
      return _d instanceof DataView ? null === (_a = _d.latestData) || void 0 === _a ? void 0 : _a.length : null === (_b = _d.values) || void 0 === _b ? void 0 : _b.length;
    }
    const dataTemp = array(spec.data).find((_d, index) => seriesSpec.dataId ? _d instanceof DataView ? _d.name === seriesSpec.dataId : _d.id === seriesSpec.dataId : seriesSpec.dataIndex === index);
    return dataTemp ? dataTemp instanceof DataView ? dataTemp.latestData.length : dataTemp.values.length : 0;
  }
  addAttrToComponentSpec(componentSpec, attr, value) {
    return Array.isArray(componentSpec) ? componentSpec[0][attr] = value : componentSpec[attr] = value, componentSpec;
  }
  transformSpec(spec) {
    var _a, _b, _c, _e, _f, _g, _h, _j, _k, _l, _m;
    super.transformSpec(spec);
    let rowNum = 0;
    const elements = [], region = [], axes = [], scrollBar2 = [], rowHeight = [], seriesRegionNum = spec.series.filter((d) => d.type !== SeriesTypeEnum.link).length, defaultSeriesRowHeight = (500 - 20 * (seriesRegionNum - 1)) / seriesRegionNum, leftAppendPadding = (null === (_a = null == spec ? void 0 : spec.appendPadding) || void 0 === _a ? void 0 : _a.left) || 0, rightAppendPadding = (null === (_b = null == spec ? void 0 : spec.appendPadding) || void 0 === _b ? void 0 : _b.right) || 0;
    if (null == spec ? void 0 : spec.legends) {
      elements.push({
        modelId: `legendRow${rowNum}`,
        col: 1,
        row: rowNum
      }), this.addAttrToComponentSpec(spec.legends, "id", `legendRow${rowNum}`);
      const legendSpec = array(spec.legends);
      let legendHeight = null !== (_c = legendSpec[0].height) && void 0 !== _c ? _c : 40;
      if (legendSpec[0].padding) {
        const legendPadding = normalizeLayoutPaddingSpec(legendSpec[0].padding);
        legendHeight += Number(null !== (_e = null == legendPadding ? void 0 : legendPadding.bottom) && void 0 !== _e ? _e : 0), legendHeight += Number(null !== (_f = null == legendPadding ? void 0 : legendPadding.top) && void 0 !== _f ? _f : 0), legendSpec[0].offsetY = Number(null !== (_h = null === (_g = legendSpec[0]) || void 0 === _g ? void 0 : _g.offsetY) && void 0 !== _h ? _h : 0) + Number(null !== (_j = null == legendPadding ? void 0 : legendPadding.top) && void 0 !== _j ? _j : 0);
      }
      rowHeight.push({
        index: rowNum,
        size: legendHeight
      }), rowNum++;
    }
    (null == spec ? void 0 : spec.dataZoom) && (elements.push({
      modelId: `dataZoomRow${rowNum}`,
      col: 1,
      row: rowNum
    }), this.addAttrToComponentSpec(spec.dataZoom, "id", `dataZoomRow${rowNum}`), rowNum++, rowHeight.push({
      index: rowNum,
      size: 10
    }), rowNum++), region.push({
      id: `regionAxesRow${rowNum}`
    }), elements.push({
      modelId: `axesRow${rowNum}`,
      col: 1,
      row: rowNum
    }), spec.axes[0].id = `axesRow${rowNum}`, spec.axes[0].regionIndex = Array.from(Array(spec.series.length), (_, index) => index + 1), rowNum++, null === (_k = null == spec ? void 0 : spec.series) || void 0 === _k || _k.forEach((seriesSpec) => {
      var _a2, _b2;
      if ([SeriesTypeEnum.bar, SeriesTypeEnum.line, SeriesTypeEnum.area, SeriesTypeEnum.dot].includes(seriesSpec.type)) {
        if (elements.push({
          modelId: `${seriesSpec.type}Row${rowNum}`,
          col: 1,
          row: rowNum
        }), elements.push({
          modelId: `axesLeftRow${rowNum}`,
          col: 0,
          row: rowNum
        }), region.push({
          id: `${seriesSpec.type}Row${rowNum}`,
          clip: false
        }), rowHeight.push({
          index: rowNum,
          size: (null == seriesSpec ? void 0 : seriesSpec.height) || defaultSeriesRowHeight
        }), axes.push({
          orient: "left",
          id: `axesLeftRow${rowNum}`,
          type: seriesSpec.type === SeriesTypeEnum.dot ? "band" : "linear",
          visible: seriesSpec.type !== SeriesTypeEnum.dot,
          title: {
            visible: true,
            autoRotate: false,
            style: {
              text: null == seriesSpec ? void 0 : seriesSpec.barTitle,
              dx: -20,
              textBaseline: "middle",
              textAlign: "end"
            }
          },
          grid: {
            visible: "boolean" != typeof (null === (_a2 = null == seriesSpec ? void 0 : seriesSpec.grid) || void 0 === _a2 ? void 0 : _a2.visible) || (null === (_b2 = null == seriesSpec ? void 0 : seriesSpec.grid) || void 0 === _b2 ? void 0 : _b2.visible),
            style: (datum, index) => {
              var _a3, _b3, _c2, _e2, _f2;
              let lineWidth = 0;
              if (0 === index) {
                const style = null === (_a3 = null == seriesSpec ? void 0 : seriesSpec.grid) || void 0 === _a3 ? void 0 : _a3.style;
                lineWidth = null !== (_c2 = null !== (_b3 = null == style ? void 0 : style.lineWidth) && void 0 !== _b3 ? _b3 : null == style ? void 0 : style.strokeWidth) && void 0 !== _c2 ? _c2 : 1;
              }
              return {
                lineWidth,
                stroke: (null === (_f2 = null === (_e2 = null == seriesSpec ? void 0 : seriesSpec.grid) || void 0 === _e2 ? void 0 : _e2.style) || void 0 === _f2 ? void 0 : _f2.stroke) || "#dfdfdf",
                lineDash: [0, 0]
              };
            }
          },
          domainLine: {
            visible: false
          },
          tick: {
            visible: false
          },
          label: {
            visible: false
          },
          regionIndex: region.length - 1
        }), seriesSpec.type === SeriesTypeEnum.dot) {
          elements.push({
            modelId: `scrollBarRightRow${rowNum}`,
            col: 2,
            row: rowNum
          });
          const dataLength = this._getSeriesDataLength(spec, seriesSpec);
          let ratio = 0;
          dataLength && (ratio = ((null == seriesSpec ? void 0 : seriesSpec.height) || defaultSeriesRowHeight) / (30 * dataLength)), scrollBar2.push(Object.assign({
            orient: "right",
            visible: seriesSpec.type === SeriesTypeEnum.dot && ratio < 1,
            id: `scrollBarRightRow${rowNum}`,
            start: 0,
            end: Math.min(ratio, 1),
            filterMode: "axis",
            regionIndex: region.length - 1,
            axisId: `axesLeftRow${rowNum}`
          }, array(null == spec ? void 0 : spec.scrollBar)[0]));
        }
        seriesSpec.regionIndex = region.length - 1, rowNum++, rowHeight.push({
          index: rowNum,
          size: (null == seriesSpec ? void 0 : seriesSpec.padding) || 20
        }), rowNum++, seriesSpec.leftAppendPadding = leftAppendPadding, seriesSpec.type === SeriesTypeEnum.dot && (seriesSpec.title.style.dx = -leftAppendPadding, seriesSpec.subTitle.style.dx = -leftAppendPadding);
      }
    }), null === (_l = null == spec ? void 0 : spec.series) || void 0 === _l || _l.forEach((seriesSpec) => {
      if (seriesSpec.type === SeriesTypeEnum.link) {
        const dotRowNum = seriesSpec.dotSeriesIndex + 1;
        elements.push({
          modelId: `${seriesSpec.type}Row${dotRowNum}`,
          col: 1,
          row: dotRowNum - 1
        }), seriesSpec.regionIndex = spec.series[seriesSpec.dotSeriesIndex].regionIndex, seriesSpec.leftAppendPadding = leftAppendPadding, seriesSpec.height = spec.series[seriesSpec.dotSeriesIndex].height, seriesSpec.clipHeight = spec.series[seriesSpec.dotSeriesIndex].clipHeight;
      }
    }), (null == spec ? void 0 : spec.legends) && this.addAttrToComponentSpec(spec.legends, "regionIndex", [region.length - 1]);
    const layout = {
      type: "grid",
      col: 4,
      row: rowNum,
      colWidth: [{
        index: 0,
        size: leftAppendPadding
      }, {
        index: 2,
        size: SCROLL_BAR_DEFAULT_SIZE
      }, {
        index: 3,
        size: rightAppendPadding
      }],
      rowHeight,
      elements
    };
    spec.layout = layout, spec.region = region, null === (_m = spec.axes) || void 0 === _m || _m.push(...axes), spec.scrollBar = scrollBar2;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/sequence/sequence
var __rest15 = function(s2, e) {
  var t = {};
  for (var p in s2)
    Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++)
      e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var SequenceChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = SequenceChartSpecTransformer, this.type = "sequence";
  }
  _createSeries(constructor, specInfo) {
    if (!constructor)
      return;
    const { spec } = specInfo, others = __rest15(specInfo, ["spec"]);
    let region;
    if (spec.type === SeriesTypeEnum.link && (spec.dotSeriesSpec = this._spec.series[spec.dotSeriesIndex]), spec.regionId && (region = this.getRegionsInUserId(spec.regionId)), region || (region = this.getRegionsInIndex(spec.regionIndex ? [spec.regionIndex] : void 0)[0]), !region)
      return;
    const series2 = new constructor(spec, Object.assign(Object.assign(Object.assign({}, this._modelOption), others), {
      region,
      specKey: "series",
      globalScale: this._globalScale
    }));
    series2 && (series2.created(), this._series.push(series2), region.addSeries(series2));
  }
};
SequenceChart.type = "sequence", SequenceChart.transformerConstructor = SequenceChartSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/sunburst/sunburst-transformer
var SunburstChartSpecTransformer = class extends BaseChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    const startAngle = isValid_default(spec.startAngle) ? spec.startAngle : POLAR_START_ANGLE2, endAngle = isValid_default(spec.endAngle) ? spec.endAngle : startAngle + radianToDegree(2 * Math.PI), series2 = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      categoryField: spec.categoryField,
      valueField: spec.valueField,
      seriesField: spec.seriesField,
      centerX: spec.centerX,
      centerY: spec.centerY,
      offsetX: spec.offsetX,
      offsetY: spec.offsetY,
      startAngle,
      endAngle,
      innerRadius: spec.innerRadius,
      outerRadius: spec.outerRadius,
      gap: spec.gap,
      labelLayout: spec.labelLayout,
      label: spec.label,
      labelAutoVisible: spec.labelAutoVisible,
      drill: spec.drill,
      drillField: spec.drillField
    }), seriesType = SeriesTypeEnum.sunburst;
    return series2.type = seriesType, series2[seriesType] = spec[seriesType], series2;
  }
  transformSpec(spec) {
    super.transformSpec(spec), this.transformSeriesSpec(spec);
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/sunburst/sunburst
var SunburstChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = SunburstChartSpecTransformer, this.type = "sunburst", this.seriesType = SeriesTypeEnum.sunburst;
  }
};
SunburstChart.type = "sunburst", SunburstChart.seriesType = SeriesTypeEnum.sunburst, SunburstChart.transformerConstructor = SunburstChartSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/treemap/treemap-transformer
var TreemapChartSpecTransformer = class extends BaseChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    const series2 = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      categoryField: spec.categoryField,
      valueField: spec.valueField,
      seriesField: spec.seriesField,
      aspectRatio: spec.aspectRatio,
      splitType: spec.splitType,
      maxDepth: spec.maxDepth,
      gapWidth: spec.gapWidth,
      nodePadding: spec.nodePadding,
      minVisibleArea: spec.minVisibleArea,
      minChildrenVisibleArea: spec.minChildrenVisibleArea,
      minChildrenVisibleSize: spec.minChildrenVisibleSize,
      roam: spec.roam,
      drill: spec.drill,
      drillField: spec.drillField,
      leaf: spec.leaf,
      nonLeaf: spec.nonLeaf,
      nonLeafLabel: spec.nonLeafLabel
    }), seriesType = this.seriesType;
    return seriesType && (series2.type = seriesType, series2[seriesType] = spec[seriesType]), series2;
  }
  transformSpec(spec) {
    super.transformSpec(spec), this.transformSeriesSpec(spec);
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/treemap/treemap
var TreemapChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = TreemapChartSpecTransformer, this.type = "treemap", this.seriesType = SeriesTypeEnum.treemap;
  }
};
TreemapChart.type = "treemap", TreemapChart.seriesType = SeriesTypeEnum.treemap, TreemapChart.transformerConstructor = TreemapChartSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/waterfall/waterfall-transformer
var WaterfallChartSpecTransformer = class extends BarChartSpecTransformer {
  transformSpec(spec) {
    super.transformSpec(spec), spec.legends && array(spec.legends).forEach((l) => {
      l.select = false, l.hover = false, l.filter = false;
    }), setDefaultCrosshairForCartesianChart(spec);
  }
  _getDefaultSeriesSpec(spec) {
    return Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      bar: spec.bar,
      stackLabel: spec.stackLabel,
      leaderLine: spec.leaderLine,
      total: spec.total
    });
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/waterfall/waterfall
var WaterfallChart = class extends BarChart {
  constructor() {
    super(...arguments), this.transformerConstructor = WaterfallChartSpecTransformer, this.type = "waterfall", this.seriesType = SeriesTypeEnum.waterfall;
  }
};
WaterfallChart.type = "waterfall", WaterfallChart.seriesType = SeriesTypeEnum.waterfall, WaterfallChart.transformerConstructor = WaterfallChartSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/correlation/correlation-transformer
var CorrelationChartSpecTransformer = class extends BaseChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    const series2 = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      categoryField: spec.categoryField,
      valueField: spec.valueField,
      seriesField: spec.seriesField,
      sizeField: spec.sizeField,
      sizeRange: spec.sizeRange,
      centerX: spec.centerX,
      centerY: spec.centerY,
      innerRadius: spec.innerRadius,
      outerRadius: spec.outerRadius,
      startAngle: spec.startAngle,
      endAngle: spec.endAngle,
      ripplePoint: spec.ripplePoint,
      centerPoint: spec.centerPoint,
      centerLabel: spec.centerLabel,
      nodePoint: spec.nodePoint,
      label: spec.label
    }), seriesType = SeriesTypeEnum.correlation;
    return series2.type = seriesType, series2[seriesType] = spec[seriesType], series2;
  }
  transformSpec(spec) {
    super.transformSpec(spec), this.transformSeriesSpec(spec);
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/correlation/correlation
var CorrelationChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = CorrelationChartSpecTransformer, this.type = "correlation", this.seriesType = SeriesTypeEnum.correlation;
  }
};
CorrelationChart.type = "correlation", CorrelationChart.seriesType = SeriesTypeEnum.correlation, CorrelationChart.transformerConstructor = CorrelationChartSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/liquid/liquid-transformer
var LiquidChartSpecTransformer = class extends BaseChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    const series2 = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      valueField: spec.valueField,
      maskShape: spec.maskShape,
      outlineMargin: spec.outlineMargin,
      outlinePadding: spec.outlinePadding,
      indicatorSmartInvert: spec.indicatorSmartInvert,
      liquidBackground: spec.liquidBackground,
      liquidOutline: spec.liquidOutline
    }), seriesType = SeriesTypeEnum.liquid;
    return seriesType && (series2.type = seriesType, series2[seriesType] = spec[seriesType]), series2;
  }
  transformSpec(spec) {
    super.transformSpec(spec), this.transformSeriesSpec(spec);
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/liquid/liquid
var LiquidChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = LiquidChartSpecTransformer, this.type = "liquid", this.seriesType = SeriesTypeEnum.liquid;
  }
};
LiquidChart.type = "liquid", LiquidChart.seriesType = SeriesTypeEnum.liquid, LiquidChart.transformerConstructor = LiquidChartSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/word-cloud/base/word-cloud-base-transformer
var BaseWordCloudChartSpecTransformer = class extends BaseChartSpecTransformer {
  transformSpec(spec) {
    super.transformSpec(spec), this.transformSeriesSpec(spec);
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/word-cloud/base/base
var BaseWordCloudChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = BaseWordCloudChartSpecTransformer, this.type = "wordCloud", this.seriesType = SeriesTypeEnum.wordCloud;
  }
};
BaseWordCloudChart.transformerConstructor = BaseWordCloudChartSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/word-cloud/word-cloud-transformer
var WordCloudChartSpecTransformer = class extends BaseWordCloudChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    const series2 = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      nameField: spec.nameField,
      valueField: spec.valueField,
      seriesField: spec.seriesField,
      fontFamilyField: spec.fontFamilyField,
      fontWeightField: spec.fontWeightField,
      fontStyleField: spec.fontStyleField,
      colorHexField: spec.colorHexField,
      colorMode: spec.colorMode,
      colorList: spec.colorList,
      rotateAngles: spec.rotateAngles,
      fontWeightRange: spec.fontWeightRange,
      fontSizeRange: spec.fontSizeRange,
      maskShape: spec.maskShape,
      keepAspect: spec.keepAspect,
      random: spec.random,
      wordCloudConfig: spec.wordCloudConfig,
      wordCloudShapeConfig: spec.wordCloudShapeConfig,
      word: spec.word,
      fillingWord: spec.fillingWord
    }), seriesType = this.seriesType;
    return seriesType && (series2.type = seriesType, series2[seriesType] = spec[seriesType]), series2;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/word-cloud/word-cloud
var WordCloudChart = class extends BaseWordCloudChart {
  constructor() {
    super(...arguments), this.transformerConstructor = WordCloudChartSpecTransformer, this.type = "wordCloud", this.seriesType = SeriesTypeEnum.wordCloud;
  }
};
WordCloudChart.type = "wordCloud", WordCloudChart.seriesType = SeriesTypeEnum.wordCloud, WordCloudChart.transformerConstructor = WordCloudChartSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/word-cloud/3d/word-cloud-3d-transformer
var WordCloud3dChartSpecTransformer = class extends BaseWordCloudChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    const series2 = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      nameField: spec.nameField,
      valueField: spec.valueField,
      seriesField: spec.seriesField,
      fontFamilyField: spec.fontFamilyField,
      fontWeightField: spec.fontWeightField,
      fontStyleField: spec.fontStyleField,
      colorHexField: spec.colorHexField,
      colorMode: spec.colorMode,
      colorList: spec.colorList,
      rotateAngles: spec.rotateAngles,
      fontWeightRange: spec.fontWeightRange,
      fontSizeRange: spec.fontSizeRange,
      depth_3d: spec.depth_3d,
      maskShape: spec.maskShape,
      keepAspect: spec.keepAspect,
      random: spec.random,
      wordCloudConfig: spec.wordCloudConfig,
      wordCloudShapeConfig: spec.wordCloudShapeConfig,
      word: spec.word,
      fillingWord: spec.fillingWord
    }), seriesType = this.seriesType;
    return seriesType && (series2.type = seriesType, series2[seriesType] = spec[seriesType]), series2;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/word-cloud/3d/word-cloud-3d
var WordCloud3dChart = class extends BaseWordCloudChart {
  constructor() {
    super(...arguments), this.transformerConstructor = WordCloud3dChartSpecTransformer, this.type = "wordCloud3d", this.seriesType = SeriesTypeEnum.wordCloud3d;
  }
};
WordCloud3dChart.type = "wordCloud3d", WordCloud3dChart.seriesType = SeriesTypeEnum.wordCloud3d, WordCloud3dChart.transformerConstructor = WordCloud3dChartSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/venn/venn-transformer
var VennChartSpecTransformer = class extends BaseChartSpecTransformer {
  _getDefaultSeriesSpec(spec) {
    const series2 = Object.assign(Object.assign({}, super._getDefaultSeriesSpec(spec)), {
      categoryField: spec.categoryField,
      valueField: spec.valueField,
      seriesField: spec.seriesField,
      circle: spec.circle,
      overlap: spec.overlap,
      overlapLabel: spec.overlapLabel
    }), seriesType = this.seriesType;
    return seriesType && (series2.type = seriesType, series2[seriesType] = spec[seriesType]), series2;
  }
  transformSpec(spec) {
    super.transformSpec(spec), this.transformSeriesSpec(spec);
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/chart/venn/venn
var VennChart = class extends BaseChart {
  constructor() {
    super(...arguments), this.transformerConstructor = VennChartSpecTransformer, this.type = "venn", this.seriesType = SeriesTypeEnum.venn;
  }
};
VennChart.type = "venn", VennChart.seriesType = SeriesTypeEnum.venn, VennChart.transformerConstructor = VennChartSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/data-zoom/util
var dataFilterWithNewDomain = (data, op) => {
  const { getNewDomain, isContinuous: isContinuous2, field: field3 } = op, datumField = field3(), newDomain = getNewDomain();
  if (isNil_default(newDomain) || isNil_default(datumField))
    return data;
  if (0 === newDomain.length)
    return [];
  const domainMap = {};
  newDomain.forEach((d) => {
    domainMap[d] || (domainMap[d] = 1);
  });
  let filter2 = null;
  return filter2 = isContinuous2() ? (d) => d[datumField] >= newDomain[0] && d[datumField] <= newDomain[1] : (d) => domainMap[d[datumField] + ""] || domainMap[d[datumField]], data.filter(filter2);
};
var dataFilterComputeDomain = (data, op) => {
  const { stateFields, valueFields, dataCollection } = op.input, { stateField, valueField } = op.output, resultObj = {}, resultData = [];
  return dataCollection.forEach((dv, i) => {
    var _a;
    if (isNil_default(stateFields[i]))
      return;
    const stateFieldInfo = null === (_a = dv.getFields()) || void 0 === _a ? void 0 : _a[stateFields[i]];
    stateFieldInfo && stateFieldInfo.lockStatisticsByDomain && stateFieldInfo.domain.forEach((d) => {
      resultObj[d] = 0;
    }), dv.latestData.forEach((d) => {
      array(stateFields[i]).forEach((state) => {
        isNil_default(d[state]) || (isNil_default(resultObj[d[state]]) && (resultObj[d[state]] = 0), isNil_default(valueFields[i]) || (resultObj[d[state]] += isNaN(parseFloat(d[valueFields[i]])) ? 1 : parseFloat(d[valueFields[i]])));
      });
    });
  }), Object.keys(resultObj).forEach((d, i) => {
    const res = {
      [stateField]: d
    };
    valueField && (res[valueField] = resultObj[d]), resultData.push(res);
  }), resultData;
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/data-zoom/data-filter-base-component
var DataFilterBaseComponent = class extends BaseComponent {
  get relatedAxisComponent() {
    return this._relatedAxisComponent;
  }
  setStartAndEnd(start, end, rangeMode = ["percent", "percent"]) {
    const [startMode = "percent", endMode = "percent"] = rangeMode, startPercent = "percent" === startMode ? start : this.dataToStatePoint(start), endPercent = "percent" === endMode ? end : this.dataToStatePoint(end);
    this._handleChange(startPercent, endPercent, true);
  }
  enableInteraction() {
    this._activeRoam = true;
  }
  disableInteraction() {
    this._activeRoam = false;
  }
  zoomIn(location) {
    this._handleChartZoom({
      zoomDelta: 1.2,
      zoomX: null == location ? void 0 : location.x,
      zoomY: null == location ? void 0 : location.y
    });
  }
  zoomOut(location) {
    this._handleChartZoom({
      zoomDelta: 0.8,
      zoomX: null == location ? void 0 : location.x,
      zoomY: null == location ? void 0 : location.y
    });
  }
  _handleChange(start, end, updateComponent) {
    var _a, _b;
    null !== (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.zoomLock) && void 0 !== _b && _b || end - start !== this._spanCache && (end - start < this._minSpan || end - start > this._maxSpan) ? this._shouldChange = false : (this._shouldChange = true, this._spanCache = end - start);
  }
  _isReverse() {
    const axis2 = this._relatedAxisComponent;
    if (!axis2)
      return false;
    const axisScale = axis2.getScale();
    return axisScale.range()[0] > axisScale.range()[1] && (!axis2.getInverse() || this._isHorizontal);
  }
  _updateRangeFactor(tag) {
    const axisScale = this._relatedAxisComponent.getScale(), reverse = this._isReverse(), newRangeFactor = reverse ? [1 - this._end, 1 - this._start] : [this._start, this._end];
    if (reverse)
      switch (tag) {
        case "startHandler":
          axisScale.rangeFactorEnd(newRangeFactor[1]);
          break;
        case "endHandler":
          axisScale.rangeFactorStart(newRangeFactor[0]);
          break;
        default:
          axisScale.rangeFactorStart(newRangeFactor[0], true), axisScale.rangeFactorEnd(newRangeFactor[1]);
      }
    else
      switch (tag) {
        case "startHandler":
          axisScale.rangeFactorStart(newRangeFactor[0]);
          break;
        case "endHandler":
          axisScale.rangeFactorEnd(newRangeFactor[1]);
          break;
        default:
          axisScale.rangeFactorEnd(newRangeFactor[1], true), axisScale.rangeFactorStart(newRangeFactor[0]);
      }
    const newFactor = axisScale.rangeFactor();
    newFactor ? (this._start = reverse ? 1 - newFactor[1] : newFactor[0], this._end = reverse ? 1 - newFactor[0] : newFactor[1]) : (this._start = 0, this._end = 1);
  }
  get visible() {
    return this._visible;
  }
  constructor(spec, options) {
    super(spec, options), this.layoutType = "none", this._orient = "left", this._cacheVisibility = void 0, this._dataUpdating = false, this._shouldChange = true, this._stateField = "x", this._activeRoam = true, this._zoomAttr = {
      enable: true,
      rate: 1,
      focus: true
    }, this._dragAttr = {
      enable: true,
      rate: 1,
      reverse: true
    }, this._scrollAttr = {
      enable: true,
      rate: 1,
      reverse: true
    }, this.effect = {
      onZoomChange: (tag) => {
        var _a, _b;
        const axis2 = this._relatedAxisComponent;
        if (axis2 && "axis" === this._filterMode) {
          const axisScale = axis2.getScale(), axisSpec = axis2.getSpec();
          this._auto && this._getAxisBandSize(axisSpec) && this._spec.ignoreBandSize && (axisScale.bandwidth("auto"), axisScale.maxBandwidth("auto"), axisScale.minBandwidth("auto")), this._updateRangeFactor(tag), this._auto && (null === (_b = null === (_a = this._component) || void 0 === _a ? void 0 : _a.setStartAndEnd) || void 0 === _b || _b.call(_a, this._start, this._end)), axis2.effect.scaleUpdate();
        } else
          eachSeries(this._regions, (s2) => {
            var _a2;
            null === (_a2 = s2.getViewData()) || void 0 === _a2 || _a2.markRunning();
          }, {
            userId: this._seriesUserId,
            specIndex: this._seriesIndex
          }), eachSeries(this._regions, (s2) => {
            s2.reFilterViewData();
          }, {
            userId: this._seriesUserId,
            specIndex: this._seriesIndex
          });
      }
    }, this._visible = true, this._handleStateChange = (startValue, endValue, tag) => {
      var _a, _b;
      return this._startValue = startValue, this._endValue = endValue, this._newDomain = this._parseDomainFromState(this._startValue, this._endValue), null === (_b = (_a = this.effect).onZoomChange) || void 0 === _b || _b.call(_a, tag), true;
    }, this._handleChartZoom = (params2) => {
      var _a, _b;
      if (!this._activeRoam)
        return;
      const { zoomDelta, zoomX, zoomY } = params2, { x, y } = this._regions[0].getLayoutStartPoint(), { width, height } = this._regions[0].getLayoutRect(), delta = Math.abs(this._start - this._end), zoomRate = null !== (_b = null === (_a = this._spec.roamZoom) || void 0 === _a ? void 0 : _a.rate) && void 0 !== _b ? _b : 1;
      if (delta >= 1 && zoomDelta < 1)
        return;
      if (delta <= 0.01 && zoomDelta > 1)
        return;
      const focusLoc = this._isHorizontal ? zoomX : zoomY, totalValue = delta * (zoomDelta - 1) * zoomRate;
      let startValue = totalValue / 2, endValue = totalValue / 2;
      if (focusLoc) {
        const startLoc = this._isHorizontal ? x : y, endLoc = this._isHorizontal ? width : height;
        startValue = Math.abs(startLoc - focusLoc) / Math.abs(endLoc - startLoc) * totalValue, endValue = Math.abs(endLoc - focusLoc) / Math.abs(endLoc - startLoc) * totalValue;
      }
      const start = clamp_default(this._start + startValue, 0, 1), end = clamp_default(this._end - endValue, 0, 1);
      this._handleChange(Math.min(start, end), Math.max(start, end), true);
    }, this._handleChartScroll = (params2, e) => {
      var _a;
      if (!this._activeRoam)
        return false;
      const { scrollX, scrollY } = params2;
      let value = this._isHorizontal ? scrollX : scrollY;
      const active = this._isHorizontal ? abs(scrollX / scrollY) >= 0.5 : abs(scrollY / scrollX) >= 0.5;
      this._scrollAttr.reverse || (value = -value), active && this._handleChartMove(value, null !== (_a = this._scrollAttr.rate) && void 0 !== _a ? _a : 1);
      const hasChange = 0 !== this._start && 1 !== this._end;
      return active && hasChange;
    }, this._handleChartDrag = (delta, e) => {
      var _a;
      if (!this._activeRoam)
        return;
      const [dx, dy] = delta;
      let value = this._isHorizontal ? dx : dy;
      this._dragAttr.reverse && (value = -value), this._handleChartMove(value, null !== (_a = this._dragAttr.rate) && void 0 !== _a ? _a : 1);
    }, this._handleChartMove = (value, rate) => {
      const totalValue = this._isHorizontal ? this.getLayoutRect().width : this.getLayoutRect().height;
      if (Math.abs(value) >= 1e-6) {
        if (value > 0 && this._end < 1) {
          const moveDelta = Math.min(1 - this._end, value / totalValue) * rate;
          this._handleChange(this._start + moveDelta, this._end + moveDelta, true);
        } else if (value < 0 && this._start > 0) {
          const moveDelta = Math.max(-this._start, value / totalValue) * rate;
          this._handleChange(this._start + moveDelta, this._end + moveDelta, true);
        }
      }
      return false;
    }, this._orient = getOrient(spec), this._isHorizontal = "horizontal" === getDirectionByOrient(this._orient);
  }
  created() {
    super.created(), this._setAxisFromSpec(), this._setRegionsFromSpec(), this._initEvent(), this._initData(), this._initStateScale(), this._setStateFromSpec();
  }
  initLayout() {
    super.initLayout(), this._layout && (this._layout.layoutOrient = this._orient);
  }
  _setAxisFromSpec() {
    if (isValid_default(this._spec.axisId) ? this._relatedAxisComponent = this._option.getComponentByUserId(this._spec.axisId) : isValid_default(this._spec.axisIndex) && (this._relatedAxisComponent = this._option.getComponentByIndex("axes", this._spec.axisIndex)), isNil_default(this._spec.field) && !this._relatedAxisComponent) {
      const axes = this._option.getComponentsByKey("axes"), sameOrientAxis = axes.find((cm) => cm._orient === this._orient);
      if (sameOrientAxis)
        this._relatedAxisComponent = sameOrientAxis;
      else {
        const bandAxis = axes.find((cm) => !isContinuous(cm.getScale().type));
        this._relatedAxisComponent = bandAxis;
      }
    }
    this._relatedAxisComponent && "axis" === this._filterMode && (this._relatedAxisComponent.autoIndentOnce = true);
  }
  _setRegionsFromSpec() {
    var _a, _b;
    this._regions = this._relatedAxisComponent ? this._relatedAxisComponent.getRegions() : this._option.getAllRegions();
    const bindSeriesFilter = this._relatedAxisComponent ? null === (_b = (_a = this._relatedAxisComponent).getBindSeriesFilter) || void 0 === _b ? void 0 : _b.call(_a) : null;
    if (isValid_default(bindSeriesFilter) && (isValid_default(bindSeriesFilter.userId) && (this._seriesUserId = array(bindSeriesFilter.userId)), isValid_default(bindSeriesFilter.specIndex) && (this._seriesIndex = array(bindSeriesFilter.specIndex))), isValid_default(this._spec.seriesId)) {
      const specSeriesId = array(this._spec.seriesId);
      this._seriesUserId ? this._seriesUserId = this._seriesUserId.filter((s2) => specSeriesId.includes(s2)) : this._seriesUserId = specSeriesId;
    }
    if (isValid_default(this._spec.seriesIndex)) {
      const specSeriesIndex = array(this._spec.seriesIndex);
      this._seriesIndex ? this._seriesIndex = this._seriesIndex.filter((s2) => specSeriesIndex.includes(s2)) : this._seriesIndex = specSeriesIndex;
    }
    if (isValid_default(this._spec.regionIndex)) {
      const regionsFromSpec = this._option.getRegionsInIndex(array(this._spec.regionIndex));
      this._regions = this._regions.filter((r) => regionsFromSpec.includes(r));
    } else if (isValid_default(this._spec.regionId)) {
      const ids = array(this._spec.regionId);
      this._regions = ids.length ? this._regions.filter((r) => ids.includes(r.id)) : [];
    } else
      ;
  }
  onDataUpdate() {
    var _a;
    const domain = this._computeDomainOfStateScale(isContinuous(this._stateScale.type));
    this._stateScale.domain(domain, true), this._handleChange(this._start, this._end, true), this._spec.auto && (this._dataUpdating = true, null === (_a = this.getChart()) || void 0 === _a || _a.setLayoutTag(true, null, false));
  }
  _computeDomainOfStateScale(isContinuous2) {
    if (this._spec.customDomain)
      return this._spec.customDomain;
    const domain = this._data.getLatestData().map((d) => d[this._stateField]);
    if (isContinuous2) {
      const domainNum = domain.map((n) => 1 * n);
      return domain.length ? [minInArray(domainNum), maxInArray(domainNum)] : [-1 / 0, 1 / 0];
    }
    return domain;
  }
  _initEvent() {
    this._initCommonEvent();
  }
  _initData() {
    const dataCollection = [], stateFields = [], valueFields = [];
    if (this._relatedAxisComponent) {
      const originalStateFields = {};
      eachSeries(this._regions, (s2) => {
        var _a, _b;
        const xAxisHelper = "cartesian" === s2.coordinate ? s2.getXAxisHelper() : "polar" === s2.coordinate ? s2.angleAxisHelper : null, yAxisHelper = "cartesian" === s2.coordinate ? s2.getYAxisHelper() : "polar" === s2.coordinate ? s2.radiusAxisHelper : null;
        if (!xAxisHelper || !yAxisHelper)
          return;
        const stateAxisHelper = xAxisHelper.getAxisId() === this._relatedAxisComponent.id ? xAxisHelper : yAxisHelper.getAxisId() === this._relatedAxisComponent.id ? yAxisHelper : this._isHorizontal ? xAxisHelper : yAxisHelper, valueAxisHelper = stateAxisHelper === xAxisHelper ? yAxisHelper : xAxisHelper, isValidateValueAxis = isContinuous(valueAxisHelper.getScale(0).type);
        dataCollection.push(s2.getRawData());
        const seriesSpec = s2.getSpec(), xFields = array(seriesSpec.xField), yFields = array(seriesSpec.yField), xField = "cartesian" === s2.coordinate ? xFields[0] : null !== (_a = seriesSpec.angleField) && void 0 !== _a ? _a : seriesSpec.categoryField, yField = "cartesian" === s2.coordinate ? yFields[0] : null !== (_b = seriesSpec.radiusField) && void 0 !== _b ? _b : seriesSpec.valueField;
        if (originalStateFields[s2.id] = "link" === s2.type ? "from_xField" : stateAxisHelper === xAxisHelper ? xField : yField, stateFields.push(originalStateFields[s2.id]), this._valueField) {
          const valueField = "link" === s2.type ? "from_yField" : valueAxisHelper === xAxisHelper ? xField : yField;
          valueFields.push(isValidateValueAxis ? valueField : null);
        }
      }, {
        userId: this._seriesUserId,
        specIndex: this._seriesIndex
      }), this._originalStateFields = originalStateFields;
    } else
      eachSeries(this._regions, (s2) => {
        dataCollection.push(s2.getRawData()), stateFields.push(this._field), this._valueField && valueFields.push(this._spec.valueField);
      }, {
        userId: this._seriesUserId,
        specIndex: this._seriesIndex
      });
    const { dataSet } = this._option;
    registerDataSetInstanceParser(dataSet, "dataview", dataViewParser), registerDataSetInstanceTransform(dataSet, "dataFilterComputeDomain", dataFilterComputeDomain);
    const data = new DataView(dataSet, {
      name: `${this.type}_${this.id}_data`
    });
    data.transform({
      type: "dataFilterComputeDomain",
      options: {
        input: {
          dataCollection,
          stateFields,
          valueFields
        },
        output: {
          stateField: this._stateField,
          valueField: this._valueField
        }
      }
    }, false), this._data = new CompilableData(this._option, data), data.reRunAllTransform(), dataSet.multipleDataViewAddListener(dataCollection, "change", this._handleDataCollectionChange.bind(this));
  }
  setAttrFromSpec() {
    var _a;
    super.setAttrFromSpec(), true === this._spec.roamZoom || this._spec.roamZoom ? this._zoomAttr = merge({}, this._zoomAttr, this._spec.roamZoom) : this._zoomAttr.enable = false, true === this._spec.roamDrag || this._spec.roamDrag ? this._dragAttr = merge({}, this._dragAttr, this._spec.roamDrag) : this._dragAttr.enable = false, true === this._spec.roamScroll || this._spec.roamScroll ? this._scrollAttr = merge({}, this._scrollAttr, this._spec.roamScroll) : this._scrollAttr.enable = false, this._field = this._spec.field, this._width = this._computeWidth(), this._height = this._computeHeight(), this._visible = null === (_a = this._spec.visible) || void 0 === _a || _a;
  }
  _statePointToData(state) {
    const scale4 = this._stateScale, domain = scale4.domain();
    if (isContinuous(scale4.type))
      return this._isReverse() ? domain[0] + (domain[1] - domain[0]) * (1 - state) : domain[0] + (domain[1] - domain[0]) * state;
    let range2 = scale4.range();
    this._isReverse() && (range2 = range2.slice().reverse());
    const posInRange = range2[0] + (range2[1] - range2[0]) * state;
    return scale4.invert(posInRange);
  }
  dataToStatePoint(data) {
    const scale4 = this._stateScale, pos = scale4.scale(data);
    let range2 = scale4.range();
    return !this._isHorizontal && isContinuous(scale4.type) && (range2 = range2.slice().reverse()), (pos - range2[0]) / (range2[1] - range2[0]);
  }
  _modeCheck(statePoint, mode) {
    return "start" === statePoint ? "percent" === mode && this._spec.start || "value" === mode && this._spec.startValue : "percent" === mode && this._spec.end || "value" === mode && this._spec.endValue;
  }
  _setStateFromSpec() {
    var _a, _b;
    let start, end;
    if (this._auto = !!this._spec.auto, this._spec.rangeMode) {
      const [startMode, endMode] = this._spec.rangeMode;
      this._modeCheck("start", startMode) && this._modeCheck("end", endMode) && (start = "percent" === startMode ? this._spec.start : this.dataToStatePoint(this._spec.startValue), end = "percent" === endMode ? this._spec.end : this.dataToStatePoint(this._spec.endValue));
    } else
      start = this._spec.start ? this._spec.start : this._spec.startValue ? this.dataToStatePoint(this._spec.startValue) : 0, end = this._spec.end ? this._spec.end : this._spec.endValue ? this.dataToStatePoint(this._spec.endValue) : 1;
    this._startValue = this._statePointToData(start), this._endValue = this._statePointToData(end), this._start = start, this._end = end, this._minSpan = null !== (_a = this._spec.minSpan) && void 0 !== _a ? _a : 0, this._maxSpan = null !== (_b = this._spec.maxSpan) && void 0 !== _b ? _b : 1, isContinuous(this._stateScale.type) && this._stateScale.domain()[0] !== this._stateScale.domain()[1] && (this._spec.minValueSpan && (this._minSpan = this._spec.minValueSpan / (this._stateScale.domain()[1] - this._stateScale.domain()[0])), this._spec.maxValueSpan && (this._maxSpan = this._spec.maxValueSpan / (this._stateScale.domain()[1] - this._stateScale.domain()[0]))), this._minSpan = Math.max(0, this._minSpan), this._maxSpan = Math.min(this._maxSpan, 1), this._relatedAxisComponent && "axis" === this._filterMode || 0 === this._start && 1 === this._end || (this._newDomain = this._parseDomainFromState(this._startValue, this._endValue));
  }
  _parseFieldOfSeries(s2) {
    var _a;
    return null === (_a = this._originalStateFields) || void 0 === _a ? void 0 : _a[s2.id];
  }
  _initStateScale() {
    const defaultRange = [0, 1];
    if (this._relatedAxisComponent) {
      const scale4 = this._relatedAxisComponent.getScale(), isContinuousScale = isContinuous(scale4.type), domain = this._computeDomainOfStateScale(isContinuousScale);
      if (this._stateScale = scale4.clone(), isContinuousScale) {
        const domainNum = domain.map((n) => 1 * n);
        this._stateScale.domain(domain.length ? [minInArray(domainNum), maxInArray(domainNum)] : [0, 1], true).range(defaultRange);
      } else
        this._stateScale.domain(domain, true).range(defaultRange);
    } else
      this._stateScale = new BandScale(), this._stateScale.domain(this._computeDomainOfStateScale(), true).range(defaultRange);
  }
  init(option) {
    super.init(option), this._addTransformToSeries(), 0 === this._start && 1 === this._end || this.effect.onZoomChange();
  }
  _addTransformToSeries() {
    this._relatedAxisComponent && "axis" === this._filterMode || (registerDataSetInstanceTransform(this._option.dataSet, "dataFilterWithNewDomain", dataFilterWithNewDomain), eachSeries(this._regions, (s2) => {
      s2.addViewDataFilter({
        type: "dataFilterWithNewDomain",
        options: {
          getNewDomain: () => this._newDomain,
          field: () => {
            var _a;
            return null !== (_a = this._field) && void 0 !== _a ? _a : this._parseFieldOfSeries(s2);
          },
          isContinuous: () => isContinuous(this._stateScale.type)
        },
        level: TransformLevel.dataZoomFilter
      });
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    }));
  }
  onRender(ctx) {
  }
  _compareSpec(spec, prevSpec) {
    const result2 = super._compareSpec(spec, prevSpec);
    return result2.reMake || isEqual(prevSpec, spec) || (result2.reRender = true, result2.reMake = true), result2;
  }
  reInit(spec) {
    super.reInit(spec), this._marks.forEach((g) => {
      g.getMarks().forEach((m4) => {
        this.initMarkStyleWithSpec(m4, this._spec[m4.name]);
      });
    });
  }
  changeRegions() {
  }
  update(ctx) {
  }
  resize(ctx) {
  }
  _parseDomainFromState(startValue, endValue) {
    if (isContinuous(this._stateScale.type))
      return [Math.min(endValue, startValue), Math.max(endValue, startValue)];
    const allDomain = this._stateScale.domain(), startIndex = allDomain.indexOf(startValue), endIndex = allDomain.indexOf(endValue);
    return allDomain.slice(Math.min(startIndex, endIndex), Math.max(startIndex, endIndex) + 1);
  }
  _initCommonEvent() {
    var _a, _b, _c, _d, _e, _f, _g;
    const option = {
      delayType: null !== (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.delayType) && void 0 !== _b ? _b : "throttle",
      delayTime: isValid_default(null === (_c = this._spec) || void 0 === _c ? void 0 : _c.delayType) ? null !== (_e = null === (_d = this._spec) || void 0 === _d ? void 0 : _d.delayTime) && void 0 !== _e ? _e : 30 : 0,
      realTime: null === (_g = null === (_f = this._spec) || void 0 === _f ? void 0 : _f.realTime) || void 0 === _g || _g
    };
    this._zoomAttr.enable && this.initZoomEventOfRegions(this._regions, null, this._handleChartZoom, option), this._scrollAttr.enable && this.initScrollEventOfRegions(this._regions, null, this._handleChartScroll, option), this._dragAttr.enable && this.initDragEventOfRegions(this._regions, null, this._handleChartDrag, option);
  }
  updateLayoutAttribute() {
    this._visible && this._createOrUpdateComponent(), super.updateLayoutAttribute();
  }
  onLayoutStart(layoutRect, viewRect, ctx) {
    super.onLayoutStart(layoutRect, viewRect, ctx);
    const isShown = this._autoUpdate(layoutRect), sizeKey = this._isHorizontal ? "height" : "width";
    this.layout.setLayoutRect({
      [sizeKey]: isShown ? this[`_${sizeKey}`] : 0
    }, {
      [sizeKey]: AttributeLevel.Built_In
    }), this._dataUpdating = false;
  }
  getBoundsInRect(rect) {
    const result2 = {
      x1: this.getLayoutStartPoint().x,
      y1: this.getLayoutStartPoint().y,
      x2: 0,
      y2: 0
    };
    return this._isHorizontal ? (result2.y2 = result2.y1 + this._height, result2.x2 = result2.x1 + rect.width) : (result2.x2 = result2.x1 + this._width, result2.y2 = result2.y1 + rect.height), result2;
  }
  hide() {
    var _a;
    null === (_a = this._component) || void 0 === _a || _a.hideAll();
  }
  show() {
    var _a;
    null === (_a = this._component) || void 0 === _a || _a.showAll();
  }
  _getAxisBandSize(axisSpec) {
    const bandSize = null == axisSpec ? void 0 : axisSpec.bandSize, maxBandSize = null == axisSpec ? void 0 : axisSpec.maxBandSize, minBandSize = null == axisSpec ? void 0 : axisSpec.minBandSize;
    if (bandSize || minBandSize || maxBandSize)
      return {
        bandSize,
        maxBandSize,
        minBandSize
      };
  }
  _autoUpdate(rect) {
    var _a, _b, _c, _d, _e, _f;
    if (!this._auto)
      return this._cacheVisibility = void 0, true;
    const axis2 = this._relatedAxisComponent, axisSpec = null == axis2 ? void 0 : axis2.getSpec(), axisScale = null == axis2 ? void 0 : axis2.getScale(), bandSizeResult = this._getAxisBandSize(axisSpec);
    if (!this._dataUpdating && isDiscrete(axisScale.type) && (null == rect ? void 0 : rect.height) === (null === (_a = this._cacheRect) || void 0 === _a ? void 0 : _a.height) && (null == rect ? void 0 : rect.width) === (null === (_b = this._cacheRect) || void 0 === _b ? void 0 : _b.width) && this._fixedBandSize === (null == bandSizeResult ? void 0 : bandSizeResult.bandSize))
      return this._cacheVisibility;
    let isShown = true;
    if (this._isHorizontal && (null == rect ? void 0 : rect.width) !== (null === (_c = this._cacheRect) || void 0 === _c ? void 0 : _c.width) ? axisScale.range(axis2.getInverse() ? [rect.width, 0] : [0, rect.width]) : (null == rect ? void 0 : rect.height) !== (null === (_d = this._cacheRect) || void 0 === _d ? void 0 : _d.height) && axisScale.range(axis2.getInverse() ? [0, rect.height] : [rect.height, 0]), this._cacheRect = {
      width: null == rect ? void 0 : rect.width,
      height: null == rect ? void 0 : rect.height
    }, this._fixedBandSize = null == bandSizeResult ? void 0 : bandSizeResult.bandSize, isDiscrete(axisScale.type)) {
      bandSizeResult && (this._start || this._end) && (this.type === ComponentTypeEnum.scrollBar && (this._start = 0, this._end = 1), this._updateRangeFactor());
      const [start, end] = null !== (_e = axisScale.rangeFactor()) && void 0 !== _e ? _e : [];
      isShown = (!isNil_default(start) || !isNil_default(end)) && !(0 === start && 1 === end);
    } else {
      const [start, end] = null !== (_f = axisScale.rangeFactor()) && void 0 !== _f ? _f : [this._start, this._end];
      isShown = !(0 === start && 1 === end);
    }
    return this.setStartAndEnd(this._start, this._end), isShown ? this.show() : this.hide(), this._cacheVisibility = isShown, isShown;
  }
  _getNeedClearVRenderComponents() {
    return [this._component];
  }
};
mixin(DataFilterBaseComponent, Zoomable);

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/data-zoom/scroll-bar/scroll-bar
var ScrollBar2 = class extends DataFilterBaseComponent {
  static getSpecInfo(chartSpec) {
    const compSpec = chartSpec[this.specKey];
    if (isNil_default(compSpec))
      return;
    if (!isArray_default(compSpec))
      return [{
        spec: compSpec,
        specPath: [this.specKey],
        specInfoPath: ["component", this.specKey, 0],
        type: ComponentTypeEnum.scrollBar
      }];
    const specInfos = [];
    return compSpec.forEach((s2, i) => {
      specInfos.push({
        spec: s2,
        specPath: [this.specKey, i],
        specInfoPath: ["component", this.specKey, i],
        type: ComponentTypeEnum.scrollBar
      });
    }), specInfos;
  }
  constructor(spec, options) {
    var _a;
    super(spec, options), this.type = ComponentTypeEnum.scrollBar, this.name = ComponentTypeEnum.scrollBar, this.specKey = "scrollBar", this.layoutZIndex = LayoutZIndex.DataZoom, this.layoutLevel = LayoutLevel.DataZoom, this.layoutType = "region-relative", this._filterMode = null !== (_a = spec.filterMode) && void 0 !== _a ? _a : "axis";
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), isBoolean_default(this._spec.roam) && (this._zoomAttr.enable = false, this._dragAttr.enable = this._spec.roam, this._scrollAttr.enable = this._spec.roam), (this._zoomAttr.enable || this._dragAttr.enable || this._scrollAttr.enable) && this.initZoomable(this.event, this._option.mode);
  }
  onLayoutEnd(ctx) {
    var _a, _b;
    this._updateScaleRange(), null === (_b = (_a = this.effect).onZoomChange) || void 0 === _b || _b.call(_a), super.onLayoutEnd(ctx);
  }
  _updateScaleRange() {
    this._component && this._component.setAttributes({
      x: this.getLayoutStartPoint().x,
      y: this.getLayoutStartPoint().y,
      width: this.getLayoutRect().width,
      height: this.getLayoutRect().height
    });
  }
  _computeWidth() {
    return isNumber_default(this._spec.width) ? this._spec.width : this._isHorizontal ? this.getLayoutRect().width : SCROLL_BAR_DEFAULT_SIZE;
  }
  _computeHeight() {
    return isNumber_default(this._spec.height) ? this._spec.height : this._isHorizontal ? SCROLL_BAR_DEFAULT_SIZE : this.getLayoutRect().height;
  }
  _getAttrs() {
    var _a, _b, _c, _d, _e, _f;
    return Object.assign({
      zIndex: this.layoutZIndex,
      x: this.getLayoutStartPoint().x,
      y: this.getLayoutStartPoint().y,
      width: this.getLayoutRect().width,
      height: this.getLayoutRect().height,
      range: [this._start, this._end],
      direction: this._isHorizontal ? "horizontal" : "vertical",
      delayType: null === (_a = this._spec) || void 0 === _a ? void 0 : _a.delayType,
      delayTime: isValid_default(null === (_b = this._spec) || void 0 === _b ? void 0 : _b.delayType) ? null !== (_d = null === (_c = this._spec) || void 0 === _c ? void 0 : _c.delayTime) && void 0 !== _d ? _d : 30 : 0,
      realTime: null === (_f = null === (_e = this._spec) || void 0 === _e ? void 0 : _e.realTime) || void 0 === _f || _f
    }, this._getComponentAttrs());
  }
  _createOrUpdateComponent() {
    const attrs = this._getAttrs();
    if (this._component)
      this._component.setAttributes(attrs);
    else {
      const container2 = this.getContainer();
      this._component = new ScrollBar(attrs), this._component.addEventListener("scrollDrag", (e) => {
        const value = e.detail.value;
        this._handleChange(value[0], value[1]);
      }), container2.add(this._component);
    }
  }
  _handleChange(start, end, updateComponent) {
    super._handleChange(start, end, updateComponent);
    const isSameScrollValue = isClose(this._start, start) && isClose(this._end, end);
    if (this._shouldChange && !isSameScrollValue) {
      updateComponent && this._component && this._component.setAttribute("range", [start, end]), this._start = start, this._end = end;
      const startValue = this._statePointToData(start), endValue = this._statePointToData(end);
      (isFunction_default(this._spec.updateDataAfterChange) ? this._spec.updateDataAfterChange(start, end, startValue, endValue) : this._handleStateChange(this._statePointToData(start), this._statePointToData(end))) && this.event.emit(ChartEvent.scrollBarChange, {
        model: this,
        value: {
          filterData: "axis" !== this._filterMode,
          start: this._start,
          end: this._end,
          startValue: this._startValue,
          endValue: this._endValue,
          newDomain: this._newDomain
        }
      });
    }
  }
  _handleDataCollectionChange() {
  }
  _initCommonEvent() {
    super._initCommonEvent(), this._component && this._component.on("scrollDrag", (e) => {
      const value = e.detail.value;
      this._handleChange(value[0], value[1]);
    });
  }
  _getComponentAttrs() {
    const { rail, slider: slider2, innerPadding } = this._spec, attrs = {};
    return isNil_default(innerPadding) || (attrs.padding = innerPadding), isEmpty_default(null == rail ? void 0 : rail.style) || (attrs.railStyle = transformToGraphic(rail.style)), isEmpty_default(null == slider2 ? void 0 : slider2.style) || (attrs.sliderStyle = transformToGraphic(slider2.style)), attrs.disableTriggerEvent = this._option.disableTriggerEvent, attrs;
  }
  _getNeedClearVRenderComponents() {
    return [this._component];
  }
};
ScrollBar2.type = ComponentTypeEnum.scrollBar, ScrollBar2.specKey = "scrollBar";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/data-zoom/data-zoom/data-zoom-transformer
var DataZoomSpecTransformer = class extends BaseComponentSpecTransformer {
  _mergeThemeToSpec(spec, chartSpec) {
    const theme2 = this._theme;
    let newSpec = spec;
    if (this._shouldMergeThemeToSpec()) {
      const merge3 = (originalSpec) => {
        const result2 = mergeSpec({
          selectedBackgroundChart: {
            line: {},
            area: {}
          }
        }, this._theme, originalSpec), { selectedBackgroundChart = {} } = originalSpec, { line: line2, area: area2 } = selectedBackgroundChart;
        return line2 && false !== line2.visible && (result2.selectedBackgroundChart.line.style = Object.assign(Object.assign({}, result2.selectedBackgroundChart.line.style), {
          visible: true
        })), area2 && false !== area2.visible && (result2.selectedBackgroundChart.area.style = Object.assign(Object.assign({}, result2.selectedBackgroundChart.area.style), {
          visible: true
        })), result2;
      }, baseSpec = spec;
      newSpec = isArray_default(baseSpec) ? baseSpec.map((spec2) => merge3(spec2)) : merge3(baseSpec);
    }
    return this._adjustPadding(newSpec), {
      spec: newSpec,
      theme: theme2
    };
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/data-zoom/data-zoom/data-zoom
var DataZoom2 = class extends DataFilterBaseComponent {
  static getSpecInfo(chartSpec) {
    const compSpec = chartSpec[this.specKey];
    if (isNil_default(compSpec))
      return;
    if (!isArray_default(compSpec))
      return [{
        spec: compSpec,
        specPath: [this.specKey],
        specInfoPath: ["component", this.specKey, 0],
        type: ComponentTypeEnum.dataZoom
      }];
    const specInfos = [];
    return compSpec.forEach((s2, i) => {
      specInfos.push({
        spec: s2,
        specPath: [this.specKey, i],
        specInfoPath: ["component", this.specKey, i],
        type: ComponentTypeEnum.dataZoom
      });
    }), specInfos;
  }
  constructor(spec, options) {
    var _a;
    super(spec, options), this.type = ComponentTypeEnum.dataZoom, this.name = ComponentTypeEnum.dataZoom, this.transformerConstructor = DataZoomSpecTransformer, this.specKey = "dataZoom", this.layoutZIndex = LayoutZIndex.DataZoom, this.layoutLevel = LayoutLevel.DataZoom, this.layoutType = "region-relative", this._isReverseCache = false, this._dataToPositionX = (datum) => {
      const offsetLeft = "left" === this._orient ? this._middleHandlerSize : 0, offsetHandler = this._isHorizontal ? this._startHandlerSize / 2 : 0, xScale = this._isHorizontal ? this._stateScale : this._valueScale, xField = this._isHorizontal ? this._stateField : this._valueField;
      return xScale.scale(datum[xField]) + this.getLayoutStartPoint().x + offsetLeft + offsetHandler;
    }, this._dataToPositionX2 = (datum) => {
      const offsetLeft = "left" === this._orient ? this._middleHandlerSize : 0, offsetHandler = this._isHorizontal ? this._startHandlerSize / 2 : 0, xScale = this._isHorizontal ? this._stateScale : this._valueScale, min3 = xScale.domain()[0];
      return xScale.scale(min3) + this.getLayoutStartPoint().x + offsetLeft + offsetHandler;
    }, this._dataToPositionY = (datum) => {
      const offsetTop = this._isHorizontal ? this._middleHandlerSize : 0, offsetHandler = this._isHorizontal ? 0 : this._startHandlerSize / 2, yScale = this._isHorizontal ? this._valueScale : this._stateScale, yField = this._isHorizontal ? this._valueField : this._stateField;
      return yScale.scale(datum[yField]) + this.getLayoutStartPoint().y + offsetTop + offsetHandler;
    }, this._dataToPositionY2 = (datum) => {
      const offsetTop = this._isHorizontal ? this._middleHandlerSize : 0, offsetHandler = this._isHorizontal ? 0 : this._startHandlerSize / 2, yScale = this._isHorizontal ? this._valueScale : this._stateScale, min3 = yScale.domain()[0];
      return yScale.scale(min3) + this.getLayoutStartPoint().y + offsetTop + offsetHandler;
    }, this._valueField = "y", this._filterMode = null !== (_a = spec.filterMode) && void 0 !== _a ? _a : "filter";
  }
  created() {
    super.created(), this._initValueScale();
  }
  setAttrFromSpec() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    super.setAttrFromSpec(), isBoolean_default(this._spec.roam) && (this._zoomAttr.enable = this._spec.roam, this._dragAttr.enable = this._spec.roam, this._scrollAttr.enable = this._spec.roam), (this._zoomAttr.enable || this._dragAttr.enable || this._scrollAttr.enable) && this.initZoomable(this.event, this._option.mode), this._backgroundSize = null !== (_b = null === (_a = this._spec.background) || void 0 === _a ? void 0 : _a.size) && void 0 !== _b ? _b : 30, this._middleHandlerSize = this._computeMiddleHandlerSize(), this._width = this._computeWidth(), this._height = this._computeHeight(), isNil_default(null === (_e = null === (_d = null === (_c = this._spec) || void 0 === _c ? void 0 : _c.startHandler) || void 0 === _d ? void 0 : _d.style) || void 0 === _e ? void 0 : _e.size) && (this._spec.startHandler.style.size = this._isHorizontal ? this._height - this._middleHandlerSize : this._width - this._middleHandlerSize), isNil_default(null === (_h = null === (_g = null === (_f = this._spec) || void 0 === _f ? void 0 : _f.endHandler) || void 0 === _g ? void 0 : _g.style) || void 0 === _h ? void 0 : _h.size) && (this._spec.endHandler.style.size = this._isHorizontal ? this._height - this._middleHandlerSize : this._width - this._middleHandlerSize);
    const startHandlerVisble = null === (_j = this._spec.startHandler.style.visible) || void 0 === _j || _j, endHandlerVisble = null === (_k = this._spec.endHandler.style.visible) || void 0 === _k || _k;
    this._startHandlerSize = startHandlerVisble ? this._spec.startHandler.style.size : 0, this._endHandlerSize = endHandlerVisble ? this._spec.endHandler.style.size : 0;
  }
  onLayoutEnd(ctx) {
    this._updateScaleRange(), this._isReverse() && !this._isReverseCache && (this._isReverseCache = this._isReverse(), this.effect.onZoomChange()), false !== this._cacheVisibility && super.onLayoutEnd(ctx);
  }
  _initValueScale() {
    const domain = this._computeDomainOfValueScale();
    if (domain) {
      const valueScale = new LinearScale();
      valueScale.domain(domain), this._valueScale = valueScale;
    }
  }
  _updateScaleRange() {
    var _a, _b;
    const handlerSize = this._startHandlerSize + this._endHandlerSize;
    if (!this._stateScale || !this._valueScale)
      return;
    let stateScaleRange;
    const defaultSize = this._isHorizontal ? this.getLayoutRect().width - handlerSize : this.getLayoutRect().height - handlerSize, defaultRange = null !== (_b = null === (_a = this._relatedAxisComponent) || void 0 === _a ? void 0 : _a.getScale().range()) && void 0 !== _b ? _b : [this._startHandlerSize / 2, defaultSize + this._startHandlerSize / 2];
    this._isHorizontal ? (stateScaleRange = this._visible ? [this._startHandlerSize / 2, this._computeWidth() - handlerSize + this._startHandlerSize / 2] : defaultRange, this._stateScale.range(stateScaleRange), this._valueScale.range([this._computeHeight() - this._middleHandlerSize, 0])) : "left" === this.layoutOrient ? (stateScaleRange = this._visible ? [this._startHandlerSize / 2, this._computeHeight() - handlerSize + this._startHandlerSize / 2] : defaultRange, this._stateScale.range(stateScaleRange), this._valueScale.range([this._computeWidth() - this._middleHandlerSize, 0])) : (stateScaleRange = this._visible ? [this._startHandlerSize / 2, this._computeHeight() - handlerSize + this._startHandlerSize / 2] : defaultRange, this._stateScale.range(stateScaleRange), this._valueScale.range([0, this._computeWidth() - this._middleHandlerSize])), this._component && false !== this._cacheVisibility && this._component.setAttributes({
      size: {
        width: this._computeWidth(),
        height: this._computeHeight()
      },
      position: {
        x: this.getLayoutStartPoint().x,
        y: this.getLayoutStartPoint().y
      }
    });
  }
  _computeDomainOfValueScale() {
    const domain = this._data.getLatestData().map((d) => d[this._valueField]), domainNum = domain.map((n) => 1 * n);
    return domain.length ? [minInArray(domainNum), maxInArray(domainNum)] : null;
  }
  _computeMiddleHandlerSize() {
    var _a, _b, _c, _d;
    let size = 0;
    if (null === (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.middleHandler) || void 0 === _b ? void 0 : _b.visible) {
      const middleHandlerIconSize = null !== (_c = this._spec.middleHandler.icon.style.size) && void 0 !== _c ? _c : 8, middleHandlerBackSize = null !== (_d = this._spec.middleHandler.background.size) && void 0 !== _d ? _d : 40;
      size += Math.max(middleHandlerIconSize, middleHandlerBackSize);
    }
    return size;
  }
  _computeWidth() {
    return false === this._visible ? 0 : isNumber_default(this._spec.width) ? this._spec.width : this._isHorizontal ? this.getLayoutRect().width : this._backgroundSize + this._middleHandlerSize;
  }
  _computeHeight() {
    return false === this._visible ? 0 : isNumber_default(this._spec.height) ? this._spec.height : this._isHorizontal ? this._backgroundSize + this._middleHandlerSize : this.getLayoutRect().height - (this._startHandlerSize + this._endHandlerSize) / 2;
  }
  _isScaleValid(scale4) {
    if (!scale4 || !scale4.domain())
      return false;
    const domain = scale4.domain();
    return (!isContinuous(scale4.type) || domain[0] !== domain[1]) && (!isDiscrete(scale4.type) || 1 !== uniqArray(domain).length);
  }
  _getAttrs(isNeedPreview) {
    var _a, _b, _c, _d, _e;
    const spec = null !== (_a = this._spec) && void 0 !== _a ? _a : {};
    return Object.assign({
      zIndex: this.layoutZIndex,
      start: this._start,
      end: this._end,
      position: {
        x: this.getLayoutStartPoint().x,
        y: this.getLayoutStartPoint().y
      },
      orient: this._orient,
      size: {
        width: this.getLayoutRect().width,
        height: this.getLayoutRect().height
      },
      showDetail: spec.showDetail,
      brushSelect: null !== (_b = spec.brushSelect) && void 0 !== _b && _b,
      zoomLock: null !== (_c = spec.zoomLock) && void 0 !== _c && _c,
      minSpan: this._minSpan,
      maxSpan: this._maxSpan,
      delayType: spec.delayType,
      delayTime: isValid_default(spec.delayType) ? null !== (_d = spec.delayTime) && void 0 !== _d ? _d : 30 : 0,
      realTime: null === (_e = spec.realTime) || void 0 === _e || _e,
      previewData: isNeedPreview && this._data.getLatestData(),
      previewPointsX: isNeedPreview && this._dataToPositionX,
      previewPointsY: isNeedPreview && this._dataToPositionY,
      tolerance: this._spec.tolerance
    }, this._getComponentAttrs(isNeedPreview));
  }
  _createOrUpdateComponent() {
    if (this._visible) {
      const xScale = this._isHorizontal ? this._stateScale : this._valueScale, yScale = this._isHorizontal ? this._valueScale : this._stateScale, isNeedPreview = this._isScaleValid(xScale) && this._isScaleValid(yScale) && false !== this._spec.showBackgroundChart, attrs = this._getAttrs(isNeedPreview);
      if (this._component)
        this._component.setAttributes(attrs);
      else {
        const container2 = this.getContainer();
        this._component = new DataZoom(attrs), this._isHorizontal ? isNeedPreview && this._component.setPreviewPointsY1(this._dataToPositionY2) : isNeedPreview && this._component.setPreviewPointsX1(this._dataToPositionX2), this._component.setStatePointToData((state) => this._statePointToData(state)), this._component.addEventListener("change", (e) => {
          const { start, end, tag } = e.detail;
          this._handleChange(start, end, void 0, tag);
        }), container2.add(this._component), this._updateScaleRange();
      }
    }
  }
  _handleChange(start, end, updateComponent, tag) {
    if (super._handleChange(start, end, updateComponent), this._shouldChange) {
      updateComponent && this._component && this._component.setStartAndEnd(start, end), this._start = start, this._end = end;
      const startValue = this._statePointToData(start), endValue = this._statePointToData(end);
      (isFunction_default(this._spec.updateDataAfterChange) ? this._spec.updateDataAfterChange(start, end, startValue, endValue) : this._handleStateChange(startValue, endValue, tag)) && this.event.emit(ChartEvent.dataZoomChange, {
        model: this,
        value: {
          filterData: "axis" !== this._filterMode,
          start,
          end,
          startValue: this._startValue,
          endValue: this._endValue,
          newDomain: this._newDomain
        }
      });
    }
  }
  _handleDataCollectionChange() {
    var _a;
    const data = this._data.getDataView();
    if (data.reRunAllTransform(), null === (_a = this._component) || void 0 === _a || _a.setPreviewData(data.latestData), this._valueScale) {
      const domain = this._computeDomainOfValueScale();
      domain && this._valueScale.domain(domain);
    }
  }
  _getComponentAttrs(isNeedPreview) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const { middleHandler = {}, startText = {}, endText = {}, backgroundChart = {}, selectedBackgroundChart = {} } = this._spec;
    return {
      backgroundStyle: transformToGraphic(null === (_a = this._spec.background) || void 0 === _a ? void 0 : _a.style),
      startHandlerStyle: transformToGraphic(null === (_b = this._spec.startHandler) || void 0 === _b ? void 0 : _b.style),
      middleHandlerStyle: middleHandler.visible ? {
        visible: true,
        icon: transformToGraphic(null === (_c = middleHandler.icon) || void 0 === _c ? void 0 : _c.style),
        background: {
          size: null === (_d = middleHandler.background) || void 0 === _d ? void 0 : _d.size,
          style: transformToGraphic(null === (_e = middleHandler.background) || void 0 === _e ? void 0 : _e.style)
        }
      } : {
        visible: false
      },
      endHandlerStyle: transformToGraphic(null === (_f = this._spec.endHandler) || void 0 === _f ? void 0 : _f.style),
      startTextStyle: {
        padding: startText.padding,
        formatMethod: this._getHandlerTextFormatMethod(startText),
        textStyle: transformToGraphic(startText.style)
      },
      endTextStyle: {
        padding: endText.padding,
        formatMethod: this._getHandlerTextFormatMethod(endText),
        textStyle: transformToGraphic(endText.style)
      },
      selectedBackgroundStyle: transformToGraphic(this._spec.selectedBackground.style),
      dragMaskStyle: transformToGraphic(null === (_g = this._spec.dragMask) || void 0 === _g ? void 0 : _g.style),
      backgroundChartStyle: isNeedPreview ? {
        line: mergeSpec(transformToGraphic(null === (_h = backgroundChart.line) || void 0 === _h ? void 0 : _h.style), {
          fill: false
        }),
        area: Object.assign({
          curveType: "basis",
          visible: true
        }, transformToGraphic(null === (_j = backgroundChart.area) || void 0 === _j ? void 0 : _j.style))
      } : {
        line: {
          visible: false
        },
        area: {
          visible: false
        }
      },
      selectedBackgroundChartStyle: isNeedPreview ? {
        line: mergeSpec(transformToGraphic(null === (_k = selectedBackgroundChart.line) || void 0 === _k ? void 0 : _k.style), {
          fill: false
        }),
        area: Object.assign({
          curveType: "basis",
          visible: true
        }, transformToGraphic(null === (_l = selectedBackgroundChart.area) || void 0 === _l ? void 0 : _l.style))
      } : {
        line: {
          visible: false
        },
        area: {
          visible: false
        }
      },
      disableTriggerEvent: this._option.disableTriggerEvent
    };
  }
  _getHandlerTextFormatMethod(spec) {
    const { formatMethod, formatter } = spec, { formatFunc } = getFormatFunction(formatMethod, formatter);
    return formatFunc ? (text2) => formatFunc(text2, {
      label: text2
    }, formatter) : void 0;
  }
  _getNeedClearVRenderComponents() {
    return [this._component];
  }
  clear() {
    if (this._component) {
      const container2 = this.getContainer();
      this._component.removeAllChild(), container2 && container2.removeChild(this._component), this._component = null;
    }
    super.clear();
  }
};
DataZoom2.type = ComponentTypeEnum.dataZoom, DataZoom2.transformerConstructor = DataZoomSpecTransformer, DataZoom2.specKey = "dataZoom";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/custom-mark/custom-mark
var CustomMark = class extends BaseComponent {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.customMark, this.specKey = "customMark", this.layoutType = "none", this.layoutZIndex = LayoutZIndex.CustomMark, this.layoutLevel = LayoutLevel.CustomMark;
  }
  static getSpecInfo(chartSpec) {
    const spec = chartSpec[this.specKey];
    return spec ? isArray_default(spec) ? spec.map((specItem, i) => ({
      spec: specItem,
      specPath: [this.specKey, i],
      specInfoPath: ["component", this.specKey, i],
      type: ComponentTypeEnum.customMark
    })) : [{
      spec,
      specPath: [this.specKey],
      specInfoPath: ["component", this.specKey, 0],
      type: ComponentTypeEnum.customMark
    }] : null;
  }
  created() {
    super.created(), this.initMarks(), this.initEvent();
  }
  getMarkAttributeContext() {
    return this._markAttributeContext;
  }
  _buildMarkAttributeContext() {
    this._markAttributeContext = {
      vchart: this._option.globalInstance,
      globalScale: (key, value) => {
        var _a;
        return null === (_a = this._option.globalScale.getScale(key)) || void 0 === _a ? void 0 : _a.scale(value);
      }
    };
  }
  initMarks() {
    if (!this._spec)
      return;
    const series2 = this._option && this._option.getAllSeries(), hasAnimation = false !== this._option.animation, depend = [];
    series2 && series2.length && series2.forEach((s2) => {
      const marks = s2 && s2.getMarksWithoutRoot();
      marks && marks.length && marks.forEach((mark) => {
        depend.push(mark);
      });
    }), this._createExtensionMark(this._spec, null, `${PREFIX}_series_${this.id}_extensionMark`, 0, {
      depend,
      hasAnimation
    });
  }
  _createExtensionMark(spec, parentMark, namePrefix, index = 0, options) {
    var _a;
    const mark = this._createMark({
      type: spec.type,
      name: `${namePrefix}_${index}`
    }, {
      skipBeforeLayouted: true,
      attributeContext: this._getMarkAttributeContext(),
      componentType: spec.componentType,
      key: spec.dataKey
    });
    if (mark) {
      if (options.hasAnimation && spec.animation) {
        const config2 = animationConfig({}, userAnimationConfig(spec.type, spec, this._markAttributeContext));
        mark.setAnimationConfig(config2);
      }
      if (options.depend && options.depend.length && mark.setDepend(...options.depend), isNil_default(parentMark) ? this._marks.addMark(mark) : parentMark && parentMark.addMark(mark), this.initMarkStyleWithSpec(mark, spec), "group" === spec.type && (namePrefix = `${namePrefix}_${index}`, null === (_a = spec.children) || void 0 === _a || _a.forEach((s2, i) => {
        this._createExtensionMark(s2, mark, namePrefix, i, options);
      })), isValid_default(spec.dataId) || isValidNumber_default(spec.dataIndex)) {
        const dataview = this.getChart().getSeriesData(spec.dataId, spec.dataIndex);
        dataview && (dataview.target.addListener("change", () => {
          mark.getData().updateData();
        }), mark.setDataView(dataview));
      }
    }
  }
  initEvent() {
  }
  _compareSpec(spec, prevSpec) {
    const result2 = super._compareSpec(spec, prevSpec);
    return isEqual(prevSpec, spec) || (result2.reMake = true), result2.change = true, result2.reRender = true, result2;
  }
  changeRegions(regions) {
  }
  _getNeedClearVRenderComponents() {
    return [];
  }
  onRender(ctx) {
  }
  afterCompile() {
    this.getMarks().forEach((mark) => {
      const product = mark.getProduct();
      product && product.addEventListener(HOOK_EVENT.AFTER_ELEMENT_ENCODE, () => {
        if (false === this._isLayout) {
          const component2 = product.getGroupGraphicItem();
          0 === component2.listenerCount("*") && component2.addEventListener("*", (event, type) => this._delegateEvent(component2, event, type));
        }
      });
    });
  }
  _getMarkAttributeContext() {
    return {
      vchart: this._option.globalInstance,
      chart: this.getChart(),
      globalScale: (key, value) => {
        var _a;
        return null === (_a = this._option.globalScale.getScale(key)) || void 0 === _a ? void 0 : _a.scale(value);
      },
      getLayoutBounds: () => {
        const { x, y } = this.getLayoutStartPoint(), { width, height } = this.getLayoutRect();
        return new Bounds().set(x, y, x + width, y + height);
      }
    };
  }
  _getLayoutRect() {
    const bounds = new Bounds();
    return this.getMarks().forEach((mark) => {
      const product = mark.getProduct();
      product && bounds.union(product.getBounds());
    }), bounds.empty() ? {
      width: 0,
      height: 0
    } : {
      width: bounds.width(),
      height: bounds.height()
    };
  }
  getBoundsInRect(rect) {
    this.setLayoutRect(rect);
    const result2 = this._getLayoutRect(), { x, y } = this.getLayoutStartPoint();
    return {
      x1: x,
      y1: y,
      x2: x + result2.width,
      y2: y + result2.height
    };
  }
};
CustomMark.type = ComponentTypeEnum.customMark, CustomMark.specKey = "customMark";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/brush/brush
var Brush2 = class extends BaseComponent {
  constructor() {
    super(...arguments), this.layoutType = "none", this.type = ComponentTypeEnum.brush, this.name = ComponentTypeEnum.brush, this.specKey = "brush", this.layoutZIndex = LayoutZIndex.Brush, this._linkedSeries = [], this._itemMap = {}, this._linkedItemMap = {}, this._inBrushElementsMap = {}, this._outOfBrushElementsMap = {}, this._linkedInBrushElementsMap = {}, this._linkedOutOfBrushElementsMap = {}, this._needInitOutState = true, this._cacheInteractiveRangeAttrs = [], this._needDisablePickable = false, this._releatedAxes = [], this._regionAxisMap = {}, this._axisDataZoomMap = {}, this._zoomRecord = [];
  }
  init() {
    const inBrushMarkAttr = this._transformBrushedMarkAttr(this._spec.inBrush), outOfBrushMarkAttr = this._transformBrushedMarkAttr(this._spec.outOfBrush);
    this._option.getAllSeries().forEach((s2) => {
      s2.getActiveMarks().forEach((m4) => {
        m4 && (s2.setMarkStyle(m4, Object.assign({}, inBrushMarkAttr), "inBrush", AttributeLevel.Series), s2.setMarkStyle(m4, Object.assign({}, outOfBrushMarkAttr), "outOfBrush", AttributeLevel.Series));
      });
    });
  }
  static getSpecInfo(chartSpec) {
    const brushSpec = chartSpec[this.specKey];
    if (!isNil_default(brushSpec) && false !== brushSpec.visible)
      return [{
        spec: brushSpec,
        specPath: [this.specKey],
        specInfoPath: ["component", this.specKey, 0],
        type: ComponentTypeEnum.brush
      }];
  }
  created() {
    super.created(), this.initEvent(), this._bindRegions(), this._bindLinkedSeries(), this._initRegionAxisMap(), this._initAxisDataZoomMap(), this._initNeedOperatedItem();
  }
  _extendDataInBrush(elementsMap) {
    const data = [];
    for (const brushName in elementsMap)
      for (const elementKey in elementsMap[brushName])
        data.push(Object.assign({}, elementsMap[brushName][elementKey].data[0]));
    return data;
  }
  _extendDatumOutOfBrush(elementsMap) {
    const data = [];
    for (const elementKey in elementsMap)
      data.push(elementsMap[elementKey].data[0]);
    return data;
  }
  _getBrushInteractiveAttr(region) {
    const regionLayoutPosition = region.getLayoutStartPoint(), regionLayoutRect = region.getLayoutRect(), seriesRegionStartX = regionLayoutPosition.x, seriesRegionEndX = seriesRegionStartX + regionLayoutRect.width, seriesRegionStartY = regionLayoutPosition.y, seriesRegionEndY = seriesRegionStartY + regionLayoutRect.height;
    return {
      interactiveRange: {
        minY: seriesRegionStartY,
        maxY: seriesRegionEndY,
        minX: seriesRegionStartX,
        maxX: seriesRegionEndX
      },
      xRange: [seriesRegionStartX, seriesRegionEndX],
      yRange: [seriesRegionStartY, seriesRegionEndY]
    };
  }
  _updateBrushComponent(region, componentIndex) {
    const interactiveAttr = this._getBrushInteractiveAttr(region), brushComponent = this._brushComponents[componentIndex];
    brushComponent.setAttributes(interactiveAttr), this._initMarkBrushState(componentIndex, ""), brushComponent.children[0].removeAllChild(), this._needInitOutState = true;
  }
  _createBrushComponent(region, componentIndex) {
    var _a, _b;
    const interactiveAttr = this._getBrushInteractiveAttr(region), brush2 = new Brush(Object.assign(Object.assign(Object.assign({
      zIndex: this.layoutZIndex,
      brushStyle: transformToGraphic(null === (_a = this._spec) || void 0 === _a ? void 0 : _a.style)
    }, interactiveAttr), this._spec), {
      disableTriggerEvent: this._option.disableTriggerEvent
    }));
    brush2.id = null !== (_b = this._spec.id) && void 0 !== _b ? _b : `brush-${this.id}`, this.getContainer().add(brush2);
    const { brushMode = "single" } = this._spec;
    this._brushComponents.push(brush2), this._cacheInteractiveRangeAttrs.push(interactiveAttr), brush2.addEventListener(IOperateType.drawStart, (e) => {
      this._emitEvent(ChartEvent.brushStart, region);
    }), brush2.addEventListener(IOperateType.moveStart, (e) => {
      this._emitEvent(ChartEvent.brushStart, region);
    }), brush2.addEventListener(IOperateType.drawing, (e) => {
      this._needInitOutState && "single" === brushMode && this._initMarkBrushState(componentIndex, "outOfBrush"), this._needInitOutState = false, this._needDisablePickable = true, this._handleBrushChange(ChartEvent.brushChange, region, e), this._emitEvent(ChartEvent.brushChange, region);
    }), brush2.addEventListener(IOperateType.moving, (e) => {
      this._handleBrushChange(ChartEvent.brushChange, region, e), this._emitEvent(ChartEvent.brushChange, region);
    }), brush2.addEventListener(IOperateType.brushClear, (e) => {
      this._initMarkBrushState(componentIndex, ""), this._needInitOutState = true, this._needDisablePickable = false, this._handleBrushChange(ChartEvent.brushChange, region, e), this._handleBrushChange(ChartEvent.brushClear, region, e), this._emitEvent(ChartEvent.brushChange, region), this._emitEvent(ChartEvent.brushClear, region);
    }), brush2.addEventListener(IOperateType.drawEnd, (e) => {
      this._needInitOutState = true, this._needDisablePickable = false;
      const { operateMask } = e.detail;
      this._handleBrushChange(ChartEvent.brushEnd, region, e), this._setAxisAndDataZoom(operateMask, region), this._emitEvent(ChartEvent.brushEnd, region);
    }), brush2.addEventListener(IOperateType.moveEnd, (e) => {
      const { operateMask } = e.detail;
      this._handleBrushChange(ChartEvent.brushEnd, region, e), this._setAxisAndDataZoom(operateMask, region), this._emitEvent(ChartEvent.brushEnd, region);
    });
  }
  _handleBrushChange(eventType, region, e) {
    const { operateMask } = e.detail;
    this._reconfigItem(operateMask, region), this._reconfigLinkedItem(operateMask, region);
  }
  _emitEvent(eventType, region) {
    this.event.emit(eventType, {
      model: this,
      value: {
        operateType: eventType,
        operateRegion: region,
        inBrushData: this._extendDataInBrush(this._inBrushElementsMap),
        outOfBrushData: this._extendDatumOutOfBrush(this._outOfBrushElementsMap),
        linkInBrushData: this._extendDataInBrush(this._linkedInBrushElementsMap),
        linkOutOfBrushData: this._extendDatumOutOfBrush(this._linkedOutOfBrushElementsMap),
        inBrushElementsMap: this._inBrushElementsMap,
        outOfBrushElementsMap: this._outOfBrushElementsMap,
        linkedInBrushElementsMap: this._linkedInBrushElementsMap,
        linkedOutOfBrushElementsMap: this._linkedOutOfBrushElementsMap,
        zoomRecord: this._zoomRecord
      }
    });
  }
  _transformBrushedMarkAttr(brushedStyle) {
    const styleResult = {};
    return (null == brushedStyle ? void 0 : brushedStyle.symbol) && (styleResult.symbolType = brushedStyle.symbol), (null == brushedStyle ? void 0 : brushedStyle.symbolSize) && (styleResult.size = brushedStyle.symbolSize), (null == brushedStyle ? void 0 : brushedStyle.color) && (styleResult.fill = brushedStyle.color), (null == brushedStyle ? void 0 : brushedStyle.colorAlpha) && (styleResult.fillOpacity = brushedStyle.colorAlpha), Object.assign(Object.assign({}, transformToGraphic(brushedStyle)), styleResult);
  }
  _reconfigItem(operateMask, region) {
    this._itemMap[region.id].forEach((mark) => {
      const grammarMark = mark.getProduct();
      if (!grammarMark || !grammarMark.elements || !grammarMark.elements.length)
        return;
      grammarMark.elements.forEach((el) => {
        var _a, _b, _c;
        const graphicItem = el.getGraphicItem(), elementKey = mark.id + "_" + el.key;
        (null === (_a = this._outOfBrushElementsMap) || void 0 === _a ? void 0 : _a[elementKey]) && this._isBrushContainItem(operateMask, graphicItem) ? (el.addState("inBrush"), this._inBrushElementsMap[null == operateMask ? void 0 : operateMask.name] || (this._inBrushElementsMap[null == operateMask ? void 0 : operateMask.name] = {}), this._inBrushElementsMap[null == operateMask ? void 0 : operateMask.name][elementKey] = el, delete this._outOfBrushElementsMap[elementKey]) : (null === (_c = null === (_b = this._inBrushElementsMap) || void 0 === _b ? void 0 : _b[null == operateMask ? void 0 : operateMask.name]) || void 0 === _c ? void 0 : _c[elementKey]) && !this._isBrushContainItem(operateMask, graphicItem) && (el.removeState("inBrush"), el.addState("outOfBrush"), this._outOfBrushElementsMap[elementKey] = el, delete this._inBrushElementsMap[operateMask.name][elementKey]), graphicItem.setAttribute("pickable", !this._needDisablePickable);
      });
    });
  }
  _reconfigLinkedItem(operateMask, region) {
    const regionLayoutPos = region.getLayoutStartPoint(), seriesId = region.getSeries().map((s2) => s2.id);
    this._linkedSeries.forEach((s2) => {
      if (!seriesId.includes(s2.id)) {
        const sRegionLayoutPos = s2.getRegion().getLayoutStartPoint(), regionOffsetX = sRegionLayoutPos.x - regionLayoutPos.x, regionOffsetY = sRegionLayoutPos.y - regionLayoutPos.y;
        this._linkedItemMap[s2.id].forEach((mark) => {
          const grammarMark = mark.getProduct();
          if (!grammarMark || !grammarMark.elements || !grammarMark.elements.length)
            return;
          grammarMark.elements.forEach((el) => {
            var _a, _b, _c;
            const graphicItem = el.getGraphicItem(), elementKey = mark.id + "_" + el.key;
            (null === (_a = this._linkedOutOfBrushElementsMap) || void 0 === _a ? void 0 : _a[elementKey]) && this._isBrushContainItem(operateMask, graphicItem, {
              dx: regionOffsetX,
              dy: regionOffsetY
            }) ? (el.addState("inBrush"), this._linkedInBrushElementsMap[null == operateMask ? void 0 : operateMask.name] || (this._linkedInBrushElementsMap[null == operateMask ? void 0 : operateMask.name] = {}), this._linkedInBrushElementsMap[null == operateMask ? void 0 : operateMask.name][elementKey] = el, delete this._linkedOutOfBrushElementsMap[elementKey]) : (null === (_c = null === (_b = this._linkedInBrushElementsMap) || void 0 === _b ? void 0 : _b[null == operateMask ? void 0 : operateMask.name]) || void 0 === _c ? void 0 : _c[elementKey]) && !this._isBrushContainItem(operateMask, graphicItem, {
              dx: regionOffsetX,
              dy: regionOffsetY
            }) && (el.removeState("inBrush"), el.addState("outOfBrush"), this._linkedOutOfBrushElementsMap[elementKey] = el), graphicItem.setAttribute("pickable", !this._needDisablePickable);
          });
        });
      }
    });
  }
  _isBrushContainItem(brushMask, item, linkedOffset) {
    var _a, _b, _c;
    if (!(null == brushMask ? void 0 : brushMask.globalTransMatrix) || !(null === (_a = null == brushMask ? void 0 : brushMask.attribute) || void 0 === _a ? void 0 : _a.points))
      return false;
    const points = null !== (_c = null === (_b = null == brushMask ? void 0 : brushMask.attribute) || void 0 === _b ? void 0 : _b.points) && void 0 !== _c ? _c : [], { a: a3, b, c: c3, d, e, f } = brushMask.globalTransMatrix, dx = (null == linkedOffset ? void 0 : linkedOffset.dx) || 0, dy = (null == linkedOffset ? void 0 : linkedOffset.dy) || 0, pointsCoord = points.map((p) => ({
      x: a3 * p.x + c3 * p.y + e + dx,
      y: b * p.x + d * p.y + f + dy
    }));
    brushMask.globalAABBBounds.clone().set(brushMask.globalAABBBounds.x1 + dx, brushMask.globalAABBBounds.y1 + dy, brushMask.globalAABBBounds.x2 + dx, brushMask.globalAABBBounds.y2 + dy);
    const x = item.globalTransMatrix.e, y = item.globalTransMatrix.f;
    let itemBounds = [];
    if ("symbol" === item.type) {
      const { size: itemSize = 0 } = null == item ? void 0 : item.attribute, size = array(itemSize)[0] / 2;
      return itemBounds = [{
        x: x - size,
        y: y - size
      }, {
        x: x + size,
        y: y - size
      }, {
        x: x + size,
        y: y + size
      }, {
        x: x - size,
        y: y + size
      }], polygonIntersectPolygon(pointsCoord, itemBounds);
    }
    if ("rect" === item.type) {
      const { x1: x14, x2: x23, y1: y14, y2: y23 } = null == item ? void 0 : item.AABBBounds, width = Math.abs(x14 - x23), height = Math.abs(y14 - y23);
      return itemBounds = [{
        x,
        y
      }, {
        x: x + width,
        y
      }, {
        x: x + width,
        y: y + height
      }, {
        x,
        y: y + height
      }], polygonIntersectPolygon(pointsCoord, itemBounds);
    }
    return brushMask.globalAABBBounds.intersects(item.globalAABBBounds);
  }
  _stateClamp(state) {
    return Math.min(Math.max(0, state), 1);
  }
  _setAxisAndDataZoom(operateMask, region) {
    var _a;
    if (this._zoomRecord = [], this._spec.zoomAfterBrush) {
      const operateMaskBounds = operateMask.AABBBounds;
      null === (_a = this._regionAxisMap["region_" + region.id]) || void 0 === _a || _a.forEach((axis2) => {
        var _a2, _b;
        const isHorizontal3 = "bottom" === axis2.layoutOrient || "top" === axis2.layoutOrient, axisRangeExpand = null !== (_a2 = this._spec.axisRangeExpand) && void 0 !== _a2 ? _a2 : 0, { x1: x14, x2: x23, y1: y14, y2: y23 } = operateMaskBounds, regionStartAttr = isHorizontal3 ? "x" : "y", boundsStart = isHorizontal3 ? x14 : y14, boundsEnd = isHorizontal3 ? x23 : y23;
        if (this._axisDataZoomMap[axis2.id]) {
          const dataZoom2 = this._axisDataZoomMap[axis2.id], releatedAxis = dataZoom2.relatedAxisComponent, startValue = releatedAxis.getScale().invert(boundsStart - region.getLayoutStartPoint()[regionStartAttr]), endValue = releatedAxis.getScale().invert(boundsEnd - region.getLayoutStartPoint()[regionStartAttr]), startPercent = dataZoom2.dataToStatePoint(startValue), endPercent = dataZoom2.dataToStatePoint(endValue), newStartPercent = this._stateClamp(startPercent - axisRangeExpand), newEndPercent = this._stateClamp(endPercent + axisRangeExpand);
          dataZoom2.setStartAndEnd(newStartPercent, newEndPercent, ["percent", "percent"]), this._zoomRecord.push({
            operateComponent: dataZoom2,
            start: newStartPercent,
            end: newEndPercent
          });
        } else {
          const range2 = axis2.getScale().range(), rangeFactor = null !== (_b = axis2.getScale().rangeFactor()) && void 0 !== _b ? _b : [0, 1], startPos = boundsStart - region.getLayoutStartPoint()[regionStartAttr], endPos = boundsEnd - region.getLayoutStartPoint()[regionStartAttr], start = (startPos - range2[0]) / (range2[1] - range2[0]) * (rangeFactor[1] - rangeFactor[0]) + rangeFactor[0], end = (endPos - range2[0]) / (range2[1] - range2[0]) * (rangeFactor[1] - rangeFactor[0]) + rangeFactor[0], newStart = this._stateClamp(start - axisRangeExpand), newEnd = this._stateClamp(end + axisRangeExpand);
          axis2.getScale().rangeFactor([newStart, newEnd]), axis2.effect.scaleUpdate(), this._zoomRecord.push({
            operateComponent: axis2,
            start: newStart,
            end: newEnd
          });
        }
      });
    }
  }
  _bindRegions() {
    isValid_default(this._spec.regionId) && isValid_default(this._spec.regionIndex) && (this._relativeRegions = this._option.getAllRegions()), this._relativeRegions = this._option.getRegionsInUserIdOrIndex(array(this._spec.regionId), array(this._spec.regionIndex));
  }
  _bindLinkedSeries() {
    isValid_default(this._spec.brushLinkSeriesId) && isValid_default(this._spec.brushLinkSeriesIndex) || (this._linkedSeries = this._option.getSeriesInUserIdOrIndex(array(this._spec.brushLinkSeriesId), array(this._spec.brushLinkSeriesIndex)));
  }
  _initRegionAxisMap() {
    isValid_default(this._spec.axisId) ? array(this._spec.axisId).forEach((axisId) => {
      this._releatedAxes.push(this._option.getComponentByUserId(axisId));
    }) : isValid_default(this._spec.axisIndex) ? array(this._spec.axisIndex).forEach((axisIndex) => {
      this._releatedAxes.push(this._option.getComponentByIndex("axes", axisIndex));
    }) : this._releatedAxes = this._option.getComponentsByKey("axes"), this._releatedAxes.forEach((axis2) => {
      null == axis2 || axis2.getRegions().forEach((region) => {
        this._regionAxisMap["region_" + region.id] ? this._regionAxisMap["region_" + region.id].push(axis2) : this._regionAxisMap["region_" + region.id] = [axis2];
      });
    });
  }
  _initAxisDataZoomMap() {
    this._option.getComponentsByKey("dataZoom").forEach((dz) => {
      dz.relatedAxisComponent && (this._axisDataZoomMap[dz.relatedAxisComponent.id] = dz);
    });
  }
  _initNeedOperatedItem() {
    const seriesUserId = this._spec.seriesId, seriesIndex = this._spec.seriesIndex;
    this._relativeRegions.forEach((r) => {
      const allMarks = [];
      r.getSeries().forEach((s2) => {
        (seriesUserId && array(seriesUserId).includes(s2.userId.toString()) || seriesIndex && array(seriesIndex).includes(s2.getSpecIndex()) || !seriesIndex && !seriesUserId) && allMarks.push(...s2.getMarksWithoutRoot()), this._itemMap[r.id] = allMarks;
      });
    }), this._linkedSeries.forEach((s2) => {
      this._linkedItemMap[s2.id] = s2.getMarksWithoutRoot();
    });
  }
  _initMarkBrushState(componentIndex, stateName) {
    this._brushComponents.forEach((brush2, index) => {
      index !== componentIndex && brush2.children[0].removeAllChild();
    }), this._inBrushElementsMap = {}, this._outOfBrushElementsMap = {}, this._linkedInBrushElementsMap = {}, this._linkedOutOfBrushElementsMap = {}, this._option.getAllSeries().forEach((s2) => {
      s2.getMarksWithoutRoot().forEach((mark) => {
        const grammarMark = mark.getProduct();
        if (!grammarMark || !grammarMark.elements || !grammarMark.elements.length)
          return;
        grammarMark.elements.forEach((el) => {
          const elementKey = mark.id + "_" + el.key;
          el.removeState("inBrush"), el.removeState("outOfBrush"), el.addState(stateName), this._outOfBrushElementsMap[elementKey] = el, this._linkedOutOfBrushElementsMap[elementKey] = el;
        });
      });
    });
  }
  initEvent() {
  }
  onRender(ctx) {
  }
  changeRegions(regions) {
  }
  _getNeedClearVRenderComponents() {
    return this._brushComponents;
  }
  _compareSpec(spec, prevSpec) {
    this._brushComponents && this._relativeRegions.forEach((region, index) => {
      this._updateBrushComponent(region, index);
    });
    const result2 = super._compareSpec(spec, prevSpec);
    return isEqual(prevSpec, spec) || (result2.reRender = true, result2.reMake = true), result2;
  }
  onLayoutEnd(ctx) {
    var _a;
    if (super.onLayoutEnd(ctx), this._option.disableTriggerEvent)
      return;
    (null === (_a = this._spec.visible) || void 0 === _a || _a) && (this._brushComponents ? this._relativeRegions.forEach((region, index) => {
      this._updateBrushComponent(region, index);
    }) : (this._brushComponents = [], this._relativeRegions.forEach((region, index) => {
      this._createBrushComponent(region, index);
    })));
  }
  clearGraphic() {
    this._brushComponents && this._brushComponents.forEach((brush2) => {
      brush2._container.incrementalClearChild();
    });
  }
  clear() {
    if (this._brushComponents) {
      const container2 = this.getContainer();
      this._brushComponents.forEach((brush2) => {
        brush2.removeAllChild(), brush2.releaseBrushEvents(), container2 && container2.removeChild(brush2);
      }), this._brushComponents = null;
    }
  }
};
Brush2.type = ComponentTypeEnum.brush, Brush2.specKey = "brush";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/map-label/layout
function overlap(a3, b, sep = 0) {
  return sep > Math.max(b.x1 - a3.x2, a3.x1 - b.x2, b.y1 - a3.y2, a3.y1 - b.y2);
}
function bound(rect) {
  return {
    x1: rect.x,
    x2: rect.x + rect.width,
    y1: rect.y,
    y2: rect.y + rect.height
  };
}
function toRect2(bound2) {
  return {
    x: bound2.x1,
    y: bound2.y1,
    width: bound2.x2 - bound2.x1,
    height: bound2.y2 - bound2.y1
  };
}
function layoutByPosition(pairs) {
  var _a;
  if (!pairs || 0 === pairs.length)
    return [];
  if (1 === pairs.length)
    return [pairs[0].rect];
  const _pairs = pairs.map((pair2) => {
    var _a2;
    return Object.assign(Object.assign({}, pair2), {
      bound: bound(pair2.rect),
      anchorCandidates: candidatesByOrient(null !== (_a2 = pair2.anchors) && void 0 !== _a2 ? _a2 : [], pair2.point, pair2.rect, pair2.offset)
    });
  }), resultBound = [];
  resultBound.push(_pairs[0].bound);
  for (let i = 1; i <= _pairs.length - 1; i++) {
    const curPair = _pairs[i], curBound = curPair.bound;
    let isOverlap = resultBound.some((r) => overlap(r, curBound));
    if (curPair.anchorCandidates)
      if (isOverlap && (null === (_a = curPair.anchorCandidates) || void 0 === _a ? void 0 : _a.length) > 0) {
        for (let j = 0; j < curPair.anchorCandidates.length; j++) {
          const anchor = curPair.anchorCandidates[j], newBound = {
            x1: anchor.x,
            y1: anchor.y,
            x2: anchor.x + curBound.x2 - curBound.x1,
            y2: anchor.y + curBound.y2 - curBound.y1,
            anchor
          };
          if (!resultBound.some((r) => overlap(r, newBound))) {
            resultBound.push(newBound), isOverlap = false;
            break;
          }
        }
        isOverlap && resultBound.push(curPair.bound);
      } else
        resultBound.push(curPair.bound);
  }
  return resultBound.map((bound2) => toRect2(bound2));
}
function layoutOuter(pairs, features, dataToPosition) {
  const _points = pairs.map((rect) => rect.pointCoord), { x1: x14, x2: x23, y1: y14, y2: y23 } = getAABBFromPoints(_points), centerPosition = dataToPosition([(x14 + x23) / 2, (y14 + y23) / 2]);
  if (!centerPosition)
    return [];
  return layoutByPosition(pairs.map((pair2) => {
    const rect = pair2.rect, targetPoint = isPointWithinFeatures(features, pair2.pointCoord) ? dataToPosition(nearestPoint(features, [pair2.pointCoord.x, pair2.pointCoord.y], uniformDegree(lineDegree(pair2.point, centerPosition)))) : pair2.point;
    targetPoint && (rect.x = targetPoint.x, rect.y = targetPoint.y);
    const degree = uniformDegree(lineDegree(pair2.point, centerPosition));
    let position;
    const anchors = [];
    return degree >= -45 && degree < 45 ? (position = "top", anchors.push("left", "right")) : degree >= 45 && degree < 135 ? position = "right" : degree >= -135 && degree < -45 ? (position = "left", anchors.push("left")) : (position = "bottom", anchors.push("left", "right")), pair2.anchors = anchors, pair2.offset = 20, pair2.rect = placeRectByOrient(pair2.rect, position, 0), pair2;
  }));
}
function uniformDegree(degree) {
  return degree > 180 ? degree - 360 : degree;
}
function lineDegree(start, end) {
  return 180 * Math.atan2(start.y - end.y, start.x - end.x) / Math.PI + 90;
}
function nearestPoint(features, origin, bearing, distance2 = 200) {
  const count = 5621 / distance2;
  let curOrigin = origin;
  for (let i = 1; i <= count; i++) {
    const dest = destination(curOrigin, distance2, bearing);
    if (!isPointWithinFeatures(features, dest))
      return [dest.x, dest.y];
    curOrigin = [dest.x, dest.y];
  }
  return origin;
}
function isPointWithinFeatures(features, p) {
  for (let i = 0; i < features.length; i++) {
    if (isPointInPolygon(p, features[i]))
      return true;
  }
  return false;
}
function placeRectByOrient(rect, position, offset = 0) {
  const result2 = Object.assign({}, rect);
  return "top" === position ? (result2.x -= rect.width / 2, result2.y -= offset + rect.height / 2) : "bottom" === position ? (result2.x -= rect.width / 2, result2.y += offset - rect.height / 2) : "left" === position ? (result2.x -= offset + rect.width, result2.y -= rect.height / 2) : "right" === position && (result2.x += offset, result2.y -= rect.height / 2), result2;
}
function candidatesByOrient(positions, anchor, rect, offset = 0) {
  const candidates = [];
  return positions.forEach((p) => {
    const { x, y } = placeRectByOrient(Object.assign(Object.assign({}, anchor), {
      width: rect.width,
      height: rect.height
    }), p, offset);
    candidates.push({
      x,
      y
    });
  }), candidates;
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/map-label/component
var MapLabelComponent = class extends BaseComponent {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.mapLabel, this.name = ComponentTypeEnum.mapLabel, this.specKey = "mapLabel", this.layoutType = "none", this.layoutZIndex = LayoutZIndex.MarkPoint, this._activeDatum = [];
  }
  static getSpecInfo(chartSpec) {
    const labelSpec = chartSpec[this.specKey];
    return labelSpec && labelSpec.visible && !isValid_default(labelSpec.series) ? [{
      spec: labelSpec,
      specPath: [this.specKey],
      specInfoPath: ["component", this.specKey, 0],
      type: ComponentTypeEnum.mapLabel
    }] : null;
  }
  setAttrFromSpec() {
    var _a, _b, _c, _d;
    this.nameField = null !== (_a = this._spec.nameField) && void 0 !== _a ? _a : null === (_b = this._series) || void 0 === _b ? void 0 : _b.getDimensionField()[0], this.valueField = null !== (_c = this._spec.valueField) && void 0 !== _c ? _c : null === (_d = this._series) || void 0 === _d ? void 0 : _d.getMeasureField()[0];
  }
  created() {
    super.created(), false != !!this._spec.visible && (this.initRelatedInfo(), this.initData(), this.initEvent());
  }
  initRelatedInfo() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    this._series = this._option.getSeriesInUserIdOrIndex([this._spec.seriesId])[0], "outer" === this._spec.position && (this._map = null === (_b = null === (_a = this._regions[0].getSeriesInType("map")[0]) || void 0 === _a ? void 0 : _a.getMapViewData()) || void 0 === _b ? void 0 : _b.latestData, this._longitudeField = null === (_e = null === (_d = (_c = this._regions[0]).getSpec) || void 0 === _d ? void 0 : _d.call(_c)) || void 0 === _e ? void 0 : _e.longitudeField, this._latitudeField = null === (_h = null === (_g = (_f = this._regions[0]).getSpec) || void 0 === _g ? void 0 : _g.call(_f)) || void 0 === _h ? void 0 : _h.latitudeField);
  }
  initData() {
    const series2 = this._series;
    if (!series2)
      return;
    const seriesData = series2.getViewData();
    if (seriesData) {
      const data = new DataView(this._option.dataSet, {
        name: `${this.name}_data`
      });
      data.parse([seriesData], {
        type: "dataview"
      }), data.transform({
        type: "copyDataView",
        level: TransformLevel.copyDataView
      }, false), this._data = new CompilableData(this._option, data), data.target.addListener("change", () => {
        "hover" !== this._spec.trigger && "click" !== this._spec.trigger && (this._activeDatum = this._data.getLatestData());
      });
    }
  }
  initEvent() {
    var _a;
    this.event.on("zoom", {
      filter: (params2) => this._isRelativeModel(params2.model)
    }, (e) => (this.handleZoom(e), true)), this.event.on("panmove", {
      filter: (params2) => this._isRelativeModel(params2.model)
    }, (e) => (this.handlePan(e), true));
    const trigger = this._spec.trigger;
    if ("none" === trigger)
      return;
    const view = null === (_a = this.getCompiler()) || void 0 === _a ? void 0 : _a.getVGrammarView();
    view && ("hover" === trigger ? (view.addEventListener("element-highlight:start", (params2) => {
      this._isRelativeSeries(params2.options.seriesId) && this._updateDatum(params2.elements[0].getDatum());
    }), view.addEventListener("element-highlight:reset", (params2) => {
      this._isRelativeSeries(params2.options.seriesId) && this._updateDatum(null);
    })) : "click" === trigger && (view.addEventListener("element-select:start", (params2) => {
      this._isRelativeSeries(params2.options.seriesId) && this._updateDatum(params2.elements[0].getDatum());
    }), view.addEventListener("elementSelectReset", (params2) => {
      this._isRelativeSeries(params2.options.seriesId) && this._updateDatum([]);
    })));
  }
  handlePan(e) {
    const { delta } = e;
    this._markerComponents.forEach((marker) => {
      marker.translate(delta[0], delta[1]);
    });
  }
  handleZoom(e) {
    this._updateMarkerLayoutAttribute();
  }
  _updateDatum(datum) {
    this._activeDatum = datum, this._markerComponents.forEach((marker, index) => {
      var _a;
      const markerDatum = null === (_a = this._data) || void 0 === _a ? void 0 : _a.getLatestData()[index];
      this._activeDatum.includes(markerDatum) ? marker.setAttribute("visible", true) : marker.setAttribute("visible", false);
    });
  }
  dataToPosition(datum) {
    return this._series.dataToPosition(datum);
  }
  updateLayoutAttribute() {
    var _a;
    const markData = null === (_a = this._data) || void 0 === _a ? void 0 : _a.getLatestData();
    markData && 0 !== markData.length && (super.updateLayoutAttribute(), this._updateMarkerLayoutAttribute());
  }
  _updateMarkerLayoutAttribute() {
    var _a;
    const layoutPairInfo = [], markerMarks = [];
    this._markerComponents || (this._markerComponents = null === (_a = this._data) || void 0 === _a ? void 0 : _a.getLatestData().map((data, index) => {
      var _a2;
      const cmp = new MarkPoint({
        position: void 0,
        animation: false
      });
      return cmp && (cmp.name = `${this.name}_marker_${index}`, cmp.id = null !== (_a2 = this._spec.id) && void 0 !== _a2 ? _a2 : `${this.name}_marker_${this.id}`, cmp.setAttribute("zIndex", this.layoutZIndex)), cmp;
    }));
    this._markerComponents.forEach((marker, index) => {
      marker.removeAllChild();
      const { pairInfo, contentMarks } = this._evaluateMarker(this._data.getLatestData()[index], index);
      pairInfo && layoutPairInfo.push(pairInfo), contentMarks && markerMarks.push(contentMarks);
    });
    const positionedRects = this._layoutLabels(layoutPairInfo);
    this._layoutMarkers(positionedRects, markerMarks), this._renderMarkers();
  }
  _evaluateMarker(data, index) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    let contentItemCount = 0, paddingWidth = 0, paddingHeight = 0, contentWidth = 0, contentHeight = 0;
    const position = this._spec.position || "top", offset = this._spec.offset, padding = normalizeLayoutPaddingSpec(null === (_a = this._spec.background) || void 0 === _a ? void 0 : _a.padding), space = this._spec.space || 0;
    paddingWidth += ((null == padding ? void 0 : padding.left) || 0) + ((null == padding ? void 0 : padding.right) || 0), paddingHeight += ((null == padding ? void 0 : padding.top) || 0) + ((null == padding ? void 0 : padding.bottom) || 0);
    const contentMarks = {}, positionAttr = this.dataToPosition(data), container2 = createGroup({});
    if (container2.name = `${this.name}_marker_itemContainer_${index}`, contentMarks.container = container2, null === (_b = this._spec.background) || void 0 === _b ? void 0 : _b.visible) {
      const labelBackground = createRect(transformToGraphic(Object.assign({}, this._spec.background.style)));
      labelBackground.setAttributes(positionAttr), contentMarks.labelBackground = labelBackground, container2.appendChild(labelBackground);
    }
    if (null === (_c = this._spec.icon) || void 0 === _c ? void 0 : _c.visible) {
      const icon = createSymbol(transformToGraphic(Object.assign({}, this._spec.icon.style)));
      icon.setAttributes(positionAttr), icon.setAttribute("symbolType", null === (_d = this._spec.icon.style) || void 0 === _d ? void 0 : _d.shape);
      const iconBound = icon.AABBBounds, iconHeight = null !== (_e = (null == iconBound ? void 0 : iconBound.y2) - (null == iconBound ? void 0 : iconBound.y1)) && void 0 !== _e ? _e : 0, iconWidth = null !== (_f = (null == iconBound ? void 0 : iconBound.x2) - (null == iconBound ? void 0 : iconBound.x1)) && void 0 !== _f ? _f : 0;
      contentMarks.icon = icon, container2.appendChild(icon), contentHeight = iconHeight, contentWidth += iconWidth, contentItemCount++;
    }
    if (null === (_g = this._spec.nameLabel) || void 0 === _g ? void 0 : _g.visible) {
      const nameLabel = createText(transformToGraphic(Object.assign({}, this._spec.nameLabel.style)));
      nameLabel.setAttributes(positionAttr), nameLabel.setAttribute("text", data[this.nameField]);
      const nameLabelBound = nameLabel.AABBBounds, nameLabelHeight = null !== (_h = (null == nameLabelBound ? void 0 : nameLabelBound.y2) - (null == nameLabelBound ? void 0 : nameLabelBound.y1)) && void 0 !== _h ? _h : 0, nameLabelWidth = null !== (_j = (null == nameLabelBound ? void 0 : nameLabelBound.x2) - (null == nameLabelBound ? void 0 : nameLabelBound.x1)) && void 0 !== _j ? _j : 0;
      contentMarks.nameLabel = nameLabel, container2.appendChild(nameLabel), contentHeight = Math.max(contentHeight, nameLabelHeight), contentWidth += nameLabelWidth, contentItemCount++;
    }
    if ((null === (_k = this._spec.valueLabel) || void 0 === _k ? void 0 : _k.visible) && isValid_default(data[this.valueField])) {
      const valueLabel = createText(transformToGraphic(Object.assign({}, this._spec.valueLabel.style)));
      valueLabel.setAttributes(positionAttr), valueLabel.setAttribute("text", data[this.valueField]);
      const valueLabelBound = valueLabel.AABBBounds, valueLabelHeight = null !== (_l = (null == valueLabelBound ? void 0 : valueLabelBound.y2) - (null == valueLabelBound ? void 0 : valueLabelBound.y1)) && void 0 !== _l ? _l : 0, valueLabelWidth = null !== (_m = (null == valueLabelBound ? void 0 : valueLabelBound.x2) - (null == valueLabelBound ? void 0 : valueLabelBound.x1)) && void 0 !== _m ? _m : 0;
      contentMarks.valueLabel = valueLabel, container2.appendChild(valueLabel), contentHeight = Math.max(contentHeight, valueLabelHeight), contentWidth += valueLabelWidth, contentItemCount++;
    }
    const firstValidMark = Object.values(contentMarks).find((m4) => !!m4 && "group" !== m4.type), anchor = {
      x: null == firstValidMark ? void 0 : firstValidMark.getComputedAttribute("x"),
      y: null == firstValidMark ? void 0 : firstValidMark.getComputedAttribute("y")
    }, itemRect = {
      x: anchor.x,
      y: anchor.y,
      width: 0,
      height: 0
    };
    itemRect.width = paddingWidth + contentWidth + (contentItemCount - 1) * space, itemRect.height = paddingHeight + contentHeight;
    const pairInfo = {
      rect: itemRect,
      point: anchor,
      index
    };
    if ("outer" !== position) {
      const anchors = ["top", "right", "left", "bottom"].filter((a3) => a3 !== position);
      pairInfo.rect = placeRectByOrient(itemRect, position, offset), pairInfo.anchors = anchors, pairInfo.offset = offset;
    } else
      pairInfo.pointCoord = {
        x: +(null == data ? void 0 : data[this._longitudeField]),
        y: +(null == data ? void 0 : data[this._latitudeField])
      };
    return {
      pairInfo,
      contentMarks
    };
  }
  _layoutMarkers(positionedRects, contentMarks) {
    var _a, _b, _c;
    for (let i = 0; i < contentMarks.length; i++) {
      if (!positionedRects[i] || !contentMarks[i])
        return;
      const { icon, nameLabel, valueLabel, labelBackground, container: container2 } = contentMarks[i], itemRect = positionedRects[i], padding = normalizeLayoutPaddingSpec(null === (_a = this._spec.background) || void 0 === _a ? void 0 : _a.padding), space = this._spec.space || 0, curY = itemRect.height / 2;
      let curX = (null == padding ? void 0 : padding.left) || 0;
      [icon, nameLabel, valueLabel].forEach((item, index) => {
        var _a2, _b2;
        if (item) {
          const bounds = item.AABBBounds;
          let offset = 0;
          "symbol" === item.type && (offset += (null !== (_a2 = bounds.x2 - bounds.x1) && void 0 !== _a2 ? _a2 : 0) / 2), item.setAttributes({
            x: curX + offset,
            y: curY
          }), curX += null !== (_b2 = bounds.x2 - bounds.x1) && void 0 !== _b2 ? _b2 : 0, 2 !== index && (curX += space);
        }
      }), null == labelBackground || labelBackground.setAttributes({
        x: 0,
        y: 0,
        width: itemRect.width,
        height: itemRect.height
      }), null == container2 || container2.setAttributes({
        dx: -itemRect.width / 2,
        dy: -itemRect.height / 2
      });
      const datum = this._data.getLatestData()[i], anchor = this.dataToPosition(datum), regionPos = this.getRegions()[0].getLayoutStartPoint(), showLeader = !(!(null === (_b = this._spec.leader) || void 0 === _b ? void 0 : _b.visible) || !(icon || nameLabel || valueLabel));
      this._markerComponents[i].setAttributes({
        x: regionPos.x,
        y: regionPos.y,
        position: anchor,
        visible: this._activeDatum.includes(datum),
        itemContent: {
          refX: 0,
          type: "custom",
          renderCustomCallback: () => container2,
          autoRotate: false,
          offsetX: itemRect.x + itemRect.width / 2 - anchor.x,
          offsetY: itemRect.y + itemRect.height / 2 - anchor.y
        },
        itemLine: {
          visible: showLeader,
          type: "type-po",
          lineStyle: transformToGraphic(Object.assign({}, null === (_c = this._spec.leader) || void 0 === _c ? void 0 : _c.style)),
          startSymbol: {
            visible: false
          }
        }
      });
    }
  }
  _renderMarkers() {
    if (this._markerComponents && this._markerComponents.length)
      for (let i = 0; i < this._markerComponents.length; i++)
        this.getContainer().add(this._markerComponents[i]);
  }
  _layoutLabels(rects) {
    return "outer" === this._spec.position && this._map ? layoutOuter(rects, this._map, (coord) => this._series.dataToPosition({
      [this._longitudeField]: coord[0],
      [this._latitudeField]: coord[1]
    })) : layoutByPosition(rects);
  }
  _isRelativeModel(model) {
    var _a, _b, _c;
    const id2 = null !== (_b = null === (_a = this._series.getXAxisHelper()) || void 0 === _a ? void 0 : _a.getAxisId()) && void 0 !== _b ? _b : null === (_c = this._series.getCoordinateHelper()) || void 0 === _c ? void 0 : _c.getCoordinateId();
    return (null == model ? void 0 : model.id) === id2;
  }
  _isRelativeSeries(model) {
    return (null == model ? void 0 : model.id) === this._series.id;
  }
  onRender(ctx) {
  }
  changeRegions() {
  }
  _getNeedClearVRenderComponents() {
    return this._markerComponents;
  }
};
MapLabelComponent.type = ComponentTypeEnum.mapLabel, MapLabelComponent.specKey = "mapLabel";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/legend/util
function transformLegendTitleAttributes(title3) {
  var _a, _b;
  const transformedTitle = Object.assign({}, title3);
  return isEmpty_default(title3.style) || (transformedTitle.textStyle = transformToGraphic(title3.style)), isEmpty_default(title3.textStyle) || mergeSpec(transformedTitle.textStyle, transformToGraphic(title3.textStyle)), (null === (_a = title3.shape) || void 0 === _a ? void 0 : _a.style) && transformToGraphic(transformedTitle.shape.style), (null === (_b = title3.background) || void 0 === _b ? void 0 : _b.style) && transformToGraphic(transformedTitle.background.style), transformedTitle;
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/legend/discrete/util
var __rest16 = function(s2, e) {
  var t = {};
  for (var p in s2)
    Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++)
      e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
function getLegendAttributes(spec, rect) {
  const { title: title3 = {}, item = {}, pager = {}, background = {}, type, id: id2, visible, orient, position, data, filter: filter2, regionId, regionIndex, seriesIndex, seriesId, padding } = spec, attrs = __rest16(spec, ["title", "item", "pager", "background", "type", "id", "visible", "orient", "position", "data", "filter", "regionId", "regionIndex", "seriesIndex", "seriesId", "padding"]);
  return title3.visible && (attrs.title = transformLegendTitleAttributes(title3)), isEmpty_default(item.focusIconStyle) || transformToGraphic(item.focusIconStyle), item.shape && (item.shape = transformComponentStyle(item.shape)), item.label && (item.label = transformComponentStyle(item.label)), item.value && (item.value = transformComponentStyle(item.value)), item.background && (item.background = transformComponentStyle(item.background)), isPercent(item.maxWidth) && (item.maxWidth = Number(item.maxWidth.substring(0, item.maxWidth.length - 1)) * rect.width / 100), isPercent(item.width) && (item.width = Number(item.width.substring(0, item.width.length - 1)) * rect.width / 100), isPercent(item.height) && (item.height = Number(item.height.substring(0, item.height.length - 1)) * rect.width / 100), attrs.item = item, "scrollbar" === pager.type ? (isEmpty_default(pager.railStyle) || transformToGraphic(pager.railStyle), isEmpty_default(pager.sliderStyle) || transformToGraphic(pager.sliderStyle)) : (isEmpty_default(pager.textStyle) || transformToGraphic(pager.textStyle), pager.handler && transformComponentStyle(pager.handler)), attrs.pager = pager, background.visible && !isEmpty_default(background.style) && (mergeSpec(attrs, background.style), isValid_default(background.padding) && (attrs.padding = background.padding)), attrs;
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/data/transforms/legend-data/discrete/discrete
var discreteLegendDataMake = (data, op) => {
  const result2 = [], tempKey = {}, { series: series2, seriesField } = op;
  return series2().forEach((s2) => {
    const field3 = seriesField(s2);
    let infoList;
    infoList = field3 === s2.getSeriesField() ? s2.getSeriesInfoList() : s2.getSeriesInfoInField(field3), infoList.forEach((info) => {
      tempKey[info.key] || (tempKey[info.key] = true, result2.push(info));
    });
  }), result2;
};
var discreteLegendFilter = (data, op) => {
  var _a, _b, _c;
  const { series: series2, selected, field: field3, data: legendData } = op, selectedData = selected(), legendKeys = legendData();
  if (0 === selectedData.length && legendKeys.length)
    return [];
  if (selectedData.length === legendKeys.length)
    return data;
  const selectedFilter = {};
  selectedData.forEach((s2) => {
    selectedFilter[s2] = true;
  });
  const datumField = null !== (_a = field3()) && void 0 !== _a ? _a : DEFAULT_DATA_SERIES_FIELD;
  return isArray_default(data) && (null === (_b = data[0]) || void 0 === _b ? void 0 : _b.nodes) ? (data[0].nodes = data[0].nodes.filter((d) => true === selectedFilter[d.key]), (null === (_c = data[0]) || void 0 === _c ? void 0 : _c.links) && (data[0].links = data[0].links.filter((d) => true === selectedFilter[d.source] && true === selectedFilter[d.target]))) : isValid_default(datumField) && (data = data.filter((d) => true === selectedFilter[series2.getSeriesFieldValue(d, datumField)])), data;
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/legend/base-legend
var BaseLegend = class extends BaseComponent {
  constructor() {
    super(...arguments), this.layoutType = "normal", this.layoutZIndex = LayoutZIndex.Legend, this.layoutLevel = LayoutLevel.Legend, this.specKey = "legends", this._orient = "left", this._visible = true, this._position = "middle", this._preSelectedData = [], this._selectedData = [], this.effect = {
      onSelectedDataChange: () => {
        eachSeries(this._regions, (s2) => {
          var _a;
          null === (_a = s2.getViewData()) || void 0 === _a || _a.markRunning();
        }, {
          userId: this._seriesUserId,
          specIndex: this._seriesIndex
        }), eachSeries(this._regions, (s2) => {
          s2.reFilterViewData();
        }, {
          userId: this._seriesUserId,
          specIndex: this._seriesIndex
        });
      }
    };
  }
  get orient() {
    return this._orient;
  }
  get visible() {
    return this._visible;
  }
  get position() {
    return this._position;
  }
  getLegendData() {
    return this._legendData.getLatestData();
  }
  getSelectedData() {
    return this._selectedData;
  }
  setAttrFromSpec() {
    var _a;
    super.setAttrFromSpec(), this._orient = isValidOrient(this._spec.orient) ? this._spec.orient : "left", this._position = null !== (_a = this._spec.position) && void 0 !== _a ? _a : "middle", this._visible = false !== this._spec.visible;
    const { regionId, regionIndex, seriesId, seriesIndex } = this._spec;
    isValid_default(seriesId) && (this._seriesUserId = array(seriesId)), isValid_default(regionId) && (this._regionUserId = array(regionId)), isValid_default(seriesIndex) && (this._seriesIndex = array(seriesIndex)), isValid_default(regionIndex) && (this._regionUserIndex = array(regionIndex)), this._regions = this._option.getRegionsInUserIdOrIndex(this._regionUserId, this._regionUserIndex);
  }
  created() {
    super.created(), this.initData();
  }
  onRender(ctx) {
  }
  _compareSpec(spec, prevSpec) {
    const result2 = super._compareSpec(spec, prevSpec);
    return result2.reRender = true, (null == spec ? void 0 : spec.orient) !== (null == prevSpec ? void 0 : prevSpec.orient) ? (result2.reMake = true, result2) : (isEqual(prevSpec, spec) || (result2.reCompile = true), result2);
  }
  changeRegions(regions) {
  }
  _bindLegendDataChange() {
    this._preSelectedData = this._selectedData.slice(), this._initSelectedData();
  }
  initData() {
    const legendData = this._initLegendData();
    legendData.target.addListener("change", this._bindLegendDataChange.bind(this)), this._legendData = new CompilableData(this._option, legendData), this._initSelectedData(), eachSeries(this._regions, (s2) => {
      s2.event.on(ChartEvent.rawDataUpdate, {
        filter: ({ model }) => (null == model ? void 0 : model.id) === s2.id
      }, () => {
        this._legendData.getDataView().reRunAllTransform();
      });
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    });
  }
  setSelectedData(selectedData) {
    var _a, _b, _c;
    const lastData = this._selectedData;
    isNil_default(selectedData) || JSON.stringify(lastData) === JSON.stringify(selectedData) || (eachSeries(this._regions, (s2) => {
      s2.legendSelectedFilter && (selectedData = s2.legendSelectedFilter(this, selectedData));
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    }), this._selectedData = [...selectedData], null === (_b = (_a = this.effect).onSelectedDataChange) || void 0 === _b || _b.call(_a), this.event.emit(ChartEvent.legendSelectedDataChange, {
      model: this
    }), null === (_c = this._legendComponent) || void 0 === _c || _c.setSelected(this._selectedData));
  }
  afterSetLayoutStartPoint(pos) {
    if (super.afterSetLayoutStartPoint(pos), this._legendComponent) {
      const { x, y } = pos;
      isValidNumber_default(x * y) && this._legendComponent.setAttributes({
        x,
        y
      });
    }
  }
  getBoundsInRect(rect, fullSpace) {
    if (!this._visible)
      return {
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0
      };
    const result2 = {
      x1: this.getLayoutStartPoint().x,
      y1: this.getLayoutStartPoint().y,
      x2: 0,
      y2: 0
    }, attrs = this._getLegendAttributes(rect);
    if (attrs.disableTriggerEvent = this._option.disableTriggerEvent, this._legendComponent)
      isEqual(attrs, this._cacheAttrs) || this._legendComponent.setAttributes(mergeSpec({}, attrs, {
        defaultSelected: this._selectedData
      }));
    else {
      const legend = new (this._getLegendConstructor())(mergeSpec({}, attrs, {
        defaultSelected: this._selectedData
      }));
      legend.name = "legend", this._legendComponent = legend;
      this.getContainer().add(legend), this._option.disableTriggerEvent || this._initEvent(), legend.on("*", (event, type) => this._delegateEvent(this._legendComponent, event, type));
    }
    this._cacheAttrs = attrs;
    const width = isFinite(this._legendComponent.AABBBounds.width()) ? this._legendComponent.AABBBounds.width() : 0, height = isFinite(this._legendComponent.AABBBounds.height()) ? this._legendComponent.AABBBounds.height() : 0;
    if ("normal-inline" !== this.layoutType) {
      const layout = "bottom" === this.layoutOrient || "top" === this.layoutOrient ? "horizontal" : "vertical", position = this._position, { width: rectWidth, height: rectHeight } = fullSpace;
      let offsetX = 0, offsetY = 0;
      "horizontal" === layout ? "middle" === position ? offsetX = (rectWidth - width) / 2 : "end" === position && (offsetX = rectWidth - width) : "middle" === position ? offsetY = (rectHeight - height) / 2 : "end" === position && (offsetY = rectHeight - height), this._legendComponent.setAttributes({
        dx: offsetX,
        dy: offsetY
      });
    }
    return result2.x2 = result2.x1 + width, result2.y2 = result2.y1 + height, result2;
  }
  onDataUpdate() {
    var _a, _b, _c;
    if (JSON.stringify(this._preSelectedData) !== JSON.stringify(this._selectedData)) {
      if (this._legendComponent) {
        const attrs = this._getLegendAttributes(this.getLayoutRect());
        isEqual(attrs, this._cacheAttrs) || this._legendComponent.setAttributes(mergeSpec({}, attrs, {
          defaultSelected: this._selectedData
        }));
      }
      null === (_b = (_a = this.effect).onSelectedDataChange) || void 0 === _b || _b.call(_a), null === (_c = this.getChart()) || void 0 === _c || _c.setLayoutTag(true, null, false), this.event.emit(ChartEvent.legendSelectedDataChange, {
        model: this
      });
    }
  }
  _getNeedClearVRenderComponents() {
    return [this._legendComponent];
  }
  clear() {
    super.clear(), this._cacheAttrs = null, this._preSelectedData = null;
  }
};
BaseLegend.specKey = "legends";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/legend/discrete/legend
var DiscreteLegend2 = class extends BaseLegend {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.discreteLegend, this.name = ComponentTypeEnum.discreteLegend;
  }
  static getSpecInfo(chartSpec) {
    const legendSpec = chartSpec[this.specKey];
    if (!legendSpec)
      return;
    if (!isArray_default(legendSpec))
      return legendSpec.type && "discrete" !== legendSpec.type ? void 0 : [{
        spec: legendSpec,
        specPath: [this.specKey],
        specInfoPath: ["component", this.specKey, 0],
        type: ComponentTypeEnum.discreteLegend
      }];
    const specInfos = [];
    return legendSpec.forEach((s2, i) => {
      s2.type && "discrete" !== s2.type || specInfos.push({
        spec: s2,
        specPath: [this.specKey, i],
        specInfoPath: ["component", this.specKey, i],
        type: ComponentTypeEnum.discreteLegend
      });
    }), specInfos;
  }
  init(option) {
    super.init(option), eachSeries(this._regions, (s2) => {
      s2.addViewDataFilter({
        type: "discreteLegendFilter",
        options: {
          series: s2,
          selected: () => this._selectedData,
          field: () => this._getSeriesLegendField(s2),
          data: () => this.getLegendDefaultData()
        },
        level: TransformLevel.legendFilter
      });
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    });
  }
  _initLegendData() {
    registerDataSetInstanceTransform(this._option.dataSet, "discreteLegendFilter", discreteLegendFilter), registerDataSetInstanceTransform(this._option.dataSet, "discreteLegendDataMake", discreteLegendDataMake);
    const legendData = new DataView(this._option.dataSet, {
      name: `${this.type}_${this.id}_data`
    });
    return legendData.transform({
      type: "discreteLegendDataMake",
      options: {
        series: () => {
          const result2 = [];
          return eachSeries(this._regions, (s2) => {
            result2.push(s2);
          }, {
            specIndex: this._spec.seriesIndex,
            userId: this._spec.seriesId
          }), result2;
        },
        seriesField: (s2) => this._getSeriesLegendField(s2)
      }
    }), legendData;
  }
  _getSeriesLegendField(s2) {
    var _a, _b, _c;
    const defaultField = s2.getSeriesField(), specifyScaleId = null !== (_a = this._spec.scaleName) && void 0 !== _a ? _a : this._spec.scale;
    if (isNil_default(specifyScaleId))
      return defaultField;
    if (!s2.getRawData())
      return defaultField;
    const scaleSpec = this._option.globalScale.getScaleSpec(specifyScaleId);
    if (!scaleSpec)
      return defaultField;
    if (this._spec.field)
      return this._spec.field;
    if (!isDataDomainSpec(scaleSpec.domain))
      return defaultField;
    const seriesData = scaleSpec.domain.find((d) => d.dataId === s2.getRawData().name);
    return seriesData && null !== (_c = null === (_b = seriesData.fields) || void 0 === _b ? void 0 : _b[0]) && void 0 !== _c ? _c : defaultField;
  }
  _initSelectedData() {
    const fullSelectedData = this.getLegendDefaultData();
    if (this._unselectedData) {
      const selected = [], unselected = [];
      fullSelectedData.forEach((entry) => {
        this._unselectedData.includes(entry) ? unselected.push(entry) : selected.push(entry);
      }), this._selectedData = selected, this._unselectedData = unselected;
    } else
      this._spec.defaultSelected ? this._selectedData = [...this._spec.defaultSelected] : this._selectedData = fullSelectedData;
  }
  getLegendDefaultData(originalData) {
    return isFunction_default(this._spec.data) ? this._getLegendItems().map((obj) => obj.label) : this._legendData.getLatestData().map(originalData ? (obj) => obj.originalKey : (obj) => obj.key);
  }
  _addDefaultTitleText(attrs) {
    var _a, _b, _c, _d;
    if ((null === (_a = attrs.title) || void 0 === _a ? void 0 : _a.visible) && isNil_default(attrs.title.text) && isNil_default(null === (_b = attrs.title.style) || void 0 === _b ? void 0 : _b.text)) {
      const series2 = null === (_d = null === (_c = this._regions) || void 0 === _c ? void 0 : _c[0]) || void 0 === _d ? void 0 : _d.getSeries()[0];
      if (!series2)
        return;
      attrs.title.text = getFieldAlias(series2.getRawData(), series2.getSeriesField());
    }
  }
  _getLegendAttributes(rect) {
    const layout = "bottom" === this.layoutOrient || "top" === this.layoutOrient ? "horizontal" : "vertical", attrs = Object.assign(Object.assign({
      layout,
      items: this._getLegendItems(),
      zIndex: this.layoutZIndex
    }, getLegendAttributes(this._spec, rect)), {
      maxWidth: rect.width,
      maxHeight: rect.height
    });
    return this._addDefaultTitleText(attrs), this._addLegendItemFormatMethods(attrs), attrs;
  }
  _getLegendConstructor() {
    return DiscreteLegend;
  }
  setSelectedData(selectedData) {
    selectedData && (this._unselectedData = this.getLegendDefaultData().filter((entry) => !selectedData.includes(entry))), super.setSelectedData(selectedData);
  }
  _initEvent() {
    if (this._legendComponent) {
      const doFilter = false !== this._spec.filter;
      this._legendComponent.addEventListener(LegendEvent.legendItemClick, (e) => {
        const selectedData = get_default(e, "detail.currentSelected");
        doFilter && this.setSelectedData(selectedData), this.event.emit(ChartEvent.legendItemClick, {
          model: this,
          value: selectedData,
          event: e
        });
      }), this._legendComponent.addEventListener(LegendEvent.legendItemHover, (e) => {
        const detail = get_default(e, "detail");
        this.event.emit(ChartEvent.legendItemHover, {
          model: this,
          value: detail,
          event: e
        });
      }), this._legendComponent.addEventListener(LegendEvent.legendItemUnHover, (e) => {
        const detail = get_default(e, "detail");
        this.event.emit(ChartEvent.legendItemUnHover, {
          model: this,
          value: detail,
          event: e
        });
      });
    }
  }
  _getLegendItems() {
    const originData = (this._legendData.getLatestData() || []).map((datum) => {
      var _a, _b;
      const fillOpacity = datum.style("fillOpacity"), strokeOpacity = datum.style("strokeOpacity"), opacity = datum.style("opacity"), texture = datum.style("texture");
      return {
        label: datum.key,
        shape: {
          symbolType: null !== (_b = null !== (_a = datum.style("symbolType")) && void 0 !== _a ? _a : datum.shapeType) && void 0 !== _b ? _b : "circle",
          fillOpacity: isValidNumber_default(fillOpacity) ? fillOpacity : 1,
          strokeOpacity: isValidNumber_default(strokeOpacity) ? strokeOpacity : 1,
          opacity: isValidNumber_default(opacity) ? opacity : 1,
          texturePadding: texture ? 1 : null,
          textureSize: texture ? 4 : null,
          texture,
          fill: datum.style("fill"),
          stroke: datum.style("stroke"),
          textureColor: datum.style("textureColor"),
          innerBorder: datum.style("innerBorder"),
          outerBorder: datum.style("outerBorder"),
          lineDash: datum.style("lineDash"),
          lineDashOffset: datum.style("lineDashOffset"),
          lineWidth: datum.style("lineWidth")
        }
      };
    });
    return isFunction_default(this._spec.data) ? this._spec.data(originData, this._option.globalScale.getScale("color"), this._option.globalScale) : originData;
  }
  _addLegendItemFormatMethods(attrs) {
    var _a, _b, _c, _d;
    const { formatMethod: labelFormatMethod, formatter: labelFormatter } = null !== (_b = null === (_a = this._spec.item) || void 0 === _a ? void 0 : _a.label) && void 0 !== _b ? _b : {}, { formatMethod: valueFormatMethod, formatter: valueFormatter } = null !== (_d = null === (_c = this._spec.item) || void 0 === _c ? void 0 : _c.value) && void 0 !== _d ? _d : {}, { formatFunc: labelFormatFunc } = getFormatFunction(labelFormatMethod, labelFormatter);
    labelFormatter && !labelFormatMethod && labelFormatFunc && (attrs.item.label.formatMethod = (value, datum) => labelFormatFunc(value, datum, labelFormatter));
    const { formatFunc: valueFormatFunc } = getFormatFunction(valueFormatMethod, valueFormatter);
    valueFormatter && !valueFormatMethod && valueFormatFunc && (attrs.item.value.formatMethod = (value, datum) => valueFormatFunc(valueFormatter, value, datum, labelFormatter));
  }
};
DiscreteLegend2.specKey = "legends", DiscreteLegend2.type = ComponentTypeEnum.discreteLegend;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/data/transforms/legend-data/continuous/continuous
var continuousLegendDataMake = (data, op) => {
  const { series: series2, field: field3, scale: scale4 } = op, datumField = field3();
  if (field3 && datumField) {
    let min3 = 1 / 0, max3 = -1 / 0;
    return series2().forEach((s2) => {
      const statisticData = s2.getRawDataStatisticsByField(datumField, true), seriesMin = null == statisticData ? void 0 : statisticData.min, seriesMax = null == statisticData ? void 0 : statisticData.max;
      isValidNumber_default(seriesMin) && (min3 = Math.min(seriesMin, min3)), isValidNumber_default(seriesMax) && (max3 = Math.max(seriesMax, max3));
    }), [min3, max3];
  }
  if (scale4) {
    const _scale = scale4();
    return _scale ? _scale.domain() : [];
  }
  return [];
};
var continuousLegendFilter = (data, op) => {
  const { selected, field: field3, data: legendData, isHierarchyData } = op, selectedRange = selected(), datumField = field3(), isHierarchy = isHierarchyData || ((data2) => data2 && data2.some((d) => d && isHierarchyItem(d)));
  if (selectedRange === legendData())
    return data;
  if (datumField && !isEmpty_default(selectedRange)) {
    const [min3, max3] = selectedRange;
    return isHierarchy(data) ? filterHierarchyDataByRange(data, +min3, +max3) : data.filter((datum) => datum[datumField] >= min3 && datum[datumField] <= max3);
  }
  return data;
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/legend/continuous/util
var __rest17 = function(s2, e) {
  var t = {};
  for (var p in s2)
    Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++)
      e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
function getContinuousLegendAttributes(spec) {
  const _a = mergeSpec({}, spec), { title: title3 = {}, handler = {}, rail = {}, track = {}, startText, endText, handlerText, sizeBackground, background = {}, type, id: id2, visible, orient, position, data, defaultSelected, field: field3, filter: filter2, regionId, regionIndex, seriesIndex, seriesId, padding } = _a, attrs = __rest17(_a, ["title", "handler", "rail", "track", "startText", "endText", "handlerText", "sizeBackground", "background", "type", "id", "visible", "orient", "position", "data", "defaultSelected", "field", "filter", "regionId", "regionIndex", "seriesIndex", "seriesId", "padding"]);
  return title3.visible && (attrs.title = transformLegendTitleAttributes(title3)), attrs.showHandler = false !== handler.visible, isEmpty_default(handler.style) || (attrs.handlerStyle = transformToGraphic(handler.style)), isValid_default(rail.width) && (attrs.railWidth = rail.width), isValid_default(rail.height) && (attrs.railHeight = rail.height), isEmpty_default(rail.style) || (attrs.railStyle = transformToGraphic(rail.style)), isEmpty_default(track.style) || (attrs.trackStyle = transformToGraphic(track.style)), attrs.startText = transformComponentStyle(startText), attrs.endText = transformComponentStyle(endText), attrs.handlerText = transformComponentStyle(handlerText), isEmpty_default(sizeBackground) || (attrs.sizeBackground = transformToGraphic(sizeBackground)), background.visible && !isEmpty_default(background.style) && (mergeSpec(attrs, background.style), isValid_default(background.padding) && (attrs.padding = background.padding)), attrs;
}
function isContinuousLegend(type) {
  return "color" === type || "size" === type;
}
var ContinuousLegendMap = {
  color: ColorContinuousLegend,
  size: SizeContinuousLegend
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/legend/continuous/legend
var SINGLE_SEQUENCE = ["#C4E7FF", "#98CAFF", "#75ACFF", "#518FF9", "#2775DC", "#005CBE", "#00429F", "#00287E"];
var SIZE = [2, 10];
var ContinuousLegend = class extends BaseLegend {
  static getSpecInfo(chartSpec) {
    const legendSpec = chartSpec[this.specKey];
    if (!legendSpec)
      return;
    if (!isArray_default(legendSpec))
      return isContinuousLegend(legendSpec.type) ? [{
        spec: legendSpec,
        specPath: [this.specKey],
        specInfoPath: ["component", this.specKey, 0],
        type: "color" === legendSpec.type ? ComponentTypeEnum.colorLegend : ComponentTypeEnum.sizeLegend
      }] : void 0;
    const specInfos = [];
    return legendSpec.forEach((s2, i) => {
      isContinuousLegend(s2.type) && specInfos.push({
        spec: s2,
        specPath: [this.specKey, i],
        specInfoPath: ["component", this.specKey, i],
        type: "color" === s2.type ? ComponentTypeEnum.colorLegend : ComponentTypeEnum.sizeLegend
      });
    }), specInfos;
  }
  constructor(spec, options) {
    super(spec, options), this.type = ComponentTypeEnum.colorLegend, this.name = ComponentTypeEnum.colorLegend;
    const legendName = "color" === this._spec.type ? ComponentTypeEnum.colorLegend : ComponentTypeEnum.sizeLegend;
    this.type = legendName, this.name = legendName;
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this._field = this._spec.field, this._legendType = this._spec.type;
  }
  init(option) {
    super.init(option), eachSeries(this._regions, (s2) => {
      s2.addViewDataFilter({
        type: "continuousLegendFilter",
        options: {
          selected: () => this._selectedData,
          field: () => this._field,
          data: () => this._legendData.getLatestData(),
          isHierarchyData: s2.isHierarchyData
        },
        level: TransformLevel.legendFilter
      });
    }, {
      userId: this._seriesUserId,
      specIndex: this._seriesIndex
    });
  }
  _getScaleInGlobal() {
    const globalScale = this._option.globalScale;
    let scaleKey = this._spec.scale;
    return scaleKey || (scaleKey = this._legendType), globalScale.getScale(scaleKey);
  }
  _initLegendData() {
    registerDataSetInstanceTransform(this._option.dataSet, "continuousLegendFilter", continuousLegendFilter), registerDataSetInstanceTransform(this._option.dataSet, "continuousLegendDataMake", continuousLegendDataMake);
    const legendData = new DataView(this._option.dataSet, {
      name: `${this.type}_${this.id}_data`
    });
    return legendData.transform({
      type: "continuousLegendDataMake",
      options: {
        series: () => getSeries(this._regions, {
          userId: this._seriesUserId,
          specIndex: this._seriesIndex
        }),
        field: () => this._field,
        scale: this._getScaleInGlobal.bind(this)
      }
    }), legendData;
  }
  _initSelectedData() {
    this._spec.defaultSelected ? this._selectedData = this._spec.defaultSelected.slice() : this._selectedData = this._legendData.getLatestData();
  }
  _addDefaultTitleText(attrs) {
    var _a, _b, _c, _d;
    if ((null === (_a = attrs.title) || void 0 === _a ? void 0 : _a.visible) && isNil_default(attrs.title.text) && isNil_default(null === (_b = attrs.title.style) || void 0 === _b ? void 0 : _b.text)) {
      const field3 = this._field;
      if (field3) {
        const series2 = null === (_d = null === (_c = this._regions) || void 0 === _c ? void 0 : _c[0]) || void 0 === _d ? void 0 : _d.getSeries()[0];
        if (!series2)
          return;
        return void (attrs.title.text = getFieldAlias(series2.getRawData(), field3));
      }
      let scaleKey = this._spec.scale;
      scaleKey || (scaleKey = this._legendType);
      const scaleSpec = this._option.globalScale.getScaleSpec(scaleKey);
      if (!isDataDomainSpec(null == scaleSpec ? void 0 : scaleSpec.domain))
        return;
      const dataInfo = scaleSpec.domain[0];
      if (0 === dataInfo.fields.length)
        return;
      attrs.title.text = getFieldAlias(this._option.dataSet.getDataView(dataInfo.dataId), dataInfo.fields[0]);
    } else
      ;
  }
  _getLegendAttributes(rect) {
    var _a, _b;
    const layout = "bottom" === this.layoutOrient || "top" === this.layoutOrient ? "horizontal" : "vertical", align = "horizontal" === layout ? "bottom" : this.layoutOrient;
    let visualMappingRange = [];
    const scale4 = this._getScaleInGlobal();
    scale4 && "linear" === scale4.type && (visualMappingRange = scale4.range()), isEmpty_default(visualMappingRange) && (visualMappingRange = "color" === this._legendType ? SINGLE_SEQUENCE : SIZE);
    let min3 = null !== (_a = this._legendData.getLatestData()[0]) && void 0 !== _a ? _a : 0, max3 = null !== (_b = this._legendData.getLatestData()[1]) && void 0 !== _b ? _b : 1;
    this._legendData.getLatestData()[0] === this._legendData.getLatestData()[1] && (min3 = Math.min(0, this._legendData.getLatestData()[0]), max3 = 0 === this._legendData.getLatestData()[0] ? 1 : Math.max(0, this._legendData.getLatestData()[0]));
    const attrs = Object.assign({
      layout,
      align,
      zIndex: this.layoutZIndex,
      min: min3,
      max: max3,
      value: this._spec.defaultSelected,
      ["color" === this._legendType ? "colors" : "sizeRange"]: visualMappingRange
    }, getContinuousLegendAttributes(this._spec));
    return this._addDefaultTitleText(attrs), attrs;
  }
  _getLegendConstructor() {
    return ContinuousLegendMap[this._legendType];
  }
  _initEvent() {
    if (this._legendComponent) {
      const doFilter = false !== this._spec.filter;
      this._legendComponent.addEventListener("change", debounce_default((e) => {
        const selectedData = get_default(e, "detail.value");
        doFilter && this.setSelectedData(selectedData), this.event.emit(ChartEvent.legendFilter, {
          model: this,
          value: selectedData,
          event: e
        });
      }, 30));
    }
  }
};
ContinuousLegend.specKey = "legends", ContinuousLegend.type = ComponentTypeEnum.continuousLegend;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/indicator/util
var indicatorMapper = (data, op) => {
  const { datum, title: title3, content } = op, mappedData = [], datumResult = datum.call(null);
  return title3.visible && mappedData.push({
    type: "title",
    index: 0,
    datum: datumResult,
    spec: title3
  }), array(content).forEach((c3, i) => {
    c3.visible && mappedData.push({
      type: "content",
      index: i,
      datum: datumResult,
      spec: c3
    });
  }), mappedData;
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/indicator/indicator
var Indicator2 = class _Indicator extends BaseComponent {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.indicator, this.name = ComponentTypeEnum.indicator, this.specKey = "indicator", this.layoutType = "none", this.layoutZIndex = LayoutZIndex.Indicator, this.layoutLevel = LayoutLevel.Indicator, this._gap = 0, this._activeDatum = null;
  }
  static getSpecInfo(chartSpec) {
    if (this.type !== _Indicator.type)
      return null;
    const indicatorSpec = chartSpec[this.specKey];
    if (!isArray_default(indicatorSpec))
      return false === indicatorSpec.visible ? [] : [{
        spec: indicatorSpec,
        specPath: [this.specKey],
        specInfoPath: ["component", this.specKey, 0],
        type: ComponentTypeEnum.indicator
      }];
    const specInfos = [];
    return indicatorSpec.forEach((s2, i) => {
      s2 && false !== s2.visible && specInfos.push({
        spec: s2,
        specPath: [this.specKey, i],
        specInfoPath: ["component", this.specKey, i],
        type: ComponentTypeEnum.indicator
      });
    }), specInfos;
  }
  created() {
    super.created(), this.initData(), this.initEvent();
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this._gap = this._spec.gap || 0, this._title = this._spec.title, this._content = array(this._spec.content), this._regions = this._option.getRegionsInUserIdOrIndex(array(this._spec.regionId), array(this._spec.regionIndex));
  }
  onRender(ctx) {
  }
  changeRegions(regions) {
  }
  initEvent() {
    var _a;
    if (this._option.disableTriggerEvent)
      return;
    if ("none" === this._spec.trigger)
      return;
    const view = null === (_a = this.getCompiler()) || void 0 === _a ? void 0 : _a.getVGrammarView();
    view && ("hover" === this._spec.trigger ? (view.addEventListener("element-highlight:start", (params2) => {
      this.isRelativeModel(params2.options.regionId) && this.updateDatum(params2.elements[0].getDatum());
    }), view.addEventListener("element-highlight:reset", (params2) => {
      this.isRelativeModel(params2.options.regionId) && this.updateDatum(null);
    })) : (view.addEventListener("element-select:start", (params2) => {
      this.isRelativeModel(params2.options.regionId) && this.updateDatum(params2.elements[0].getDatum());
    }), view.addEventListener("element-select:reset", (params2) => {
      this.isRelativeModel(params2.options.regionId) && this.updateDatum(null);
    })));
  }
  updateDatum(datum) {
    this._activeDatum = datum, this._displayData.updateData();
    const attrs = this._getIndicatorAttrs();
    this._createOrUpdateIndicatorComponent(attrs);
  }
  initData() {
    registerDataSetInstanceTransform(this._option.dataSet, "indicatorFilter", indicatorMapper);
    const displayData = new DataView(this._option.dataSet, {
      name: `${this.type}_${this.id}_data`
    });
    displayData.transform({
      type: "indicatorFilter",
      options: {
        title: this._title,
        content: this._content,
        datum: () => this._activeDatum
      }
    }), displayData.target.addListener("change", this.updateDatum.bind(this)), this._displayData = new CompilableData(this._option, displayData);
  }
  updateLayoutAttribute() {
    const attrs = this._getIndicatorAttrs();
    this._createOrUpdateIndicatorComponent(attrs), super.updateLayoutAttribute();
  }
  _getIndicatorAttrs() {
    const region = this._regions[0], { width, height } = region.getLayoutRect(), { x, y } = region.getLayoutStartPoint(), contentComponentSpec = [];
    return array(this._spec.content).forEach((eachItem) => {
      const contentSpec = mergeSpec({}, this._theme.content, eachItem);
      contentComponentSpec.push({
        visible: false !== contentSpec.visible && (!contentSpec.field || null !== this._activeDatum),
        space: contentSpec.space || this._gap,
        autoLimit: contentSpec.autoLimit,
        autoFit: contentSpec.autoFit,
        fitPercent: contentSpec.fitPercent,
        fitStrategy: contentSpec.fitStrategy,
        style: Object.assign(Object.assign({}, transformToGraphic(contentSpec.style)), {
          text: this._createText(contentSpec.field, contentSpec.style.text)
        })
      });
    }), {
      visible: false !== this._spec.visible && (false !== this._spec.fixed || null !== this._activeDatum),
      size: {
        width,
        height
      },
      zIndex: this.layoutZIndex,
      x,
      y,
      dx: this._spec.offsetX ? getActualNumValue(this._spec.offsetX, this._computeLayoutRadius()) : 0,
      dy: this._spec.offsetY ? getActualNumValue(this._spec.offsetY, this._computeLayoutRadius()) : 0,
      limitRatio: this._spec.limitRatio || 1 / 0,
      title: {
        visible: false !== this._spec.title.visible && (!isValid_default(this._spec.title.field) || null !== this._activeDatum),
        space: this._spec.title.space || this._gap,
        autoLimit: this._spec.title.autoLimit,
        autoFit: this._spec.title.autoFit,
        fitPercent: this._spec.title.fitPercent,
        fitStrategy: this._spec.title.fitStrategy,
        style: Object.assign(Object.assign({}, transformToGraphic(this._spec.title.style)), {
          text: this._createText(this._spec.title.field, this._spec.title.style.text)
        })
      },
      content: contentComponentSpec
    };
  }
  _createOrUpdateIndicatorComponent(attrs) {
    if (this._indicatorComponent)
      isEqual(attrs, this._cacheAttrs) || this._indicatorComponent.setAttributes(attrs);
    else {
      const container2 = this.getContainer(), indicator2 = new Indicator(attrs);
      indicator2.name = "indicator", container2.add(indicator2), this._indicatorComponent = indicator2, this._indicatorComponent.on("*", (event, type) => this._delegateEvent(this._indicatorComponent, event, type));
    }
    return this._cacheAttrs = attrs, this._indicatorComponent;
  }
  _createText(field3, text2) {
    var _a;
    return field3 ? this._activeDatum ? this._activeDatum[field3] : "" : isFunction_default(text2) ? null !== (_a = text2(this._activeDatum, void 0)) && void 0 !== _a ? _a : "" : null != text2 ? text2 : "";
  }
  _computeLayoutRadius() {
    const region = this._regions[0], { width, height } = region.getLayoutRect();
    return Math.min(width / 2, height / 2);
  }
  isRelativeModel(regionId) {
    return this._regions.some((region) => region.id === regionId);
  }
  _getNeedClearVRenderComponents() {
    return [this._indicatorComponent];
  }
  clear() {
    this._cacheAttrs = null, super.clear();
  }
  getIndicatorComponent() {
    return this._indicatorComponent;
  }
};
Indicator2.type = ComponentTypeEnum.indicator, Indicator2.specKey = "indicator";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/title/title
var Title2 = class extends BaseComponent {
  get orient() {
    return this._orient;
  }
  constructor(spec, options) {
    super(spec, options), this.type = ComponentTypeEnum.title, this.specKey = ComponentTypeEnum.title, this.layoutType = "normal", this.layoutZIndex = LayoutZIndex.Title, this.layoutLevel = LayoutLevel.Title, this._orient = "top", this._orient = isValidOrient(spec.orient) ? spec.orient : "top";
  }
  initLayout() {
    super.initLayout(), this._layout && (this._layout.layoutOrient = this._orient);
  }
  static getSpecInfo(chartSpec) {
    const titleSpec = chartSpec[this.specKey];
    if (!titleSpec || false === titleSpec.visible)
      return null;
    if (!isArray_default(titleSpec))
      return [{
        spec: titleSpec,
        specPath: [this.specKey],
        specInfoPath: ["component", this.specKey, 0],
        type: ComponentTypeEnum.title
      }];
    const specInfos = [];
    return titleSpec.forEach((s2, i) => {
      false !== s2.visible && specInfos.push({
        spec: s2,
        specPath: [this.specKey, i],
        specInfoPath: ["component", this.specKey, i],
        type: ComponentTypeEnum.title
      });
    }), specInfos;
  }
  onRender(ctx) {
  }
  _compareSpec(spec, prevSpec) {
    const result2 = super._compareSpec(spec, prevSpec);
    return (null == prevSpec ? void 0 : prevSpec.orient) !== (null == spec ? void 0 : spec.orient) && (result2.reMake = true), result2.change = true, result2.reRender = true, result2;
  }
  changeRegions(regions) {
  }
  update(ctx) {
  }
  resize(ctx) {
  }
  afterSetLayoutStartPoint(pos) {
    isValidNumber_default(pos.x) && this._titleComponent && this._titleComponent.setAttribute("x", pos.x), isValidNumber_default(pos.y) && this._titleComponent && this._titleComponent.setAttribute("y", pos.y), super.afterSetLayoutStartPoint(pos);
  }
  getBoundsInRect(rect) {
    let result2 = {};
    this.setLayoutRect(rect);
    const attrs = this._getTitleAttrs();
    this._createOrUpdateTitleComponent(attrs), result2 = this._getTitleLayoutRect();
    const { x, y } = this.getLayoutStartPoint();
    return {
      x1: x,
      y1: y,
      x2: x + result2.width,
      y2: y + result2.height
    };
  }
  _getTitleLayoutRect() {
    const titleBounds = this._titleComponent.AABBBounds;
    return {
      width: this._spec.width ? this._spec.width : isValidNumber_default(titleBounds.width()) ? titleBounds.width() : 0,
      height: this._spec.height ? this._spec.height : isValidNumber_default(titleBounds.height()) ? titleBounds.height() : 0
    };
  }
  _getTitleAttrs() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const realWidth = Math.max(0, null !== (_a = this._spec.width) && void 0 !== _a ? _a : this.getLayoutRect().width);
    return Object.assign(Object.assign({}, pickWithout(this._spec, ["padding"])), {
      textType: null !== (_b = this._spec.textType) && void 0 !== _b ? _b : "text",
      text: null !== (_c = this._spec.text) && void 0 !== _c ? _c : "",
      subtextType: null !== (_d = this._spec.subtextType) && void 0 !== _d ? _d : "text",
      subtext: null !== (_e = this._spec.subtext) && void 0 !== _e ? _e : "",
      x: null !== (_f = this._spec.x) && void 0 !== _f ? _f : 0,
      y: null !== (_g = this._spec.y) && void 0 !== _g ? _g : 0,
      width: realWidth,
      height: this._spec.height,
      minWidth: this._spec.minWidth,
      maxWidth: this._spec.maxWidth,
      minHeight: this._spec.minHeight,
      maxHeight: this._spec.maxHeight,
      padding: this._spec.innerPadding,
      align: null !== (_h = this._spec.align) && void 0 !== _h ? _h : "left",
      verticalAlign: null !== (_j = this._spec.verticalAlign) && void 0 !== _j ? _j : "top",
      textStyle: Object.assign({
        width: realWidth
      }, this._spec.textStyle),
      subtextStyle: Object.assign({
        width: realWidth
      }, this._spec.subtextStyle)
    });
  }
  _createOrUpdateTitleComponent(attrs) {
    if (this._titleComponent)
      isEqual(attrs, this._cacheAttrs) || this._titleComponent.setAttributes(attrs);
    else {
      const container2 = this.getContainer(), title3 = new Title(attrs);
      title3.name = "title", container2.add(title3), this._titleComponent = title3, title3.on("*", (event, type) => this._delegateEvent(title3, event, type));
    }
    return this._cacheAttrs = attrs, this._titleComponent;
  }
  _getNeedClearVRenderComponents() {
    return [this._titleComponent];
  }
  clear() {
    super.clear(), this._cacheAttrs = null;
  }
};
Title2.type = ComponentTypeEnum.title, Title2.specKey = ComponentTypeEnum.title;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/crosshair/config
function getDefaultCrosshairTriggerEventByMode(mode) {
  return mode === RenderModeEnum["desktop-browser"] || mode === RenderModeEnum["desktop-miniApp"] ? {
    click: "pointertap",
    hover: "pointermove",
    hoverOut: "pointerleave",
    clickOut: "pointerleave"
  } : isMobileLikeMode(mode) || isMiniAppLikeMode(mode) ? {
    click: "tap",
    hover: ["pointerdown", "pointermove"],
    hoverOut: "pointerleave",
    clickOut: "pointerleave"
  } : null;
}
var LayoutType;
!function(LayoutType2) {
  LayoutType2[LayoutType2.ALL = 3] = "ALL", LayoutType2[LayoutType2.HORIZONTAL = 2] = "HORIZONTAL", LayoutType2[LayoutType2.VERTICAL = 1] = "VERTICAL";
}(LayoutType || (LayoutType = {}));

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/crosshair/base
var __rest18 = function(s2, e) {
  var t = {};
  for (var p in s2)
    Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++)
      e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var ORIENT_MAP = {
  x: ["top", "bottom"],
  y: ["left", "right"],
  category: ["angle"],
  value: ["radius"]
};
var BaseCrossHair = class extends BaseComponent {
  get enableRemain() {
    return "none" === this.triggerOff;
  }
  constructor(spec, options) {
    super(spec, options), this.specKey = "crosshair", this.layoutType = "none", this.gridZIndex = LayoutZIndex.CrossHair_Grid, this.labelZIndex = LayoutZIndex.CrossHair, this.trigger = "hover", this._handleIn = (params2) => {
      if (!this._option)
        return;
      const { x, y } = this.calculateTriggerPoint(params2);
      this.showDefault = false, this._layoutCrosshair(x, y);
      const components = this._getNeedClearVRenderComponents();
      this._hasActive = components.some((comp) => comp && false !== comp.attribute.visible);
    }, this._handleClickInEvent = (params2) => {
      this._handleIn(params2), this._clickLock = this._hasActive && this._spec.lockAfterClick, this._clickLock && isNumber_default(this.triggerOff) && (this._timer && clearTimeout(this._timer), this._timer = setTimeout(() => {
        this._clickLock = false, this._handleOutEvent();
      }, this.triggerOff));
    }, this._handleHoverInEvent = throttle_default((params2) => {
      this._clickLock || this._handleIn(params2);
    }, 10), this._handleOutEvent = () => {
      this.enableRemain || this._clickLock || !this._hasActive || (this.clearOutEvent(), this.hide());
    }, this._handleTooltipShow = (params2) => {
      const tooltipData = params2.tooltipData;
      if (params2.isEmptyTooltip || !tooltipData || !tooltipData.length)
        return void this._handleTooltipHideOrRelease();
      if (isObject_default(this._spec.followTooltip) && false === this._spec.followTooltip[params2.activeType])
        return void this._handleTooltipHideOrRelease();
      const { x, y } = this.calculateTriggerPoint(params2);
      this.showDefault = false, this._layoutCrosshair(x, y, tooltipData, params2.activeType);
      const components = this._getNeedClearVRenderComponents();
      this._hasActive = components.some((comp) => comp && false !== comp.attribute.visible);
    }, this._handleTooltipHideOrRelease = () => {
      this.clearOutEvent(), this.hide();
    }, this.enable = true, this.showDefault = true;
  }
  _getLimitBounds() {
    var _a, _b;
    if (!this._limitBounds) {
      const { width, height } = null !== (_b = null === (_a = this._option.globalInstance.getChart()) || void 0 === _a ? void 0 : _a.getViewRect()) && void 0 !== _b ? _b : {
        width: 0,
        height: 0
      };
      this._limitBounds = {
        x1: 0,
        y1: 0,
        x2: width,
        y2: height
      };
    }
    return this._limitBounds;
  }
  _showDefaultCrosshair() {
    this.showDefault && this._showDefaultCrosshairBySpec();
  }
  setAttrFromSpec() {
    super.setAttrFromSpec(), this._parseCrosshairSpec();
  }
  created() {
    super.created(), this._initEvent();
  }
  _compareSpec(spec, prevSpec) {
    const result2 = super._compareSpec(spec, prevSpec);
    return result2.reMake || isEqual(prevSpec, spec) || (result2.reRender = true, result2.reMake = true), result2;
  }
  _initEvent() {
    if (!this._option.disableTriggerEvent)
      if (this._spec.followTooltip)
        this._registerTooltipEvent();
      else {
        const triggerConfig = this._getTriggerEvent();
        triggerConfig && triggerConfig.forEach((cfg) => {
          this._registerEvent(cfg.in, false, cfg.click), cfg.out && this._registerEvent(cfg.out, true);
        });
      }
  }
  _registerEvent(eventName, isOut, click) {
    const handler = isOut ? this._handleOutEvent : click ? this._handleClickInEvent : this._handleHoverInEvent, cfg = isOut ? {
      level: Event_Bubble_Level.chart
    } : {
      source: Event_Source_Type.chart
    };
    isArray_default(eventName) ? eventName.forEach((evt) => {
      this.event.on(evt, cfg, handler);
    }) : this.event.on(eventName, cfg, handler);
  }
  _eventOff(eventName, isOut, click) {
    const handler = isOut ? this._handleOutEvent : click ? this._handleClickInEvent : this._handleHoverInEvent;
    isArray_default(eventName) ? eventName.forEach((evt) => {
      this.event.off(evt, handler);
    }) : this.event.off(eventName, handler);
  }
  updateLayoutAttribute() {
    this._limitBounds = null, this._showDefaultCrosshair();
  }
  calculateTriggerPoint(params2) {
    const { event } = params2, layer = this._option.getCompiler().getStage().getLayer(void 0), point5 = {
      x: event.viewX,
      y: event.viewY
    };
    return layer.globalTransMatrix.transformPoint({
      x: event.viewX,
      y: event.viewY
    }, point5), {
      x: point5.x - this.getLayoutStartPoint().x,
      y: point5.y - this.getLayoutStartPoint().y
    };
  }
  _getTriggerEvent() {
    const { mode = RenderModeEnum["desktop-browser"] } = this._option, triggerConfig = getDefaultCrosshairTriggerEventByMode(mode);
    if (triggerConfig) {
      const trigger = this.trigger || "hover", outTrigger = (inTrigger) => "click" === inTrigger ? "none" === this.triggerOff ? null : triggerConfig.clickOut : triggerConfig.hoverOut;
      if (isArray_default(trigger)) {
        const res = [];
        return trigger.forEach((item) => {
          res.push({
            click: "click" === item,
            in: triggerConfig[item],
            out: outTrigger(item)
          });
        }), res;
      }
      return [{
        click: "click" === trigger,
        in: triggerConfig[trigger],
        out: outTrigger(trigger)
      }];
    }
    return null;
  }
  _registerTooltipEvent() {
    this.event.on(ChartEvent.tooltipHide, {
      source: Event_Source_Type.chart
    }, this._handleTooltipHideOrRelease), this.event.on(ChartEvent.tooltipShow, {
      source: Event_Source_Type.chart
    }, this._handleTooltipShow), this.event.on(ChartEvent.tooltipRelease, {
      source: Event_Source_Type.chart
    }, this._handleTooltipHideOrRelease);
  }
  _getAxisInfoByField(field3) {
    var _a, _b;
    const axesComponents = null === (_b = (_a = this._option).getComponentsByKey) || void 0 === _b ? void 0 : _b.call(_a, "axes");
    if (!(null == axesComponents ? void 0 : axesComponents.length))
      return null;
    let bindingAxesIndex = get_default(this._spec, `${field3}Field.bindingAxesIndex`);
    if (bindingAxesIndex || (bindingAxesIndex = [], axesComponents.forEach((item, index) => {
      ORIENT_MAP[field3].includes(item.getOrient()) && bindingAxesIndex.push(index);
    })), !bindingAxesIndex.length)
      return null;
    const map4 = /* @__PURE__ */ new Map();
    let x14 = 1 / 0, y14 = 1 / 0, x23 = -1 / 0, y23 = -1 / 0;
    const { x: sx, y: sy } = this.getLayoutStartPoint();
    return bindingAxesIndex.forEach((idx) => {
      x14 = 1 / 0, y14 = 1 / 0, x23 = -1 / 0, y23 = -1 / 0;
      const axis2 = axesComponents.find((axis3) => axis3.getSpecIndex() === idx);
      if (!axis2)
        return;
      axis2.getRegions().forEach((r) => {
        const { x: regionStartX, y: regionStartY } = r.getLayoutStartPoint();
        x14 = Math.min(x14, regionStartX - sx), y14 = Math.min(y14, regionStartY - sy), x23 = Math.max(x23, regionStartX + r.getLayoutRect().width - sx), y23 = Math.max(y23, regionStartY + r.getLayoutRect().height - sy);
      }), map4.set(idx, {
        x1: x14,
        y1: y14,
        x2: x23,
        y2: y23,
        axis: axis2
      });
    }), map4;
  }
  changeRegions(regions) {
  }
  onLayoutEnd(ctx) {
    const region = this._regions[0];
    this.setLayoutRect(region.getLayoutRect()), this.setLayoutStartPosition(region.getLayoutStartPoint()), super.onLayoutEnd(ctx);
  }
  onRender(ctx) {
  }
  _releaseEvent() {
    this.clearOutEvent();
    const triggerConfig = this._getTriggerEvent();
    triggerConfig && triggerConfig.forEach((cfg) => {
      this._eventOff(cfg.in, false, cfg.click), cfg.out && this._eventOff(cfg.out, true);
    });
  }
  _parseCrosshairSpec() {
    this._parseFieldInfo();
    const { trigger, triggerOff, labelZIndex, gridZIndex } = this._spec;
    trigger && (this.trigger = trigger), ("none" === triggerOff || isNumber_default(triggerOff) && triggerOff > 0) && (this.triggerOff = triggerOff), void 0 !== labelZIndex && (this.labelZIndex = labelZIndex), void 0 !== gridZIndex && (this.gridZIndex = gridZIndex);
  }
  _parseField(field3, fieldName) {
    var _a, _b, _c;
    const hair = {}, { line: line2 = {}, label = {}, visible } = field3;
    if (hair.visible = visible, hair.type = line2.type || "line", false === line2.visible)
      hair.style = {
        visible: false
      };
    else {
      const style = line2.style || {}, { stroke: stroke2, fill, lineWidth } = style, _d = style, { strokeOpacity, fillOpacity, opacity } = _d, restStyle = __rest18(_d, ["strokeOpacity", "fillOpacity", "opacity"]), isLineType = "line" === hair.type;
      let finalOpacity = isLineType ? strokeOpacity : fillOpacity;
      if (isNumber_default(opacity) && (finalOpacity = (null != finalOpacity ? finalOpacity : 1) * opacity), hair.style = Object.assign({
        opacity: finalOpacity,
        pickable: false,
        visible: true
      }, restStyle), isLineType)
        hair.style.stroke = stroke2 || fill, hair.style.lineWidth = get_default(line2, "width", lineWidth || 2);
      else {
        hair.style.fill = fill || stroke2, (null === (_c = null === (_b = null === (_a = this._spec[fieldName]) || void 0 === _a ? void 0 : _a.line) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.stroke) && (hair.style.stroke = this._spec[fieldName].line.style.stroke);
        const rectSize2 = get_default(line2, "width");
        if ("string" == typeof rectSize2) {
          const percent = parseInt(rectSize2.substring(0, rectSize2.length - 1), 10) / 100;
          hair.style.sizePercent = percent;
        } else
          "number" != typeof rectSize2 && "function" != typeof rectSize2 || (hair.style.size = rectSize2);
      }
    }
    if (label.visible) {
      const labelBackground = label.labelBackground || {}, labelStyle = label.style || {}, _e = labelBackground.style || {}, { fill: rectFill = "rgba(47, 59, 82, 0.9)", stroke: rectStroke, outerBorder } = _e, rectStyle = __rest18(_e, ["fill", "stroke", "outerBorder"]);
      hair.label = {
        visible: true,
        formatMethod: label.formatMethod,
        formatter: label.formatter,
        minWidth: labelBackground.minWidth,
        maxWidth: labelBackground.maxWidth,
        padding: labelBackground.padding,
        textStyle: Object.assign(Object.assign({
          fontSize: 14,
          pickable: false
        }, labelStyle), {
          fill: labelStyle.fill || "#fff",
          stroke: get_default(labelStyle, "stroke")
        }),
        panel: (isBoolean_default(labelBackground.visible) ? labelBackground.visible : labelBackground) ? Object.assign({
          visible: true,
          pickable: false,
          fill: rectFill,
          stroke: rectStroke,
          outerBorder: Object.assign({
            stroke: rectFill,
            distance: 0,
            lineWidth: 3
          }, outerBorder)
        }, rectStyle) : {
          visible: false
        },
        zIndex: this.labelZIndex,
        childrenPickable: false,
        pickable: false
      };
    } else
      hair.label = {
        visible: false
      };
    return hair;
  }
  _filterAxisByPoint(axisMap, relativeX, relativeY) {
    return axisMap && axisMap.forEach((item) => {
      const axis2 = item.axis;
      if (outOfBounds(item, relativeX, relativeY) && axisMap.delete(axis2.getSpecIndex()), axis2.type.startsWith("polarAxis")) {
        const center2 = axis2.getCenter(), innerRadius = axis2.getInnerRadius(), outerRadius = axis2.getOuterRadius(), distance2 = PointService.distancePP({
          x: relativeX,
          y: relativeY
        }, center2);
        (distance2 > outerRadius || distance2 < innerRadius) && axisMap.delete(axis2.getSpecIndex());
      }
    }), axisMap;
  }
  clearOutEvent() {
    this._timer && (clearTimeout(this._timer), this._timer = null), this._clickLock && (this._clickLock = null), this._hasActive && (this._hasActive = null);
  }
};
BaseCrossHair.specKey = "crosshair";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/crosshair/cartesian
var CartesianCrossHair = class extends BaseCrossHair {
  static getSpecInfo(chartSpec) {
    const crosshairSpec = chartSpec[this.specKey];
    if (isNil_default(crosshairSpec))
      return;
    if (!isArray_default(crosshairSpec))
      return crosshairSpec.xField || crosshairSpec.yField ? [{
        spec: crosshairSpec,
        specPath: [this.specKey],
        specInfoPath: ["component", this.specKey, 0],
        type: ComponentTypeEnum.cartesianCrosshair
      }] : void 0;
    const specInfos = [];
    return crosshairSpec.forEach((s2, i) => {
      (s2.xField || s2.yField) && specInfos.push({
        spec: s2,
        specPath: [this.specKey, i],
        specInfoPath: ["component", this.specKey, i],
        type: ComponentTypeEnum.cartesianCrosshair
      });
    }), specInfos;
  }
  constructor(spec, options) {
    super(spec, options), this.type = ComponentTypeEnum.cartesianCrosshair, this.name = ComponentTypeEnum.cartesianCrosshair, this._currValueX = /* @__PURE__ */ new Map(), this._currValueY = /* @__PURE__ */ new Map();
  }
  _showDefaultCrosshairBySpec() {
    const { xField, yField } = this._spec;
    if ((null == xField ? void 0 : xField.visible) && xField.defaultSelect) {
      const { axisIndex, datum } = xField.defaultSelect;
      this._defaultCrosshair(axisIndex, datum, 1);
    }
    if ((null == yField ? void 0 : yField.visible) && yField.defaultSelect) {
      const { axisIndex, datum } = yField.defaultSelect;
      this._defaultCrosshair(axisIndex, datum, 2);
    }
  }
  _defaultCrosshair(axisIndex, value, tag) {
    const axis2 = this._option.getComponentsByKey("axes").find((c3) => c3.getSpecIndex() === axisIndex);
    axis2 && (1 === tag ? (this._currValueX.clear(), this._currValueX.set(axisIndex, {
      axis: axis2,
      value
    })) : (this._currValueY.clear(), this._currValueY.set(axisIndex, {
      axis: axis2,
      value
    })), this.layoutByValue(tag));
  }
  _findAllAxisContains(relativeX, relativeY) {
    const xAxisMap = this._getAxisInfoByField("x"), yAxisMap = this._getAxisInfoByField("y");
    return {
      xAxisMap: this._filterAxisByPoint(xAxisMap, relativeX, relativeY),
      yAxisMap: this._filterAxisByPoint(yAxisMap, relativeX, relativeY)
    };
  }
  _getValueAt(axis2, p) {
    return axis2.getScale().invert(p);
  }
  clearAxisValue() {
    this._currValueX.clear(), this._currValueY.clear();
  }
  setAxisValue(value, axis2) {
    isXAxis(axis2.getOrient()) ? this._currValueX.set(axis2.getSpecIndex(), {
      value,
      axis: axis2
    }) : this._currValueY.set(axis2.getSpecIndex(), {
      value,
      axis: axis2
    });
  }
  _getAllAxisValues(axisMap, p, currValue, vertical) {
    let discrete = false;
    return axisMap.forEach((item) => {
      isDiscrete(item.axis.getScale().type) && (discrete ? this.enable = false : discrete = true);
    }), !!this.enable && (axisMap.forEach((item, id2) => {
      const axis2 = item.axis;
      currValue.set(id2, {
        value: this._getValueAt(axis2, p - (vertical ? axis2.getLayoutStartPoint().x - this.getLayoutStartPoint().x : axis2.getLayoutStartPoint().y - this.getLayoutStartPoint().y)),
        axis: axis2
      });
    }), true);
  }
  _layoutCrosshair(relativeX, relativeY, tooltipData, activeType) {
    var _a;
    let x = relativeX, y = relativeY;
    if (tooltipData && tooltipData.length) {
      if ("dimension" === activeType) {
        const dimensionInfo = tooltipData[0], dimensionData = dimensionInfo.data[0], pos = dimensionData.series.dataToPosition(dimensionData.datum[0]);
        (isValid_default(dimensionInfo.dimType) ? "y" === dimensionInfo.dimType : isYAxis(null === (_a = null == dimensionInfo ? void 0 : dimensionInfo.axis) || void 0 === _a ? void 0 : _a.getOrient())) ? y = pos.y : x = pos.x;
      } else if ("mark" === activeType) {
        const dimensionData = tooltipData[0], pos = dimensionData.series.dataToPosition(dimensionData.datum[0]);
        x = pos.x, y = pos.y;
      }
    }
    const { xAxisMap, yAxisMap } = this._findAllAxisContains(x, y);
    if (xAxisMap && 0 === xAxisMap.size || yAxisMap && 0 === yAxisMap.size) {
      if (this.enableRemain)
        return;
      this.hide();
    } else
      this._currValueX.clear(), this._currValueY.clear(), xAxisMap && xAxisMap.size && this._getAllAxisValues(xAxisMap, x, this._currValueX, true), yAxisMap && yAxisMap.size && this._getAllAxisValues(yAxisMap, y, this._currValueY, false), this.layoutByValue(3);
  }
  hide() {
    this._xCrosshair && this._xCrosshair.hideAll(), this._xTopLabel && this._xTopLabel.hideAll(), this._xBottomLabel && this._xBottomLabel.hideAll(), this._yCrosshair && this._yCrosshair.hideAll(), this._yLeftLabel && this._yLeftLabel.hideAll(), this._yRightLabel && this._yRightLabel.hideAll();
  }
  layoutByValue(tag = 3) {
    if (!this.enable)
      return;
    const series2 = getFirstSeries(this._regions, "cartesian");
    if (!series2)
      return;
    const { x, y, offsetWidth, offsetHeight, bandWidth, bandHeight } = layoutByValue(tag, series2, this.getLayoutStartPoint(), this._currValueX, this._currValueY, this._xHair, this._yHair, this.enableRemain, this._cacheXCrossHairInfo, this._cacheYCrossHairInfo);
    this.enableRemain && (x && (this._cacheXCrossHairInfo = Object.assign(Object.assign({}, x), {
      _isCache: true
    })), y && (this._cacheYCrossHairInfo = Object.assign(Object.assign({}, y), {
      _isCache: true
    }))), x && this._layoutVertical(x, bandWidth, offsetWidth), y && this._layoutHorizontal(y, bandHeight, offsetHeight);
  }
  _layoutVertical(crosshairInfo, bandWidth, offsetWidth) {
    var _a, _b;
    if (crosshairInfo._isCache && this.enableRemain || !this._xHair)
      return;
    const { x, topPos, height, top, bottom, visible } = crosshairInfo;
    if (visible) {
      const type = this._xHair.type, positionAttribute = layoutVerticalCrosshair(this._xHair, crosshairInfo, bandWidth, offsetWidth);
      if (this._updateCrosshair("x", type, positionAttribute), top.visible) {
        const updateAttrs = Object.assign(Object.assign(Object.assign({
          x: x + bandWidth / 2,
          y: topPos
        }, top), this._xHair.label), {
          textStyle: Object.assign(Object.assign({}, null === (_a = this._xHair.label) || void 0 === _a ? void 0 : _a.textStyle), {
            textAlign: "center",
            textBaseline: "bottom"
          }),
          zIndex: this.labelZIndex,
          visible: true
        });
        this._updateCrosshairLabel(this._xTopLabel, updateAttrs, (label) => {
          label.name = "crosshair-x-top-label", this._xTopLabel = label;
        });
      } else
        this._xTopLabel && this._xTopLabel.hideAll();
      if (bottom.visible) {
        const updateAttrs = Object.assign(Object.assign(Object.assign({
          x: x + bandWidth / 2,
          y: topPos + height
        }, bottom), this._xHair.label), {
          textStyle: Object.assign(Object.assign({}, null === (_b = this._xHair.label) || void 0 === _b ? void 0 : _b.textStyle), {
            textAlign: "center",
            textBaseline: "top"
          }),
          zIndex: this.labelZIndex,
          visible: true
        });
        this._updateCrosshairLabel(this._xBottomLabel, updateAttrs, (label) => {
          label.name = "crosshair-x-bottom-label", this._xBottomLabel = label;
        });
      } else
        this._xBottomLabel && this._xBottomLabel.hideAll();
    }
  }
  _layoutHorizontal(crosshairInfo, bandHeight, offsetHeight) {
    var _a, _b;
    if (crosshairInfo._isCache && this.enableRemain || !this._yHair)
      return;
    const { leftPos, width, y, left: left2, right: right2, visible } = crosshairInfo;
    if (visible) {
      const type = this._yHair.type, positionAttribute = layoutHorizontalCrosshair(this._yHair, crosshairInfo, bandHeight, offsetHeight);
      if (this._updateCrosshair("y", type, positionAttribute), left2.visible) {
        const updateAttrs = Object.assign(Object.assign(Object.assign({
          x: leftPos,
          y: y + bandHeight / 2
        }, left2), this._yHair.label), {
          textStyle: Object.assign(Object.assign({}, null === (_a = this._yHair.label) || void 0 === _a ? void 0 : _a.textStyle), {
            textAlign: "right",
            textBaseline: "middle"
          }),
          zIndex: this.labelZIndex
        });
        this._updateCrosshairLabel(this._yLeftLabel, updateAttrs, (label) => {
          label.name = "crosshair-y-left-label", this._yLeftLabel = label;
        });
      } else
        this._yLeftLabel && this._yLeftLabel.hideAll();
      if (right2.visible) {
        const updateAttrs = Object.assign(Object.assign(Object.assign({
          x: leftPos + width,
          y: y + bandHeight
        }, right2), this._yHair.label), {
          textStyle: Object.assign(Object.assign({}, null === (_b = this._yHair.label) || void 0 === _b ? void 0 : _b.textStyle), {
            textAlign: "left",
            textBaseline: "middle"
          }),
          zIndex: this.labelZIndex
        });
        this._updateCrosshairLabel(this._yRightLabel, updateAttrs, (label) => {
          label.name = "crosshair-y-right-label", this._yRightLabel = label;
        });
      } else
        this._yRightLabel && this._yRightLabel.hideAll();
    }
  }
  _parseFieldInfo() {
    const { xField, yField } = this._spec;
    xField && xField.visible && (this._xHair = this._parseField(xField, "xField")), yField && yField.visible && (this._yHair = this._parseField(yField, "yField"));
  }
  _updateCrosshair(dim, type, attributes) {
    const container2 = this.getContainer();
    let crosshair2;
    if (crosshair2 = "x" === dim ? this._xCrosshair : this._yCrosshair, crosshair2)
      crosshair2.setAttributes(attributes);
    else {
      const style = "x" === dim ? this._xHair.style : this._yHair.style;
      "line" === type ? crosshair2 = new LineCrosshair(Object.assign(Object.assign({}, attributes), {
        lineStyle: style,
        zIndex: this.gridZIndex + 1,
        disableTriggerEvent: this._option.disableTriggerEvent,
        pickable: false
      })) : "rect" === type && (crosshair2 = new RectCrosshair(Object.assign(Object.assign({}, attributes), {
        rectStyle: style,
        zIndex: this.gridZIndex,
        disableTriggerEvent: this._option.disableTriggerEvent,
        pickable: false
      }))), null == container2 || container2.add(crosshair2), "x" === dim ? this._xCrosshair = crosshair2 : this._yCrosshair = crosshair2;
    }
  }
  _updateCrosshairLabel(label, attributes, callback) {
    const container2 = this.getContainer();
    label ? label.setAttributes(attributes) : (callback(label = new Tag(attributes)), null == container2 || container2.add(label)), limitTagInBounds(label, this._getLimitBounds());
  }
  _getNeedClearVRenderComponents() {
    return [this._xCrosshair, this._xTopLabel, this._xBottomLabel, this._yCrosshair, this._yLeftLabel, this._yRightLabel];
  }
};
CartesianCrossHair.specKey = "crosshair", CartesianCrossHair.type = ComponentTypeEnum.cartesianCrosshair;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/crosshair/utils/polar
var __rest19 = function(s2, e) {
  var t = {};
  for (var p in s2)
    Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++)
      e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var layoutByValue2 = (series2, currValueAngle, currValueRadius, angleHair, radiusHair, enableRemain = false, cacheAngleCrossHairInfo, cacheRadiusCrossHairInfo) => {
  let angleCrossHairInfo = {
    x: 0,
    y: 0,
    center: {
      x: 0,
      y: 0
    },
    radius: 0,
    distance: 0,
    startAngle: 0,
    endAngle: 0,
    innerRadius: 0,
    visible: false,
    label: {
      visible: false,
      text: "",
      offset: 0
    }
  }, radiusCrossHairInfo = {
    x: 0,
    y: 0,
    center: {
      x: 0,
      y: 0
    },
    radius: 0,
    distance: 0,
    startAngle: 0,
    endAngle: 0,
    innerRadius: 0,
    visible: false,
    sides: series2.angleAxisHelper.getScale(0).domain().length,
    label: {
      visible: false,
      text: "",
      offset: 0
    }
  };
  if (angleHair) {
    angleCrossHairInfo.visible = !!currValueAngle.size;
    const bandWidth = series2.angleAxisHelper.getBandwidth(0);
    currValueAngle.forEach((_a) => {
      var _b, { axis: axis2, value, coord } = _a, rest = __rest19(_a, ["axis", "value", "coord"]);
      value = null != value ? value : "", mergeSpec(angleCrossHairInfo, rest);
      const angle2 = series2.angleAxisHelper.dataToPosition([value]);
      angleCrossHairInfo.angle = angle2;
      const niceLabelFormatter = axis2.niceLabelFormatter;
      (null === (_b = angleHair.label) || void 0 === _b ? void 0 : _b.visible) && (angleCrossHairInfo.label.visible = true, angleCrossHairInfo.label.defaultFormatter = niceLabelFormatter, angleCrossHairInfo.label.text = value, angleCrossHairInfo.label.offset = getAxisLabelOffset(axis2.getSpec())), angleCrossHairInfo.startAngle = angle2 - bandWidth / 2, angleCrossHairInfo.endAngle = angle2 + bandWidth / 2;
    });
  }
  if (radiusHair && (radiusCrossHairInfo.visible = !!currValueRadius.size, currValueRadius.forEach((_a) => {
    var _b, { axis: axis2, value, coord } = _a, rest = __rest19(_a, ["axis", "value", "coord"]);
    value = null != value ? value : "";
    const niceLabelFormatter = axis2.niceLabelFormatter;
    (null === (_b = radiusHair.label) || void 0 === _b ? void 0 : _b.visible) && (radiusCrossHairInfo.label.visible = true, radiusCrossHairInfo.label.defaultFormatter = niceLabelFormatter, radiusCrossHairInfo.label.text = value, radiusCrossHairInfo.label.offset = getAxisLabelOffset(axis2.getSpec())), radiusCrossHairInfo.angle = coord.angle, radiusCrossHairInfo.axis = axis2, mergeSpec(radiusCrossHairInfo, rest);
  })), enableRemain && !angleCrossHairInfo.visible && isValid_default(cacheAngleCrossHairInfo))
    angleCrossHairInfo = cacheAngleCrossHairInfo;
  else if (angleCrossHairInfo.label.visible && angleHair && angleHair.label) {
    const { label } = angleCrossHairInfo, { formatMethod, formatter } = angleHair.label, { formatFunc, args } = getFormatFunction(formatMethod, formatter, label.text, {
      label: label.text,
      orient: "angle"
    });
    formatFunc ? label.text = formatFunc(...args) : label.defaultFormatter && (label.text = label.defaultFormatter(label.text));
  }
  if (enableRemain && !radiusCrossHairInfo.visible && isValid_default(cacheRadiusCrossHairInfo))
    radiusCrossHairInfo = cacheRadiusCrossHairInfo;
  else if (radiusCrossHairInfo.label.visible && radiusHair && radiusHair.label) {
    const { label } = radiusCrossHairInfo, { formatMethod, formatter } = radiusHair.label, { formatFunc, args } = getFormatFunction(formatMethod, formatter, label.text, {
      label: label.text,
      orient: "radius"
    });
    formatFunc ? label.text = formatFunc(...args) : label.defaultFormatter && (label.text = label.defaultFormatter(label.text));
  }
  return {
    angle: angleCrossHairInfo,
    radius: radiusCrossHairInfo
  };
};
var layoutAngleCrosshair = (angleHair, crosshairInfo) => {
  const { angle: angle2, innerRadius, radius, startAngle, endAngle, center: center2 } = crosshairInfo;
  let positionAttrs;
  return positionAttrs = "sector" === ("rect" === angleHair.type ? "sector" : "line") ? {
    center: center2,
    innerRadius,
    radius,
    startAngle,
    endAngle
  } : {
    start: polarToCartesian(center2, innerRadius, angle2),
    end: polarToCartesian(center2, radius, angle2)
  }, positionAttrs;
};
var layoutRadiusCrosshair = (radiusHair, crosshairInfo) => {
  const { center: center2, startAngle, endAngle, distance: distance2, sides, axis: axis2, point: point5, radius, innerRadius } = crosshairInfo;
  let polygonRadius = distance2;
  if ("polygon" === (radiusHair.smooth ? "circle" : "polygon")) {
    const axisCenter = axis2.getCenter(), curAngle = getAngleByPoint(axisCenter, point5), stepAngle = (endAngle - startAngle) / sides, index = Math.floor((curAngle - startAngle) / stepAngle), preAngle = index * stepAngle + startAngle, nextAngle = Math.min((index + 1) * stepAngle + startAngle, endAngle), prePoint = polarToCartesian(axisCenter, distance2, preAngle), nextPoint = polarToCartesian(axisCenter, distance2, nextAngle), insertPoint = getIntersectPoint([nextPoint.x, nextPoint.y], [prePoint.x, prePoint.y], [axisCenter.x, axisCenter.y], [point5.x, point5.y]);
    insertPoint && (polygonRadius = clamp_default(PointService.distancePN(point5, insertPoint[0], insertPoint[1]) + distance2, innerRadius, radius));
  }
  return {
    center: center2,
    startAngle,
    endAngle,
    radius: polygonRadius,
    sides
  };
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/crosshair/polar
var PolarCrossHair = class extends BaseCrossHair {
  static getSpecInfo(chartSpec) {
    const crosshairSpec = chartSpec[this.specKey];
    if (isNil_default(crosshairSpec))
      return;
    if (!isArray_default(crosshairSpec))
      return crosshairSpec.categoryField || crosshairSpec.valueField ? [{
        spec: crosshairSpec,
        specPath: [this.specKey],
        specInfoPath: ["component", this.specKey, 0],
        type: ComponentTypeEnum.polarCrosshair
      }] : void 0;
    const specInfos = [];
    return crosshairSpec.forEach((s2, i) => {
      (s2.categoryField || s2.valueField) && specInfos.push({
        spec: s2,
        specPath: [this.specKey, i],
        specInfoPath: ["component", this.specKey, i],
        type: ComponentTypeEnum.polarCrosshair
      });
    }), specInfos;
  }
  constructor(spec, options) {
    super(spec, options), this.type = ComponentTypeEnum.polarCrosshair, this.name = ComponentTypeEnum.polarCrosshair, this._currValueAngle = /* @__PURE__ */ new Map(), this._currValueRadius = /* @__PURE__ */ new Map();
  }
  _showDefaultCrosshairBySpec() {
    const { categoryField, valueField } = this._spec;
    if ((null == categoryField ? void 0 : categoryField.visible) && categoryField.defaultSelect) {
      const { axisIndex, datum } = categoryField.defaultSelect;
      this._defaultCrosshair(axisIndex, datum, 1);
    }
    if ((null == valueField ? void 0 : valueField.visible) && valueField.defaultSelect) {
      const { axisIndex, datum } = valueField.defaultSelect;
      this._defaultCrosshair(axisIndex, datum, 2);
    }
  }
  _defaultCrosshair(axisIndex, datum, tag) {
    const axis2 = this._option.getComponentsByKey("axes").find((c3) => c3.getSpecIndex() === axisIndex);
    if (axis2) {
      if (1 === tag) {
        this._currValueAngle.clear();
        const polarCoord = {
          angle: axis2.valueToPosition(datum),
          radius: axis2.getOuterRadius()
        }, canvasPosition = axis2.coordToPoint(polarCoord);
        this._currValueAngle.set(axisIndex, this._getValueByAxis(axis2, canvasPosition));
      } else {
        this._currValueRadius.clear();
        const polarCoord = {
          angle: axis2.startAngle,
          radius: axis2.valueToPosition(datum)
        }, canvasPosition = axis2.coordToPoint(polarCoord);
        this._currValueRadius.set(axisIndex, this._getValueByAxis(axis2, canvasPosition));
      }
      this.layoutByValue(3);
    }
  }
  hide() {
    this._radiusCrosshair && this._radiusCrosshair.hideAll(), this._radiusLabelCrosshair && this._radiusLabelCrosshair.hideAll(), this._angleCrosshair && this._angleCrosshair.hideAll(), this._angleLabelCrosshair && this._angleLabelCrosshair.hideAll();
  }
  _findAllAxisContains(relativeX, relativeY) {
    const angleAxisMap = this._getAxisInfoByField("category"), radiusAxisMap = this._getAxisInfoByField("value");
    return {
      angleAxisMap: this._filterAxisByPoint(angleAxisMap, relativeX, relativeY),
      radiusAxisMap: this._filterAxisByPoint(radiusAxisMap, relativeX, relativeY)
    };
  }
  _getAllAxisValues(axisMap, point5, currValue) {
    let discrete = false;
    return axisMap.forEach((item) => {
      isDiscrete(item.axis.getScale().type) && (discrete ? this.enable = false : discrete = true);
    }), !!this.enable && (axisMap.forEach((item, id2) => {
      const axis2 = item.axis;
      currValue.set(id2, this._getValueByAxis(axis2, point5));
    }), true);
  }
  _getValueByAxis(axis2, point5) {
    const { x: axisStartX, y: axisStartY } = axis2.getLayoutStartPoint(), { x, y } = this.getLayoutStartPoint(), value = axis2.positionToData({
      x: point5.x - (axisStartX - x),
      y: point5.y - (axisStartY - y)
    }), center2 = {
      x: axis2.getCenter().x + this.getLayoutStartPoint().x,
      y: axis2.getCenter().y + this.getLayoutStartPoint().y
    };
    return {
      value,
      axis: axis2,
      center: center2,
      innerRadius: axis2.getInnerRadius(),
      radius: axis2.getOuterRadius(),
      startAngle: axis2.startAngle,
      endAngle: axis2.endAngle,
      distance: PointService.distancePP(point5, axis2.getCenter()),
      coord: axis2.pointToCoord(point5),
      point: point5
    };
  }
  _layoutCrosshair(relativeX, relativeY, tooltipData, activeType) {
    let x = relativeX, y = relativeY;
    if (tooltipData && tooltipData.length) {
      if ("dimension" === activeType) {
        const dimensionInfo = tooltipData[0];
        if (dimensionInfo.axis) {
          const triggerCoord = dimensionInfo.axis.pointToCoord({
            x,
            y
          }), coord = "radius" === dimensionInfo.axis.getOrient() ? {
            radius: dimensionInfo.position,
            angle: triggerCoord.angle
          } : {
            radius: triggerCoord.radius,
            angle: dimensionInfo.position
          }, uniformPos = dimensionInfo.axis.coordToPoint(coord);
          x = uniformPos.x, y = uniformPos.y;
        }
      } else if ("mark" === activeType) {
        const dimensionData = tooltipData[0], pos = dimensionData.series.dataToPosition(dimensionData.datum[0]);
        x = pos.x, y = pos.y;
      }
    }
    const { angleAxisMap, radiusAxisMap } = this._findAllAxisContains(x, y);
    if (0 !== angleAxisMap.size || 0 !== radiusAxisMap.size)
      this._currValueAngle.clear(), this._currValueRadius.clear(), angleAxisMap && this._getAllAxisValues(angleAxisMap, {
        x,
        y
      }, this._currValueAngle), radiusAxisMap && this._getAllAxisValues(radiusAxisMap, {
        x,
        y
      }, this._currValueRadius), this.layoutByValue(3);
    else {
      if (this.enableRemain)
        return;
      this.hide();
    }
  }
  layoutByValue(tag = 3) {
    if (!this.enable)
      return;
    const series2 = getFirstSeries(this._regions, "polar");
    if (!series2)
      return;
    const { angle: angle2, radius } = layoutByValue2(series2, this._currValueAngle, this._currValueRadius, this._angleHair, this._radiusHair, this.enableRemain, this._cacheAngleCrossHairInfo, this._cacheRadiusCrossHairInfo);
    this.enableRemain && (this._cacheAngleCrossHairInfo = Object.assign(Object.assign({}, angle2), {
      _isCache: true
    }), this._cacheRadiusCrossHairInfo = Object.assign(Object.assign({}, radius), {
      _isCache: true
    })), tag && (this._layoutRadius(radius), this._layoutAngle(angle2));
  }
  _layoutAngle(crosshairInfo) {
    var _a;
    if (crosshairInfo._isCache && this.enableRemain)
      return;
    const container2 = this.getContainer(), { angle: angle2, radius, label, center: center2, visible } = crosshairInfo;
    if (visible) {
      const crosshairType = "rect" === this._angleHair.type ? "sector" : "line", positionAttrs = layoutAngleCrosshair(this._angleHair, crosshairInfo);
      if (this._angleCrosshair)
        this._angleCrosshair.setAttributes(positionAttrs);
      else {
        let crosshair2;
        "line" === crosshairType ? crosshair2 = new LineCrosshair(Object.assign(Object.assign({}, positionAttrs), {
          lineStyle: this._angleHair.style,
          zIndex: this.gridZIndex,
          pickable: false
        })) : "sector" === crosshairType && (crosshair2 = new SectorCrosshair(Object.assign(Object.assign({}, positionAttrs), {
          sectorStyle: this._angleHair.style,
          zIndex: this.gridZIndex,
          pickable: false
        }))), this._angleCrosshair = crosshair2, container2.add(crosshair2);
      }
      if (label.visible) {
        const orient = angleLabelOrientAttribute(angle2), labelAttrs = Object.assign(Object.assign(Object.assign(Object.assign({}, polarToCartesian(center2, radius + label.offset, angle2)), this._angleHair.label), label), {
          textStyle: Object.assign(Object.assign({}, null === (_a = this._angleHair.label) || void 0 === _a ? void 0 : _a.textStyle), {
            textAlign: orient.align,
            textBaseline: orient.baseline
          }),
          zIndex: this.labelZIndex
        });
        this._updateCrosshairLabel(this._angleLabelCrosshair, labelAttrs, (label2) => {
          label2.name = "crosshair-angle-label", this._angleLabelCrosshair = label2;
        });
      } else
        this._angleLabelCrosshair && this._angleLabelCrosshair.hideAll();
    }
  }
  _layoutRadius(crosshairInfo) {
    var _a;
    if (crosshairInfo._isCache && this.enableRemain)
      return;
    const { center: center2, startAngle, label, visible } = crosshairInfo, container2 = this.getContainer();
    if (visible) {
      const crosshairType = this._radiusHair.smooth ? "circle" : "polygon", positionAttrs = layoutRadiusCrosshair(this._radiusHair, crosshairInfo), polygonRadius = positionAttrs.radius;
      if (this._radiusCrosshair)
        this._radiusCrosshair.setAttributes(positionAttrs);
      else {
        let crosshair2;
        crosshair2 = "polygon" === crosshairType ? new PolygonCrosshair(Object.assign(Object.assign({}, positionAttrs), {
          lineStyle: this._radiusHair.style,
          zIndex: this.gridZIndex + 1
        })) : new CircleCrosshair(Object.assign(Object.assign({}, positionAttrs), {
          lineStyle: this._radiusHair.style,
          zIndex: this.gridZIndex
        })), this._radiusCrosshair = crosshair2, container2.add(crosshair2);
      }
      if (label.visible) {
        const orient = radiusLabelOrientAttribute(startAngle), labelAttrs = Object.assign(Object.assign(Object.assign(Object.assign({}, polarToCartesian(center2, polygonRadius, startAngle)), this._radiusHair.label), label), {
          textStyle: Object.assign(Object.assign({}, null === (_a = this._radiusHair.label) || void 0 === _a ? void 0 : _a.textStyle), {
            textAlign: orient.align,
            textBaseline: orient.baseline
          }),
          zIndex: this.labelZIndex
        });
        this._updateCrosshairLabel(this._radiusLabelCrosshair, labelAttrs, (label2) => {
          label2.name = "crosshair-radius-label", this._radiusLabelCrosshair = label2;
        });
      } else
        this._radiusLabelCrosshair && this._radiusLabelCrosshair.hideAll();
    }
  }
  _parseFieldInfo() {
    var _a;
    const { categoryField, valueField } = this._spec;
    categoryField && categoryField.visible && (this._angleHair = this._parseField(categoryField, "categoryField")), valueField && valueField.visible && (this._radiusHair = this._parseField(valueField, "valueField"), this._radiusHair.smooth = null === (_a = null == valueField ? void 0 : valueField.line) || void 0 === _a ? void 0 : _a.smooth);
  }
  _updateCrosshairLabel(label, labelAttrs, callback) {
    const container2 = this.getContainer();
    label ? label.setAttributes(labelAttrs) : (label = new Tag(labelAttrs), null == container2 || container2.add(label), callback(label)), limitTagInBounds(label, this._getLimitBounds());
  }
  _getNeedClearVRenderComponents() {
    return [this._radiusCrosshair, this._radiusLabelCrosshair, this._angleCrosshair, this._angleLabelCrosshair];
  }
};
PolarCrossHair.specKey = "crosshair", PolarCrossHair.type = ComponentTypeEnum.polarCrosshair;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/player/utils/transform
var rectToAttribute = (markSpec) => {
  const result2 = Object.assign({}, markSpec);
  return transformToGraphic(result2);
};
var symbolToAttribute = (markSpec) => {
  const result2 = Object.assign({}, markSpec);
  return transformToGraphic(result2);
};
var baseToAttribute = (spec) => Object.assign(Object.assign({}, spec), {
  style: Object.assign({}, transformToGraphic(spec.style))
});
var transformToAttrs = (spec) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
  const trackStyle = rectToAttribute(null !== (_b = null === (_a = null == spec ? void 0 : spec.slider) || void 0 === _a ? void 0 : _a.trackStyle) && void 0 !== _b ? _b : {}), railStyle = rectToAttribute(null !== (_d = null === (_c = null == spec ? void 0 : spec.slider) || void 0 === _c ? void 0 : _c.railStyle) && void 0 !== _d ? _d : {}), handlerStyle = symbolToAttribute(null !== (_f = null === (_e = null == spec ? void 0 : spec.slider) || void 0 === _e ? void 0 : _e.handlerStyle) && void 0 !== _f ? _f : {}), start = baseToAttribute(null !== (_h = null === (_g = null == spec ? void 0 : spec.controller) || void 0 === _g ? void 0 : _g.start) && void 0 !== _h ? _h : {}), pause = baseToAttribute(null !== (_k = null === (_j = null == spec ? void 0 : spec.controller) || void 0 === _j ? void 0 : _j.pause) && void 0 !== _k ? _k : {}), backward = baseToAttribute(null !== (_m = null === (_l = null == spec ? void 0 : spec.controller) || void 0 === _l ? void 0 : _l.backward) && void 0 !== _m ? _m : {}), forward = baseToAttribute(null !== (_p = null === (_o = null == spec ? void 0 : spec.controller) || void 0 === _o ? void 0 : _o.forward) && void 0 !== _p ? _p : {}), attrs = Object.assign(Object.assign({}, spec), {
    direction: spec.direction,
    interval: spec.interval,
    visible: spec.visible,
    orient: null !== (_q = spec.orient) && void 0 !== _q ? _q : "bottom",
    slider: Object.assign(Object.assign({}, spec.slider), {
      trackStyle,
      railStyle,
      handlerStyle
    }),
    controller: Object.assign(Object.assign({}, spec.controller), {
      start,
      pause,
      backward,
      forward
    })
  });
  return spec.visible || (attrs.controller.visible = false, attrs.slider.visible = false), attrs;
};
var transformContinuousSpecToAttrs = (spec, data) => Object.assign(Object.assign({}, transformToAttrs(spec)), {
  data,
  type: "continuous"
});
var transformDiscreteSpecToAttrs = (spec, data) => Object.assign(Object.assign({}, transformToAttrs(spec)), {
  data,
  type: "discrete"
});

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/player/utils/orient
var isVertical2 = (orient) => "left" === orient || "right" === orient;
var isHorizontal2 = (orient) => "top" === orient || "bottom" === orient;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/player/player
var Player = class extends BaseComponent {
  constructor() {
    super(...arguments), this.layoutZIndex = LayoutZIndex.Player, this.layoutLevel = LayoutLevel.Player, this.specKey = "player", this.type = ComponentTypeEnum.player, this._orient = "bottom", this._getPlayerAttrs = () => {
      var _a, _b, _c, _d, _e, _f;
      const type = this._spec.type, layoutAttrs = {
        size: {
          width: this._width,
          height: this._height
        },
        dx: null !== (_a = this._spec.dx) && void 0 !== _a ? _a : 0 + this._dx,
        dy: null !== (_b = this._spec.dy) && void 0 !== _b ? _b : 0 + this._dy
      };
      return "discrete" === type ? Object.assign(Object.assign(Object.assign({}, transformDiscreteSpecToAttrs(this._spec, this._specs)), layoutAttrs), {
        disableTriggerEvent: this._option.disableTriggerEvent,
        loop: null === (_d = null === (_c = this._spec) || void 0 === _c ? void 0 : _c.loop) || void 0 === _d || _d
      }) : Object.assign(Object.assign(Object.assign({}, transformContinuousSpecToAttrs(this._spec, this._specs)), layoutAttrs), {
        disableTriggerEvent: this._option.disableTriggerEvent,
        loop: null === (_f = null === (_e = this._spec) || void 0 === _e ? void 0 : _e.loop) || void 0 === _f || _f
      });
    }, this._createOrUpdatePlayerComponent = () => {
      const attrs = Object.assign({}, this._getPlayerAttrs()), container2 = this.getContainer();
      this._playerComponent ? isEqual(attrs, this._cacheAttrs) || (this._cacheAttrs = attrs, this._playerComponent.setAttributes(attrs), this._playerComponent._initAttributes(), this._playerComponent.render()) : ("discrete" === attrs.type ? this._playerComponent = new DiscretePlayer(attrs) : this._playerComponent = new ContinuousPlayer(attrs), this._cacheAttrs = attrs, this._playerComponent.name = "player", container2.add(this._playerComponent), this._initEvent());
    }, this._maxSize = () => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      return Math.max(...array(null === (_b = null === (_a = this._spec.controller.start) || void 0 === _a ? void 0 : _a.style) || void 0 === _b ? void 0 : _b.size), ...array(null === (_d = null === (_c = this._spec.controller.pause) || void 0 === _c ? void 0 : _c.style) || void 0 === _d ? void 0 : _d.size), ...array(null === (_f = null === (_e = this._spec.controller.backward) || void 0 === _e ? void 0 : _e.style) || void 0 === _f ? void 0 : _f.size), ...array(null === (_h = null === (_g = this._spec.controller.forward) || void 0 === _g ? void 0 : _g.style) || void 0 === _h ? void 0 : _h.size), null !== (_j = isVertical2(this._orient) ? this._spec.slider.railStyle.width : this._spec.slider.railStyle.height) && void 0 !== _j ? _j : 10);
    }, this._sliderExceededSize = () => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j;
      const sliderHeight = null !== (_a = isVertical2(this._orient) ? this._spec.slider.railStyle.width : this._spec.slider.railStyle.height) && void 0 !== _a ? _a : 10, controllersHeight = Math.max(...array(null === (_c = null === (_b = this._spec.controller.start) || void 0 === _b ? void 0 : _b.style) || void 0 === _c ? void 0 : _c.size), ...array(null === (_e = null === (_d = this._spec.controller.pause) || void 0 === _d ? void 0 : _d.style) || void 0 === _e ? void 0 : _e.size), ...array(null === (_g = null === (_f = this._spec.controller.backward) || void 0 === _f ? void 0 : _f.style) || void 0 === _g ? void 0 : _g.size), ...array(null === (_j = null === (_h = this._spec.controller.forward) || void 0 === _h ? void 0 : _h.style) || void 0 === _j ? void 0 : _j.size));
      return sliderHeight >= controllersHeight ? sliderHeight - controllersHeight : 0;
    }, this._initEvent = () => {
      this._option.disableTriggerEvent || (this._option.globalInstance.on(ChartEvent.rendered, () => {
        var _a;
        (null === (_a = this._spec) || void 0 === _a ? void 0 : _a.auto) && this._playerComponent.play();
      }), this._playerComponent.addEventListener(PlayerEventEnum.end, () => {
        var _a;
        this.event.emit(ChartEvent.playerEnd, {
          model: this
        }), this._alternate && "discrete" === this._spec.type && (this._direction = "default" === this._direction ? "reverse" : "default", this._playerComponent.setAttributes({
          direction: this._direction,
          dataIndex: "reverse" === this._direction ? this._specs.length - 2 : 1
        })), (null === (_a = this._spec) || void 0 === _a ? void 0 : _a.loop) && this._playerComponent.play();
      }), this._playerComponent.addEventListener(PlayerEventEnum.change, (e) => {
        const { index } = e.detail, spec = this._specs[index];
        array(spec.data).forEach((data) => {
          var _a, _b;
          null === (_b = null === (_a = this._option) || void 0 === _a ? void 0 : _a.globalInstance) || void 0 === _b || _b.updateData(data.id, data.values);
        }), this.event.emit(ChartEvent.playerChange, {
          model: this,
          value: {
            spec,
            index,
            specs: this._specs
          }
        });
      }), this._playerComponent.addEventListener(PlayerEventEnum.backward, (e) => {
        const { index } = e.detail, spec = this._specs[index];
        this.event.emit(ChartEvent.playerBackward, {
          model: this,
          value: {
            spec,
            index,
            specs: this._specs
          }
        });
      }), this._playerComponent.addEventListener(PlayerEventEnum.forward, (e) => {
        const { index } = e.detail, spec = this._specs[index];
        this.event.emit(ChartEvent.playerForward, {
          model: this,
          value: {
            spec,
            index,
            specs: this._specs
          }
        });
      }), this._playerComponent.addEventListener(PlayerEventEnum.play, (e) => {
        const { index } = e.detail, spec = this._specs[index];
        this.event.emit(ChartEvent.playerPlay, {
          model: this,
          value: {
            spec,
            index,
            specs: this._specs
          }
        });
      }), this._playerComponent.addEventListener(PlayerEventEnum.pause, (e) => {
        const { index } = e.detail, spec = this._specs[index];
        this.event.emit(ChartEvent.playerPause, {
          model: this,
          value: {
            spec,
            index,
            specs: this._specs
          }
        });
      }));
    };
  }
  get orient() {
    return this._orient;
  }
  set layoutOrient(v) {
    this._orient = v;
  }
  static getSpecInfo(chartSpec) {
    const playerSpec = chartSpec[this.specKey];
    return isNil_default(playerSpec) ? null : [{
      spec: playerSpec,
      specPath: [this.specKey],
      specInfoPath: ["component", this.specKey, 0],
      type: ComponentTypeEnum.player
    }];
  }
  setAttrFromSpec() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    super.setAttrFromSpec(), this._orient = null !== (_a = this._spec.orient) && void 0 !== _a ? _a : "bottom", this._specs = null !== (_b = this._spec.specs) && void 0 !== _b ? _b : [], this._direction = null !== (_c = this._spec.direction) && void 0 !== _c ? _c : "default", this._alternate = null !== (_d = this._spec.alternate) && void 0 !== _d && _d, this._dx = null !== (_e = this._spec.dx) && void 0 !== _e ? _e : 0, this._dy = null !== (_f = this._spec.dy) && void 0 !== _f ? _f : 0, this._position = null !== (_g = this._spec.position) && void 0 !== _g ? _g : "middle", this._visible = null === (_h = this._spec.visible) || void 0 === _h || _h;
  }
  afterSetLayoutStartPoint(pos) {
    if (super.afterSetLayoutStartPoint(pos), isValidNumber_default(pos.x)) {
      const offsetX = isVertical2(this._orient) ? pos.x + this._sliderExceededSize() / 2 : pos.x;
      this._playerComponent && this._playerComponent.setAttribute("x", offsetX);
    }
    if (isValidNumber_default(pos.y)) {
      const offsetY = isHorizontal2(this._orient) ? pos.y + this._sliderExceededSize() / 2 : pos.y;
      this._playerComponent && this._playerComponent.setAttribute("y", offsetY);
    }
  }
  getBoundsInRect(rect, fullSpace) {
    this._width = this._computeWidth(rect), this._height = this._computeHeight(rect), this._dx = this._computeDx(fullSpace), this._dy = this._computeDy(fullSpace);
    const bounds = this._computeLayoutRect(rect, this._width, this._height);
    return this._createOrUpdatePlayerComponent(), bounds;
  }
  changeRegions(regions) {
  }
  onRender(ctx) {
  }
  _getNeedClearVRenderComponents() {
    return [this._playerComponent];
  }
  _computeLayoutRect(rect, width, height) {
    if (false === this._visible)
      return {
        x1: 0,
        x2: 0,
        y1: 0,
        y2: 0
      };
    switch (this._orient) {
      case "top":
      case "left":
        return {
          x1: 0,
          y1: 0,
          x2: width,
          y2: height
        };
      case "right":
        return {
          x1: rect.width - width,
          y1: 0,
          x2: rect.width,
          y2: rect.height
        };
      default:
        return {
          x1: 0,
          y1: rect.height - height,
          x2: rect.width,
          y2: rect.height
        };
    }
  }
  _computeWidth(rect) {
    return isNumber_default(this._spec.width) ? Math.min(rect.width, Number(this._spec.width)) : isVertical2(this._orient) ? this._maxSize() : rect.width;
  }
  _computeHeight(rect) {
    return isNumber_default(this._spec.height) ? (this._height = this._spec.height, Math.min(rect.height, Number(this._spec.height))) : isHorizontal2(this._orient) ? this._maxSize() : rect.height;
  }
  _computeDx(rect) {
    return isVertical2(this._orient) || "start" === this._position ? 0 : "middle" === this._position ? (rect.width - this._width) / 2 : rect.width - this._width;
  }
  _computeDy(rect) {
    return isHorizontal2(this._orient) || "start" === this._position ? 0 : "middle" === this._position ? (rect.height - this._height) / 2 : rect.height - this._height;
  }
};
Player.specKey = "player", Player.type = ComponentTypeEnum.player;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/constant/marker
var AGGR_TYPE = ["sum", "average", "min", "max", "variance", "standardDeviation", "median"];

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/marker/utils
var __rest20 = function(s2, e) {
  var t = {};
  for (var p in s2)
    Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++)
      e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
function isNeedExtendDomain(domain, datum, autoRange) {
  if (!autoRange)
    return false;
  const domainNum = domain.map((n) => 1 * n), min3 = minInArray(domainNum), max3 = maxInArray(domainNum);
  return datum < min3 || datum > max3;
}
function getXValue(datum, xDomain, autoRange, refSeries, regionWidth, regionStartLayoutStartPoint) {
  var _a, _b;
  const { relativeSeries } = refSeries;
  let x;
  return isNumber_default(datum.x) && isNeedExtendDomain(xDomain, datum.x, autoRange) && (null === (_b = null == relativeSeries ? void 0 : (_a = relativeSeries.getXAxisHelper()).setExtendDomain) || void 0 === _b || _b.call(_a, "marker_xAxis_extend", datum.x)), x = isPercent(datum.x) ? convertPercentToValue(datum.x, regionWidth) + regionStartLayoutStartPoint.x : relativeSeries.getXAxisHelper().dataToPosition([datum.x]) + regionStartLayoutStartPoint.x, x;
}
function getYValue(datum, yDomain, autoRange, refSeries, regionHeight, regionStartLayoutStartPoint) {
  var _a, _b;
  const { relativeSeries } = refSeries;
  let y;
  return isNumber_default(datum.y) && isNeedExtendDomain(yDomain, datum.y, autoRange) && (null === (_b = null === (_a = relativeSeries.getYAxisHelper()) || void 0 === _a ? void 0 : _a.setExtendDomain) || void 0 === _b || _b.call(_a, "marker_yAxis_extend", datum.y)), y = isPercent(datum.y) ? convertPercentToValue(datum.y, regionHeight) + regionStartLayoutStartPoint.y : relativeSeries.getYAxisHelper().dataToPosition([datum.y]) + regionStartLayoutStartPoint.y, y;
}
function getAngleValue(datum, angleDomain, autoRange, refSeries) {
  var _a, _b;
  const { relativeSeries } = refSeries;
  return isNumber_default(datum.angle) && isNeedExtendDomain(angleDomain, datum.angle, autoRange) && (null === (_b = null === (_a = relativeSeries.angleAxisHelper) || void 0 === _a ? void 0 : _a.setExtendDomain) || void 0 === _b || _b.call(_a, "marker_angleAxis_extend", datum.angle)), relativeSeries.angleAxisHelper.dataToPosition([datum.angle]);
}
function getRadiusValue(datum, radiusDomain, autoRange, refSeries) {
  var _a, _b;
  const { relativeSeries } = refSeries;
  return isNumber_default(datum.radius) && isNeedExtendDomain(radiusDomain, datum.radius, autoRange) && (null === (_b = null === (_a = relativeSeries.radiusAxisHelper) || void 0 === _a ? void 0 : _a.setExtendDomain) || void 0 === _b || _b.call(_a, "marker_radiusAxis_extend", datum.radius)), relativeSeries.radiusAxisHelper.dataToPosition([datum.radius]);
}
function convertPercentToValue(percent, relativeLength) {
  return Number(percent.substring(0, percent.length - 1)) * relativeLength / 100;
}
function isAggrSpec(spec) {
  return AGGR_TYPE.includes(spec);
}
function xyLayout(data, startRelativeSeries, endRelativeSeries, relativeSeries, autoRange) {
  const regionStart = startRelativeSeries.getRegion(), regionStartLayoutStartPoint = regionStart.getLayoutStartPoint(), regionEnd = endRelativeSeries.getRegion(), regionEndLayoutStartPoint = regionEnd.getLayoutStartPoint(), regionWidth = Math.abs(Math.min(regionStartLayoutStartPoint.x, regionEndLayoutStartPoint.x) - Math.max(regionStartLayoutStartPoint.x + regionStart.getLayoutRect().width, regionEndLayoutStartPoint.x + regionEnd.getLayoutRect().width)), regionHeight = Math.abs(Math.min(regionStartLayoutStartPoint.y, regionEndLayoutStartPoint.y) - Math.max(regionStartLayoutStartPoint.y + regionStart.getLayoutRect().height, regionEndLayoutStartPoint.y + regionEnd.getLayoutRect().height)), refSeries = {
    relativeSeries,
    startRelativeSeries,
    endRelativeSeries
  }, lines = [], dataPoints = data.latestData[0] && data.latestData[0].latestData ? data.latestData[0].latestData : data.latestData, xDomain = relativeSeries.getXAxisHelper().getScale(0).domain(), yDomain = relativeSeries.getYAxisHelper().getScale(0).domain();
  return dataPoints.forEach((datum) => {
    const isValidX = isValid_default(datum.x), isValidY = isValid_default(datum.y);
    if (isValidX && isValidY) {
      const x = getXValue(datum, xDomain, autoRange, refSeries, regionWidth, regionStartLayoutStartPoint), y = getYValue(datum, yDomain, autoRange, refSeries, regionHeight, regionStartLayoutStartPoint);
      lines.push([{
        x,
        y
      }]);
    } else if (isValidX) {
      const x = getXValue(datum, xDomain, autoRange, refSeries, regionWidth, regionStartLayoutStartPoint), y = Math.max(regionStartLayoutStartPoint.y + regionStart.getLayoutRect().height, regionEndLayoutStartPoint.y + regionEnd.getLayoutRect().height), y14 = Math.min(regionStartLayoutStartPoint.y, regionEndLayoutStartPoint.y);
      lines.push([{
        x,
        y
      }, {
        x,
        y: y14
      }]);
    } else if (isValidY) {
      const x = Math.min(regionStartLayoutStartPoint.x, regionEndLayoutStartPoint.x), y = getYValue(datum, yDomain, autoRange, refSeries, regionHeight, regionStartLayoutStartPoint), x14 = Math.max(regionStartLayoutStartPoint.x + regionStart.getLayoutRect().width, regionEndLayoutStartPoint.x + regionEnd.getLayoutRect().width);
      lines.push([{
        x,
        y
      }, {
        x: x14,
        y
      }]);
    }
  }), lines;
}
function polarLayout(data, startRelativeSeries, endRelativeSeries, relativeSeries, autoRange) {
  const refSeries = {
    relativeSeries,
    startRelativeSeries,
    endRelativeSeries
  }, lines = [], dataPoints = data.latestData[0] && data.latestData[0].latestData ? data.latestData[0].latestData : data.latestData, angleDomain = relativeSeries.angleAxisHelper.getScale(0).domain(), radiusDomain = relativeSeries.radiusAxisHelper.getScale(0).domain(), regionRadius = Math.min(relativeSeries.getRegion().getLayoutRect().width / 2, relativeSeries.getRegion().getLayoutRect().height / 2);
  return dataPoints.forEach((datum) => {
    const isValidAngle = isValid_default(datum.angle), isValidRadius = isValid_default(datum.radius);
    if (isValidAngle && isValidRadius) {
      const angle2 = getAngleValue(datum, angleDomain, autoRange, refSeries), radius = getRadiusValue(datum, radiusDomain, autoRange, refSeries);
      lines.push([{
        angle: angle2,
        radius
      }]);
    } else if (isValidAngle) {
      const angle2 = getAngleValue(datum, angleDomain, autoRange, refSeries);
      lines.push([{
        angle: angle2,
        radius: -regionRadius
      }, {
        angle: angle2,
        radius: regionRadius
      }]);
    } else if (isValidRadius) {
      const radius = getRadiusValue(datum, radiusDomain, autoRange, refSeries);
      lines.push([{
        radius,
        angle: 0
      }, {
        radius,
        angle: 2 * Math.PI
      }]);
    }
  }), lines;
}
function geoLayout(data, relativeSeries) {
  const lines = [];
  return (data.latestData[0] && data.latestData[0].latestData ? data.latestData[0].latestData : data.latestData).forEach((datum) => {
    isValid_default(datum.areaName) && lines.push([{
      x: relativeSeries.nameValueToPosition(datum.areaName).x + relativeSeries.getRegion().getLayoutStartPoint().x,
      y: relativeSeries.nameValueToPosition(datum.areaName).y + relativeSeries.getRegion().getLayoutStartPoint().y
    }]);
  }), lines;
}
function cartesianCoordinateLayout(data, relativeSeries, autoRange, coordinatesOffset) {
  const points = [], dataPoints = data.latestData[0] && data.latestData[0].latestData ? data.latestData[0].latestData : data.latestData, isArrayCoordinatesOffset = isArray_default(coordinatesOffset);
  return dataPoints.forEach((datum, index) => {
    var _a, _b, _c, _d;
    const refRelativeSeries = (null == datum ? void 0 : datum.getRefRelativeSeries) ? datum.getRefRelativeSeries() : relativeSeries, regionStart = refRelativeSeries.getRegion(), regionStartLayoutStartPoint = regionStart.getLayoutStartPoint(), { width: regionWidth, height: regionHeight } = regionStart.getLayoutRect();
    let offsetX = 0, offsetY = 0;
    if (coordinatesOffset) {
      const currentCoordinatesOffset = isArrayCoordinatesOffset ? coordinatesOffset[index] : coordinatesOffset, x = currentCoordinatesOffset.x, y = currentCoordinatesOffset.y;
      x && (offsetX = isPercent(x) ? Number(x.substring(0, x.length - 1)) * regionWidth / 100 : x), y && (offsetY = isPercent(y) ? Number(y.substring(0, y.length - 1)) * regionHeight / 100 : y);
    }
    const xDomain = refRelativeSeries.getXAxisHelper().getScale(0).domain(), yDomain = refRelativeSeries.getYAxisHelper().getScale(0).domain(), xValue = array(datum.x), yValue = array(datum.y);
    1 === xValue.length && isNumber_default(xValue[0]) && isNeedExtendDomain(xDomain, xValue[0], autoRange) && (null === (_b = null === (_a = refRelativeSeries.getXAxisHelper()) || void 0 === _a ? void 0 : _a.setExtendDomain) || void 0 === _b || _b.call(_a, "marker_xAxis_extend", xValue[0])), 1 === yValue.length && isNumber_default(yValue[0]) && isNeedExtendDomain(yDomain, yValue[0], autoRange) && (null === (_d = null === (_c = refRelativeSeries.getYAxisHelper()) || void 0 === _c ? void 0 : _c.setExtendDomain) || void 0 === _d || _d.call(_c, "marker_yAxis_extend", yValue[0])), points.push({
      x: refRelativeSeries.getXAxisHelper().dataToPosition(xValue) + regionStartLayoutStartPoint.x + offsetX,
      y: refRelativeSeries.getYAxisHelper().dataToPosition(yValue) + regionStartLayoutStartPoint.y + offsetY
    });
  }), points;
}
function polarCoordinateLayout(data, relativeSeries, autoRange) {
  const points = [];
  return (data.latestData[0] && data.latestData[0].latestData ? data.latestData[0].latestData : data.latestData).forEach((datum) => {
    var _a, _b, _c, _d;
    const refRelativeSeries = (null == datum ? void 0 : datum.getRefRelativeSeries) ? datum.getRefRelativeSeries() : relativeSeries, angleDomain = refRelativeSeries.angleAxisHelper.getScale(0).domain(), radiusDomain = refRelativeSeries.radiusAxisHelper.getScale(0).domain(), angleValue = array(datum.angle), radiusValue = array(datum.radius);
    1 === angleValue.length && isNumber_default(angleValue[0]) && isNeedExtendDomain(angleDomain, angleValue[0], autoRange) && (null === (_b = null === (_a = refRelativeSeries.angleAxisHelper) || void 0 === _a ? void 0 : _a.setExtendDomain) || void 0 === _b || _b.call(_a, "marker_xAxis_extend", angleValue[0])), 1 === radiusValue.length && isNumber_default(radiusValue[0]) && isNeedExtendDomain(radiusDomain, radiusValue[0], autoRange) && (null === (_d = null === (_c = refRelativeSeries.radiusAxisHelper) || void 0 === _c ? void 0 : _c.setExtendDomain) || void 0 === _d || _d.call(_c, "marker_yAxis_extend", radiusValue[0])), points.push({
      angle: refRelativeSeries.angleAxisHelper.dataToPosition(angleValue),
      radius: refRelativeSeries.radiusAxisHelper.dataToPosition(radiusValue)
    });
  }), points;
}
function positionLayout(positions, series2, regionRelative) {
  if (regionRelative) {
    const region = series2.getRegion(), { x: regionStartX, y: regionStartY } = region.getLayoutStartPoint(), { width: regionWidth, height: regionHeight } = region.getLayoutRect();
    return positions.map((position) => {
      let { x, y } = position;
      return isPercent(x) && (x = convertPercentToValue(x, regionWidth)), x += regionStartX, isPercent(y) && (y = convertPercentToValue(y, regionHeight)), y += regionStartY, {
        x,
        y
      };
    });
  }
  const { width: canvasWidth, height: canvasHeight } = series2.getOption().getChart().getViewRect();
  return positions.map((position) => {
    let { x, y } = position;
    return isPercent(x) && (x = convertPercentToValue(x, canvasWidth)), isPercent(y) && (y = convertPercentToValue(y, canvasHeight)), {
      x,
      y
    };
  });
}
function computeClipRange(regions) {
  let minX = 1 / 0, maxX = -1 / 0, minY = 1 / 0, maxY = -1 / 0;
  return regions.forEach((region) => {
    const regionPos = region.getLayoutStartPoint(), regionRect = region.getLayoutRect();
    regionPos.x < minX && (minX = regionPos.x), regionPos.x + regionRect.width > maxX && (maxX = regionPos.x + regionRect.width), regionPos.y < minY && (minY = regionPos.y), regionPos.y + regionRect.height > maxY && (maxY = regionPos.y + regionRect.height);
  }), {
    minX,
    maxX,
    minY,
    maxY
  };
}
function transformLabelAttributes(label, markerData) {
  const { labelBackground = {}, style, shape } = label, restLabel = __rest20(label, ["labelBackground", "style", "shape"]);
  if (false !== label.visible) {
    const labelAttrs = restLabel;
    return (null == shape ? void 0 : shape.visible) ? labelAttrs.shape = Object.assign({
      visible: true
    }, transformToGraphic(shape.style)) : labelAttrs.shape = {
      visible: false
    }, false !== labelBackground.visible ? (labelAttrs.panel = Object.assign({
      visible: true
    }, transformStyle(transformToGraphic(labelBackground.style), markerData)), isValid_default(labelBackground.padding) && (labelAttrs.padding = normalizePadding(labelBackground.padding))) : (labelAttrs.panel = {
      visible: false
    }, labelAttrs.padding = 0), style && (labelAttrs.textStyle = transformStyle(transformToGraphic(style), markerData)), labelAttrs;
  }
  return {
    visible: false
  };
}
function transformState(state, markerData) {
  for (const stateKey in state)
    isFunction_default(state[stateKey]) && (state[stateKey] = state[stateKey](markerData));
  return state;
}
function transformStyle(style, markerData) {
  return isFunction_default(style) ? style(markerData) : style;
}
function transformOffset(offset, region) {
  return isFunction_default(offset) ? offset(region) : offset;
}
function computeOffsetFromRegion(point5, offset, region) {
  return isValid_default(point5) ? "regionLeft" === offset ? region.getLayoutStartPoint().x - point5.x : "regionRight" === offset ? region.getLayoutStartPoint().x + region.getLayoutRect().width - point5.x : "regionTop" === offset ? region.getLayoutStartPoint().y - point5.y : "regionBottom" === offset ? region.getLayoutStartPoint().y + region.getLayoutRect().height - point5.y : offset : offset;
}
function getMarkLineProcessInfo(spec) {
  const isXProcess = "x" in spec, isYProcess = "y" in spec, isX1Process = "x1" in spec, isY1Process = "y1" in spec, isAngleProcess = "angle" in spec, isRadiusProcess = "radius" in spec, isAngle1Process = "angle1" in spec, isRadius1Process = "radius1" in spec;
  return {
    doXProcess: isXProcess && !isYProcess && !isY1Process,
    doXYY1Process: isXProcess && isYProcess && isY1Process,
    doYProcess: isYProcess && !isXProcess && !isX1Process,
    doYXX1Process: isYProcess && isXProcess && isX1Process,
    doXYProcess: isXProcess && isYProcess && isX1Process && isY1Process,
    doAngleProcess: isAngleProcess && !isAngle1Process && !isRadiusProcess && !isRadius1Process,
    doRadiusProcess: isRadiusProcess && !isRadius1Process && !isAngleProcess && !isAngle1Process,
    doAngRadRad1Process: isAngleProcess && !isAngle1Process && isRadiusProcess && isRadius1Process,
    doRadAngAng1Process: isRadiusProcess && isAngleProcess && isAngle1Process && !isRadius1Process,
    doRadAngProcess: isAngleProcess && isRadiusProcess && isAngle1Process && isRadius1Process,
    doCoordinatesProcess: "coordinates" in spec && (!("process" in spec) || "process" in spec && "xy" in spec.process)
  };
}
function getMarkAreaProcessInfo(spec) {
  const isXProcess = "x" in spec, isX1Process = "x1" in spec, isYProcess = "y" in spec, isY1Process = "y1" in spec, isAngleProcess = "angle" in spec, isRadiusProcess = "radius" in spec, isAngle1Process = "angle1" in spec, isRadius1Process = "radius1" in spec;
  return {
    doXProcess: isXProcess && isX1Process && !isYProcess && !isY1Process,
    doYProcess: isYProcess && isY1Process && !isXProcess && !isX1Process,
    doXYProcess: isXProcess && isX1Process && isYProcess && isY1Process,
    doAngleProcess: isAngleProcess && isAngle1Process && !isRadiusProcess && !isRadius1Process,
    doRadiusProcess: isRadiusProcess && isRadius1Process && !isAngleProcess && !isAngle1Process,
    doRadAngProcess: isAngleProcess && isRadiusProcess && isAngle1Process && isRadius1Process,
    doCoordinatesProcess: "coordinates" in spec
  };
}
function getMarkPointProcessInfo(spec) {
  return {
    doXYProcess: isValid_default(spec.x) && isValid_default(spec.y),
    doPolarProcess: isValid_default(spec.angle) && isValid_default(spec.radius),
    doGeoProcess: isValid_default(spec.areaName)
  };
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/marker/mark-line/util
function getInsertPoints(start, end, direction2, offset = 0) {
  const points = [], dy = start.y - end.y, dx = start.x - end.x;
  switch (direction2) {
    case "top":
      points.push(start), points.push({
        x: start.x,
        y: dy > 0 ? start.y - offset - Math.abs(dy) : start.y - offset
      }), points.push({
        x: end.x,
        y: dy > 0 ? end.y - offset : end.y - offset - Math.abs(dy)
      }), points.push(end);
      break;
    case "bottom":
      points.push(start), points.push({
        x: start.x,
        y: dy < 0 ? start.y + offset + Math.abs(dy) : start.y + offset
      }), points.push({
        x: end.x,
        y: dy < 0 ? end.y + offset : end.y + offset + Math.abs(dy)
      }), points.push(end);
      break;
    case "left":
      points.push(start), points.push({
        x: dx > 0 ? start.x - offset - Math.abs(dx) : start.x - offset,
        y: start.y
      }), points.push({
        x: dx > 0 ? end.x - offset : end.x - offset - Math.abs(dx),
        y: end.y
      }), points.push(end);
      break;
    case "right":
      points.push(start), points.push({
        x: dx > 0 ? start.x + offset : start.x + offset + Math.abs(dx),
        y: start.y
      }), points.push({
        x: dx > 0 ? end.x + offset + Math.abs(dx) : end.x + offset,
        y: end.y
      }), points.push(end);
  }
  return points;
}
function getTextOffset(start, end, direction2, offset = 0) {
  const dy = start.y - end.y, dx = start.x - end.x;
  return "bottom" === direction2 ? {
    dx: dx > 0 ? -dx / 2 : Math.abs(dx / 2),
    dy: dy > 0 ? offset : Math.abs(dy) + offset
  } : "top" === direction2 ? {
    dx: dx > 0 ? -Math.abs(dx / 2) : +Math.abs(dx / 2),
    dy: dy > 0 ? -(Math.abs(dy) + offset) : -offset
  } : "left" === direction2 ? {
    dx: dx > 0 ? -dx - offset : -offset,
    dy: dy > 0 ? -dy / 2 : Math.abs(dy / 2)
  } : "right" === direction2 ? {
    dx: dx > 0 ? offset : Math.abs(dx) + offset,
    dy: dy > 0 ? -dy / 2 : Math.abs(dy / 2)
  } : {};
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/data/transforms/aggregation
var markerMin = (_data, opt) => {
  const data = _data[0].latestData;
  return min2(data, opt.field);
};
var markerMax = (_data, opt) => {
  const data = _data[0].latestData;
  return max2(data, opt.field);
};
function markerSum(_data, opt) {
  const data = _data[0].latestData;
  return sum2(data, opt.field);
}
function markerAverage(_data, opt) {
  const data = _data[0].latestData;
  return average(data, opt.field);
}
function markerVariance(_data, opt) {
  const data = _data[0].latestData;
  return variance(data, opt.field);
}
function markerStandardDeviation(_data, opt) {
  const data = _data[0].latestData;
  return standardDeviation(data, opt.field);
}
function markerMedian(_data, opt) {
  const data = _data[0].latestData;
  return median2(data, opt.field);
}
function markerAggregation(_data, options) {
  const results = [];
  return options.forEach((option) => {
    const result2 = {
      x: null,
      y: null,
      angle: null,
      radius: null,
      areaName: null
    };
    if (isValid_default(option.x)) {
      const x = option.x;
      isArray_default(x) ? result2.x = x.map((item) => getFinalValue(item, _data, option)) : result2.x = getFinalValue(x, _data, option);
    }
    if (isValid_default(option.y)) {
      const y = option.y;
      isArray_default(y) ? result2.y = y.map((item) => getFinalValue(item, _data, option)) : result2.y = getFinalValue(y, _data, option);
    }
    if (isValid_default(option.angle)) {
      const angle2 = option.angle;
      isArray_default(angle2) ? result2.angle = angle2.map((item) => getFinalValue(item, _data, option)) : result2.angle = getFinalValue(angle2, _data, option);
    }
    if (isValid_default(option.radius)) {
      const radius = option.radius;
      isArray_default(radius) ? result2.radius = radius.map((item) => getFinalValue(item, _data, option)) : result2.radius = getFinalValue(radius, _data, option);
    }
    if (isValid_default(option.areaName)) {
      const name = option.areaName;
      result2.areaName = getFinalValue(name, _data, option);
    }
    option.getRefRelativeSeries && (result2.getRefRelativeSeries = option.getRefRelativeSeries), results.push(result2);
  }), results;
}
var aggrMap = {
  min: markerMin,
  max: markerMax,
  sum: markerSum,
  average: markerAverage,
  variance: markerVariance,
  standardDeviation: markerStandardDeviation,
  median: markerMedian
};
function getFinalValue(source, _data, option) {
  const relativeSeries = option.getRelativeSeries(), startSeries = option.getStartRelativeSeries(), endSeries = option.getEndRelativeSeries(), relativeSeriesData = relativeSeries.getData().getLatestData(), startRelativeSeriesData = startSeries.getData().getLatestData(), endRelativeSeriesData = endSeries.getData().getLatestData();
  if (isFunction_default(source))
    return source(relativeSeriesData, startRelativeSeriesData, endRelativeSeriesData, relativeSeries, startSeries, endSeries);
  if (isPlainObject_default(source)) {
    const { aggrType, field: field3 } = source;
    return aggrMap[aggrType](_data, {
      field: field3
    });
  }
  return source;
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/marker/base-marker
var BaseMarker = class extends BaseComponent {
  constructor() {
    super(...arguments), this.layoutType = "none", this._layoutOffsetX = 0, this._layoutOffsetY = 0;
  }
  getRelativeSeries() {
    return this._relativeSeries;
  }
  getMarkerData() {
    return this._markerData;
  }
  static _getMarkerCoordinateType(markerSpec) {
    return "cartesian";
  }
  static getSpecInfo(chartSpec) {
    const markerSpec = chartSpec[this.specKey];
    if (isEmpty_default(markerSpec))
      return;
    if (!isArray_default(markerSpec) && false !== markerSpec.visible && this._getMarkerCoordinateType(markerSpec) === this.coordinateType)
      return [{
        spec: markerSpec,
        specPath: [this.specKey],
        specInfoPath: ["component", this.specKey, 0],
        type: this.type
      }];
    const specInfos = [];
    return array(markerSpec).forEach((m4, i) => {
      false !== m4.visible && this._getMarkerCoordinateType(m4) === this.coordinateType && specInfos.push({
        spec: m4,
        specPath: [this.specKey, i],
        specInfoPath: ["component", this.specKey, i],
        type: this.type
      });
    }), specInfos;
  }
  created() {
    super.created(), this._bindSeries(), this._initDataView(), this.initEvent();
  }
  _getAllRelativeSeries() {
    return {
      getRelativeSeries: () => this._relativeSeries,
      getStartRelativeSeries: () => this._startRelativeSeries,
      getEndRelativeSeries: () => this._endRelativeSeries
    };
  }
  _getFieldInfoFromSpec(dim, spec, relativeSeries) {
    const specKeyByDim = {
      x: "xField",
      y: "yField",
      radius: "valueField",
      angle: "categoryField",
      areaName: "nameField"
    };
    return isString_default(spec) && isAggrSpec(spec) ? {
      field: relativeSeries.getSpec()[specKeyByDim[dim]],
      aggrType: spec
    } : spec;
  }
  _processSpecByDims(dimSpec) {
    const relativeSeries = this._relativeSeries, dimMap = {};
    return dimSpec.forEach((d) => dimMap[d.dim] = this._getFieldInfoFromSpec(d.dim, d.specValue, relativeSeries)), Object.assign(Object.assign({}, dimMap), this._getAllRelativeSeries());
  }
  _processSpecCoo(spec) {
    var _a;
    let option;
    return (null !== (_a = spec.coordinates) && void 0 !== _a ? _a : array(spec.coordinate)).map((coordinate) => {
      const refRelativeSeries = this._getSeriesByIdOrIndex(coordinate.refRelativeSeriesId, coordinate.refRelativeSeriesIndex);
      if ("cartesian" === this.coordinateType) {
        const { xField, yField } = refRelativeSeries.getSpec(), { xFieldDim, xFieldIndex, yFieldDim, yFieldIndex } = coordinate;
        let bindXField = xField;
        isValid_default(xFieldIndex) && (bindXField = array(xField)[xFieldIndex]), xFieldDim && array(xField).includes(xFieldDim) && (bindXField = xFieldDim);
        let bindYField = yField;
        isValid_default(yFieldIndex) && (bindYField = array(yField)[yFieldIndex]), yFieldDim && array(yField).includes(yFieldDim) && (bindYField = yFieldDim), option = Object.assign({
          x: void 0,
          y: void 0
        }, this._getAllRelativeSeries()), isString_default(coordinate[bindXField]) && isAggrSpec(coordinate[bindXField]) ? option.x = {
          field: bindXField,
          aggrType: coordinate[bindXField]
        } : option.x = array(bindXField).map((field3) => coordinate[field3]), isString_default(coordinate[bindYField]) && isAggrSpec(coordinate[bindYField]) ? option.y = {
          field: bindYField,
          aggrType: coordinate[bindYField]
        } : option.y = array(bindYField).map((field3) => coordinate[field3]);
      } else if ("polar" === this.coordinateType) {
        const { valueField: radiusField, categoryField: angleField } = refRelativeSeries.getSpec(), { angleFieldDim, angleFieldIndex } = coordinate;
        let bindAngleField = angleField;
        isValid_default(angleFieldIndex) && (bindAngleField = array(angleField)[angleFieldIndex]), angleFieldDim && array(angleField).includes(angleFieldDim) && (bindAngleField = angleFieldDim);
        const bindRadiusField = radiusField;
        option = Object.assign({
          angle: void 0,
          radius: void 0
        }, this._getAllRelativeSeries()), isString_default(coordinate[bindAngleField]) && isAggrSpec(coordinate[bindAngleField]) ? option.angle = {
          field: bindAngleField,
          aggrType: coordinate[bindAngleField]
        } : option.angle = array(bindAngleField).map((field3) => coordinate[field3]), isString_default(coordinate[bindRadiusField]) && isAggrSpec(coordinate[bindRadiusField]) ? option.radius = {
          field: bindRadiusField,
          aggrType: coordinate[bindRadiusField]
        } : option.radius = array(bindRadiusField).map((field3) => coordinate[field3]);
      }
      return option.getRefRelativeSeries = () => refRelativeSeries, option;
    });
  }
  _getRelativeDataView() {
    if (this._specifiedDataSeries) {
      let resultData = [];
      array(this._specifiedDataSeries).forEach((series2) => {
        resultData = resultData.concat(series2.getViewData().latestData);
      });
      const dataSet = new DataSet();
      return dataSet.registerParser("array", arrayParser), new DataView(dataSet).parse(resultData, {
        type: "array"
      });
    }
    return this._relativeSeries.getViewData();
  }
  updateLayoutAttribute() {
    var _a, _b, _c;
    if (null === (_a = this._spec.visible) || void 0 === _a || _a) {
      if (!this._markerComponent) {
        const markerComponent = this._createMarkerComponent();
        markerComponent.name = null !== (_b = this._spec.name) && void 0 !== _b ? _b : this.type, markerComponent.id = null !== (_c = this._spec.id) && void 0 !== _c ? _c : `${this.type}-${this.id}`, this._markerComponent = markerComponent, this.getContainer().add(this._markerComponent), this._markerComponent.on("*", (event, type) => {
          this._delegateEvent(this._markerComponent, event, type, null, this.getMarkerData.bind(this));
        });
      }
      this._markerLayout();
    }
    super.updateLayoutAttribute();
  }
  _getSeriesByIdOrIndex(seriesUserId, seriesIndex) {
    var _a, _b;
    let series2;
    return series2 = null === (_a = this._option.getSeriesInUserIdOrIndex(isValid_default(seriesUserId) ? [seriesUserId] : [], [seriesIndex])) || void 0 === _a ? void 0 : _a[0], series2 || (series2 = null !== (_b = this._relativeSeries) && void 0 !== _b ? _b : this._getFirstSeries()), series2;
  }
  _bindSeries() {
    const spec = this._spec;
    this._relativeSeries = this._getSeriesByIdOrIndex(spec.relativeSeriesId, spec.relativeSeriesIndex), this._startRelativeSeries = this._getSeriesByIdOrIndex(spec.startRelativeSeriesId, spec.startRelativeSeriesIndex), this._endRelativeSeries = this._getSeriesByIdOrIndex(spec.endRelativeSeriesId, spec.endRelativeSeriesIndex), spec.specifiedDataSeriesIndex && "all" === spec.specifiedDataSeriesIndex || spec.specifiedDataSeriesId && "all" === spec.specifiedDataSeriesId ? this._specifiedDataSeries = this._option.getAllSeries() : (spec.specifiedDataSeriesIndex || spec.specifiedDataSeriesId) && (this._specifiedDataSeries = this._getSeriesByIdOrIndex(spec.specifiedDataSeriesId, spec.specifiedDataSeriesIndex));
  }
  initEvent() {
    "cartesian" !== this._relativeSeries.coordinate && (this._relativeSeries.event.on("zoom", this._markerLayout.bind(this)), this._relativeSeries.event.on("panmove", this._markerLayout.bind(this)), this._relativeSeries.event.on("scroll", this._markerLayout.bind(this)));
  }
  onRender(ctx) {
  }
  changeRegions(regions) {
  }
  clear() {
    super.clear(), this._firstSeries = null;
  }
  _getFirstSeries() {
    var _a;
    if (this._firstSeries)
      return this._firstSeries;
    const firstSeries = getFirstSeries(this._regions);
    return firstSeries ? (this._firstSeries = firstSeries, firstSeries) : (null === (_a = this._option) || void 0 === _a || _a.onError("need at least one series"), null);
  }
  _getNeedClearVRenderComponents() {
    return [this._markerComponent];
  }
  onLayoutStart(layoutRect, chartViewRect, ctx) {
    isNil_default(this._spec.offsetX) || (this._layoutOffsetX = calcLayoutNumber(this._spec.offsetX, chartViewRect.width, chartViewRect)), isNil_default(this._spec.offsetY) || (this._layoutOffsetY = calcLayoutNumber(this._spec.offsetY, chartViewRect.height, chartViewRect)), super.onLayoutStart(layoutRect, chartViewRect, ctx);
  }
  _compareSpec(spec, prevSpec) {
    const result2 = super._compareSpec(spec, prevSpec);
    return isEqual(prevSpec, spec) || (result2.reRender = true, result2.reMake = true, result2.change = true), result2;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/data/transforms/regression
function markerRegression(_data, opt) {
  const data = _data[0].latestData;
  return regression(data, opt.fieldX, opt.fieldY);
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/data/transforms/marker-filter
function markerFilter(data, options) {
  if (options && options.getRelativeSeries) {
    const series2 = options.getRelativeSeries();
    if (series2) {
      const viewData = series2.getViewData();
      return viewData && viewData.latestData && viewData.latestData.length ? data : [];
    }
  }
  return data;
}

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/marker/mark-line/base-mark-line
var BaseMarkLine = class extends BaseMarker {
  constructor() {
    super(...arguments), this.specKey = "markLine", this.layoutZIndex = LayoutZIndex.MarkLine;
  }
  static _getMarkerCoordinateType(markerSpec) {
    const { doAngleProcess, doRadiusProcess, doAngRadRad1Process, doRadAngAng1Process, doRadAngProcess } = getMarkLineProcessInfo(markerSpec);
    return "polar" === markerSpec.coordinateType || doAngleProcess || doRadiusProcess || doAngRadRad1Process || doRadAngAng1Process || doRadAngProcess ? "polar" : "cartesian";
  }
  _createMarkerComponent() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;
    const { label = {}, startSymbol = {}, endSymbol = {} } = this._spec, markLineAttrs = {
      zIndex: this.layoutZIndex,
      interactive: null === (_a = this._spec.interactive) || void 0 === _a || _a,
      hover: null === (_b = this._spec.interactive) || void 0 === _b || _b,
      select: null === (_c = this._spec.interactive) || void 0 === _c || _c,
      points: [{
        x: 0,
        y: 0
      }, {
        x: 0,
        y: 0
      }],
      center: {
        x: 0,
        y: 0
      },
      radius: 0,
      startAngle: 0,
      endAngle: 0,
      lineStyle: transformStyle(transformToGraphic(null === (_d = this._spec.line) || void 0 === _d ? void 0 : _d.style), this._markerData),
      clipInRange: null !== (_e = this._spec.clip) && void 0 !== _e && _e,
      label: transformLabelAttributes(label, this._markerData),
      state: {
        line: transformState(null !== (_g = null === (_f = this._spec.line) || void 0 === _f ? void 0 : _f.state) && void 0 !== _g ? _g : {}, this._markerData),
        lineStartSymbol: transformState(null !== (_j = null === (_h = this._spec.startSymbol) || void 0 === _h ? void 0 : _h.state) && void 0 !== _j ? _j : {}, this._markerData),
        lineEndSymbol: transformState(null !== (_l = null === (_k = this._spec.endSymbol) || void 0 === _k ? void 0 : _k.state) && void 0 !== _l ? _l : {}, this._markerData),
        label: transformState(null !== (_p = null === (_o = null === (_m = this._spec) || void 0 === _m ? void 0 : _m.label) || void 0 === _o ? void 0 : _o.state) && void 0 !== _p ? _p : {}, this._markerData),
        labelBackground: transformState(null !== (_t = null === (_s = null === (_r = null === (_q = this._spec) || void 0 === _q ? void 0 : _q.label) || void 0 === _r ? void 0 : _r.labelBackground) || void 0 === _s ? void 0 : _s.state) && void 0 !== _t ? _t : {}, this._markerData)
      },
      animation: null !== (_u = this._spec.animation) && void 0 !== _u && _u,
      animationEnter: this._spec.animationEnter,
      animationExit: this._spec.animationExit,
      animationUpdate: this._spec.animationUpdate
    };
    startSymbol.visible ? markLineAttrs.startSymbol = Object.assign(Object.assign({}, startSymbol), {
      visible: true,
      style: transformToGraphic(startSymbol.style)
    }) : markLineAttrs.startSymbol = {
      visible: false
    }, endSymbol.visible ? markLineAttrs.endSymbol = Object.assign(Object.assign({}, endSymbol), {
      visible: true,
      style: transformToGraphic(endSymbol.style)
    }) : markLineAttrs.endSymbol = {
      visible: false
    };
    return this._newMarkLineComponent(markLineAttrs);
  }
  _getUpdateMarkerAttrs() {
    var _a, _b, _c, _d;
    const spec = this._spec, data = this._markerData, startRelativeSeries = this._startRelativeSeries, endRelativeSeries = this._endRelativeSeries, relativeSeries = this._relativeSeries, pointsAttr = this._computePointsAttr(), seriesData = relativeSeries.getViewData().latestData, dataPoints = data.latestData[0] && data.latestData[0].latestData ? data.latestData[0].latestData : data.latestData;
    let limitRect;
    if (spec.clip || (null === (_a = spec.label) || void 0 === _a ? void 0 : _a.confine)) {
      const { minX, maxX, minY, maxY } = computeClipRange([startRelativeSeries.getRegion(), endRelativeSeries.getRegion(), relativeSeries.getRegion()]);
      limitRect = {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
      };
    }
    const markerComponentAttr = null !== (_c = null === (_b = this._markerComponent) || void 0 === _b ? void 0 : _b.attribute) && void 0 !== _c ? _c : {}, labelAttrs = Object.assign(Object.assign({}, markerComponentAttr.label), {
      text: this._spec.label.formatMethod ? this._spec.label.formatMethod(dataPoints, seriesData) : null === (_d = markerComponentAttr.label) || void 0 === _d ? void 0 : _d.text
    });
    return Object.assign(Object.assign({}, pointsAttr), {
      label: labelAttrs,
      limitRect,
      dx: this._layoutOffsetX,
      dy: this._layoutOffsetY
    });
  }
  _markerLayout() {
    var _a;
    const updateAttrs = this._getUpdateMarkerAttrs();
    null === (_a = this._markerComponent) || void 0 === _a || _a.setAttributes(updateAttrs);
  }
  _initDataView() {
    const spec = this._spec, isCoordinateProcess = "coordinates" in spec, { doXProcess, doYProcess, doXYY1Process, doYXX1Process, doXYProcess, doAngleProcess, doRadiusProcess, doAngRadRad1Process, doRadAngAng1Process, doRadAngProcess } = getMarkLineProcessInfo(spec);
    if (this._markerData = this._getRelativeDataView(), !(doXProcess || doYProcess || doXYY1Process || doYXX1Process || doXYProcess || doAngleProcess || doRadiusProcess || doAngRadRad1Process || doRadAngAng1Process || doRadAngProcess || isCoordinateProcess))
      return;
    registerDataSetInstanceTransform(this._option.dataSet, "markerAggregation", markerAggregation), registerDataSetInstanceTransform(this._option.dataSet, "markerRegression", markerRegression), registerDataSetInstanceTransform(this._option.dataSet, "markerFilter", markerFilter);
    const { options, needAggr, needRegr, processData } = this._computeOptions(), data = new DataView(this._option.dataSet);
    data.parse([processData], {
      type: "dataview"
    }), needAggr && data.transform({
      type: "markerAggregation",
      options
    }), needRegr && data.transform({
      type: "markerRegression",
      options
    }), data.transform({
      type: "markerFilter",
      options: this._getAllRelativeSeries()
    }), data.target.on("change", () => {
      this._markerLayout();
    }), this._markerData = data;
  }
};
BaseMarkLine.specKey = "markLine";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/marker/mark-line/cartesian-mark-line
var CartesianMarkLine = class extends BaseMarkLine {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.markLine, this.name = ComponentTypeEnum.markLine, this.coordinateType = "cartesian";
  }
  _newMarkLineComponent(attr) {
    return new MarkLine(attr);
  }
  _computePointsAttr() {
    var _a;
    const spec = this._spec, data = this._markerData, startRelativeSeries = this._startRelativeSeries, endRelativeSeries = this._endRelativeSeries, relativeSeries = this._relativeSeries, isValidCoordinates = isValid_default(spec.coordinates), isValidProcess = isValid_default(spec.process), isValidProcessX = isValidProcess && isValid_default(spec.process.x), isValidProcessY = isValidProcess && isValid_default(spec.process.y), isPositionLayout = isValid_default(spec.positions), autoRange = null !== (_a = spec.autoRange) && void 0 !== _a && _a, { doXProcess, doYProcess, doXYY1Process, doYXX1Process, doXYProcess, doCoordinatesProcess } = getMarkLineProcessInfo(spec);
    let points = [];
    if (doXProcess || doXYY1Process || doYProcess || doYXX1Process || doXYProcess || isValidCoordinates && isValidProcessX || isValidCoordinates && isValidProcessY) {
      const xyPoints = xyLayout(data, startRelativeSeries, endRelativeSeries, relativeSeries, autoRange);
      points = 1 === xyPoints.length ? xyPoints[0] : xyPoints.map((point5) => point5[0]);
    } else
      doCoordinatesProcess ? points = cartesianCoordinateLayout(data, relativeSeries, autoRange, spec.coordinatesOffset) : isPositionLayout && (points = positionLayout(spec.positions, relativeSeries, spec.regionRelative));
    return {
      points
    };
  }
  _markerLayout() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const updateAttrs = this._getUpdateMarkerAttrs();
    if ("type-step" === this._spec.type) {
      const startRelativeSeries = this._startRelativeSeries, endRelativeSeries = this._endRelativeSeries, { multiSegment, mainSegmentIndex } = this._spec.line || {}, { connectDirection, expandDistance = 0 } = this._spec;
      let expandDistanceValue;
      if (isPercent(expandDistance)) {
        const regionStart = startRelativeSeries.getRegion(), regionStartLayoutStartPoint = regionStart.getLayoutStartPoint(), regionEnd = endRelativeSeries.getRegion(), regionEndLayoutStartPoint = regionEnd.getLayoutStartPoint();
        if ("bottom" === connectDirection || "top" === connectDirection) {
          const regionHeight = Math.abs(Math.min(regionStartLayoutStartPoint.y, regionEndLayoutStartPoint.y) - Math.max(regionStartLayoutStartPoint.y + regionStart.getLayoutRect().height, regionEndLayoutStartPoint.y + regionEnd.getLayoutRect().height));
          expandDistanceValue = Number(expandDistance.substring(0, expandDistance.length - 1)) * regionHeight / 100;
        } else {
          const regionWidth = Math.abs(Math.min(regionStartLayoutStartPoint.x, regionEndLayoutStartPoint.x) - Math.max(regionStartLayoutStartPoint.x + regionStart.getLayoutRect().width, regionEndLayoutStartPoint.x + regionEnd.getLayoutRect().width));
          expandDistanceValue = Number(expandDistance.substring(0, expandDistance.length - 1)) * regionWidth / 100;
        }
      } else
        expandDistanceValue = expandDistance;
      const { points, label, limitRect } = updateAttrs, joinPoints = getInsertPoints(points[0], points[1], connectDirection, expandDistanceValue);
      let labelPositionAttrs;
      labelPositionAttrs = multiSegment && isValid_default(mainSegmentIndex) ? {
        position: "middle",
        autoRotate: false,
        refX: 0,
        refY: 0
      } : Object.assign(Object.assign({
        position: "start",
        autoRotate: false
      }, getTextOffset(points[0], points[1], connectDirection, expandDistanceValue)), {
        refX: 0,
        refY: 0
      }), isValidNumber_default(null === (_a = this._spec.label) || void 0 === _a ? void 0 : _a.refX) && (labelPositionAttrs.refX += this._spec.label.refX), isValidNumber_default(null === (_b = this._spec.label) || void 0 === _b ? void 0 : _b.refY) && (labelPositionAttrs.refY += this._spec.label.refY), isValidNumber_default(null === (_c = this._spec.label) || void 0 === _c ? void 0 : _c.dx) && (labelPositionAttrs.dx = (labelPositionAttrs.dx || 0) + this._spec.label.dx), isValidNumber_default(null === (_d = this._spec.label) || void 0 === _d ? void 0 : _d.dy) && (labelPositionAttrs.dy = (labelPositionAttrs.dy || 0) + this._spec.label.dy);
      const markerComponentAttr = null !== (_f = null === (_e = this._markerComponent) || void 0 === _e ? void 0 : _e.attribute) && void 0 !== _f ? _f : {};
      null === (_g = this._markerComponent) || void 0 === _g || _g.setAttributes({
        points: multiSegment ? [[joinPoints[0], joinPoints[1]], [joinPoints[1], joinPoints[2]], [joinPoints[2], joinPoints[3]]] : joinPoints,
        label: Object.assign(Object.assign(Object.assign({}, label), labelPositionAttrs), {
          textStyle: Object.assign(Object.assign({}, markerComponentAttr.label.textStyle), {
            textAlign: "center",
            textBaseline: "middle"
          })
        }),
        limitRect,
        multiSegment,
        mainSegmentIndex,
        dx: this._layoutOffsetX,
        dy: this._layoutOffsetY
      });
    } else
      null === (_h = this._markerComponent) || void 0 === _h || _h.setAttributes(updateAttrs);
  }
  _computeOptions() {
    let options, processData = this._getRelativeDataView(), needAggr = true, needRegr = false;
    const spec = this._spec, relativeSeries = this._relativeSeries, { doXProcess, doYProcess, doXYY1Process, doYXX1Process, doXYProcess, doCoordinatesProcess } = getMarkLineProcessInfo(spec);
    if (doXYProcess)
      options = [this._processSpecByDims([{
        dim: "x",
        specValue: spec.x
      }, {
        dim: "y",
        specValue: spec.y
      }]), this._processSpecByDims([{
        dim: "x",
        specValue: spec.x1
      }, {
        dim: "y",
        specValue: spec.y1
      }])];
    else if (doXProcess)
      options = [this._processSpecByDims([{
        dim: "x",
        specValue: spec.x
      }])];
    else if (doYProcess)
      options = [this._processSpecByDims([{
        dim: "y",
        specValue: spec.y
      }])];
    else if (doXYY1Process)
      options = [this._processSpecByDims([{
        dim: "x",
        specValue: spec.x
      }, {
        dim: "y",
        specValue: spec.y
      }]), this._processSpecByDims([{
        dim: "x",
        specValue: spec.x
      }, {
        dim: "y",
        specValue: spec.y1
      }])];
    else if (doYXX1Process)
      options = [this._processSpecByDims([{
        dim: "x",
        specValue: spec.x
      }, {
        dim: "y",
        specValue: spec.y
      }]), this._processSpecByDims([{
        dim: "x",
        specValue: spec.x1
      }, {
        dim: "y",
        specValue: spec.y
      }])];
    else if (doCoordinatesProcess) {
      if (options = this._processSpecCoo(spec), needAggr = false, processData = new DataView(this._option.dataSet, {
        name: `${this.type}_${this.id}_data`
      }).parse([relativeSeries.getViewData()], {
        type: "dataview"
      }).transform({
        type: "markerAggregation",
        options
      }), spec.process && "x" in spec.process && (options = [this._processSpecByDims([{
        dim: "x",
        specValue: spec.process.x
      }])], needAggr = true), spec.process && "y" in spec.process && (options = options = [this._processSpecByDims([{
        dim: "y",
        specValue: spec.process.y
      }])], needAggr = true), spec.process && "xy" in spec.process) {
        const { xField, yField } = relativeSeries.getSpec();
        options = {
          fieldX: xField,
          fieldY: yField
        }, needRegr = true;
      }
    } else
      needAggr = false;
    return {
      options,
      needAggr,
      needRegr,
      processData
    };
  }
};
CartesianMarkLine.type = ComponentTypeEnum.markLine, CartesianMarkLine.coordinateType = "cartesian";
var registerMarkLine = () => {
  Factory2.registerComponent(CartesianMarkLine.type, CartesianMarkLine), registerMarkLineAnimate();
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/marker/mark-line/polar-mark-line
var PolarMarkLine = class extends BaseMarkLine {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.polarMarkLine, this.name = ComponentTypeEnum.polarMarkLine, this.coordinateType = "polar";
  }
  _newMarkLineComponent(attr) {
    const { doRadiusProcess, doRadAngAng1Process } = getMarkLineProcessInfo(this._spec);
    return doRadiusProcess || doRadAngAng1Process ? new MarkArcLine(attr) : new MarkLine(attr);
  }
  _computePointsAttr() {
    var _a;
    const spec = this._spec, data = this._markerData, startRelativeSeries = this._startRelativeSeries, endRelativeSeries = this._endRelativeSeries, relativeSeries = this._relativeSeries, autoRange = null !== (_a = spec.autoRange) && void 0 !== _a && _a, { doAngleProcess, doRadiusProcess, doAngRadRad1Process, doRadAngAng1Process, doRadAngProcess, doCoordinatesProcess } = getMarkLineProcessInfo(spec);
    let points = [], pointsAttr = {};
    const center2 = {
      x: this._relativeSeries.getRegion().getLayoutStartPoint().x + this._relativeSeries.angleAxisHelper.center().x,
      y: this._relativeSeries.getRegion().getLayoutStartPoint().y + this._relativeSeries.angleAxisHelper.center().y
    };
    if (doAngleProcess || doRadiusProcess || doAngRadRad1Process || doRadAngAng1Process || doRadAngProcess) {
      const polarPoints = polarLayout(data, startRelativeSeries, endRelativeSeries, relativeSeries, autoRange);
      points = 1 === polarPoints.length ? polarPoints[0] : polarPoints.map((point5) => point5[0]), pointsAttr = points[0].radius === points[1].radius ? {
        radius: points[0].radius,
        startAngle: points[0].angle,
        endAngle: points[1].angle,
        center: center2
      } : {
        points: points.map((point5) => polarToCartesian(center2, point5.radius, point5.angle))
      };
    } else
      doCoordinatesProcess && (points = polarCoordinateLayout(data, relativeSeries, autoRange), pointsAttr = {
        points: points.map((point5) => polarToCartesian(center2, point5.radius, point5.angle))
      });
    return pointsAttr;
  }
  _computeOptions() {
    const spec = this._spec, { doAngleProcess, doRadiusProcess, doAngRadRad1Process, doRadAngAng1Process, doRadAngProcess, doCoordinatesProcess } = getMarkLineProcessInfo(spec);
    let options;
    const processData = this._getRelativeDataView();
    return doRadAngProcess ? options = [this._processSpecByDims([{
      dim: "angle",
      specValue: spec.angle
    }, {
      dim: "radius",
      specValue: spec.radius
    }]), this._processSpecByDims([{
      dim: "angle",
      specValue: spec.angle1
    }, {
      dim: "radius",
      specValue: spec.radius1
    }])] : doAngleProcess ? options = [this._processSpecByDims([{
      dim: "angle",
      specValue: spec.angle
    }])] : doRadiusProcess ? options = [this._processSpecByDims([{
      dim: "radius",
      specValue: spec.radius
    }])] : doAngRadRad1Process ? options = [this._processSpecByDims([{
      dim: "angle",
      specValue: spec.angle
    }, {
      dim: "radius",
      specValue: spec.radius
    }]), this._processSpecByDims([{
      dim: "angle",
      specValue: spec.angle
    }, {
      dim: "radius",
      specValue: spec.radius1
    }])] : doRadAngAng1Process ? options = [this._processSpecByDims([{
      dim: "angle",
      specValue: spec.angle
    }, {
      dim: "radius",
      specValue: spec.radius
    }]), this._processSpecByDims([{
      dim: "angle",
      specValue: spec.angle1
    }, {
      dim: "radius",
      specValue: spec.radius
    }])] : doCoordinatesProcess && (options = this._processSpecCoo(spec)), {
      options,
      needAggr: true,
      needRegr: false,
      processData
    };
  }
};
PolarMarkLine.type = ComponentTypeEnum.polarMarkLine, PolarMarkLine.coordinateType = "polar";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/marker/mark-area/base-mark-area
var BaseMarkArea = class extends BaseMarker {
  constructor() {
    super(...arguments), this.specKey = "markArea", this.layoutZIndex = LayoutZIndex.MarkArea;
  }
  static _getMarkerCoordinateType(markerSpec) {
    const { doAngleProcess, doRadiusProcess, doRadAngProcess } = getMarkAreaProcessInfo(markerSpec);
    return "polar" === markerSpec.coordinateType || doAngleProcess || doRadiusProcess || doRadAngProcess ? "polar" : "cartesian";
  }
  _createMarkerComponent() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    const label = null !== (_a = this._spec.label) && void 0 !== _a ? _a : {}, markAreaAttrs = {
      zIndex: this.layoutZIndex,
      interactive: null === (_b = this._spec.interactive) || void 0 === _b || _b,
      hover: null === (_c = this._spec.interactive) || void 0 === _c || _c,
      select: null === (_d = this._spec.interactive) || void 0 === _d || _d,
      points: [{
        x: 0,
        y: 0
      }],
      center: {
        x: 0,
        y: 0
      },
      innerRadius: 0,
      outerRadius: 0,
      startAngle: 0,
      endAngle: 0,
      areaStyle: transformStyle(transformToGraphic(null === (_e = this._spec.area) || void 0 === _e ? void 0 : _e.style), this._markerData),
      clipInRange: null !== (_f = this._spec.clip) && void 0 !== _f && _f,
      label: transformLabelAttributes(label, this._markerData),
      state: {
        area: transformState(null === (_g = this._spec.area) || void 0 === _g ? void 0 : _g.state, this._markerData),
        label: transformState(null === (_h = this._spec.label) || void 0 === _h ? void 0 : _h.state, this._markerData),
        labelBackground: transformState(null === (_l = null === (_k = null === (_j = this._spec) || void 0 === _j ? void 0 : _j.label) || void 0 === _k ? void 0 : _k.labelBackground) || void 0 === _l ? void 0 : _l.state, this._markerData)
      },
      animation: null !== (_m = this._spec.animation) && void 0 !== _m && _m,
      animationEnter: this._spec.animationEnter,
      animationExit: this._spec.animationExit,
      animationUpdate: this._spec.animationUpdate
    };
    return this._newMarkAreaComponent(markAreaAttrs);
  }
  _markerLayout() {
    var _a, _b, _c, _d;
    const spec = this._spec, data = this._markerData, startRelativeSeries = this._startRelativeSeries, endRelativeSeries = this._endRelativeSeries, relativeSeries = this._relativeSeries, pointsAttr = this._computePointsAttr(), seriesData = this._getRelativeDataView().latestData, dataPoints = data ? data.latestData[0] && data.latestData[0].latestData ? data.latestData[0].latestData : data.latestData : seriesData;
    let limitRect;
    if (spec.clip || (null === (_a = spec.label) || void 0 === _a ? void 0 : _a.confine)) {
      const { minX, maxX, minY, maxY } = computeClipRange([startRelativeSeries.getRegion(), endRelativeSeries.getRegion(), relativeSeries.getRegion()]);
      limitRect = {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
      };
    }
    this._markerComponent && this._markerComponent.setAttributes(Object.assign(Object.assign({}, pointsAttr), {
      label: Object.assign(Object.assign({}, null === (_b = this._markerComponent.attribute) || void 0 === _b ? void 0 : _b.label), {
        text: this._spec.label.formatMethod ? this._spec.label.formatMethod(dataPoints, seriesData) : null === (_d = null === (_c = this._markerComponent.attribute) || void 0 === _c ? void 0 : _c.label) || void 0 === _d ? void 0 : _d.text
      }),
      limitRect,
      dx: this._layoutOffsetX,
      dy: this._layoutOffsetY
    }));
  }
  _initDataView() {
    const spec = this._spec, { doXProcess, doYProcess, doXYProcess, doAngleProcess, doRadiusProcess, doRadAngProcess, doCoordinatesProcess } = getMarkAreaProcessInfo(spec);
    if (!(doXProcess || doYProcess || doXYProcess || doAngleProcess || doRadiusProcess || doRadAngProcess || doCoordinatesProcess))
      return null;
    const { options } = this._computeOptions(), seriesData = this._getRelativeDataView();
    registerDataSetInstanceTransform(this._option.dataSet, "markerAggregation", markerAggregation), registerDataSetInstanceTransform(this._option.dataSet, "markerFilter", markerFilter);
    const data = new DataView(this._option.dataSet, {
      name: `${this.type}_${this.id}_data`
    });
    data.parse([seriesData], {
      type: "dataview"
    }), data.transform({
      type: "markerAggregation",
      options
    }), data.transform({
      type: "markerFilter",
      options: this._getAllRelativeSeries()
    }), data.target.on("change", () => {
      this._markerLayout();
    }), this._markerData = data;
  }
};
BaseMarkArea.specKey = "markArea";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/marker/mark-area/cartesian-mark-area
var CartesianMarkArea = class extends BaseMarkArea {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.markArea, this.name = ComponentTypeEnum.markArea, this.coordinateType = "cartesian";
  }
  _newMarkAreaComponent(attr) {
    return new MarkArea(attr);
  }
  _computePointsAttr() {
    var _a;
    const spec = this._spec, data = this._markerData, startRelativeSeries = this._startRelativeSeries, endRelativeSeries = this._endRelativeSeries, relativeSeries = this._relativeSeries, { doXProcess, doYProcess, doXYProcess, doCoordinatesProcess } = getMarkAreaProcessInfo(spec), isPositionLayout = isValid_default(spec.positions), autoRange = null !== (_a = spec.autoRange) && void 0 !== _a && _a;
    let points = [], lines = [];
    if (doXYProcess) {
      lines = xyLayout(data, startRelativeSeries, endRelativeSeries, relativeSeries, autoRange);
      const [start, end] = lines;
      start && start.length && end && end.length && (points = [{
        x: start[0].x,
        y: end[0].y
      }, start[0], {
        x: end[0].x,
        y: start[0].y
      }, end[0]]);
    } else if (doXProcess || doYProcess) {
      lines = xyLayout(data, startRelativeSeries, endRelativeSeries, relativeSeries, autoRange);
      const [start, end] = lines;
      start && start.length && end && end.length && (points = [...start, end[1], end[0]]);
    } else
      doCoordinatesProcess ? points = cartesianCoordinateLayout(data, relativeSeries, autoRange, spec.coordinatesOffset) : isPositionLayout && (points = positionLayout(spec.positions, relativeSeries, spec.regionRelative));
    return {
      points
    };
  }
  _computeOptions() {
    const spec = this._spec, { doXProcess, doYProcess, doXYProcess, doCoordinatesProcess } = getMarkAreaProcessInfo(spec);
    let options;
    return doXYProcess ? options = [this._processSpecByDims([{
      dim: "x",
      specValue: spec.x
    }, {
      dim: "y",
      specValue: spec.y
    }]), this._processSpecByDims([{
      dim: "x",
      specValue: spec.x1
    }, {
      dim: "y",
      specValue: spec.y1
    }])] : doXProcess ? options = [this._processSpecByDims([{
      dim: "x",
      specValue: spec.x
    }]), this._processSpecByDims([{
      dim: "x",
      specValue: spec.x1
    }])] : doYProcess ? options = [this._processSpecByDims([{
      dim: "y",
      specValue: spec.y
    }]), this._processSpecByDims([{
      dim: "y",
      specValue: spec.y1
    }])] : doCoordinatesProcess && (options = this._processSpecCoo(spec)), {
      options
    };
  }
};
CartesianMarkArea.type = ComponentTypeEnum.markArea, CartesianMarkArea.coordinateType = "cartesian";
var registerMarkArea = () => {
  Factory2.registerComponent(CartesianMarkArea.type, CartesianMarkArea), registerMarkAreaAnimate();
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/marker/mark-area/polar-mark-area
var PolarMarkArea = class extends BaseMarkArea {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.polarMarkArea, this.name = ComponentTypeEnum.polarMarkArea, this.coordinateType = "polar";
  }
  _newMarkAreaComponent(attr) {
    const { doRadiusProcess, doAngleProcess, doRadAngProcess } = getMarkAreaProcessInfo(this._spec);
    return doAngleProcess || doRadiusProcess || doRadAngProcess ? new MarkArcArea(attr) : new MarkArea(attr);
  }
  _computePointsAttr() {
    var _a;
    const spec = this._spec, data = this._markerData, startRelativeSeries = this._startRelativeSeries, endRelativeSeries = this._endRelativeSeries, relativeSeries = this._relativeSeries, { doAngleProcess, doRadiusProcess, doRadAngProcess, doCoordinatesProcess } = getMarkAreaProcessInfo(spec), autoRange = null !== (_a = spec.autoRange) && void 0 !== _a && _a;
    let points, pointsAttr = {};
    const center2 = {
      x: this._relativeSeries.getRegion().getLayoutStartPoint().x + this._relativeSeries.angleAxisHelper.center().x,
      y: this._relativeSeries.getRegion().getLayoutStartPoint().y + this._relativeSeries.angleAxisHelper.center().y
    };
    if (doAngleProcess || doRadiusProcess || doRadAngProcess) {
      const polarLines = polarLayout(data, startRelativeSeries, endRelativeSeries, relativeSeries, autoRange);
      doRadAngProcess ? pointsAttr = {
        innerRadius: polarLines[0][0].radius,
        outerRadius: polarLines[1][0].radius,
        startAngle: polarLines[0][0].angle,
        endAngle: polarLines[1][0].angle,
        center: center2
      } : doAngleProcess ? pointsAttr = {
        innerRadius: 0,
        outerRadius: Math.abs(polarLines[0][0].radius),
        startAngle: polarLines[0][1].angle,
        endAngle: polarLines[1][1].angle,
        center: center2
      } : doRadiusProcess && (pointsAttr = {
        innerRadius: polarLines[0][0].radius,
        outerRadius: polarLines[1][0].radius,
        startAngle: polarLines[0][0].angle,
        endAngle: polarLines[1][1].angle,
        center: center2
      });
    } else
      doCoordinatesProcess && (points = polarCoordinateLayout(data, relativeSeries, autoRange), pointsAttr = {
        points: points.map((point5) => polarToCartesian(center2, point5.radius, point5.angle))
      });
    return pointsAttr;
  }
  _computeOptions() {
    const spec = this._spec, { doAngleProcess, doRadiusProcess, doRadAngProcess, doCoordinatesProcess } = getMarkAreaProcessInfo(spec);
    let options;
    return doRadAngProcess ? options = [this._processSpecByDims([{
      dim: "angle",
      specValue: spec.angle
    }, {
      dim: "radius",
      specValue: spec.radius
    }]), this._processSpecByDims([{
      dim: "angle",
      specValue: spec.angle1
    }, {
      dim: "radius",
      specValue: spec.radius1
    }])] : doAngleProcess ? options = [this._processSpecByDims([{
      dim: "angle",
      specValue: spec.angle
    }, {
      dim: "radius",
      specValue: spec.radius
    }]), this._processSpecByDims([{
      dim: "angle",
      specValue: spec.angle1
    }, {
      dim: "radius",
      specValue: spec.radius
    }])] : doRadiusProcess ? options = [this._processSpecByDims([{
      dim: "radius",
      specValue: spec.radius
    }]), this._processSpecByDims([{
      dim: "radius",
      specValue: spec.radius1
    }])] : doCoordinatesProcess && (options = this._processSpecCoo(spec)), {
      options
    };
  }
};
PolarMarkArea.type = ComponentTypeEnum.polarMarkArea, PolarMarkArea.coordinateType = "polar";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/marker/mark-point/base-mark-point
var __rest21 = function(s2, e) {
  var t = {};
  for (var p in s2)
    Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0 && (t[p] = s2[p]);
  if (null != s2 && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s2); i < p.length; i++)
      e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]) && (t[p[i]] = s2[p[i]]);
  }
  return t;
};
var BaseMarkPoint = class extends BaseMarker {
  constructor() {
    super(...arguments), this.specKey = "markPoint", this.layoutZIndex = LayoutZIndex.MarkPoint;
  }
  static _getMarkerCoordinateType(markerSpec) {
    const { doPolarProcess, doGeoProcess } = getMarkPointProcessInfo(markerSpec);
    return "polar" === markerSpec.coordinateType || doPolarProcess ? "polar" : "geo" === markerSpec.coordinateType || doGeoProcess ? "geo" : "cartesian";
  }
  _createMarkerComponent() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3;
    const { itemContent = {}, itemLine = {}, targetSymbol = {} } = this._spec, { text: label = {}, symbol, image, richText: richText2 } = itemContent, restItemContent = __rest21(itemContent, ["text", "symbol", "image", "richText"]), markPointAttrs = {
      zIndex: this.layoutZIndex,
      interactive: null === (_a = this._spec.interactive) || void 0 === _a || _a,
      hover: null === (_b = this._spec.interactive) || void 0 === _b || _b,
      select: null === (_c = this._spec.interactive) || void 0 === _c || _c,
      position: {
        x: 0,
        y: 0
      },
      clipInRange: null !== (_d = this._spec.clip) && void 0 !== _d && _d,
      itemContent: Object.assign({
        offsetX: transformOffset(itemContent.offsetX, this._relativeSeries.getRegion()),
        offsetY: transformOffset(itemContent.offsetX, this._relativeSeries.getRegion())
      }, restItemContent),
      targetSymbol: {
        offset: null !== (_e = targetSymbol.offset) && void 0 !== _e ? _e : 0,
        visible: null !== (_f = targetSymbol.visible) && void 0 !== _f && _f,
        size: null !== (_g = targetSymbol.size) && void 0 !== _g ? _g : 20,
        style: transformStyle(targetSymbol.style, this._markerData)
      },
      state: {
        line: transformState(null !== (_j = null === (_h = this._spec.itemLine.line) || void 0 === _h ? void 0 : _h.state) && void 0 !== _j ? _j : {}, this._markerData),
        lineStartSymbol: transformState(null !== (_l = null === (_k = this._spec.itemLine.startSymbol) || void 0 === _k ? void 0 : _k.state) && void 0 !== _l ? _l : {}, this._markerData),
        lineEndSymbol: transformState(null !== (_o = null === (_m = this._spec.itemLine.endSymbol) || void 0 === _m ? void 0 : _m.state) && void 0 !== _o ? _o : {}, this._markerData),
        symbol: transformState(null !== (_q = null === (_p = this._spec.itemContent.symbol) || void 0 === _p ? void 0 : _p.state) && void 0 !== _q ? _q : {}, this._markerData),
        image: transformState(null !== (_s = null === (_r = this._spec.itemContent.image) || void 0 === _r ? void 0 : _r.state) && void 0 !== _s ? _s : {}, this._markerData),
        text: transformState(null !== (_u = null === (_t = this._spec.itemContent.text) || void 0 === _t ? void 0 : _t.state) && void 0 !== _u ? _u : {}, this._markerData),
        textBackground: transformState(null === (_w = null === (_v = this._spec.itemContent.text) || void 0 === _v ? void 0 : _v.labelBackground) || void 0 === _w ? void 0 : _w.state, this._markerData),
        richText: transformState(null !== (_y = null === (_x = this._spec.itemContent.richText) || void 0 === _x ? void 0 : _x.state) && void 0 !== _y ? _y : {}, this._markerData),
        customMark: transformState(null !== (_0 = null === (_z = this._spec.itemContent.customMark) || void 0 === _z ? void 0 : _z.state) && void 0 !== _0 ? _0 : {}, this._markerData),
        targetItem: transformState(null !== (_2 = null === (_1 = this._spec.targetSymbol) || void 0 === _1 ? void 0 : _1.state) && void 0 !== _2 ? _2 : {}, this._markerData)
      },
      animation: null !== (_3 = this._spec.animation) && void 0 !== _3 && _3,
      animationEnter: this._spec.animationEnter,
      animationExit: this._spec.animationExit,
      animationUpdate: this._spec.animationUpdate
    };
    (null == symbol ? void 0 : symbol.style) && (markPointAttrs.itemContent.symbolStyle = transformToGraphic(transformStyle(symbol.style, this._markerData))), (null == image ? void 0 : image.style) && (markPointAttrs.itemContent.imageStyle = transformStyle(image.style, this._markerData)), label && (markPointAttrs.itemContent.textStyle = transformLabelAttributes(label, this._markerData)), (null == richText2 ? void 0 : richText2.style) && (markPointAttrs.itemContent.richTextStyle = transformStyle(richText2.style, this._markerData));
    const { visible, line: line2 = {} } = itemLine, restItemLine = __rest21(itemLine, ["visible", "line"]);
    markPointAttrs.itemLine = false !== visible ? Object.assign(Object.assign({}, restItemLine), {
      visible: true,
      lineStyle: transformToGraphic(line2.style)
    }) : {
      visible: false
    };
    return new MarkPoint(markPointAttrs);
  }
  _markerLayout() {
    var _a, _b, _c, _d, _e;
    const spec = this._spec, data = this._markerData, relativeSeries = this._relativeSeries, { point: point5 } = this._computePointsAttr(), seriesData = this._getRelativeDataView().latestData, dataPoints = data ? data.latestData[0] && data.latestData[0].latestData ? data.latestData[0].latestData : data.latestData : seriesData;
    let limitRect;
    if (spec.clip || (null === (_a = spec.itemContent) || void 0 === _a ? void 0 : _a.confine)) {
      const { minX, maxX, minY, maxY } = computeClipRange([relativeSeries.getRegion()]);
      limitRect = {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
      };
    }
    if (this._markerComponent) {
      const attribute = null !== (_b = this._markerComponent.attribute) && void 0 !== _b ? _b : {}, textStyle = null !== (_d = null === (_c = attribute.itemContent) || void 0 === _c ? void 0 : _c.textStyle) && void 0 !== _d ? _d : {};
      this._markerComponent.setAttributes({
        position: void 0 === point5 ? {
          x: null,
          y: null
        } : point5,
        itemContent: Object.assign(Object.assign({}, attribute.itemContent), {
          textStyle: Object.assign(Object.assign({}, textStyle), {
            text: (null === (_e = this._spec.itemContent.text) || void 0 === _e ? void 0 : _e.formatMethod) ? this._spec.itemContent.text.formatMethod(dataPoints, seriesData) : textStyle.text
          }),
          offsetX: computeOffsetFromRegion(point5, attribute.itemContent.offsetX, this._relativeSeries.getRegion()),
          offsetY: computeOffsetFromRegion(point5, attribute.itemContent.offsetY, this._relativeSeries.getRegion())
        }),
        limitRect,
        dx: this._layoutOffsetX,
        dy: this._layoutOffsetY
      });
    }
  }
  _initDataView() {
    const spec = this._spec, { doXYProcess, doPolarProcess, doGeoProcess } = getMarkPointProcessInfo(spec);
    if (!(isValid_default(spec.coordinate) || doXYProcess || doPolarProcess || doGeoProcess))
      return;
    registerDataSetInstanceTransform(this._option.dataSet, "markerAggregation", markerAggregation), registerDataSetInstanceTransform(this._option.dataSet, "markerFilter", markerFilter);
    const { options } = this._computeOptions(), data = new DataView(this._option.dataSet, {
      name: `${this.type}_${this.id}_data`
    });
    data.parse([this._getRelativeDataView()], {
      type: "dataview"
    }), data.transform({
      type: "markerAggregation",
      options
    }), data.transform({
      type: "markerFilter",
      options: this._getAllRelativeSeries()
    }), data.target.on("change", () => {
      this._markerLayout();
    }), this._markerData = data;
  }
};
BaseMarkPoint.specKey = "markPoint";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/marker/mark-point/cartesian-mark-point
var CartesianMarkPoint = class extends BaseMarkPoint {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.markPoint, this.name = ComponentTypeEnum.markPoint, this.coordinateType = "cartesian";
  }
  _computePointsAttr() {
    var _a;
    const spec = this._spec, data = this._markerData, relativeSeries = this._relativeSeries, isXYLayout = "x" in spec && "y" in spec, isCoordinateLayout = "coordinate" in spec, isPositionLayout = "position" in spec, autoRange = null !== (_a = null == spec ? void 0 : spec.autoRange) && void 0 !== _a && _a;
    let point5;
    return isXYLayout ? point5 = xyLayout(data, relativeSeries, relativeSeries, relativeSeries, autoRange)[0][0] : isCoordinateLayout ? point5 = cartesianCoordinateLayout(data, relativeSeries, autoRange, spec.coordinatesOffset)[0] : isPositionLayout && (point5 = positionLayout([spec.position], relativeSeries, spec.regionRelative)[0]), {
      point: point5
    };
  }
  _computeOptions() {
    const spec = this._spec, { doXYProcess } = getMarkPointProcessInfo(spec), isCoordinateProcess = isValid_default(spec.coordinate);
    let options;
    return doXYProcess ? options = [this._processSpecByDims([{
      dim: "x",
      specValue: spec.x
    }, {
      dim: "y",
      specValue: spec.y
    }])] : isCoordinateProcess && (options = this._processSpecCoo(spec)), {
      options
    };
  }
};
CartesianMarkPoint.type = ComponentTypeEnum.markPoint, CartesianMarkPoint.coordinateType = "cartesian";
var registerMarkPoint = () => {
  Factory2.registerComponent(CartesianMarkPoint.type, CartesianMarkPoint), registerMarkPointAnimate();
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/marker/mark-point/polar-mark-point
var PolarMarkPoint = class extends BaseMarkPoint {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.polarMarkPoint, this.name = ComponentTypeEnum.polarMarkPoint, this.coordinateType = "polar";
  }
  _computePointsAttr() {
    var _a, _b;
    const data = this._markerData, relativeSeries = this._relativeSeries, autoRange = null !== (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.autoRange) && void 0 !== _b && _b, polarPoint = polarLayout(data, relativeSeries, relativeSeries, relativeSeries, autoRange)[0][0], center2 = {
      x: this._relativeSeries.getRegion().getLayoutStartPoint().x + this._relativeSeries.angleAxisHelper.center().x,
      y: this._relativeSeries.getRegion().getLayoutStartPoint().y + this._relativeSeries.angleAxisHelper.center().y
    };
    return {
      point: polarToCartesian(center2, polarPoint.radius, polarPoint.angle)
    };
  }
  _computeOptions() {
    const spec = this._spec;
    return {
      options: [this._processSpecByDims([{
        dim: "radius",
        specValue: spec.radius
      }, {
        dim: "angle",
        specValue: spec.angle
      }])]
    };
  }
};
PolarMarkPoint.type = ComponentTypeEnum.polarMarkPoint, PolarMarkPoint.coordinateType = "polar";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/marker/mark-point/geo-mark-point
var GeoMarkPoint = class extends BaseMarkPoint {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.geoMarkPoint, this.name = ComponentTypeEnum.geoMarkPoint, this.coordinateType = "geo";
  }
  _computePointsAttr() {
    const data = this._markerData, relativeSeries = this._relativeSeries;
    return {
      point: geoLayout(data, relativeSeries)[0][0]
    };
  }
  _computeOptions() {
    const spec = this._spec;
    return {
      options: [this._processSpecByDims([{
        dim: "areaName",
        specValue: spec.areaName
      }])]
    };
  }
};
GeoMarkPoint.type = ComponentTypeEnum.geoMarkPoint, GeoMarkPoint.coordinateType = "geo";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/tooltip/processor/base
var BaseTooltipProcessor = class {
  constructor(component2) {
    this._showTooltipByHandler = (data, params2) => {
      var _a, _b, _c;
      if (isNil_default(data))
        return 1;
      params2.changePositionOnly || this.clearCache(), this._updateViewSpec(params2);
      const spec = this._cacheViewSpec;
      if (isNil_default(null == spec ? void 0 : spec[this.activeType]) || false === spec.visible)
        return 1;
      params2.tooltipSpec = spec, this._updateActualTooltip(data, params2), params2.tooltipActual = this._cacheActualTooltip;
      const { title: title3, content } = this._cacheActualTooltip, isEmpty2 = isNil_default(null == title3 ? void 0 : title3.key) && isNil_default(null == title3 ? void 0 : title3.value) && !(null == content ? void 0 : content.length);
      if (this.component.event.emit(ChartEvent.tooltipShow, Object.assign(Object.assign({}, params2), {
        isEmptyTooltip: isNil_default(null == title3 ? void 0 : title3.key) && isNil_default(null == title3 ? void 0 : title3.value) && !(null == content ? void 0 : content.length),
        tooltipData: data,
        activeType: this.activeType,
        tooltip: this.component
      })), isEmpty2)
        return 1;
      let showTooltip2;
      return (null === (_a = spec.handler) || void 0 === _a ? void 0 : _a.showTooltip) ? showTooltip2 = spec.handler.showTooltip.bind(spec.handler) : (null === (_b = this.component.tooltipHandler) || void 0 === _b ? void 0 : _b.showTooltip) && (showTooltip2 = this.component.tooltipHandler.showTooltip.bind(this.component.tooltipHandler)), showTooltip2 ? null !== (_c = showTooltip2(this.activeType, data, params2)) && void 0 !== _c ? _c : 0 : 1;
    }, this.component = component2;
  }
  _preprocessDimensionInfo(dimensionInfo) {
    const newDimensionInfo = [];
    if (null == dimensionInfo || dimensionInfo.forEach((info) => {
      const di = Object.assign(Object.assign({}, info), {
        data: info.data.filter(({ series: series2 }) => {
          var _a, _b;
          return false !== (null === (_b = null === (_a = series2.getSpec()) || void 0 === _a ? void 0 : _a.tooltip) || void 0 === _b ? void 0 : _b.visible);
        })
      });
      di.data.length > 0 && newDimensionInfo.push(di);
    }), newDimensionInfo.length > 0)
      return newDimensionInfo;
  }
  _getDimensionInfo(params2) {
    var _a, _b;
    let targetDimensionInfo;
    const chart = this.component.getChart(), layer = chart.getCompiler().getStage().getLayer(void 0), point5 = {
      x: params2.event.viewX,
      y: params2.event.viewY
    };
    if (layer.globalTransMatrix.transformPoint({
      x: params2.event.viewX,
      y: params2.event.viewY
    }, point5), targetDimensionInfo = [...null !== (_a = getCartesianDimensionInfo(chart, point5, true)) && void 0 !== _a ? _a : [], ...null !== (_b = getPolarDimensionInfo(chart, point5)) && void 0 !== _b ? _b : []], 0 === targetDimensionInfo.length)
      targetDimensionInfo = void 0;
    else if (targetDimensionInfo.length > 1) {
      const dimensionAxisInfo = targetDimensionInfo.filter((info) => {
        var _a2;
        const axis2 = info.axis;
        if (axis2.getSpec().hasDimensionTooltip)
          return true;
        if (!isDiscrete(axis2.getScale().type))
          return false;
        let firstSeries;
        for (const region of null !== (_a2 = null == axis2 ? void 0 : axis2.getRegions()) && void 0 !== _a2 ? _a2 : []) {
          for (const series2 of region.getSeries())
            if ("cartesian" === series2.coordinate) {
              firstSeries = series2;
              break;
            }
          if (isValid_default(firstSeries))
            break;
        }
        return isValid_default(firstSeries) && firstSeries.getDimensionField()[0] === firstSeries.fieldY[0] ? "left" === axis2.getOrient() || "right" === axis2.getOrient() : "bottom" === axis2.getOrient() || "top" === axis2.getOrient();
      });
      if (targetDimensionInfo = dimensionAxisInfo.length ? dimensionAxisInfo : targetDimensionInfo.slice(0, 1), targetDimensionInfo.length > 1) {
        const dimensionDataKeySet = /* @__PURE__ */ new Set();
        targetDimensionInfo.forEach((info) => {
          info.data = info.data.filter(({ key }) => !dimensionDataKeySet.has(key) && (dimensionDataKeySet.add(key), true));
        });
      }
    }
    return targetDimensionInfo;
  }
  _updateViewSpec(params2) {
    const { changePositionOnly, model, dimensionInfo } = params2;
    changePositionOnly && this._cacheViewSpec || (this._cacheViewSpec = getTooltipSpecForShow(this.activeType, this.component.getSpec(), model, dimensionInfo));
  }
  _updateActualTooltip(data, params2) {
    var _a, _b, _c, _d;
    const pattern = this._cacheViewSpec[this.activeType], { changePositionOnly } = params2;
    if (!changePositionOnly || !this._cacheActualTooltip) {
      const tooltipContent = getShowContent(pattern, data, params2), visible = !!isValid_default(tooltipContent) && false !== getTooltipPatternValue(pattern.visible, data, params2);
      this._cacheActualTooltip = Object.assign(Object.assign({}, tooltipContent), {
        visible,
        activeType: pattern.activeType,
        data
      });
      const { title: title3, content } = this._cacheActualTooltip;
      this._cacheActualTooltip.title = null !== (_b = null === (_a = pattern.updateTitle) || void 0 === _a ? void 0 : _a.call(pattern, title3, data, params2)) && void 0 !== _b ? _b : title3, this._cacheActualTooltip.content = null !== (_d = null === (_c = pattern.updateContent) || void 0 === _c ? void 0 : _c.call(pattern, content, data, params2)) && void 0 !== _d ? _d : content;
    }
  }
  clearCache() {
    this._cacheViewSpec = void 0, this._cacheActualTooltip = void 0;
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/tooltip/processor/dimension-tooltip
var DimensionTooltipProcessor = class extends BaseTooltipProcessor {
  constructor() {
    super(...arguments), this.activeType = "dimension";
  }
  showTooltip(info, params2, changePositionOnly) {
    const newParams = Object.assign(Object.assign({}, params2), {
      dimensionInfo: this._preprocessDimensionInfo(info),
      changePositionOnly,
      tooltip: this.component
    });
    return this._showTooltipByHandler(info, newParams);
  }
  shouldHandleTooltip(params2, mouseEventData) {
    var _a, _b;
    const { tooltipInfo: info } = mouseEventData;
    if (isNil_default(info))
      return false;
    const helper = null === (_a = params2.model) || void 0 === _a ? void 0 : _a.tooltipHelper;
    return !!(null !== (_b = null == helper ? void 0 : helper.activeType) && void 0 !== _b ? _b : this.component.getSpec().activeType).includes("dimension");
  }
  getMouseEventData(params2) {
    var _a;
    return {
      tooltipInfo: this._getDimensionInfo(params2),
      ignore: [...null !== (_a = this.component.getOption().getAllSeries()) && void 0 !== _a ? _a : []].some((model) => {
        var _a2;
        const ignoreTriggers = null === (_a2 = model.tooltipHelper) || void 0 === _a2 ? void 0 : _a2.ignoreTriggerSet.dimension;
        return params2.model && (null == ignoreTriggers ? void 0 : ignoreTriggers.has(params2.model)) || params2.mark && (null == ignoreTriggers ? void 0 : ignoreTriggers.has(params2.mark));
      })
    };
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/tooltip/processor/mark-tooltip
var MarkTooltipProcessor = class extends BaseTooltipProcessor {
  constructor() {
    super(...arguments), this.activeType = "mark";
  }
  showTooltip(info, params2, changePositionOnly) {
    const { datum, series: series2, dimensionInfo } = info, tooltipData = [{
      datum: [datum],
      series: series2
    }], newParams = Object.assign(Object.assign({}, params2), {
      dimensionInfo: this._preprocessDimensionInfo(dimensionInfo),
      changePositionOnly,
      tooltip: this.component
    });
    return this._showTooltipByHandler(tooltipData, newParams);
  }
  shouldHandleTooltip(params2, mouseEventData) {
    var _a;
    const { tooltipInfo: info } = mouseEventData;
    if (isNil_default(info))
      return false;
    const helper = null === (_a = params2.model) || void 0 === _a ? void 0 : _a.tooltipHelper;
    return !!(null == helper ? void 0 : helper.activeType.includes("mark"));
  }
  getMouseEventData(params2, dimensionInfo) {
    var _a;
    let info, ignore;
    if ("series" === (null === (_a = params2.model) || void 0 === _a ? void 0 : _a.modelType)) {
      const series2 = params2.model, helper = series2.tooltipHelper, activeTriggers = null == helper ? void 0 : helper.activeTriggerSet.mark, ignoreTriggers = null == helper ? void 0 : helper.ignoreTriggerSet.mark;
      (null == activeTriggers ? void 0 : activeTriggers.has(params2.model)) || (null == activeTriggers ? void 0 : activeTriggers.has(params2.mark)) ? info = {
        mark: params2.mark,
        datum: params2.datum,
        series: series2,
        dimensionInfo
      } : ((null == ignoreTriggers ? void 0 : ignoreTriggers.has(params2.model)) || (null == ignoreTriggers ? void 0 : ignoreTriggers.has(params2.mark))) && (ignore = true);
    }
    return {
      tooltipInfo: info,
      ignore
    };
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/tooltip/processor/group-tooltip
var GroupTooltipProcessor = class extends BaseTooltipProcessor {
  constructor() {
    super(...arguments), this.activeType = "group";
  }
  showTooltip(info, params2, changePositionOnly) {
    const { datum, series: series2, dimensionInfo } = info, tooltipData = [{
      datum: array(datum),
      series: series2
    }], newParams = Object.assign(Object.assign({}, params2), {
      groupDatum: this._getGroupDatum(params2),
      dimensionInfo: this._preprocessDimensionInfo(dimensionInfo),
      changePositionOnly,
      tooltip: this.component
    });
    return this._showTooltipByHandler(tooltipData, newParams);
  }
  shouldHandleTooltip(params2, mouseEventData) {
    var _a;
    const { tooltipInfo: info } = mouseEventData;
    if (isNil_default(info))
      return false;
    const helper = null === (_a = params2.model) || void 0 === _a ? void 0 : _a.tooltipHelper;
    return !!(null == helper ? void 0 : helper.activeType.includes("group"));
  }
  getMouseEventData(params2, dimensionInfo) {
    var _a, _b;
    let info, ignore;
    if ("series" === (null === (_a = params2.model) || void 0 === _a ? void 0 : _a.modelType)) {
      const series2 = params2.model, helper = series2.tooltipHelper, activeTriggers = null == helper ? void 0 : helper.activeTriggerSet.group, ignoreTriggers = null == helper ? void 0 : helper.ignoreTriggerSet.group;
      if ((null == activeTriggers ? void 0 : activeTriggers.has(params2.model)) || (null == activeTriggers ? void 0 : activeTriggers.has(params2.mark))) {
        const patternSpec = this.component.getSpec()[this.activeType];
        ((null == patternSpec ? void 0 : patternSpec.triggerMark) ? array(patternSpec.triggerMark) : []).includes(null === (_b = params2.mark) || void 0 === _b ? void 0 : _b.name) && (info = {
          mark: params2.mark,
          datum: params2.datum,
          series: series2,
          dimensionInfo
        });
      } else
        ((null == ignoreTriggers ? void 0 : ignoreTriggers.has(params2.model)) || (null == ignoreTriggers ? void 0 : ignoreTriggers.has(params2.mark))) && (ignore = true);
    }
    return {
      tooltipInfo: info,
      ignore
    };
  }
  _getGroupDatum(params2) {
    const { model, mark, datum } = params2, series2 = model;
    if (["line", "area"].includes(mark.type))
      return array(datum);
    const datumList = series2.getViewData().latestData, seriesField = series2.getSeriesField();
    if (!seriesField)
      return datumList;
    const seriesFieldValue = array(datum)[0][seriesField];
    return datumList.filter((d) => d[seriesField] === seriesFieldValue);
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/tooltip/processor/util
var isMarkInfo = (info) => isValid_default(info) && !isArray_default(info);
var isDimensionInfo = (info) => isValid_default(info) && isArray_default(info);

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/tooltip/tooltip-transformer
var TooltipSpecTransformer = class extends BaseComponentSpecTransformer {
  _shouldMergeThemeToSpec() {
    return false;
  }
  _initTheme(spec, chartSpec) {
    const { spec: newSpec, theme: theme2 } = super._initTheme(spec, chartSpec);
    return newSpec.style = mergeSpec({}, this._theme, newSpec.style), {
      spec: newSpec,
      theme: theme2
    };
  }
  _transformSpecAfterMergingTheme(spec, chartSpec, chartSpecInfo) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    super._transformSpecAfterMergingTheme(spec, chartSpec, chartSpecInfo), spec.visible = null === (_a = spec.visible) || void 0 === _a || _a, spec.activeType = getTooltipActualActiveType(spec), spec.renderMode = null !== (_b = spec.renderMode) && void 0 !== _b ? _b : isMiniAppLikeMode(this._option.mode) || !isTrueBrowser(this._option.mode) ? "canvas" : "html", spec.trigger = null !== (_c = spec.trigger) && void 0 !== _c ? _c : "hover", spec.className = null !== (_d = spec.className) && void 0 !== _d ? _d : TOOLTIP_EL_CLASS_NAME, spec.enterable = null !== (_e = spec.enterable) && void 0 !== _e && _e, spec.transitionDuration = null !== (_f = spec.transitionDuration) && void 0 !== _f ? _f : 150, spec.triggerOff = null !== (_g = spec.triggerOff) && void 0 !== _g ? _g : spec.trigger, spec.confine = null !== (_h = spec.confine) && void 0 !== _h ? _h : "canvas" === spec.renderMode, isValid_default(spec.mark) && (spec.mark.activeType = "mark"), isValid_default(spec.dimension) && (spec.dimension.activeType = "dimension"), isValid_default(spec.parentElement) ? isString_default(spec.parentElement) && (spec.parentElement = null === (_j = null === globalThis || void 0 === globalThis ? void 0 : globalThis.document) || void 0 === _j ? void 0 : _j.getElementById(spec.parentElement)) : isTrueBrowser(this._option.mode) && (spec.parentElement = null == domDocument ? void 0 : domDocument.body);
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/tooltip/tooltip
var Tooltip2 = class extends BaseComponent {
  constructor() {
    super(...arguments), this.layoutZIndex = 1, this.type = ComponentTypeEnum.tooltip, this.name = ComponentTypeEnum.tooltip, this.transformerConstructor = TooltipSpecTransformer, this.specKey = "tooltip", this.layoutType = "none", this._alwaysShow = false, this._eventList = [], this._isTooltipShown = false, this._clickLock = false, this._mountEvent = (eType, query, callback) => {
      this.event.on(eType, query, callback), this._eventList.push({
        eventType: eType,
        handler: callback
      });
    }, this._getMouseOutHandler = (needPointerDetection) => (params2) => {
      var _a, _b, _c;
      if (this._alwaysShow)
        return;
      if (!this._isTooltipShown && !(null === (_b = null === (_a = this.tooltipHandler) || void 0 === _a ? void 0 : _a.isTooltipShown) || void 0 === _b ? void 0 : _b.call(_a)))
        return;
      const browserEnv = isTrueBrowser(null === (_c = this._option) || void 0 === _c ? void 0 : _c.mode), { clientX, clientY } = params2.event;
      browserEnv && this._isPointerOnTooltip(params2) || browserEnv && needPointerDetection && this._isPointerInChart({
        x: clientX,
        y: clientY
      }) || this._handleChartMouseOut(params2);
    }, this._handleChartMouseOut = (params2) => {
      this._alwaysShow || "none" !== this._spec.triggerOff && (this._hideTooltipByHandler(Object.assign(Object.assign({}, params2), {
        tooltip: this
      })), this._cacheInfo = void 0, this._cacheParams = void 0, this._cacheActiveType = void 0);
    }, this._getMouseMoveHandler = (isClick) => (params2) => {
      if (this.tooltipHandler || this._initHandler(), this.processor || this._initProcessor(), this._alwaysShow)
        return;
      if (this._isPointerOnTooltip(params2))
        return;
      if (!isClick && this._clickLock)
        return;
      const mouseEventData = this._getMouseEventData(params2), { tooltipInfo: { dimension: dimensionInfo }, ignore: { mark: ignoreMark, dimension: ignoreDimension } } = mouseEventData, success = {
        mark: false,
        dimension: false,
        group: false
      };
      success.group = this._showTooltipByMouseEvent("group", mouseEventData, params2, isClick), success.group || (success.mark = this._showTooltipByMouseEvent("mark", mouseEventData, params2, isClick)), success.mark || success.group || (success.dimension = this._showTooltipByMouseEvent("dimension", mouseEventData, params2, isClick)), Object.values(success).every((val) => !val) && !isEmptyPos(params2) && (ignoreMark && isMarkInfo(this._cacheInfo) ? success.mark = this._showTooltipByMouseEvent("mark", mouseEventData, params2, isClick, true) : ignoreDimension && isDimensionInfo(this._cacheInfo) ? success.dimension = this._showTooltipByMouseEvent("dimension", mouseEventData, params2, isClick, true) : isValid_default(dimensionInfo) && (success.dimension = this._showTooltipByMouseEvent("dimension", mouseEventData, params2, isClick))), success.mark || success.group || success.dimension && !isNil_default(dimensionInfo) || (this._handleChartMouseOut(params2), isClick && this._clickLock && (this._clickLock = false));
    }, this._showTooltipByMouseEvent = (activeType, mouseEventData, params2, isClick, useCache) => {
      var _a;
      const processor = this.processor[activeType];
      if (!processor.shouldHandleTooltip(params2, {
        tooltipInfo: mouseEventData.tooltipInfo[activeType],
        ignore: mouseEventData.ignore[activeType]
      }))
        return false;
      let success;
      if (useCache)
        success = !processor.showTooltip(this._cacheInfo, params2, true);
      else {
        const tooltipInfo = mouseEventData.tooltipInfo[activeType], isSameAsCache = this._isSameAsCache(tooltipInfo, params2, activeType);
        success = !processor.showTooltip(tooltipInfo, params2, isSameAsCache), success && (this._cacheInfo = tooltipInfo, this._cacheParams = params2, this._cacheActiveType = activeType);
      }
      success && (this._isTooltipShown = true, isClick && this._spec.lockAfterClick && !this._clickLock && (this._clickLock = true));
      const vchart = null === (_a = this._option) || void 0 === _a ? void 0 : _a.globalInstance;
      return success && VChart.globalConfig.uniqueTooltip && vchart && VChart.hideTooltip(vchart.id), success;
    }, this._getMouseEventData = (params2) => {
      const result2 = {
        tooltipInfo: {},
        ignore: {}
      };
      let activeType = "dimension";
      const { tooltipInfo, ignore } = this.processor[activeType].getMouseEventData(params2);
      result2.tooltipInfo[activeType] = tooltipInfo, result2.ignore[activeType] = ignore;
      const dimensionInfo = tooltipInfo;
      for (activeType of Object.keys(this.processor))
        if ("dimension" !== activeType) {
          const { tooltipInfo: tooltipInfo2, ignore: ignore2 } = this.processor[activeType].getMouseEventData(params2, dimensionInfo);
          result2.tooltipInfo[activeType] = tooltipInfo2, result2.ignore[activeType] = ignore2;
        }
      return result2;
    }, this._hideTooltipByHandler = (params2) => {
      var _a, _b, _c, _d;
      if (!this._isTooltipShown && !(null === (_b = null === (_a = this.tooltipHandler) || void 0 === _a ? void 0 : _a.isTooltipShown) || void 0 === _b ? void 0 : _b.call(_a)))
        return 0;
      let hideTooltip;
      if (this.event.emit(ChartEvent.tooltipHide, Object.assign(Object.assign({}, params2), {
        source: Event_Source_Type.chart,
        tooltip: this
      })), Object.values(this.processor).forEach((processor) => {
        processor.clearCache();
      }), (null === (_c = this._spec.handler) || void 0 === _c ? void 0 : _c.hideTooltip) ? hideTooltip = this._spec.handler.hideTooltip.bind(this._spec.handler) : (null === (_d = this.tooltipHandler) || void 0 === _d ? void 0 : _d.hideTooltip) && (hideTooltip = this.tooltipHandler.hideTooltip.bind(this.tooltipHandler)), hideTooltip) {
        const result2 = hideTooltip(params2);
        return result2 || (this._isTooltipShown = false), result2;
      }
      return 1;
    };
  }
  static getSpecInfo(chartSpec) {
    const tooltipSpec = chartSpec[this.specKey];
    if (!tooltipSpec)
      return null;
    if (!isArray_default(tooltipSpec))
      return [{
        spec: tooltipSpec,
        specPath: [this.specKey],
        specInfoPath: ["component", this.specKey, 0],
        type: ComponentTypeEnum.tooltip
      }];
    const specInfos = [];
    return tooltipSpec.forEach((s2, i) => {
      specInfos.push({
        spec: s2,
        specPath: [this.specKey, i],
        specInfoPath: ["component", this.specKey, i],
        type: ComponentTypeEnum.tooltip
      });
    }), specInfos;
  }
  isTooltipShown() {
    return this._isTooltipShown;
  }
  changeRegions(regions) {
  }
  _getNeedClearVRenderComponents() {
    return [];
  }
  _registerEvent() {
  }
  _releaseEvent() {
  }
  onLayout(ctx) {
  }
  onLayoutEnd(ctx) {
  }
  onRender(ctx) {
  }
  created() {
    super.created(), this._regions = this._option.getAllRegions(), this._initEvent();
  }
  release() {
    var _a, _b;
    super.release(), this._eventList.forEach(({ eventType, handler }) => {
      this.event.off(eventType, handler);
    }), this._eventList = [], null === (_b = null === (_a = this.tooltipHandler) || void 0 === _a ? void 0 : _a.release) || void 0 === _b || _b.call(_a), this._isTooltipShown = false;
  }
  beforeRelease() {
    this.event.emit(ChartEvent.tooltipHide, {
      tooltip: this,
      chart: this.getChart()
    }), this.event.emit(ChartEvent.tooltipRelease, {
      tooltip: this,
      chart: this.getChart()
    });
  }
  _initHandler() {
    var _a, _b, _c;
    const renderMode = null !== (_a = this._spec.renderMode) && void 0 !== _a ? _a : "html", userTooltipHandler = this._option.globalInstance.getTooltipHandlerByUser();
    if (userTooltipHandler)
      this.tooltipHandler = userTooltipHandler;
    else {
      const type = "canvas" === renderMode ? TooltipHandlerType.canvas : TooltipHandlerType.dom, handlerConstructor = Factory2.getComponentPluginInType(type);
      handlerConstructor || error("Can not find tooltip handler: " + type);
      const handler = new handlerConstructor();
      handler.name = `${this._spec.className}-${null !== (_b = this._option.globalInstance.id) && void 0 !== _b ? _b : 0}-${this.getSpecIndex()}`, null === (_c = this.pluginService) || void 0 === _c || _c.load([handler]), this.tooltipHandler = handler;
    }
  }
  _initProcessor() {
    this.processor = {
      mark: new MarkTooltipProcessor(this),
      dimension: new DimensionTooltipProcessor(this),
      group: new GroupTooltipProcessor(this)
    };
  }
  _initEvent() {
    var _a;
    if (this._option.disableTriggerEvent)
      return;
    const trigger = array(null !== (_a = this._spec.trigger) && void 0 !== _a ? _a : "hover"), mode = this._option.mode;
    trigger.includes("hover") && (this._mountEvent("pointermove", {
      source: "chart"
    }, this._getMouseMoveHandler(false)), (isMobileLikeMode(mode) || isMiniAppLikeMode(mode)) && (this._mountEvent("pointerdown", {
      source: "chart"
    }, this._getMouseMoveHandler(false)), this._mountEvent("pointerup", {
      source: "window"
    }, this._getMouseOutHandler(true))), this._mountEvent("pointerout", {
      source: "canvas"
    }, this._getMouseOutHandler(false))), trigger.includes("click") && (this._mountEvent("pointertap", {
      source: "chart"
    }, this._getMouseMoveHandler(true)), this._mountEvent("pointerup", {
      source: "window"
    }, this._getMouseOutHandler(true)));
  }
  reInit(spec) {
    var _a, _b;
    super.reInit(spec), this.tooltipHandler ? null === (_b = (_a = this.tooltipHandler).reInit) || void 0 === _b || _b.call(_a) : this._initHandler();
  }
  showTooltip(datum, options) {
    var _a;
    if (this.tooltipHandler || this._initHandler(), this.processor || this._initProcessor(), !(null === (_a = this.tooltipHandler) || void 0 === _a ? void 0 : _a.showTooltip))
      return false;
    const result2 = showTooltip(datum, options, this);
    return "none" !== result2 && (this._alwaysShow = !!(null == options ? void 0 : options.alwaysShow)), result2;
  }
  hideTooltip() {
    const params2 = {
      changePositionOnly: false,
      tooltip: this,
      item: void 0,
      datum: void 0,
      source: Event_Source_Type.chart
    };
    return this._alwaysShow = false, !this._hideTooltipByHandler(params2);
  }
  _isSameAsCache(nextInfo, nextParams, nextActiveType) {
    if (nextActiveType !== this._cacheActiveType)
      return false;
    if (nextInfo === this._cacheInfo)
      return true;
    if (isNil_default(this._cacheInfo) || isNil_default(nextInfo))
      return false;
    if (isDimensionInfo(nextInfo)) {
      if (isMarkInfo(this._cacheInfo))
        return false;
      const prevInfo = this._cacheInfo;
      if (!(prevInfo.length === nextInfo.length && nextInfo.every((info, i) => isSameDimensionInfo(info, prevInfo[i]))))
        return false;
    } else {
      if (isDimensionInfo(this._cacheInfo))
        return false;
      const prevInfo = this._cacheInfo;
      if (!((null == nextInfo ? void 0 : nextInfo.datum) === prevInfo.datum && (null == nextInfo ? void 0 : nextInfo.mark) === prevInfo.mark && (null == nextInfo ? void 0 : nextInfo.series) === prevInfo.series))
        return false;
    }
    const prevParams = this._cacheParams;
    return !isNil_default(prevParams) && !isNil_default(nextParams) && (prevParams.mark === nextParams.mark && prevParams.model === nextParams.model && prevParams.datum === nextParams.datum);
  }
  _isPointerInChart(point5) {
    var _a;
    const globalInstance = null === (_a = this._option) || void 0 === _a ? void 0 : _a.globalInstance;
    if (!globalInstance)
      return false;
    if (!globalInstance.getChart())
      return false;
    const { x, y } = point5, canvas = globalInstance.getCanvas(), { x: chartX, y: chartY, width: chartWidth, height: chartHeight } = canvas.getBoundingClientRect();
    return x >= chartX && x <= chartX + chartWidth && y >= chartY && y <= chartY + chartHeight;
  }
  _isPointerOnTooltip(params2) {
    var _a, _b;
    if (this._spec.enterable && "html" === this._spec.renderMode) {
      const { event } = params2;
      let newTarget;
      if (isValid_default(event.nativeEvent)) {
        const nativeEvent = event.nativeEvent;
        newTarget = nativeEvent.relatedTarget, nativeEvent.composedPath && nativeEvent.composedPath().length > 0 && (newTarget = nativeEvent.composedPath()[0]);
      } else
        newTarget = event.relatedTarget;
      const container2 = null === (_b = null === (_a = this.tooltipHandler) || void 0 === _a ? void 0 : _a.getTooltipContainer) || void 0 === _b ? void 0 : _b.call(_a);
      if (isValid_default(container2) && isValid_default(newTarget) && hasParentElement(newTarget, container2))
        return true;
    }
    return false;
  }
  getVisible() {
    return false !== this._spec.visible;
  }
};
Tooltip2.type = ComponentTypeEnum.tooltip, Tooltip2.transformerConstructor = TooltipSpecTransformer, Tooltip2.specKey = "tooltip";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/tooltip/interface/common
var TooltipResult;
!function(TooltipResult2) {
  TooltipResult2[TooltipResult2.success = 0] = "success", TooltipResult2[TooltipResult2.failed = 1] = "failed";
}(TooltipResult || (TooltipResult = {}));

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/label/base-label
var BaseLabelComponent = class extends BaseComponent {
  constructor(spec, options) {
    super(spec, options), this.type = ComponentTypeEnum.label, this.name = ComponentTypeEnum.label, this.layoutType = "none", this.layoutZIndex = LayoutZIndex.Label, this._regions = options.getRegionsInIndex(options.regionIndexes);
  }
  _interactiveConfig(labelSpec) {
    const { interactive } = labelSpec, result2 = {
      hover: false,
      select: false,
      state: labelSpec.state
    };
    if (true !== interactive)
      return result2;
    const { hover, select } = this._option.getChart().getSpec();
    return false === hover && false === hover.enable || (result2.hover = true), false === select && false === select.enable || (result2.select = true), result2;
  }
  _compareSpec(spec, prevSpec) {
    const result2 = super._compareSpec(spec, prevSpec);
    return result2.reRender = true, isEqual(prevSpec, spec) || (result2.reMake = true), result2;
  }
  onRender(ctx) {
  }
  changeRegions(regions) {
  }
  _getNeedClearVRenderComponents() {
    return [];
  }
  _delegateLabelEvent(component2) {
    0 === component2.listenerCount("*") && component2.addEventListener("*", (event, type) => this._delegateEvent(component2, event, type));
  }
};
BaseLabelComponent.type = ComponentTypeEnum.label;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/mark/label
var LabelMark = class extends TextMark {
  constructor() {
    super(...arguments), this.skipEncode = false;
  }
  getRule() {
    return this._rule;
  }
  setRule(rule) {
    this._rule = rule;
  }
  getTarget() {
    return this._target;
  }
  setTarget(target) {
    this._target = target, this._rule || this.setRule(target.type);
  }
  getComponent() {
    return this._component;
  }
  setComponent(component2) {
    this._component = component2;
  }
};
LabelMark.type = "text", LabelMark.constructorType = "label";

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/label/label-transformer
var LabelSpecTransformer = class extends BaseComponentSpecTransformer {
  _initTheme(spec, chartSpec) {
    return {
      spec,
      theme: this._theme
    };
  }
};

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/label/label
var Label = class extends BaseLabelComponent {
  constructor(spec, options) {
    super(spec, options), this.type = ComponentTypeEnum.label, this.name = ComponentTypeEnum.label, this.specKey = "label", this.transformerConstructor = LabelSpecTransformer, this.layoutZIndex = LayoutZIndex.Label, this._layoutRule = spec.labelLayout || "series";
  }
  static getSpecInfo(chartSpec, chartSpecInfo) {
    const specInfo = [], regionSpecInfo = (null == chartSpecInfo ? void 0 : chartSpecInfo.region) || [];
    return regionSpecInfo.forEach((regionInfo, i) => {
      (regionInfo.seriesIndexes || []).some((seriesIndex) => {
        const seriesInfo = chartSpecInfo.series[seriesIndex], { markLabelSpec = {} } = seriesInfo;
        return Object.values(markLabelSpec).some((labelSpecList) => Array.isArray(labelSpecList) && ((labelSpecList2) => labelSpecList2.some((labelSpec) => labelSpec.visible))(labelSpecList));
      }) && specInfo.push({
        spec: chartSpec,
        type: ComponentTypeEnum.label,
        specInfoPath: ["component", this.specKey, i],
        regionIndexes: [i]
      });
    }), specInfo;
  }
  init(option) {
    super.init(option), this.initEvent(), this._initTextMark(), this._initLabelComponent(), this._initTextMarkStyle();
  }
  reInit(spec) {
    super.reInit(spec), this._labelInfoMap && this._labelInfoMap.clear(), this._initTextMark(), this._initTextMarkStyle();
  }
  initEvent() {
    this.event.on(ChartEvent.dataZoomChange, () => {
      this._labelComponentMap.forEach((info, component2) => {
        const graphicItem = component2.getProduct().getGroupGraphicItem();
        graphicItem && graphicItem.disableAnimation();
      }), this.event.on(HOOK_EVENT.AFTER_MARK_RENDER_END, enableAnimation);
    });
    const enableAnimation = () => {
      this._labelComponentMap.forEach((info, component2) => {
        const graphicItem = component2.getProduct().getGroupGraphicItem();
        graphicItem && graphicItem.enableAnimation();
      }), this.event.off(HOOK_EVENT.AFTER_MARK_RENDER_END, enableAnimation);
    };
  }
  afterCompile() {
    this._labelComponentMap.forEach((info, component2) => {
      const product = component2.getProduct();
      product && product.addEventListener(HOOK_EVENT.AFTER_ELEMENT_ENCODE, () => {
        false === this._isLayout && this._delegateLabelEvent(product.getGroupGraphicItem());
      });
    });
  }
  _initTextMark() {
    this._labelInfoMap || (this._labelInfoMap = /* @__PURE__ */ new Map()), this._labelComponentMap || (this._labelComponentMap = /* @__PURE__ */ new Map()), eachSeries(this._regions, (series2) => {
      const { markLabelSpec = {} } = series2.getSpecInfo(), markNames = Object.keys(markLabelSpec), region = series2.getRegion();
      this._labelInfoMap.get(region) || this._labelInfoMap.set(region, []);
      for (let i = 0; i < markNames.length; i++) {
        const markName = markNames[i], mark = series2.getMarkInName(markName);
        mark && markLabelSpec[markName].forEach((spec, index) => {
          if (spec.visible) {
            const info = this._labelInfoMap.get(region), labelMark = this._createMark({
              type: "label",
              name: `${markName}-label-${index}`
            }, {
              noSeparateStyle: true,
              attributeContext: series2.getMarkAttributeContext()
            });
            labelMark.setTarget(mark), info.push({
              labelMark,
              baseMark: mark,
              series: series2,
              labelSpec: spec
            });
          }
        });
      }
    });
  }
  _initLabelComponent() {
    this._labelInfoMap.forEach((regionLabelInfo, region) => {
      if ("region" === this._layoutRule) {
        const component2 = this._createMark({
          type: "component",
          name: `${region.getGroupMark().name}-label-component`
        }, {
          componentType: "label",
          noSeparateStyle: true,
          support3d: this._spec.support3d
        });
        component2 && (component2.setSkipBeforeLayouted(true), this._marks.addMark(component2), this._labelComponentMap.set(component2, () => this._labelInfoMap.get(region)));
      } else
        regionLabelInfo.forEach((labelInfo, i) => {
          const component2 = this._createMark({
            type: "component",
            name: `${labelInfo.labelMark.name}-component`
          }, {
            componentType: "label",
            noSeparateStyle: true,
            support3d: labelInfo.baseMark.getSupport3d()
          });
          component2 && (component2.setSkipBeforeLayouted(true), this._marks.addMark(component2), this._labelComponentMap.set(component2, () => this._labelInfoMap.get(region)[i]), labelInfo.labelMark.setComponent(component2));
        });
    });
  }
  _initTextMarkStyle() {
    this._labelInfoMap.forEach((labelInfos) => {
      labelInfos.forEach((info) => {
        var _a, _b;
        const { labelMark, labelSpec, series: series2 } = info;
        if (this.initMarkStyleWithSpec(labelMark, labelSpec, void 0), isFunction_default(null == labelSpec ? void 0 : labelSpec.getStyleHandler)) {
          const styleHandler = labelSpec.getStyleHandler(series2);
          null == styleHandler || styleHandler.call(series2, labelMark, labelSpec);
        }
        (null === (_b = null === (_a = labelMark.stateStyle) || void 0 === _a ? void 0 : _a.normal) || void 0 === _b ? void 0 : _b.lineWidth) && labelMark.setAttribute("stroke", series2.getColorAttribute(), "normal", AttributeLevel.Base_Series);
      });
    });
  }
  updateLayoutAttribute() {
    super.updateLayoutAttribute(), this._labelComponentMap.forEach((labelInfoCb, labelComponent) => {
      const labelInfo = labelInfoCb();
      isArray_default(labelInfo) ? this._updateMultiLabelAttribute(labelInfo, labelComponent) : this._updateSingleLabelAttribute(labelInfo, labelComponent);
    });
  }
  _updateMultiLabelAttribute(labelInfo, labelComponent) {
    this._updateLabelComponentAttribute(labelComponent.getProduct(), labelInfo.map(({ baseMark }) => baseMark.getProduct()), labelInfo);
  }
  _updateSingleLabelAttribute(labelInfo, labelComponent) {
    const { baseMark } = labelInfo;
    this._updateLabelComponentAttribute(labelComponent.getProduct(), baseMark.getProduct(), [labelInfo]);
  }
  _updateLabelComponentAttribute(component2, target, labelInfos) {
    const dependCmp = this._option.getComponentsByType("totalLabel");
    component2.target(target).configure({
      interactive: false
    }).depend(dependCmp.map((cmp) => cmp.getMarks()[0].getProduct())).labelStyle((mark, params2) => {
      var _a, _b;
      const labelInfo = labelInfos[params2.labelIndex];
      if (labelInfo) {
        const { labelSpec, labelMark } = labelInfo, rule = labelMark.getRule(), interactive = this._interactiveConfig(labelSpec), centerOffset = null !== (_b = null === (_a = this._spec) || void 0 === _a ? void 0 : _a.centerOffset) && void 0 !== _b ? _b : 0, spec = mergeSpec({
          textStyle: Object.assign({
            pickable: true === labelSpec.interactive
          }, labelSpec.style),
          overlap: {
            avoidMarks: dependCmp.map((cmp) => cmp.getMarks()[0].getProductId())
          }
        }, defaultLabelConfig(rule, labelInfo), Object.assign(Object.assign(Object.assign({}, pickWithout(labelSpec, ["position", "style", "state", "type"])), interactive), {
          centerOffset
        }));
        return "line" !== rule && "area" !== rule || (spec.type = rule), spec;
      }
    }).encode((datum, element, params2) => {
      if (labelInfos[params2.labelIndex]) {
        const { labelSpec, labelMark } = labelInfos[params2.labelIndex];
        return labelMark.skipEncode ? {
          data: datum
        } : textAttribute(labelInfos[params2.labelIndex], datum, labelSpec.formatMethod, labelSpec.formatter);
      }
    }).size(() => labelInfos[0].series.getRegion().getLayoutRect());
  }
  compileMarks() {
    this.getMarks().forEach((m4) => {
      var _a;
      const labelInfo = this._labelComponentMap.get(m4)();
      let group;
      group = isArray_default(labelInfo) ? labelInfo[0].series.getRegion().getGroupMark().getProduct() : labelInfo.series.getRegion().getGroupMark().getProduct(), m4.compile({
        group
      }), null === (_a = m4.getProduct()) || void 0 === _a || _a.configure({
        context: {
          model: this,
          labelInfo
        }
      });
    });
  }
  getVRenderComponents() {
    const labels = [];
    return this._labelComponentMap.forEach((info, component2) => {
      const graphicItem = component2.getProduct().getGroupGraphicItem();
      graphicItem && labels.push(graphicItem);
    }), labels;
  }
};
Label.type = ComponentTypeEnum.label, Label.specKey = "label", Label.transformerConstructor = LabelSpecTransformer;

// http-url:https://unpkg.com/@visactor/vchart@1.11.3/esm/component/label/total-label
var TotalLabel = class extends BaseLabelComponent {
  constructor() {
    super(...arguments), this.type = ComponentTypeEnum.totalLabel, this.name = ComponentTypeEnum.totalLabel, this.specKey = "totalLabel", this.layoutZIndex = LayoutZIndex.Label;
  }
  static getSpecInfo(chartSpec, chartSpecInfo) {
    var _a;
    const specInfo = [];
    return null === (_a = null == chartSpecInfo ? void 0 : chartSpecInfo.region) || void 0 === _a || _a.forEach((regionInfo, regionIndex) => {
      var _a2;
      null === (_a2 = regionInfo.seriesIndexes) || void 0 === _a2 || _a2.forEach((seriesIndex) => {
        const { spec } = chartSpecInfo.series[seriesIndex], labelSpec = spec[this.specKey];
        (null == labelSpec ? void 0 : labelSpec.visible) && specInfo.push({
          spec: labelSpec,
          type: ComponentTypeEnum.totalLabel,
          specPath: ["series", seriesIndex, this.specKey],
          specInfoPath: ["component", this.specKey, seriesIndex],
          regionIndexes: [regionIndex],
          seriesIndexes: [seriesIndex]
        });
      });
    }), specInfo;
  }
  init(option) {
    super.init(option), this._initTextMark(), this._initLabelComponent();
  }
  _initTextMark() {
    var _a;
    const series2 = this._getSeries();
    if (null === (_a = series2.getSpec().totalLabel) || void 0 === _a ? void 0 : _a.visible) {
      const mark = series2.getSeriesMark();
      if (mark) {
        const textMark = this._createMark({
          type: "label",
          name: `${mark.name}-total-label`
        });
        this._baseMark = mark, this._textMark = textMark, this._initTextMarkStyle();
      }
    }
  }
  _initTextMarkStyle() {
    var _a;
    super.initMarkStyleWithSpec(this._textMark, this._spec), this.setMarkStyle(this._textMark, {
      text: (datum) => datum[STACK_FIELD_TOTAL]
    }, "normal", AttributeLevel.Default);
    const series2 = this._getSeries();
    null === (_a = series2.initTotalLabelMarkStyle) || void 0 === _a || _a.call(series2, this._textMark);
  }
  _initLabelComponent() {
    const series2 = this._getSeries(), component2 = this._createMark({
      type: "component",
      name: `${series2.name}-total-label-component`
    }, {
      componentType: "label",
      noSeparateStyle: true,
      support3d: this._spec.support3d
    });
    component2 && this._marks.addMark(component2);
  }
  afterCompile() {
    this._marks.forEach((componentMark, index) => {
      const product = componentMark.getProduct();
      product && product.addEventListener(HOOK_EVENT.AFTER_ELEMENT_ENCODE, () => {
        false === this._isLayout && this._delegateLabelEvent(product.getGroupGraphicItem());
      });
    });
  }
  updateLayoutAttribute() {
    super.updateLayoutAttribute();
    const series2 = this._getSeries();
    this._marks.forEach((componentMark, index) => {
      componentMark.getProduct().target(this._baseMark.getProduct()).configure({
        interactive: false
      }).labelStyle(() => {
        var _a, _b;
        if (this._baseMark) {
          const { offset, animation, overlap: overlap2 } = this._spec, interactive = this._interactiveConfig(this._spec);
          return mergeSpec({
            textStyle: {
              pickable: true === this._spec.interactive
            },
            position: totalLabelPosition(series2, this._baseMark.type),
            x: 0,
            y: 0
          }, null !== (_b = null === (_a = series2.getTotalLabelComponentStyle) || void 0 === _a ? void 0 : _a.call(series2, {
            baseMark: this._baseMark,
            labelMark: this._textMark
          })) && void 0 !== _b ? _b : {}, Object.assign({
            offset,
            animation,
            overlap: overlap2,
            dataFilter: (data) => data.filter((d) => d.data[STACK_FIELD_TOTAL_TOP])
          }, interactive));
        }
      }).encode((datum) => textAttribute({
        baseMark: this._baseMark,
        labelMark: this._textMark,
        series: series2,
        labelSpec: series2.getSpec().totalLabel
      }, datum, this._spec.formatMethod)).size(() => this._regions[0].getLayoutRect());
    });
  }
  compileMarks() {
    this.getMarks().forEach((m4) => {
      var _a;
      const group = this._regions[0].getGroupMark().getProduct();
      m4.compile({
        group
      }), null === (_a = m4.getProduct()) || void 0 === _a || _a.configure({
        context: {
          model: this
        }
      });
    });
  }
  getVRenderComponents() {
    const labels = [];
    return this.getMarks().forEach((m4) => {
      const graphicItem = m4.getProduct().getGroupGraphicItem();
      graphicItem && labels.push(graphicItem);
    }), labels;
  }
  _getSeries() {
    return this._option.getSeriesInIndex([this.getSpecPath()[1]])[0];
  }
};
TotalLabel.type = ComponentTypeEnum.totalLabel, TotalLabel.specKey = "totalLabel";
function totalLabelPosition(series2, type) {
  var _a, _b;
  let position;
  const { direction: direction2 } = series2, positionMap = {
    vertical: ["top", "bottom"],
    horizontal: ["right", "left"]
  }, index = ("horizontal" === direction2 ? null === (_a = series2.getXAxisHelper()) || void 0 === _a ? void 0 : _a.isInverse() : null === (_b = series2.getYAxisHelper()) || void 0 === _b ? void 0 : _b.isInverse()) ? 1 : 0;
  switch (type) {
    case "rect":
    case "symbol":
      position = positionMap[direction2][index];
      break;
    default:
      position = "top";
  }
  return position;
}

// /input.ts
registerBarChart();
registerLineChart();
registerPieChart();
registerCartesianBandAxis();
registerCartesianLinearAxis();
registerMarkArea();
registerMarkLine();
registerMarkPoint();
registerWXEnv();
registerElementSelect();
registerElementHighlight();
registerElementActive();
registerElementActiveByLegend();
registerElementHighlightByLegend();
registerElementHighlightByName();
registerElementHighlightByGroup();
registerElementHighlightByKey();
export {
  VChart
};
